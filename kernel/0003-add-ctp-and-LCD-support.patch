From 09b8983d594540cf9ad848b25804c88fea720dd5 Mon Sep 17 00:00:00 2001
From: lnxbuild <lnxbuild@localhost>
Date: Fri, 16 Aug 2013 09:01:41 +0800
Subject: [PATCH 03/11] add ctp and LCD support

Change-Id: Idd770e84c59920da7825d49b073450d12154684d
---
 .../dts/dsi-v2-panel-auo-rm68190-qhd-video.dtsi    |   92 +
 .../dts/dsi-v2-panel-boe-nt35517-qhd-video.dtsi    |  166 +
 .../dts/dsi-v2-panel-byd-nt35517-qhd-video.dtsi    |  164 +
 arch/arm/boot/dts/dsi-v2-panel-emulator.dtsi       |   64 +
 .../boot/dts/dsi-v2-panel-hx8389b-qhd-video.dtsi   |  118 +
 .../boot/dts/dsi-v2-panel-otm9605a-qhd-video.dtsi  |    2 +-
 arch/arm/boot/dts/msm8610-qrd.dtsi                 |   81 +-
 arch/arm/boot/dts/msm8610-v1-qrd-skuac.dts         |    5 +
 arch/arm/configs/msm8610_defconfig                 |   38 +-
 drivers/input/touchscreen/Kconfig                  |    1 +
 drivers/input/touchscreen/Makefile                 |    1 +
 drivers/input/touchscreen/cypress/Kconfig          |  206 +
 drivers/input/touchscreen/cypress/Makefile         |   62 +
 drivers/input/touchscreen/cypress/cyttsp4_btn.c    |  527 +++
 drivers/input/touchscreen/cypress/cyttsp4_bus.c    |  761 ++++
 drivers/input/touchscreen/cypress/cyttsp4_core.c   | 3999 ++++++++++++++++++++
 drivers/input/touchscreen/cypress/cyttsp4_debug.c  |  608 +++
 .../touchscreen/cypress/cyttsp4_device_access.c    | 2738 ++++++++++++++
 .../touchscreen/cypress/cyttsp4_device_access.h    |   79 +
 .../input/touchscreen/cypress/cyttsp4_devtree.c    |  765 ++++
 .../input/touchscreen/cypress/cyttsp4_devtree.h    |   36 +
 drivers/input/touchscreen/cypress/cyttsp4_i2c.c    |  326 ++
 drivers/input/touchscreen/cypress/cyttsp4_i2c.h    |   35 +
 drivers/input/touchscreen/cypress/cyttsp4_img.h    | 3990 +++++++++++++++++++
 drivers/input/touchscreen/cypress/cyttsp4_loader.c | 1883 +++++++++
 .../input/touchscreen/cypress/cyttsp4_mt_common.c  |  711 ++++
 .../input/touchscreen/cypress/cyttsp4_mt_common.h  |   86 +
 drivers/input/touchscreen/cypress/cyttsp4_mta.c    |  108 +
 drivers/input/touchscreen/cypress/cyttsp4_mtb.c    |  115 +
 .../input/touchscreen/cypress/cyttsp4_platform.c   |  235 ++
 .../input/touchscreen/cypress/cyttsp4_proximity.c  |  585 +++
 drivers/input/touchscreen/cypress/cyttsp4_regs.h   |  578 +++
 drivers/input/touchscreen/cypress/cyttsp4_spi.c    |  462 +++
 drivers/input/touchscreen/cypress/cyttsp4_spi.h    |   37 +
 .../cypress/cyttsp4_test_device_access_api.c       |  196 +
 .../platform/msm/camera_v2/sensor/msm_sensor.c     |   10 +
 .../platform/msm/camera_v2/sensor/msm_sensor.h     |    2 +
 drivers/video/msm/mdss/Makefile                    |    1 +
 drivers/video/msm/mdss/dsi_panel_v2.c              |   16 +-
 drivers/video/msm/mdss/hw_lcd_common.c             |  278 ++
 include/linux/cyttsp4_btn.h                        |   39 +
 include/linux/cyttsp4_bus.h                        |  346 ++
 include/linux/cyttsp4_core.h                       |  148 +
 include/linux/cyttsp4_device_access-api.h          |   56 +
 include/linux/cyttsp4_mt.h                         |   84 +
 include/linux/cyttsp4_platform.h                   |   61 +
 include/linux/cyttsp4_proximity.h                  |   42 +
 include/linux/hw_lcd_common.h                      |   95 +
 48 files changed, 21021 insertions(+), 17 deletions(-)
 create mode 100644 arch/arm/boot/dts/dsi-v2-panel-auo-rm68190-qhd-video.dtsi
 create mode 100644 arch/arm/boot/dts/dsi-v2-panel-boe-nt35517-qhd-video.dtsi
 create mode 100644 arch/arm/boot/dts/dsi-v2-panel-byd-nt35517-qhd-video.dtsi
 create mode 100644 arch/arm/boot/dts/dsi-v2-panel-emulator.dtsi
 create mode 100644 arch/arm/boot/dts/dsi-v2-panel-hx8389b-qhd-video.dtsi
 create mode 100644 drivers/input/touchscreen/cypress/Kconfig
 create mode 100644 drivers/input/touchscreen/cypress/Makefile
 create mode 100644 drivers/input/touchscreen/cypress/cyttsp4_btn.c
 create mode 100644 drivers/input/touchscreen/cypress/cyttsp4_bus.c
 create mode 100644 drivers/input/touchscreen/cypress/cyttsp4_core.c
 create mode 100644 drivers/input/touchscreen/cypress/cyttsp4_debug.c
 create mode 100644 drivers/input/touchscreen/cypress/cyttsp4_device_access.c
 create mode 100644 drivers/input/touchscreen/cypress/cyttsp4_device_access.h
 create mode 100644 drivers/input/touchscreen/cypress/cyttsp4_devtree.c
 create mode 100644 drivers/input/touchscreen/cypress/cyttsp4_devtree.h
 create mode 100644 drivers/input/touchscreen/cypress/cyttsp4_i2c.c
 create mode 100644 drivers/input/touchscreen/cypress/cyttsp4_i2c.h
 create mode 100644 drivers/input/touchscreen/cypress/cyttsp4_img.h
 create mode 100644 drivers/input/touchscreen/cypress/cyttsp4_loader.c
 create mode 100644 drivers/input/touchscreen/cypress/cyttsp4_mt_common.c
 create mode 100644 drivers/input/touchscreen/cypress/cyttsp4_mt_common.h
 create mode 100644 drivers/input/touchscreen/cypress/cyttsp4_mta.c
 create mode 100644 drivers/input/touchscreen/cypress/cyttsp4_mtb.c
 create mode 100644 drivers/input/touchscreen/cypress/cyttsp4_platform.c
 create mode 100644 drivers/input/touchscreen/cypress/cyttsp4_proximity.c
 create mode 100644 drivers/input/touchscreen/cypress/cyttsp4_regs.h
 create mode 100644 drivers/input/touchscreen/cypress/cyttsp4_spi.c
 create mode 100644 drivers/input/touchscreen/cypress/cyttsp4_spi.h
 create mode 100644 drivers/input/touchscreen/cypress/cyttsp4_test_device_access_api.c
 create mode 100644 drivers/video/msm/mdss/hw_lcd_common.c
 create mode 100644 include/linux/cyttsp4_btn.h
 create mode 100644 include/linux/cyttsp4_bus.h
 create mode 100644 include/linux/cyttsp4_core.h
 create mode 100644 include/linux/cyttsp4_device_access-api.h
 create mode 100644 include/linux/cyttsp4_mt.h
 create mode 100644 include/linux/cyttsp4_platform.h
 create mode 100644 include/linux/cyttsp4_proximity.h
 create mode 100644 include/linux/hw_lcd_common.h

diff --git a/arch/arm/boot/dts/dsi-v2-panel-auo-rm68190-qhd-video.dtsi b/arch/arm/boot/dts/dsi-v2-panel-auo-rm68190-qhd-video.dtsi
new file mode 100644
index 0000000..f25d006
--- /dev/null
+++ b/arch/arm/boot/dts/dsi-v2-panel-auo-rm68190-qhd-video.dtsi
@@ -0,0 +1,92 @@
+/* Copyright (c) 2013, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/ {
+	qcom,dsi_v2_auo_rm68190_qhd_video {
+		compatible = "huawei,lcd_panel_id4";
+		label = "AUO RM68190 QHD video mode dsi panel";
+		qcom,dsi-ctrl-phandle = <&mdss_dsi0>;
+		qcom,rst-gpio = <&msmgpio 41 0>;
+		vdda-supply = <&pm8110_l19>;
+		vddio-supply=<&pm8110_l6>;
+		qcom,mdss-pan-res = <540 960>;
+		qcom,mdss-pan-bpp = <24>;
+		qcom,mdss-pan-dest = "display_1";
+		qcom,mdss-pan-porch-values = <4 10 4 4 10 4>;
+		qcom,mdss-pan-underflow-clr = <0xff>;
+		qcom,mdss-pan-bl-levels = <1 255>;
+		qcom,mdss-pan-bl-ctrl = "bl_ctrl_dcs";
+		qcom,mdss-pan-dsi-mode = <0>;
+		qcom,mdss-pan-dsi-h-pulse-mode = <1>;
+		qcom,mdss-pan-dsi-h-power-stop = <0 0 0>;
+		qcom,mdss-pan-dsi-bllp-power-stop = <1 1>;
+		qcom,mdss-pan-dsi-traffic-mode = <2>;
+		qcom,mdss-pan-dsi-dst-format = <3>;
+		qcom,mdss-pan-dsi-vc = <0>;
+		qcom,mdss-pan-dsi-rgb-swap = <0>;
+		qcom,mdss-pan-dsi-data-lanes = <1 1 0 0>;
+		qcom,mdss-pan-dsi-dlane-swap = <1>;
+		qcom,mdss-pan-dsi-t-clk = <0x1b 0x04>;
+		qcom,mdss-pan-dsi-stream = <0>;
+		qcom,mdss-pan-dsi-mdp-tr = <0x0>;/*todo*/
+		qcom,mdss-pan-dsi-dma-tr = <0x04>;
+		qcom,mdss-pan-dsi-frame-rate = <60>;
+		qcom,panel-phy-regulatorSettings =[09 08 05 00 20 03];
+		qcom,panel-phy-timingSettings = [72 19 10  00 3c 46
+						 14 1c 1c  03 04 00];
+		qcom,panel-phy-strengthCtrl = [ff 06];
+		qcom,panel-phy-bistCtrl = [03 03 00 00 0f 00];
+		qcom,panel-phy-laneConfig =
+					[80 45 00 00 01 66 /*lane0**/
+					80 45 00 00 01 66 /*lane1*/
+					80 45 00 00 01 66 /*lane2*/
+					80 45 00 00 01 66 /*lane3*/
+					40 67 00 00 01 88]; /*Clk*/
+
+		qcom,on-cmds-dsi-state = "DSI_LP_MODE";
+		qcom,panel-on-cmds = [39 01 00 00 00 06
+					F0 55 AA 52 08 00
+				39 01 00 00 00 03
+					B1 68 00
+				39 01 00 00 00 02
+					B3 82
+				39 01 00 00 00 13
+					C8 01 02 45 45 45 45 45
+					45 45 45 45 45 45 45 45
+					45 45 45
+				39 01 00 00 00 02
+					BC 05
+				39 01 00 00 00 02
+					BA 05
+				39 01 00 00 00 05
+					FF AA 55 25 01
+				39 01 00 00 00 02
+					F3 02
+				39 01 00 00 00 02
+					6F 17
+				39 01 00 00 00 02
+					F2 20
+				39 01 00 00 28 02
+					35 00
+				39 01 00 00 00 02
+					51 ff
+				39 01 00 00 00 02
+					53 2c
+				05 01 00 00 28 02
+					11 00
+				05 01 00 00 28 02
+					29 00];
+		qcom,panel-off-cmds = [05 01 00 00 32 02 28 00
+					05 01 00 00 78 02 10 00];
+		qcom,off-cmds-dsi-state = "DSI_LP_MODE";
+	};
+};
diff --git a/arch/arm/boot/dts/dsi-v2-panel-boe-nt35517-qhd-video.dtsi b/arch/arm/boot/dts/dsi-v2-panel-boe-nt35517-qhd-video.dtsi
new file mode 100644
index 0000000..ebd3c4a
--- /dev/null
+++ b/arch/arm/boot/dts/dsi-v2-panel-boe-nt35517-qhd-video.dtsi
@@ -0,0 +1,166 @@
+/* Copyright (c) 2013, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/ {
+	qcom,dsi_v2_boe_nt35517_qhd_video {
+		compatible = "huawei,lcd_panel_id5";
+		label = "BOE NT35517 QHD video mode dsi panel";
+		qcom,dsi-ctrl-phandle = <&mdss_dsi0>;
+		qcom,rst-gpio = <&msmgpio 41 0>;
+		vdda-supply = <&pm8110_l19>;
+		vddio-supply=<&pm8110_l6>;
+		qcom,mdss-pan-res = <540 960>;
+		qcom,mdss-pan-bpp = <24>;
+		qcom,mdss-pan-dest = "display_1";
+		qcom,mdss-pan-porch-values = <60 8 60 15 5 7>;
+		qcom,mdss-pan-underflow-clr = <0xff>;
+		qcom,mdss-pan-bl-levels = <1 255>;
+		qcom,mdss-pan-bl-ctrl = "bl_ctrl_dcs";
+		qcom,mdss-pan-dsi-mode = <0>;
+		qcom,mdss-pan-dsi-h-pulse-mode = <1>;
+		qcom,mdss-pan-dsi-h-power-stop = <0 0 0>;
+		qcom,mdss-pan-dsi-bllp-power-stop = <1 1>;
+		qcom,mdss-pan-dsi-traffic-mode = <2>;
+		qcom,mdss-pan-dsi-dst-format = <3>;
+		qcom,mdss-pan-dsi-vc = <0>;
+		qcom,mdss-pan-dsi-rgb-swap = <0>;
+		qcom,mdss-pan-dsi-data-lanes = <1 1 0 0>;
+		qcom,mdss-pan-dsi-dlane-swap = <1>;
+		qcom,mdss-pan-dsi-t-clk = <0x1b 0x04>;
+		qcom,mdss-pan-dsi-stream = <0>;
+		qcom,mdss-pan-dsi-mdp-tr = <0x0>;/*todo*/
+		qcom,mdss-pan-dsi-dma-tr = <0x04>;
+		qcom,mdss-pan-dsi-frame-rate = <60>;
+		qcom,panel-phy-regulatorSettings =[09 08 05 00 20 03];
+		qcom,panel-phy-timingSettings = [85 1e 14  00 43 4c
+						 18 21 22  03 04 00];
+		qcom,panel-phy-strengthCtrl = [ff 06];
+		qcom,panel-phy-bistCtrl = [03 03 00 00 0f 00];
+		qcom,panel-phy-laneConfig =
+					[80 45 00 00 01 66 /*lane0**/
+					80 45 00 00 01 66 /*lane1*/
+					80 45 00 00 01 66 /*lane2*/
+					80 45 00 00 01 66 /*lane3*/
+					40 67 00 00 01 88]; /*Clk*/
+
+		qcom,on-cmds-dsi-state = "DSI_LP_MODE";
+		qcom,panel-on-cmds = [39 01 00 00 00 06
+							F0 55 AA 52 08 00
+						30 01 00 00 00 02
+							BC 00
+						39 01 00 00 00 04
+							CC 03 00 00
+						39 01 00 00 00 06
+							B0 00 0C 40 3C 3C
+						39 01 00 00 00 03
+							B1 FC 00
+						39 01 00 00 00 02
+							B6 08
+						39 01 00 00 00 03
+							B7 00 00
+						39 01 00 00 00 02
+							BA 01
+						39 01 00 00 00 06
+							BD 01 41 10 37 01
+						39 01 00 00 00 03
+							E0 01 01
+						39 01 00 00 00 06
+							F0 55 AA 52 08 01
+						39 01 00 00 00 04
+							B0 0A 0A 0A
+						39 01 00 00 00 04
+							B6 44 44 44
+						39 01 00 00 00 04
+							B1 0A 0A 0A
+						39 01 00 00 00 04
+							B7 24 24 24
+						39 01 00 00 00 04
+							B2 03 03 03
+						39 01 00 00 00 04
+							B8 33 33 33
+						39 01 00 00 00 04
+							B3 0D 0D 0D
+						39 01 00 00 00 04
+							B9 24 24 24
+						39 01 00 00 00 04
+							B4 0A 0A 0A
+						39 01 00 00 00 04
+							BA 24 24 24
+						39 01 00 00 00 04
+							B5 07 07 07
+						39 01 00 00 00 04
+							BC 00 78 00
+						39 01 00 00 00 04
+							BD 00 78 00
+						39 01 00 00 00 11
+							D1 00 43 00 5A 00 7E 00 96 00 A1 00 C3 00 E9 01 14
+						39 01 00 00 00 11
+							D2 01 35 01 6D 01 9A 01 E1 02 19 02 1B 02 4D 02 85
+						39 01 00 00 00 11
+							D3 02 A6 02 D4 02 F2 03 23 03 41 03 6A 03 7F 03 9E
+						39 01 00 00 00 05
+							D4 03 B4 03 FF
+						39 01 00 00 00 11
+							D5 00 43 00 5A 00 7E 00 96 00 A1 00 C3 00 E9 01 14
+						39 01 00 00 00 11
+							D6 01 35 01 6D 01 9A 01 E1 02 19 02 1B 02 4D 02 85
+						39 01 00 00 00 11
+							D7 02 A6 02 D4 02 F2 03 23 03 41 03 6A 03 7F 03 9E
+						39 01 00 00 00 05
+							D8 03 B4 03 FF
+						39 01 00 00 00 11
+							D9 00 43 00 5A 00 7E 00 96 00 A1 00 C3 00 E9 01 14
+						39 01 00 00 00 11
+							DD 01 35 01 6D 01 9A 01 E1 02 19 02 1B 02 4D 02 85
+						39 01 00 00 00 11
+							DE 02 A6 02 D4 02 F2 03 23 03 41 03 6A 03 7F 03 9E
+						39 01 00 00 00 05
+							DF 03 B4 03 FF
+						39 01 00 00 00 11
+							E0 00 43 00 5A 00 7E 00 96 00 A1 00 C3 00 E9 01 14
+						39 01 00 00 00 11
+							E1 01 35 01 6D 01 9A 01 E1 02 19 02 1B 02 4D 02 85
+						39 01 00 00 00 11
+							E2 02 A6 02 D4 02 F2 03 23 03 41 03 6A 03 7F 03 9E
+						39 01 00 00 00 05
+							E3 03 B4 03 FF
+						39 01 00 00 00 11
+							E4 00 43 00 5A 00 7E 00 96 00 A1 00 C3 00 E9 01 14
+						39 01 00 00 00 11
+							E5 01 35 01 6D 01 9A 01 E1 02 19 02 1B 02 4D 02 85
+						39 01 00 00 00 11
+							E6 02 A6 02 D4 02 F2 03 23 03 41 03 6A 03 7F 03 9E
+						39 01 00 00 00 05
+							E7 03 B4 03 FF
+						39 01 00 00 00 11
+							E8 00 43 00 5A 00 7E 00 96 00 A1 00 C3 00 E9 01 14
+						39 01 00 00 00 11
+							E9 01 35 01 6D 01 9A 01 E1 02 19 02 1B 02 4D 02 85
+						39 01 00 00 00 11
+							EA 02 A6 02 D4 02 F2 03 23 03 41 03 6A 03 7F 03 9E
+						39 01 00 00 00 05
+							EB 03 B4 03 FF
+						39 01 00 00 00 02
+							51 ff
+						39 01 00 00 00 02
+							53 2c
+						39 01 00 00 00 02
+							55 02
+						05 01 00 00 78 02
+							11 00
+						05 01 00 00 28 02
+							29 00];
+		qcom,panel-off-cmds = [05 01 00 00 32 02 28 00
+					05 01 00 00 78 02 10 00];
+		qcom,off-cmds-dsi-state = "DSI_LP_MODE";
+	};
+};
diff --git a/arch/arm/boot/dts/dsi-v2-panel-byd-nt35517-qhd-video.dtsi b/arch/arm/boot/dts/dsi-v2-panel-byd-nt35517-qhd-video.dtsi
new file mode 100644
index 0000000..ef031a4
--- /dev/null
+++ b/arch/arm/boot/dts/dsi-v2-panel-byd-nt35517-qhd-video.dtsi
@@ -0,0 +1,164 @@
+/* Copyright (c) 2013, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/ {
+	qcom,dsi_v2_byd_nt35517_qhd_video {
+		compatible = "huawei,lcd_panel_id1";
+		label = "BYD NT35517 QHD video mode dsi panel";
+		qcom,dsi-ctrl-phandle = <&mdss_dsi0>;
+		qcom,rst-gpio = <&msmgpio 41 0>;
+		vdda-supply = <&pm8110_l19>;
+		vddio-supply=<&pm8110_l6>;
+		qcom,mdss-pan-res = <540 960>;
+		qcom,mdss-pan-bpp = <24>;
+		qcom,mdss-pan-dest = "display_1";
+		qcom,mdss-pan-porch-values = <3 11 15 3 11 15>;
+		qcom,mdss-pan-underflow-clr = <0xff>;
+		qcom,mdss-pan-bl-levels = <1 255>;
+		qcom,mdss-pan-bl-ctrl = "bl_ctrl_dcs";
+		qcom,mdss-pan-dsi-mode = <0>;
+		qcom,mdss-pan-dsi-h-pulse-mode = <1>;
+		qcom,mdss-pan-dsi-h-power-stop = <0 0 0>;
+		qcom,mdss-pan-dsi-bllp-power-stop = <1 1>;
+		qcom,mdss-pan-dsi-traffic-mode = <2>;
+		qcom,mdss-pan-dsi-dst-format = <3>;
+		qcom,mdss-pan-dsi-vc = <0>;
+		qcom,mdss-pan-dsi-rgb-swap = <0>;
+		qcom,mdss-pan-dsi-data-lanes = <1 1 0 0>;
+		qcom,mdss-pan-dsi-dlane-swap = <1>;
+		qcom,mdss-pan-dsi-t-clk = <0x1b 0x04>;
+		qcom,mdss-pan-dsi-stream = <0>;
+		qcom,mdss-pan-dsi-mdp-tr = <0x0>;/*todo*/
+		qcom,mdss-pan-dsi-dma-tr = <0x04>;
+		qcom,mdss-pan-dsi-frame-rate = <60>;
+		qcom,panel-phy-regulatorSettings =[09 08 05 00 20 03];
+		qcom,panel-phy-timingSettings = [75 1a 11  00 3d 45
+						 15 1d 1c  03 04 00];
+		qcom,panel-phy-strengthCtrl = [ff 06];
+		qcom,panel-phy-bistCtrl = [03 03 00 00 0f 00];
+		qcom,panel-phy-laneConfig =
+					[80 45 00 00 01 66 /*lane0**/
+					80 45 00 00 01 66 /*lane1*/
+					80 45 00 00 01 66 /*lane2*/
+					80 45 00 00 01 66 /*lane3*/
+					40 67 00 00 01 88]; /*Clk*/
+
+		qcom,on-cmds-dsi-state = "DSI_LP_MODE";
+		qcom,panel-on-cmds = [39 01 00 00 00 06
+						F0 55 AA 52 08 00
+					39 01 00 00 00 02
+						B3 82
+					39 01 00 00 00 02
+						BC 00
+					39 01 00 00 00 06
+						F0 55 AA 52 08 01
+					39 01 00 00 00 02
+						C0 C0
+					39 01 00 00 00 02
+						C2 20
+					39 01 00 00 00 02
+						B0 05
+					39 01 00 00 00 02
+						B6 44
+					39 01 00 00 00 02
+						B1 05
+					39 01 00 00 00 02
+						B7 34
+					39 01 00 00 00 02
+						B2 02
+					39 01 00 00 00 02
+						B8 13
+					39 01 00 00 00 02
+						B3 0E
+					39 01 00 00 00 02
+						B9 23
+					39 01 00 00 00 02
+						B4 08
+					39 01 00 00 00 02
+						BA 23
+					39 01 00 00 00 04
+						BC 00 78 00
+					39 01 00 00 00 04
+						BD 00 78 00
+					39 01 00 00 00 02
+						BE 34
+					39 01 00 00 00 11
+						D1 00 1C 00 38 00 5C 00 7A 00 91 00 B6 00 D5 01 07
+					39 01 00 00 00 11
+						D2 01 2F 01 6E 01 9F 01 EC 02 28 02 29 02 61 02 9C
+					39 01 00 00 00 11
+						D3 02 C0 02 ED 03 0A 03 2D 03 40 03 50 03 56 03 5B
+					39 01 00 00 00 05
+						D4 03 5D 03 5D
+					39 01 00 00 00 11
+						D5 00 1C 00 38 00 5C 00 7A 00 91 00 B6 00 D5 01 07
+					39 01 00 00 00 11
+						D6 01 2F 01 6E 01 9F 01 EC 02 28 02 29 02 61 02 9C
+					39 01 00 00 00 11
+						D7 02 C0 02 ED 03 0A 03 2D 03 40 03 50 03 56 03 5B
+					39 01 00 00 00 05
+						D8 03 5D 03 5D
+					39 01 00 00 00 11
+						D9 00 1C 00 38 00 5C 00 7A 00 91 00 B6 00 D5 01 07
+					39 01 00 00 00 11
+						DD 01 2F 01 6E 01 9F 01 EC 02 28 02 29 02 61 02 9C
+					39 01 00 00 00 11
+						DE 02 C0 02 ED 03 0A 03 2D 03 40 03 50 03 56 03 5B
+					39 01 00 00 00 05
+						DF 03 5D 03 5D
+					39 01 00 00 00 11
+						E0 00 1C 00 38 00 5C 00 7A 00 91 00 B6 00 D5 01 07
+					39 01 00 00 00 11
+						E1 01 2F 01 6E 01 9F 01 EC 02 28 02 29 02 61 02 9C
+					39 01 00 00 00 11
+						E2 02 C0 02 ED 03 0A 03 2D 03 40 03 50 03 56 03 5B
+					39 01 00 00 00 05
+						E3 03 5D 03 5D
+					39 01 00 00 00 11
+						E4 00 1C 00 38 00 5C 00 7A 00 91 00 B6 00 D5 01 07
+					39 01 00 00 00 11
+						E5 01 2F 01 6E 01 9F 01 EC 02 28 02 29 02 61 02 9C
+					39 01 00 00 00 11
+						E6 02 C0 02 ED 03 0A 03 2D 03 40 03 50 03 56 03 5B
+					39 01 00 00 00 05
+						E7 03 5D 03 5D
+					39 01 00 00 00 11
+						E8 00 1C 00 38 00 5C 00 7A 00 91 00 B6 00 D5 01 07
+					39 01 00 00 00 11
+						E9 01 2F 01 6E 01 9F 01 EC 02 28 02 29 02 61 02 9C
+					39 01 00 00 00 11
+						EA 02 C0 02 ED 03 0A 03 2D 03 40 03 50 03 56 03 5B
+					39 01 00 00 00 05
+						EB 03 5D 03 5D
+					39 01 00 00 00 05
+						FF AA 55 25 01
+					39 01 00 00 00 02
+						6F 0B
+					39 01 00 00 00 05
+						F4 12 12 56 13
+					39 01 00 00 00 02
+						51 ff
+					39 01 00 00 00 02
+						53 2c
+					39 01 00 00 00 02
+						55 02
+					39 01 00 00 00 02
+						35 00
+					05 01 00 00 78 02
+						11 00
+					05 01 00 00 28 02
+						29 00];
+		qcom,panel-off-cmds = [05 01 00 00 32 02 28 00
+					05 01 00 00 78 02 10 00];
+		qcom,off-cmds-dsi-state = "DSI_LP_MODE";
+	};
+};
diff --git a/arch/arm/boot/dts/dsi-v2-panel-emulator.dtsi b/arch/arm/boot/dts/dsi-v2-panel-emulator.dtsi
new file mode 100644
index 0000000..88f710f
--- /dev/null
+++ b/arch/arm/boot/dts/dsi-v2-panel-emulator.dtsi
@@ -0,0 +1,64 @@
+/* Copyright (c) 2013, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/ {
+	qcom,dsi_v2_emulator {
+		compatible = "huawei,lcd_panel_idA"; /* this panel id only for emulator, copy form dsi-v2-panel-hx8389b-qhd-video.dtsi*/
+		label = "EMULATOR panel";
+		qcom,dsi-ctrl-phandle = <&mdss_dsi0>;
+		qcom,rst-gpio = <&msmgpio 41 0>;
+		vdda-supply = <&pm8110_l19>;
+		vddio-supply=<&pm8110_l6>;
+		qcom,mdss-pan-res = <540 960>;
+		qcom,mdss-pan-bpp = <24>;
+		qcom,mdss-pan-dest = "display_1";
+		qcom,mdss-pan-porch-values = <96 96 96 15 5 10>;
+		qcom,mdss-pan-underflow-clr = <0xff>;
+		qcom,mdss-pan-bl-levels = <1 255>;
+		qcom,mdss-pan-bl-ctrl = "bl_ctrl_wled";
+		qcom,mdss-pan-dsi-mode = <0>;
+		qcom,mdss-pan-dsi-h-pulse-mode = <1>;
+		qcom,mdss-pan-dsi-h-power-stop = <1 1 1>;
+		qcom,mdss-pan-dsi-bllp-power-stop = <1 1>;
+		qcom,mdss-pan-dsi-traffic-mode = <2>;
+		qcom,mdss-pan-dsi-dst-format = <3>;
+		qcom,mdss-pan-dsi-vc = <0>;
+		qcom,mdss-pan-dsi-rgb-swap = <0>;
+		qcom,mdss-pan-dsi-data-lanes = <1 1 0 0>;
+		qcom,mdss-pan-dsi-dlane-swap = <1>;
+		qcom,mdss-pan-dsi-t-clk = <0x1b 0x04>;
+		qcom,mdss-pan-dsi-stream = <0>;
+		qcom,mdss-pan-dsi-mdp-tr = <0x0>;/*todo*/
+		qcom,mdss-pan-dsi-dma-tr = <0x04>;
+		qcom,mdss-pan-dsi-frame-rate = <60>;
+		qcom,panel-phy-regulatorSettings =[09 08 05 00 20 03];
+		qcom,panel-phy-timingSettings = [8b 12 14  00 45 4a
+						 19 23 23  03 04 00];
+		qcom,panel-phy-strengthCtrl = [ff 06];
+		qcom,panel-phy-bistCtrl = [03 03 00 00 0f 00];
+		qcom,panel-phy-laneConfig =
+					[80 45 00 00 01 66 /*lane0**/
+					80 45 00 00 01 66 /*lane1*/
+					80 45 00 00 01 66 /*lane2*/
+					80 45 00 00 01 66 /*lane3*/
+					40 67 00 00 01 88]; /*Clk*/
+
+		qcom,on-cmds-dsi-state = "DSI_LP_MODE";
+		qcom,panel-on-cmds = [05 01 00 00 0a 02
+						11 00
+					05 01 00 00 78 02
+						29 00];
+		qcom,panel-off-cmds = [05 01 00 00 32 02 28 00
+					05 01 00 00 78 02 10 00];
+		qcom,off-cmds-dsi-state = "DSI_LP_MODE";
+	};
+};
diff --git a/arch/arm/boot/dts/dsi-v2-panel-hx8389b-qhd-video.dtsi b/arch/arm/boot/dts/dsi-v2-panel-hx8389b-qhd-video.dtsi
new file mode 100644
index 0000000..39825b5
--- /dev/null
+++ b/arch/arm/boot/dts/dsi-v2-panel-hx8389b-qhd-video.dtsi
@@ -0,0 +1,118 @@
+/* Copyright (c) 2013, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/ {
+	qcom,dsi_v2_hx8389b_qhd_video {
+		compatible = "huawei,lcd_panel_id0";
+		label = "HX8389B QHD video mode dsi panel";
+		qcom,dsi-ctrl-phandle = <&mdss_dsi0>;
+		qcom,rst-gpio = <&msmgpio 41 0>;
+		vdda-supply = <&pm8110_l19>;
+		vddio-supply=<&pm8110_l6>;
+		qcom,mdss-pan-res = <540 960>;
+		qcom,mdss-pan-bpp = <24>;
+		qcom,mdss-pan-dest = "display_1";
+		qcom,mdss-pan-porch-values = <96 96 96 15 5 10>;
+		qcom,mdss-pan-underflow-clr = <0xff>;
+		qcom,mdss-pan-bl-levels = <1 255>;
+		qcom,mdss-pan-bl-ctrl = "bl_ctrl_dcs";
+		qcom,mdss-pan-dsi-mode = <0>;
+		qcom,mdss-pan-dsi-h-pulse-mode = <1>;
+		qcom,mdss-pan-dsi-h-power-stop = <1 1 1>;
+		qcom,mdss-pan-dsi-bllp-power-stop = <1 1>;
+		qcom,mdss-pan-dsi-traffic-mode = <2>;
+		qcom,mdss-pan-dsi-dst-format = <3>;
+		qcom,mdss-pan-dsi-vc = <0>;
+		qcom,mdss-pan-dsi-rgb-swap = <0>;
+		qcom,mdss-pan-dsi-data-lanes = <1 1 0 0>;
+		qcom,mdss-pan-dsi-dlane-swap = <1>;
+		qcom,mdss-pan-dsi-t-clk = <0x1b 0x04>;
+		qcom,mdss-pan-dsi-stream = <0>;
+		qcom,mdss-pan-dsi-mdp-tr = <0x0>;/*todo*/
+		qcom,mdss-pan-dsi-dma-tr = <0x04>;
+		qcom,mdss-pan-dsi-frame-rate = <60>;
+		qcom,panel-phy-regulatorSettings =[09 08 05 00 20 03];
+		qcom,panel-phy-timingSettings = [9f 25 19  00 4d 57
+						 1d 29 2a  03 04 00];
+		qcom,panel-phy-strengthCtrl = [ff 06];
+		qcom,panel-phy-bistCtrl = [03 03 00 00 0f 00];
+		qcom,panel-phy-laneConfig =
+					[80 45 00 00 01 66 /*lane0**/
+					80 45 00 00 01 66 /*lane1*/
+					80 45 00 00 01 66 /*lane2*/
+					80 45 00 00 01 66 /*lane3*/
+					40 67 00 00 01 88]; /*Clk*/
+
+		qcom,on-cmds-dsi-state = "DSI_LP_MODE";
+		qcom,panel-on-cmds = [39 01 00 00 00 04
+						B9 FF 83 89
+					39 01 00 00 00 02
+						51 ff
+					39 01 00 00 00 02
+						53 24
+					39 01 00 00 05 02
+						55 00
+					39 01 00 00 01 08
+						BA 41 93 00 16 A4 10 18
+					39 01 00 00 01 02
+						C6 08
+					39 01 00 00 01 14
+						B1 00 00 07 EF 97 10 11
+						94 F1 26 2E 3F 3F 42 01
+						32 F7 20 80
+					39 01 00 00 0a 04
+						DE 05 58 10
+					39 01 00 00 00 08
+						B2 00 00 78 0E 03 3F 80
+					39 01 00 00 01 18
+						B4 80 08 00 32 10 07 32
+						10 07 32 10 07 27 01 5A
+						0B 37 05 4C 14 50 5B 0a
+					39 01 00 00 0a 31
+						D5 00 00 00 00 01 00 00
+						00 60 00 99 88 88 88 88
+						23 88 01 88 67 88 45 01
+						23 23 88 88 88 88 88 99
+						88 88 88 54 88 76 88 10
+						88 32 32 10 88 88 88 88
+						88
+					39 01 00 00 0a 23
+						E0 01 1B 21 34 32 3F 32
+						4B 07 0D 10 13 16 13 14
+						0F 19 01 1B 21 34 32 3F
+						32 4B 07 0D 10 13 16 13
+						14 0F 19
+					39 01 00 00 05 05
+						B6 00 89 00 89
+					39 01 00 00 01 02
+						CC 02
+					39 01 00 00 00 04
+						B7 00 00 50
+					39 01 00 00 00 02
+						E6 01
+					39 01 00 00 00 02
+						E4 00
+					39 01 00 00 0a 02
+						51 64
+					39 01 00 00 00 02
+						53 24
+					39 01 00 00 00 02
+						55 01
+					05 01 00 00 0a 02
+						11 00
+					05 01 00 00 78 02
+						29 00];
+		qcom,panel-off-cmds = [05 01 00 00 32 02 28 00
+					05 01 00 00 78 02 10 00];
+		qcom,off-cmds-dsi-state = "DSI_LP_MODE";
+	};
+};
diff --git a/arch/arm/boot/dts/dsi-v2-panel-otm9605a-qhd-video.dtsi b/arch/arm/boot/dts/dsi-v2-panel-otm9605a-qhd-video.dtsi
index da3e18e..51190cc 100755
--- a/arch/arm/boot/dts/dsi-v2-panel-otm9605a-qhd-video.dtsi
+++ b/arch/arm/boot/dts/dsi-v2-panel-otm9605a-qhd-video.dtsi
@@ -12,7 +12,7 @@
 
 / {
 	qcom,dsi_v2_otm9605a_qhd_video {
-		compatible = "qcom,dsi-panel-v2";
+		compatible = "huawei,lcd_panel_id9";
 		label = "OTM9605A QHD video mode dsi panel";
 		qcom,dsi-ctrl-phandle = <&mdss_dsi0>;
 		qcom,rst-gpio = <&msmgpio 41 0>;
diff --git a/arch/arm/boot/dts/msm8610-qrd.dtsi b/arch/arm/boot/dts/msm8610-qrd.dtsi
index f3b8974..62db7ab 100644
--- a/arch/arm/boot/dts/msm8610-qrd.dtsi
+++ b/arch/arm/boot/dts/msm8610-qrd.dtsi
@@ -28,7 +28,7 @@
 
 &soc {
 	i2c@f9923000{
-		focaltech@38{
+		/*focaltech@38{
 			compatible = "focaltech,5x06";
 			reg = <0x38>;
 			interrupt-parent = <&msmgpio>;
@@ -43,6 +43,85 @@
 			focaltech,button-map= <139 102 158>;
 			focaltech,no-force-update;
 			focaltech,i2c-pull-up;
+		};*/
+		tsc@1a {
+			compatible = "cy,cyttsp4_i2c_adapter";
+			reg = <0x1a>;
+			/* GPIO 38, high-to-low edge triggered */
+			interrupts = <1 0x2>;
+			interrupt-parent = <&msmgpio>;
+			vdd-supply = <&pm8110_l19>;
+			vcc_i2c-supply = <&pm8110_l14>;
+		cy,adapter_id = "cyttsp4_i2c_adapter";
+
+		cy,core {
+			cy,name = "cyttsp4_core";
+			cy,id = "main_ttsp_core";
+
+			cy,irq_gpio = <1>;
+			cy,rst_gpio = <0>;
+
+			/* Enable cy,max_xfer_len to limit max I2C/SPI transfer length */
+			/* cy,max_xfer_len = <0x100>; */
+
+			/* CY_CORE_FLAG_WAKE_ON_GESTURE */
+			cy,flags = <1>;
+			/* CY_CORE_EWG_TAP_TAP | CY_CORE_EWG_TWO_FINGER_SLIDE */
+			cy,easy_wakeup_gesture = <3>;
+			cy,btn_keys = <158 /* KEY_HOME */
+				       172 /* KEY_MENU */
+				       139 /* KEY_BACK */
+				       217 /* KEY_SEARCH */
+				       114 /* KEY_VOLUMEDOWN */
+				       115 /* KEY_VOLUMEUP */
+				       212 /* KEY_CAMERA */
+				       116>; /* KEY_POWER */
+			cy,btn_keys-tag = <0>;
+
+			cy,mt {
+				cy,name = "cyttsp4_mt";
+
+				cy,inp_dev_name = "cyttsp4_mt";
+				/* CY_MT_FLAG_FLIP | CY_MT_FLAG_INV_X | CY_MT_FLAG_INV_Y */
+				cy,flags = <0x0>;
+				cy,abs =
+					/* ABS_MT_POSITION_X, CY_ABS_MIN_X, CY_ABS_MAX_X, 0, 0 */
+					<0x35 0 540 0 0
+					/* ABS_MT_POSITION_Y, CY_ABS_MIN_Y, CY_ABS_MAX_Y, 0, 0 */
+					0x36 0 960 0 0
+					/* ABS_MT_PRESSURE, CY_ABS_MIN_P, CY_ABS_MAX_P, 0, 0 */
+					0x3a 0 255 0 0
+					/* CY_IGNORE_VALUE, CY_ABS_MIN_W, CY_ABS_MAX_W, 0, 0 */
+					0xffff 0 255 0 0
+					/* ABS_MT_TRACKING_ID, CY_ABS_MIN_T, CY_ABS_MAX_T, 0, 0 */
+					0x39 0 15 0 0
+					/* ABS_MT_TOUCH_MAJOR, 0, 255, 0, 0 */
+					0x30 0 255 0 0
+					/* ABS_MT_TOUCH_MINOR, 0, 255, 0, 0 */
+					0x31 0 255 0 0
+					/* ABS_MT_ORIENTATION, -128, 127, 0, 0 */
+					0x34 0xfffffed7 127 0 0>;
+
+			    cy,vkeys_x = <540>;
+				cy,vkeys_y = <960>;
+				 cy,virtual_keys = /* KeyCode CenterX CenterY Width Height */
+				         /* KEY_BACK */
+				         <158 100 1000 80 70
+				         /* KEY_HOME */
+					 /* < DTS2013081205521 yangzicheng 20130812 begin */
+					 /*modify the key value of KEY_HOME*/
+				         102 280 1000 80 70
+					 /* DTS2013081205521 yangzicheng 20130812 end > */
+				         /* KEY_MENU */
+				         139 450 1000 80 70>;
+			};
+			/*
+				cy,btn {
+					cy,name = "cyttsp4_btn";
+					cy,inp_dev_name = "cyttsp4_btn";
+					};*/
+
+		};
 		};
 	};
 
diff --git a/arch/arm/boot/dts/msm8610-v1-qrd-skuac.dts b/arch/arm/boot/dts/msm8610-v1-qrd-skuac.dts
index 4de516c..8c75ebf 100644
--- a/arch/arm/boot/dts/msm8610-v1-qrd-skuac.dts
+++ b/arch/arm/boot/dts/msm8610-v1-qrd-skuac.dts
@@ -15,6 +15,11 @@
 /include/ "msm8610-v1.dtsi"
 /include/ "msm8610-qrd.dtsi"
 /include/ "dsi-v2-panel-otm9605a-qhd-video.dtsi"
+/include/ "dsi-v2-panel-auo-rm68190-qhd-video.dtsi"
+/include/ "dsi-v2-panel-boe-nt35517-qhd-video.dtsi"
+/include/ "dsi-v2-panel-byd-nt35517-qhd-video.dtsi"
+/include/ "dsi-v2-panel-hx8389b-qhd-video.dtsi"
+/include/ "dsi-v2-panel-emulator.dtsi"
 
 / {
 	model = "Qualcomm MSM 8610 QRD";
diff --git a/arch/arm/configs/msm8610_defconfig b/arch/arm/configs/msm8610_defconfig
index a5f0704..601850c 100644
--- a/arch/arm/configs/msm8610_defconfig
+++ b/arch/arm/configs/msm8610_defconfig
@@ -223,12 +223,38 @@ CONFIG_INPUT_EVDEV=y
 CONFIG_INPUT_EVBUG=m
 CONFIG_KEYBOARD_GPIO=y
 CONFIG_INPUT_TOUCHSCREEN=y
-CONFIG_TOUCHSCREEN_ATMEL_MXT=y
-CONFIG_TOUCHSCREEN_FT5X06=y
-CONFIG_TOUCHSCREEN_GEN_VKEYS=y
-CONFIG_TOUCHSCREEN_SYNAPTICS_I2C_RMI4=y
-CONFIG_TOUCHSCREEN_SYNAPTICS_DSX_RMI4_DEV=y
-CONFIG_TOUCHSCREEN_SYNAPTICS_DSX_FW_UPDATE=y
+#CONFIG_TOUCHSCREEN_ATMEL_MXT=y
+#CONFIG_TOUCHSCREEN_FT5X06=y
+#CONFIG_TOUCHSCREEN_GEN_VKEYS=y
+#CONFIG_TOUCHSCREEN_SYNAPTICS_I2C_RMI4=y
+#CONFIG_TOUCHSCREEN_SYNAPTICS_DSX_RMI4_DEV=y
+#CONFIG_TOUCHSCREEN_SYNAPTICS_DSX_FW_UPDATE=y
+#===========touch===============
+CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4=y
+CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_DEVICETREE_SUPPORT=y
+CONFIG_CYTTSP4_PLATFORM=y
+CONFIG_CYPRESS_CYTTSP4_BUS=y
+CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_USE_FW_BIN_FILE=y
+CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_I2C=y
+# CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_SPI is not set
+# CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_MT_A is not set
+#CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_BUTTON is not set
+CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_MT_B=y
+CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_DEVICE_ACCESS=y
+CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_LOADER=y
+# CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_DEBUG is not set
+# CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_VDEBUG is not set
+CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_DEBUG_MODULE=y
+# CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_PLATFORM_FW_UPGRADE is not set
+CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_BINARY_FW_UPGRADE=y
+# CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_PLATFORM_TTCONFIG_UPGRADE is not set
+CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_MANUAL_TTCONFIG_UPGRADE=y
+# CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_PROXIMITY is not set
+# CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_DEVICE_ACCESS_API is not set
+# CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_TEST_DEVICE_ACCESS_API is not set
+# CONFIG_EXTRA_FIRMWARE="cyttsp4_fw.bin" 
+# CONFIG_EXTRA_FIRMWARE_DIR="firmware"
+#==========end touch====================
 CONFIG_INPUT_MISC=y
 CONFIG_INPUT_UINPUT=y
 CONFIG_INPUT_GPIO=m
diff --git a/drivers/input/touchscreen/Kconfig b/drivers/input/touchscreen/Kconfig
index 9b0c5c7..338d461 100644
--- a/drivers/input/touchscreen/Kconfig
+++ b/drivers/input/touchscreen/Kconfig
@@ -1019,5 +1019,6 @@ config TOUCHSCREEN_GT9XX
           If unsure, say N.
 
 source "drivers/input/touchscreen/gt9xx/Kconfig"
+source "drivers/input/touchscreen/cypress/Kconfig"
 
 endif
diff --git a/drivers/input/touchscreen/Makefile b/drivers/input/touchscreen/Makefile
index 3acc612..a9671a7 100644
--- a/drivers/input/touchscreen/Makefile
+++ b/drivers/input/touchscreen/Makefile
@@ -83,3 +83,4 @@ obj-$(CONFIG_TOUCHSCREEN_SYNAPTICS_I2C_RMI4)		+= synaptics_i2c_rmi4.o
 obj-$(CONFIG_TOUCHSCREEN_SYNAPTICS_DSX_RMI4_DEV)	+= synaptics_rmi_dev.o
 obj-$(CONFIG_TOUCHSCREEN_SYNAPTICS_DSX_FW_UPDATE) 	+= synaptics_fw_update.o
 obj-$(CONFIG_TOUCHSCREEN_GT9XX)		+= gt9xx/
+obj-y   += cypress/
\ No newline at end of file
diff --git a/drivers/input/touchscreen/cypress/Kconfig b/drivers/input/touchscreen/cypress/Kconfig
new file mode 100644
index 0000000..0145807
--- /dev/null
+++ b/drivers/input/touchscreen/cypress/Kconfig
@@ -0,0 +1,206 @@
+#
+# Touchscreen driver configuration
+#
+config CYPRESS_CYTTSP4_BUS
+	bool "Cypress TTSP core bus"
+	default n
+	help
+	  This option enables support Cypress TTSP core bus.
+	  This support is needed for various device and drivers
+	  using Cypress TrueTouch(TM) Standard Product
+	  protocol.
+
+config TOUCHSCREEN_CYPRESS_CYTTSP4
+	tristate "Cypress TrueTouch Gen4 Touchscreen Driver"
+	default y
+	select CYPRESS_CYTTSP4_BUS
+	help
+	  Core driver for Cypress TrueTouch(tm) Standard Product
+	  Geneartion4 touchscreen controllers.
+
+	  Say Y here if you have a Cypress Gen4 touchscreen.
+
+	  If unsure, say N.
+
+	  To compile this driver as a module, choose M here.
+
+config TOUCHSCREEN_CYPRESS_CYTTSP4_DEVICETREE_SUPPORT
+	bool "Enable Device Tree support"
+	default n
+	depends on TOUCHSCREEN_CYPRESS_CYTTSP4 && OF
+	help
+	  This option enables support for device tree.
+
+	  Say Y here to enable device tree support.
+
+config TOUCHSCREEN_CYPRESS_CYTTSP4_DEBUG
+	bool "Enable debug output"
+	depends on TOUCHSCREEN_CYPRESS_CYTTSP4
+	default n
+	help
+	  Enable Debug output for Cypress TrueTouch(tm)
+	  Standard Product Generation4 drivers set.
+
+	  Say Y here to enable debug output.
+
+config TOUCHSCREEN_CYPRESS_CYTTSP4_VDEBUG
+	bool "Enable verbose debug output"
+	depends on TOUCHSCREEN_CYPRESS_CYTTSP4_DEBUG
+	default n 
+	help
+	  Enable Verbose Debug output for Cypress TrueTouch(tm)
+	  Standard Product Generation4 drivers set.
+
+	  Say Y here to enable verbose debug output.
+
+config TOUCHSCREEN_CYPRESS_CYTTSP4_I2C
+	tristate "Cypress TrueTouch Gen4 I2C"
+	depends on TOUCHSCREEN_CYPRESS_CYTTSP4
+	select I2C
+	default y
+	help
+	  Cypress TrueTouch(tm) Standard Product Generation4
+	  I2C bus interface.
+
+	  Say Y here to enable I2C bus interface to TTSP
+	  touchscreen controller.
+
+config TOUCHSCREEN_CYPRESS_CYTTSP4_SPI
+	tristate "Cypress TrueTouch Gen4 SPI"
+	depends on TOUCHSCREEN_CYPRESS_CYTTSP4
+	select SPI
+	default m
+	help
+	  Cypress TrueTouch(tm) Standard Product Generation4
+	  SPI bus interface.
+
+	  Say Y here to enable SPI bus interface to TTSP
+	  touchscreen controller.
+
+config TOUCHSCREEN_CYPRESS_CYTTSP4_MT_A
+	tristate "Cypress TrueTouch Gen4 MultiTouch Protocol A"
+	depends on TOUCHSCREEN_CYPRESS_CYTTSP4
+	default m
+	help
+	  Cypress TrueTouch(tm) Standard Product Generation4
+	  MutliTouch Protocol A support.
+
+	  Say Y here to enable MutiTouch touch reporting
+	  using protocol A.
+
+config TOUCHSCREEN_CYPRESS_CYTTSP4_MT_B
+	tristate "Cypress TrueTouch Gen4 MultiTouch Protocol B"
+	depends on TOUCHSCREEN_CYPRESS_CYTTSP4
+	default y
+	help
+	  Cypress TrueTouch(tm) Standard Product Generation4
+	  MutliTouch Protocol B support.
+
+	  Say Y here to enable MutiTouch touch reporting
+	  using protocol B.
+
+config TOUCHSCREEN_CYPRESS_CYTTSP4_BUTTON
+	tristate "Cypress TrueTouch Gen4 MultiTouch CapSense Button"
+	depends on TOUCHSCREEN_CYPRESS_CYTTSP4
+	default y  
+	help
+	  Cypress TrueTouch(tm) Standard Product Generation4
+	  CapSense driver.
+
+	  Say Y here to enable CapSense reporting.
+
+config TOUCHSCREEN_CYPRESS_CYTTSP4_PROXIMITY
+	tristate "Cypress TrueTouch Gen4 Proximity"
+	depends on TOUCHSCREEN_CYPRESS_CYTTSP4
+	default m
+	help
+	  Cypress TrueTouch(tm) Standard Product Generation4
+	  Proximity driver.
+
+	  Say Y here to enable proximity reporting.
+
+config TOUCHSCREEN_CYPRESS_CYTTSP4_DEVICE_ACCESS
+	tristate "Cypress TrueTouch Gen4 MultiTouch Device Access"
+	depends on TOUCHSCREEN_CYPRESS_CYTTSP4
+	default m
+	help
+	  Cypress TrueTouch(tm) Standard Product Generation4
+	  Device access module.
+
+	  This modules adds an interface to access touchscreen
+	  controller using driver sysfs nodes.
+
+config TOUCHSCREEN_CYPRESS_CYTTSP4_DEVICE_ACCESS_API
+	bool "Enable Device Access kernel API"
+	depends on TOUCHSCREEN_CYPRESS_CYTTSP4_DEVICE_ACCESS
+	default n
+	help
+	  Say Y here to enable Device access kernel API.
+
+config TOUCHSCREEN_CYPRESS_CYTTSP4_TEST_DEVICE_ACCESS_API
+	tristate "Simple Test module for Device Access kernel API"
+	depends on TOUCHSCREEN_CYPRESS_CYTTSP4_DEVICE_ACCESS
+	depends on TOUCHSCREEN_CYPRESS_CYTTSP4_DEVICE_ACCESS_API
+	default n
+	help
+	  Say Y here to enable test module for Device access kernel API.
+
+config TOUCHSCREEN_CYPRESS_CYTTSP4_LOADER
+	tristate "Cypress TrueTouch Gen4 MultiTouch Loader"
+	depends on TOUCHSCREEN_CYPRESS_CYTTSP4
+	default y 
+	help
+	  Cypress TrueTouch(tm) Standard Product Generation4
+	  FW Loader module.
+
+	  This module enables support for Firmware upgrade.
+
+config TOUCHSCREEN_CYPRESS_CYTTSP4_PLATFORM_FW_UPGRADE
+	bool "FW upgrade from header file"
+	depends on TOUCHSCREEN_CYPRESS_CYTTSP4_LOADER
+	default n 
+	help
+	  Include Cypress TrueTouch(tm) Standard Product
+	  Generation4 device Firmware into driver.
+
+	  Need proper header file for this.
+
+config TOUCHSCREEN_CYPRESS_CYTTSP4_BINARY_FW_UPGRADE
+	bool "FW upgrade from binary file"
+	depends on TOUCHSCREEN_CYPRESS_CYTTSP4_LOADER
+	default n
+	help
+	  Include Cypress TrueTouch(tm) Standard Product
+	  Generation4 device Firmware into kernel itself.
+
+	  This should be enabled for manual FW upgrade.
+
+config TOUCHSCREEN_CYPRESS_CYTTSP4_PLATFORM_TTCONFIG_UPGRADE
+	bool "TT Configuration upgrade from header file"
+	depends on TOUCHSCREEN_CYPRESS_CYTTSP4_LOADER
+	default n 
+	help
+	  Include Cypress TrueTouch(tm) Standard Product
+	  Generation4 device TrueTouch Configuration into
+	  kernel itself.
+
+	  Need proper header file for this.
+
+config TOUCHSCREEN_CYPRESS_CYTTSP4_MANUAL_TTCONFIG_UPGRADE
+	bool "TT Configuration upgrade via SysFs"
+	depends on TOUCHSCREEN_CYPRESS_CYTTSP4_LOADER
+	default n 
+	help
+	  Provides a SysFs interface to upgrade TrueTouch
+	  Configuration with a binary configuration file.
+
+config TOUCHSCREEN_CYPRESS_CYTTSP4_DEBUG_MODULE
+	tristate "Cypress TrueTouch Gen4 MultiTouch Debug Module"
+	depends on TOUCHSCREEN_CYPRESS_CYTTSP4
+	default m
+	help
+	  Cypress TrueTouch(tm) Standard Product Generation4
+	  Debug module.
+
+	  This module adds support for verbose printing touch
+	  information.
diff --git a/drivers/input/touchscreen/cypress/Makefile b/drivers/input/touchscreen/cypress/Makefile
new file mode 100644
index 0000000..b09c450
--- /dev/null
+++ b/drivers/input/touchscreen/cypress/Makefile
@@ -0,0 +1,62 @@
+#
+# Makefile for the touchscreen drivers.
+#
+
+# Each configuration option enables a list of files.
+
+obj-$(CONFIG_CYPRESS_CYTTSP4_BUS) += cyttsp4_bus.o
+obj-$(CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4)	+= cyttsp4_core.o
+ifdef CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4
+obj-y += cyttsp4_platform.o
+endif
+obj-$(CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_I2C)	+= cyttsp4_i2c.o
+obj-$(CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_SPI)	+= cyttsp4_spi.o
+obj-$(CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_MT_A)	+= cyttsp4_mt_a.o
+cyttsp4_mt_a-y := cyttsp4_mta.o cyttsp4_mt_common.o
+obj-$(CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_MT_B)	+= cyttsp4_mt_b.o
+cyttsp4_mt_b-y := cyttsp4_mtb.o cyttsp4_mt_common.o
+obj-$(CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_BUTTON)	+= cyttsp4_btn.o
+obj-$(CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_PROXIMITY)	+= cyttsp4_proximity.o
+obj-$(CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_DEVICE_ACCESS)	+= cyttsp4_device_access.o
+obj-$(CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_TEST_DEVICE_ACCESS_API)	+= cyttsp4_test_device_access_api.o
+obj-$(CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_LOADER)	+= cyttsp4_loader.o
+obj-$(CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_DEBUG_MODULE)	+= cyttsp4_debug.o
+obj-$(CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_DEVICETREE_SUPPORT)	+= cyttsp4_devtree.o
+ifeq ($(CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_DEBUG),y)
+CFLAGS_cyttsp4_bus.o += -DDEBUG
+CFLAGS_cyttsp4_core.o += -DDEBUG
+CFLAGS_cyttsp4_i2c.o += -DDEBUG
+CFLAGS_cyttsp4_spi.o += -DDEBUG
+CFLAGS_cyttsp4_mta.o += -DDEBUG
+CFLAGS_cyttsp4_mtb.o += -DDEBUG
+CFLAGS_cyttsp4_mt_a.o += -DDEBUG
+CFLAGS_cyttsp4_mt_b.o += -DDEBUG
+CFLAGS_cyttsp4_mt_common.o += -DDEBUG
+CFLAGS_cyttsp4_btn.o += -DDEBUG
+CFLAGS_cyttsp4_proximity.o += -DDEBUG
+CFLAGS_cyttsp4_device_access.o += -DDEBUG
+CFLAGS_cyttsp4_loader.o += -DDEBUG
+CFLAGS_cyttsp4_debug.o += -DDEBUG
+CFLAGS_cyttsp4_devtree.o += -DDEBUG
+CFLAGS_cyttsp4_platform.o += -DDEBUG
+endif
+
+ifeq ($(CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_VDEBUG),y)
+CFLAGS_cyttsp4_bus.o += -DVERBOSE_DEBUG
+CFLAGS_cyttsp4_core.o += -DVERBOSE_DEBUG
+CFLAGS_cyttsp4_i2c.o += -DVERBOSE_DEBUG
+CFLAGS_cyttsp4_spi.o += -DVERBOSE_DEBUG
+CFLAGS_cyttsp4_mta.o += -DVERBOSE_DEBUG
+CFLAGS_cyttsp4_mtb.o += -DVERBOSE_DEBUG
+CFLAGS_cyttsp4_mt_a.o += -DVERBOSE_DEBUG
+CFLAGS_cyttsp4_mt_b.o += -DVERBOSE_DEBUG
+CFLAGS_cyttsp4_mt_common.o += -DVERBOSE_DEBUG
+CFLAGS_cyttsp4_btn.o += -DVERBOSE_DEBUG
+CFLAGS_cyttsp4_proximity.o += -DVERBOSE_DEBUG
+CFLAGS_cyttsp4_device_access.o += -DVERBOSE_DEBUG
+CFLAGS_cyttsp4_loader.o += -DVERBOSE_DEBUG
+CFLAGS_cyttsp4_debug.o += -DVERBOSE_DEBUG
+CFLAGS_cyttsp4_devtree.o += -DVERBOSE_DEBUG
+CFLAGS_cyttsp4_platform.o += -DVERBOSE_DEBUG
+endif
+
diff --git a/drivers/input/touchscreen/cypress/cyttsp4_btn.c b/drivers/input/touchscreen/cypress/cyttsp4_btn.c
new file mode 100644
index 0000000..279beb7
--- /dev/null
+++ b/drivers/input/touchscreen/cypress/cyttsp4_btn.c
@@ -0,0 +1,527 @@
+/*
+ * cyttsp4_btn.c
+ * Cypress TrueTouch(TM) Standard Product V4 CapSense touch reports module.
+ * For use with Cypress Txx4xx parts.
+ * Supported parts include:
+ * TMA4XX
+ * TMA1036
+ *
+ * Copyright (C) 2012 Cypress Semiconductor
+ * Copyright (C) 2011 Sony Ericsson Mobile Communications AB.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2, and only version 2, as published by the
+ * Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * Contact Cypress Semiconductor at www.cypress.com <ttdrivers@cypress.com>
+ *
+ */
+
+#include <linux/cyttsp4_bus.h>
+
+#include <linux/delay.h>
+#ifdef CONFIG_HAS_EARLYSUSPEND
+#include <linux/earlysuspend.h>
+#endif
+#include <linux/gpio.h>
+#include <linux/input.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/limits.h>
+#include <linux/module.h>
+#include <linux/pm_runtime.h>
+#include <linux/slab.h>
+#include <linux/workqueue.h>
+
+#include <linux/cyttsp4_btn.h>
+#include <linux/cyttsp4_core.h>
+#include "cyttsp4_regs.h"
+
+struct cyttsp4_btn_data {
+	struct cyttsp4_device *ttsp;
+	struct cyttsp4_btn_platform_data *pdata;
+	struct cyttsp4_sysinfo *si;
+	struct input_dev *input;
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	struct early_suspend es;
+#endif
+	struct mutex report_lock;
+	bool is_suspended;
+	bool input_device_registered;
+	char phys[NAME_MAX];
+	u8 pr_buf[CY_MAX_PRBUF_SIZE];
+};
+
+
+static inline void cyttsp4_btn_key_action(struct cyttsp4_btn_data *bd,
+	int btn_no, int btn_state)
+{
+	struct device *dev = &bd->ttsp->dev;
+	struct cyttsp4_sysinfo *si = bd->si;
+
+	if (!si->btn[btn_no].enabled ||
+			si->btn[btn_no].state == btn_state)
+		return;
+
+	si->btn[btn_no].state = btn_state;
+	input_report_key(bd->input, si->btn[btn_no].key_code, btn_state);
+	input_sync(bd->input);
+
+	dev_dbg(dev, "%s: btn=%d key_code=%d %s\n", __func__,
+		btn_no, si->btn[btn_no].key_code,
+		btn_state == CY_BTN_PRESSED ?
+			"PRESSED" : "RELEASED");
+}
+
+static void cyttsp4_get_btn_touches(struct cyttsp4_btn_data *bd)
+{
+	struct cyttsp4_sysinfo *si = bd->si;
+	int num_btn_regs = si->si_ofs.num_btn_regs;
+	int num_btns = si->si_ofs.num_btns;
+	int cur_reg;
+	int cur_reg_val;
+	int cur_btn;
+	int cur_btn_state;
+	int i;
+
+	for (cur_btn = 0, cur_reg = 0; cur_reg < num_btn_regs; cur_reg++) {
+		cur_reg_val = si->xy_mode[si->si_ofs.rep_ofs + 2 + cur_reg];
+
+		for (i = 0; i < CY_NUM_BTN_PER_REG && cur_btn < num_btns;
+				i++, cur_btn++) {
+			/* Get current button state */
+			cur_btn_state = cur_reg_val &
+					((1 << CY_BITS_PER_BTN) - 1);
+			/* Shift reg value for next iteration */
+			cur_reg_val >>= CY_BITS_PER_BTN;
+
+			cyttsp4_btn_key_action(bd, cur_btn, cur_btn_state);
+		}
+	}
+}
+
+static void cyttsp4_btn_lift_all(struct cyttsp4_btn_data *bd)
+{
+	struct cyttsp4_sysinfo *si = bd->si;
+	int i;
+
+	if (!si || si->si_ofs.num_btns == 0)
+		return;
+
+	for (i = 0; i < si->si_ofs.num_btns; i++)
+		cyttsp4_btn_key_action(bd, i, CY_BTN_RELEASED);
+}
+
+#ifdef VERBOSE_DEBUG
+static void cyttsp4_log_btn_data(struct cyttsp4_btn_data *bd)
+{
+	struct device *dev = &bd->ttsp->dev;
+	struct cyttsp4_sysinfo *si = bd->si;
+	int cur;
+	int t;
+
+	for (cur = 0; cur < si->si_ofs.num_btns; cur++) {
+		bd->pr_buf[0] = 0;
+		snprintf(bd->pr_buf, CY_MAX_PRBUF_SIZE, "btn_rec[%d]=0x", cur);
+		for (t = 0; t < si->si_ofs.btn_rec_size; t++)
+			snprintf(bd->pr_buf, CY_MAX_PRBUF_SIZE, "%s%02X",
+				bd->pr_buf, si->btn_rec_data
+				[(cur * si->si_ofs.btn_rec_size) + t]);
+
+		dev_vdbg(dev, "%s: %s\n", __func__, bd->pr_buf);
+	}
+	return;
+}
+#endif
+
+/* read xy_data for all current CapSense button touches */
+static int cyttsp4_xy_worker(struct cyttsp4_btn_data *bd)
+{
+	struct device *dev = &bd->ttsp->dev;
+	struct cyttsp4_sysinfo *si = bd->si;
+	u8 rep_stat = si->xy_mode[si->si_ofs.rep_ofs + 1];
+#ifdef VERBOSE_DEBUG
+	int rc;
+#endif
+
+	/* rep_data for bad packet check */
+	if (IS_BAD_PKT(rep_stat)) {
+		dev_dbg(dev, "%s: Invalid buffer detected\n", __func__);
+		return 0;
+	}
+
+	/* extract button press/release touch information */
+	if (si->si_ofs.num_btns > 0) {
+		cyttsp4_get_btn_touches(bd);
+#ifdef VERBOSE_DEBUG
+		/* read button diff data */
+		rc = cyttsp4_read(bd->ttsp, CY_MODE_OPERATIONAL,
+				si->si_ofs.tt_stat_ofs + 1 +
+				si->si_ofs.max_tchs * si->si_ofs.tch_rec_size,
+				si->btn_rec_data,
+				si->si_ofs.num_btns * si->si_ofs.btn_rec_size);
+		if (rc < 0) {
+			dev_err(dev, "%s: read fail on button regs r=%d\n",
+					__func__, rc);
+			return 0;
+		}
+
+		/* log button press/release touch information */
+		cyttsp4_log_btn_data(bd);
+#endif
+	}
+
+	dev_vdbg(dev, "%s: done\n", __func__);
+
+	return 0;
+}
+
+static int cyttsp4_btn_attention(struct cyttsp4_device *ttsp)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_btn_data *bd = dev_get_drvdata(dev);
+	int rc = 0;
+
+	dev_vdbg(dev, "%s\n", __func__);
+
+	mutex_lock(&bd->report_lock);
+	if (!bd->is_suspended) {
+		/* core handles handshake */
+		rc = cyttsp4_xy_worker(bd);
+	} else {
+		dev_vdbg(dev, "%s: Ignoring report while suspended\n",
+			__func__);
+	}
+	mutex_unlock(&bd->report_lock);
+	if (rc < 0)
+		dev_err(dev, "%s: xy_worker error r=%d\n", __func__, rc);
+
+	return rc;
+}
+
+static int cyttsp4_startup_attention(struct cyttsp4_device *ttsp)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_btn_data *bd = dev_get_drvdata(dev);
+
+	dev_vdbg(dev, "%s\n", __func__);
+
+	mutex_lock(&bd->report_lock);
+	cyttsp4_btn_lift_all(bd);
+	mutex_unlock(&bd->report_lock);
+
+	return 0;
+}
+
+static int cyttsp4_btn_open(struct input_dev *input)
+{
+	struct device *dev = input->dev.parent;
+	struct cyttsp4_device *ttsp =
+		container_of(dev, struct cyttsp4_device, dev);
+
+	dev_dbg(dev, "%s\n", __func__);
+
+	pm_runtime_get(dev);
+
+	dev_vdbg(dev, "%s: setup subscriptions\n", __func__);
+
+	/* set up touch call back */
+	cyttsp4_subscribe_attention(ttsp, CY_ATTEN_IRQ,
+		cyttsp4_btn_attention, CY_MODE_OPERATIONAL);
+
+	/* set up startup call back */
+	cyttsp4_subscribe_attention(ttsp, CY_ATTEN_STARTUP,
+		cyttsp4_startup_attention, 0);
+
+	return 0;
+}
+
+static void cyttsp4_btn_close(struct input_dev *input)
+{
+	struct device *dev = input->dev.parent;
+	struct cyttsp4_device *ttsp =
+		container_of(dev, struct cyttsp4_device, dev);
+
+	dev_dbg(dev, "%s\n", __func__);
+
+	cyttsp4_unsubscribe_attention(ttsp, CY_ATTEN_IRQ,
+		cyttsp4_btn_attention, CY_MODE_OPERATIONAL);
+
+	cyttsp4_unsubscribe_attention(ttsp, CY_ATTEN_STARTUP,
+		cyttsp4_startup_attention, 0);
+
+	pm_runtime_put(dev);
+}
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+static void cyttsp4_btn_early_suspend(struct early_suspend *h)
+{
+	struct cyttsp4_btn_data *bd =
+		container_of(h, struct cyttsp4_btn_data, es);
+	struct device *dev = &bd->ttsp->dev;
+
+	dev_dbg(dev, "%s\n", __func__);
+
+#ifndef CONFIG_PM_RUNTIME
+	mutex_lock(&bd->report_lock);
+	bd->is_suspended = true;
+	cyttsp4_btn_lift_all(bd);
+	mutex_unlock(&bd->report_lock);
+#endif
+
+	pm_runtime_put(dev);
+}
+
+static void cyttsp4_btn_late_resume(struct early_suspend *h)
+{
+	struct cyttsp4_btn_data *bd =
+		container_of(h, struct cyttsp4_btn_data, es);
+	struct device *dev = &bd->ttsp->dev;
+
+	dev_dbg(dev, "%s\n", __func__);
+
+#ifndef CONFIG_PM_RUNTIME
+	mutex_lock(&bd->report_lock);
+	bd->is_suspended = false;
+	mutex_unlock(&bd->report_lock);
+#endif
+
+	pm_runtime_get(dev);
+}
+#endif
+
+#ifdef CONFIG_PM_RUNTIME
+static int cyttsp4_btn_suspend(struct device *dev)
+{
+	struct cyttsp4_btn_data *bd = dev_get_drvdata(dev);
+
+	dev_dbg(dev, "%s\n", __func__);
+
+	mutex_lock(&bd->report_lock);
+	bd->is_suspended = true;
+	cyttsp4_btn_lift_all(bd);
+	mutex_unlock(&bd->report_lock);
+
+	return 0;
+}
+
+static int cyttsp4_btn_resume(struct device *dev)
+{
+	struct cyttsp4_btn_data *bd = dev_get_drvdata(dev);
+
+	dev_dbg(dev, "%s\n", __func__);
+
+	mutex_lock(&bd->report_lock);
+	bd->is_suspended = false;
+	mutex_unlock(&bd->report_lock);
+
+	return 0;
+}
+#endif
+
+static const struct dev_pm_ops cyttsp4_btn_pm_ops = {
+	SET_RUNTIME_PM_OPS(cyttsp4_btn_suspend, cyttsp4_btn_resume, NULL)
+};
+
+static int cyttsp4_setup_input_device(struct cyttsp4_device *ttsp)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_btn_data *bd = dev_get_drvdata(dev);
+	int i;
+	int rc;
+
+	dev_vdbg(dev, "%s: Initialize event signals\n", __func__);
+	__set_bit(EV_KEY, bd->input->evbit);
+	for (i = 0; i < bd->si->si_ofs.num_btns; i++)
+		__set_bit(bd->si->btn[i].key_code, bd->input->keybit);
+
+	rc = input_register_device(bd->input);
+	if (rc < 0)
+		dev_err(dev, "%s: Error, failed register input device r=%d\n",
+			__func__, rc);
+	else
+		bd->input_device_registered = true;
+
+	return rc;
+}
+
+static int cyttsp4_setup_input_attention(struct cyttsp4_device *ttsp)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_btn_data *bd = dev_get_drvdata(dev);
+	int rc;
+
+	dev_vdbg(dev, "%s\n", __func__);
+
+	bd->si = cyttsp4_request_sysinfo(ttsp);
+	if (!bd->si)
+		return -1;
+
+	rc = cyttsp4_setup_input_device(ttsp);
+
+	cyttsp4_unsubscribe_attention(ttsp, CY_ATTEN_STARTUP,
+		cyttsp4_setup_input_attention, 0);
+
+	return rc;
+}
+
+static int cyttsp4_btn_probe(struct cyttsp4_device *ttsp)
+{
+	struct cyttsp4_btn_data *bd;
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_btn_platform_data *pdata = dev_get_platdata(dev);
+	int rc = 0;
+
+	dev_info(dev, "%s\n", __func__);
+	dev_dbg(dev, "%s: debug on\n", __func__);
+	dev_vdbg(dev, "%s: verbose debug on\n", __func__);
+
+	if (pdata == NULL) {
+		dev_err(dev, "%s: Missing platform data\n", __func__);
+		rc = -ENODEV;
+		goto error_no_pdata;
+	}
+
+	bd = kzalloc(sizeof(*bd), GFP_KERNEL);
+	if (bd == NULL) {
+		dev_err(dev, "%s: Error, kzalloc\n", __func__);
+		rc = -ENOMEM;
+		goto error_alloc_data_failed;
+	}
+
+	mutex_init(&bd->report_lock);
+	bd->ttsp = ttsp;
+	bd->pdata = pdata;
+	dev_set_drvdata(dev, bd);
+	/* Create the input device and register it. */
+	dev_vdbg(dev, "%s: Create the input device and register it\n",
+		__func__);
+	bd->input = input_allocate_device();
+	if (bd->input == NULL) {
+		dev_err(dev, "%s: Error, failed to allocate input device\n",
+			__func__);
+		rc = -ENOSYS;
+		goto error_alloc_failed;
+	}
+
+	bd->input->name = ttsp->name;
+	scnprintf(bd->phys, sizeof(bd->phys)-1, "%s", dev_name(dev));
+	bd->input->phys = bd->phys;
+	bd->input->dev.parent = &bd->ttsp->dev;
+	bd->input->open = cyttsp4_btn_open;
+	bd->input->close = cyttsp4_btn_close;
+	input_set_drvdata(bd->input, bd);
+
+	pm_runtime_enable(dev);
+
+	/* get sysinfo */
+	bd->si = cyttsp4_request_sysinfo(ttsp);
+	if (bd->si) {
+		rc = cyttsp4_setup_input_device(ttsp);
+		if (rc)
+			goto error_init_input;
+	} else {
+		dev_err(dev, "%s: Fail get sysinfo pointer from core p=%p\n",
+			__func__, bd->si);
+		cyttsp4_subscribe_attention(ttsp, CY_ATTEN_STARTUP,
+			cyttsp4_setup_input_attention, 0);
+	}
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	bd->es.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN + 1;
+	bd->es.suspend = cyttsp4_btn_early_suspend;
+	bd->es.resume = cyttsp4_btn_late_resume;
+	register_early_suspend(&bd->es);
+#endif
+
+	dev_dbg(dev, "%s: ok\n", __func__);
+	return 0;
+
+error_init_input:
+	pm_runtime_suspend(dev);
+	pm_runtime_disable(dev);
+	input_free_device(bd->input);
+error_alloc_failed:
+	dev_set_drvdata(dev, NULL);
+	kfree(bd);
+error_alloc_data_failed:
+error_no_pdata:
+	dev_err(dev, "%s failed.\n", __func__);
+	return rc;
+}
+
+static int cyttsp4_btn_release(struct cyttsp4_device *ttsp)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_btn_data *bd = dev_get_drvdata(dev);
+
+	dev_dbg(dev, "%s\n", __func__);
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	/*
+	 * This check is to prevent pm_runtime usage_count drop below zero
+	 * because of removing the module while in suspended state
+	 */
+	if (bd->is_suspended)
+		pm_runtime_get_noresume(dev);
+
+	unregister_early_suspend(&bd->es);
+#endif
+
+	if (bd->input_device_registered) {
+		input_unregister_device(bd->input);
+	} else {
+		input_free_device(bd->input);
+		cyttsp4_unsubscribe_attention(ttsp, CY_ATTEN_STARTUP,
+			cyttsp4_setup_input_attention, 0);
+	}
+
+	pm_runtime_suspend(dev);
+	pm_runtime_disable(dev);
+
+	dev_set_drvdata(dev, NULL);
+	kfree(bd);
+	return 0;
+}
+
+static struct cyttsp4_driver cyttsp4_btn_driver = {
+	.probe = cyttsp4_btn_probe,
+	.remove = cyttsp4_btn_release,
+	.driver = {
+		.name = CYTTSP4_BTN_NAME,
+		.bus = &cyttsp4_bus_type,
+		.owner = THIS_MODULE,
+		.pm = &cyttsp4_btn_pm_ops,
+	},
+};
+
+static int __init cyttsp4_btn_init(void)
+{
+	int rc = 0;
+	rc = cyttsp4_register_driver(&cyttsp4_btn_driver);
+	pr_info("%s: Cypress TTSP MT v4 CapSense BTN (Built %s), rc=%d\n",
+		 __func__, CY_DRIVER_DATE, rc);
+	return rc;
+}
+module_init(cyttsp4_btn_init);
+
+static void __exit cyttsp4_btn_exit(void)
+{
+	cyttsp4_unregister_driver(&cyttsp4_btn_driver);
+	pr_info("%s: module exit\n", __func__);
+}
+module_exit(cyttsp4_btn_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Cypress TTSP 2D multi-touch CapSense BTN driver");
+MODULE_AUTHOR("Cypress Semiconductor");
diff --git a/drivers/input/touchscreen/cypress/cyttsp4_bus.c b/drivers/input/touchscreen/cypress/cyttsp4_bus.c
new file mode 100644
index 0000000..9de266e
--- /dev/null
+++ b/drivers/input/touchscreen/cypress/cyttsp4_bus.c
@@ -0,0 +1,761 @@
+/*
+ * cyttsp4_bus.c
+ * Cypress TrueTouch(TM) Standard Product V4 Bus Driver.
+ * For use with Cypress Txx4xx parts.
+ * Supported parts include:
+ * TMA4XX
+ * TMA1036
+ *
+ * Copyright (C) 2012 Cypress Semiconductor
+ * Copyright (C) 2011 Sony Ericsson Mobile Communications AB.
+ *
+ * Author: Aleksej Makarov aleksej.makarov@sonyericsson.com
+ * Modified by: Cypress Semiconductor for complete set of TTSP Bus interfaces.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2, and only version 2, as published by the
+ * Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * Contact Cypress Semiconductor at www.cypress.com <ttdrivers@cypress.com>
+ *
+ */
+
+#include <linux/cyttsp4_bus.h>
+
+#include <linux/device.h>
+#include <linux/kernel.h>
+#include <linux/list.h>
+#include <linux/mutex.h>
+#include <linux/pm_runtime.h>
+#include <linux/slab.h>
+#include <linux/limits.h>
+
+static DEFINE_MUTEX(core_lock);
+static LIST_HEAD(adapter_list);
+static LIST_HEAD(core_dev_list);
+static LIST_HEAD(cyttsp4_dev_list);
+
+struct bus_type cyttsp4_bus_type;
+
+static void cyttsp4_dev_release(struct device *dev)
+{
+	dev_vdbg(dev, "%s: Enter\n", __func__);
+	put_device(dev->parent);
+}
+
+static struct device_type cyttsp4_dev_type = {
+	.release = cyttsp4_dev_release
+};
+
+static struct device_type cyttsp4_core_type = {
+	.release = cyttsp4_dev_release
+};
+
+static int cyttsp4_match_dev(struct device *dev, void *data)
+{
+	return dev == (struct device *)data;
+}
+
+static void cyttsp4_initialize_device(struct cyttsp4_device *dev,
+		struct cyttsp4_device_info const *dev_info)
+{
+	dev->name = dev_info->name;
+	dev->core_id = dev_info->core_id;
+	dev->dev.platform_data = dev_info->platform_data;
+}
+
+static void _cyttsp4_reinitialize_device(struct cyttsp4_device *dev)
+{
+	void *platform_data = dev->dev.platform_data;
+
+	memset(&dev->dev, 0, sizeof(dev->dev));
+	dev->dev.platform_data = platform_data;
+	dev->core = NULL;
+}
+
+static void cyttsp4_initialize_core(struct cyttsp4_core *core,
+		struct cyttsp4_core_info const *core_info)
+{
+	core->name = core_info->name;
+	core->id = core_info->id;
+	core->adap_id = core_info->adap_id;
+	core->dev.platform_data = core_info->platform_data;
+}
+
+static void _cyttsp4_reinitialize_core(struct cyttsp4_core *core)
+{
+	void *platform_data = core->dev.platform_data;
+
+	memset(&core->dev, 0, sizeof(core->dev));
+	core->dev.platform_data = platform_data;
+	core->adap = NULL;
+}
+
+static int _cyttsp4_register_dev(struct cyttsp4_device *pdev,
+		struct cyttsp4_core *core)
+{
+	int ret;
+
+	/* Check if the device is registered with the system */
+	if (bus_find_device(&cyttsp4_bus_type, NULL, &pdev->dev,
+			cyttsp4_match_dev)) {
+		put_device(&pdev->dev);
+		return -EEXIST;
+	}
+
+	pdev->core = core;
+	pdev->dev.parent = get_device(&core->dev);
+	pdev->dev.bus = &cyttsp4_bus_type;
+	pdev->dev.type = &cyttsp4_dev_type;
+	dev_set_name(&pdev->dev, "%s.%s", pdev->name,  core->id);
+
+	ret = device_register(&pdev->dev);
+	dev_dbg(&pdev->dev,
+		"%s: Registering device '%s'. Parent at '%s', err = %d\n",
+		 __func__, dev_name(&pdev->dev),
+		 dev_name(pdev->dev.parent), ret);
+	if (ret) {
+		dev_err(&pdev->dev, "%s: failed to register device, err %d\n",
+			__func__, ret);
+		pdev->core = NULL;
+	}
+	return ret;
+}
+
+static void _cyttsp4_unregister_dev(struct cyttsp4_device *pdev)
+{
+	/* Check if the device is registered with the system */
+	if (!bus_find_device(&cyttsp4_bus_type, NULL, &pdev->dev,
+			cyttsp4_match_dev))
+		return;
+
+	dev_dbg(&pdev->dev, "%s: Unregistering device '%s'.\n",
+		__func__, dev_name(&pdev->dev));
+	/* Put reference taken by bus_find_device() */
+	put_device(&pdev->dev);
+	device_unregister(&pdev->dev);
+}
+
+static int _cyttsp4_register_core(struct cyttsp4_core *pdev,
+		struct cyttsp4_adapter *adap)
+{
+	int ret;
+
+	/* Check if the device is registered with the system */
+	if (bus_find_device(&cyttsp4_bus_type, NULL, &pdev->dev,
+			cyttsp4_match_dev)) {
+		put_device(&pdev->dev);
+		return -EEXIST;
+	}
+
+	pdev->adap = adap;
+	pdev->dev.parent = get_device(adap->dev);
+	pdev->dev.bus = &cyttsp4_bus_type;
+	pdev->dev.type = &cyttsp4_core_type;
+	dev_set_name(&pdev->dev, "%s.%s", pdev->id,  adap->id);
+
+	ret = device_register(&pdev->dev);
+	dev_dbg(&pdev->dev,
+		"%s: Registering device '%s'. Parent at '%s', err = %d\n",
+		 __func__, dev_name(&pdev->dev),
+		 dev_name(pdev->dev.parent), ret);
+	if (ret) {
+		dev_err(&pdev->dev, "%s: failed to register device, err %d\n",
+			__func__, ret);
+		pdev->adap = NULL;
+	}
+	return ret;
+}
+
+static void _cyttsp4_unregister_core(struct cyttsp4_core *pdev)
+{
+	/* Check if the core is registered with the system */
+	if (!bus_find_device(&cyttsp4_bus_type, NULL, &pdev->dev,
+			cyttsp4_match_dev))
+		return;
+
+	dev_dbg(&pdev->dev, "%s: Unregistering core '%s'.\n",
+		__func__, dev_name(&pdev->dev));
+	/* Put reference taken by bus_find_device() */
+	put_device(&pdev->dev);
+	device_unregister(&pdev->dev);
+}
+
+static void _cyttsp4_unregister_and_reinitialize_devices(
+		struct cyttsp4_core *core)
+{
+	struct cyttsp4_device *dev;
+
+	list_for_each_entry(dev, &cyttsp4_dev_list, node)
+		if (dev->core == core) {
+			_cyttsp4_unregister_dev(dev);
+			_cyttsp4_reinitialize_device(dev);
+		}
+}
+
+static struct cyttsp4_adapter *find_adapter(char const *adap_id)
+{
+	struct cyttsp4_adapter *a;
+
+	list_for_each_entry(a, &adapter_list, node)
+		if (!strncmp(a->id, adap_id, NAME_MAX))
+			return a;
+	return NULL;
+}
+
+static struct cyttsp4_core *find_core(char const *core_id)
+{
+	struct cyttsp4_core *d;
+
+	list_for_each_entry(d, &core_dev_list, node)
+		if (!strncmp(d->id, core_id, NAME_MAX))
+			return d;
+	return NULL;
+}
+
+static struct cyttsp4_core *find_core_with_driver(char const *core_id)
+{
+	struct cyttsp4_core *d;
+
+	d = find_core(core_id);
+	if (d && d->dev.driver)
+		return d;
+	return NULL;
+}
+
+static struct cyttsp4_device *find_device(char const *name,
+		char const *core_id)
+{
+	struct cyttsp4_device *d;
+
+	list_for_each_entry(d, &cyttsp4_dev_list, node)
+		if (!strncmp(d->name, name, NAME_MAX) &&
+				!strncmp(d->core_id, core_id, NAME_MAX))
+			return d;
+	return NULL;
+}
+
+static void rescan_devices(struct cyttsp4_core *core)
+{
+	struct cyttsp4_device *d;
+
+	list_for_each_entry(d, &cyttsp4_dev_list, node)
+		if (!d->core && !strncmp(core->id, d->core_id, NAME_MAX))
+			_cyttsp4_register_dev(d, core);
+}
+
+static void rescan_cores(struct cyttsp4_adapter *adap)
+{
+	struct cyttsp4_core *d;
+
+	list_for_each_entry(d, &core_dev_list, node)
+		if (!d->adap && !strncmp(adap->id, d->adap_id, NAME_MAX))
+			_cyttsp4_register_core(d, adap);
+}
+
+static int cyttsp4_check_device_info(
+	struct cyttsp4_device_info const *dev_info)
+{
+	int len;
+
+	if (!dev_info->name)
+		return -EINVAL;
+	if (!dev_info->core_id)
+		return -EINVAL;
+
+	len = strnlen(dev_info->name, NAME_MAX);
+	if (len == 0 || len == NAME_MAX)
+		return -EINVAL;
+
+	len = strnlen(dev_info->core_id, NAME_MAX);
+	if (len == 0 || len == NAME_MAX)
+		return -EINVAL;
+
+	return 0;
+}
+
+static int cyttsp4_check_core_info(
+	struct cyttsp4_core_info const *core_info)
+{
+	int len;
+
+	if (!core_info->name)
+		return -EINVAL;
+	if (!core_info->id)
+		return -EINVAL;
+	if (!core_info->adap_id)
+		return -EINVAL;
+
+	len = strnlen(core_info->name, NAME_MAX);
+	if (len == 0 || len == NAME_MAX)
+		return -EINVAL;
+
+	len = strnlen(core_info->id, NAME_MAX);
+	if (len == 0 || len == NAME_MAX)
+		return -EINVAL;
+
+	len = strnlen(core_info->adap_id, NAME_MAX);
+	if (len == 0 || len == NAME_MAX)
+		return -EINVAL;
+
+	return 0;
+}
+
+int cyttsp4_register_device(struct cyttsp4_device_info const *dev_info)
+{
+	struct cyttsp4_device *dev;
+	struct cyttsp4_core *core;
+	int ret;
+
+	if (!dev_info) {
+		ret = -EINVAL;
+		goto fail;
+	}
+
+	ret = cyttsp4_check_device_info(dev_info);
+	if (ret) {
+		pr_debug("%s: dev_info is invalid\n", __func__);
+		goto fail;
+	}
+
+	mutex_lock(&core_lock);
+	if (find_device(dev_info->name, dev_info->core_id)) {
+		pr_debug("%s: device '%s' with core id '%s' already exists\n",
+			__func__, dev_info->name, dev_info->core_id);
+		ret = -EEXIST;
+		goto fail_unlock;
+	}
+	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
+	if (!dev) {
+		pr_err("%s: failed to allocate device '%s'\n",
+			__func__, dev_info->name);
+		ret = -ENOMEM;
+		goto fail_unlock;
+	}
+	cyttsp4_initialize_device(dev, dev_info);
+	list_add(&dev->node, &cyttsp4_dev_list);
+	pr_debug("%s: '%s' added to cyttsp4_dev_list\n", __func__, dev->name);
+	core = find_core_with_driver(dev->core_id);
+	if (core)
+		ret = _cyttsp4_register_dev(dev, core);
+fail_unlock:
+	mutex_unlock(&core_lock);
+fail:
+	return ret;
+}
+EXPORT_SYMBOL_GPL(cyttsp4_register_device);
+
+int cyttsp4_unregister_device(char const *name, char const *core_id)
+{
+	struct cyttsp4_device *dev;
+	int ret = 0;
+
+	if (!name || !core_id) {
+		ret = -EINVAL;
+		goto fail;
+	}
+
+	mutex_lock(&core_lock);
+	dev = find_device(name, core_id);
+	if (!dev) {
+		pr_err("%s: device '%s' could not be found\n", __func__, name);
+		ret = -ENODEV;
+		goto fail_unlock;
+	}
+	_cyttsp4_unregister_dev(dev);
+	list_del(&dev->node);
+	pr_debug("%s: '%s' removed from cyttsp4_dev_list\n", __func__,
+		dev->name);
+	kfree(dev);
+fail_unlock:
+	mutex_unlock(&core_lock);
+fail:
+	return ret;
+}
+EXPORT_SYMBOL_GPL(cyttsp4_unregister_device);
+
+int cyttsp4_register_core_device(struct cyttsp4_core_info const *core_info)
+{
+	struct cyttsp4_core *core;
+	struct cyttsp4_adapter *adap;
+	int ret;
+
+	if (!core_info) {
+		ret = -EINVAL;
+		goto fail;
+	}
+
+	ret = cyttsp4_check_core_info(core_info);
+	if (ret) {
+		pr_debug("%s: core_info is invalid\n", __func__);
+		goto fail;
+	}
+
+	mutex_lock(&core_lock);
+	if (find_core(core_info->id)) {
+		pr_debug("%s: core id '%s' already exists\n",
+				__func__, core_info->id);
+		ret = -EEXIST;
+		goto fail_unlock;
+	}
+	core = kzalloc(sizeof(*core), GFP_KERNEL);
+	if (!core) {
+		pr_err("%s: failed to allocate core device '%s'\n",
+			__func__, core_info->name);
+		ret = -ENOMEM;
+		goto fail_unlock;
+	}
+	cyttsp4_initialize_core(core, core_info);
+	list_add(&core->node, &core_dev_list);
+	pr_debug("%s: '%s' added to core_dev_list\n", __func__, core->name);
+	adap = find_adapter(core->adap_id);
+	if (adap) {
+		pr_debug("%s: adapter for '%s' is '%s'\n", __func__,
+				core->id, dev_name(adap->dev));
+		ret = _cyttsp4_register_core(core, adap);
+		if (!ret)
+			rescan_devices(core);
+	}
+fail_unlock:
+	mutex_unlock(&core_lock);
+fail:
+	return ret;
+}
+EXPORT_SYMBOL_GPL(cyttsp4_register_core_device);
+
+int cyttsp4_add_adapter(char const *id, struct cyttsp4_ops const *ops,
+		struct device *parent)
+{
+	int rc = 0;
+	struct cyttsp4_adapter *a;
+
+	if (!parent) {
+		dev_err(parent, "%s: need parent for '%s'\n", __func__, id);
+		return -EINVAL;
+	}
+	mutex_lock(&core_lock);
+	if (find_adapter(id)) {
+		dev_err(parent, "%s: adapter '%s' already exists\n",
+				__func__, id);
+		rc = -EEXIST;
+		goto fail;
+	}
+	a = kzalloc(sizeof(*a), GFP_KERNEL);
+	if (!a) {
+		dev_err(parent, "%s: failed to allocate adapter '%s'\n",
+				__func__, id);
+		rc = -ENOMEM;
+		goto fail;
+	}
+	memcpy(a->id, id, sizeof(a->id));
+	a->id[sizeof(a->id) - 1] = 0;
+	a->read = ops->read;
+	a->write = ops->write;
+	a->dev = parent;
+	list_add(&a->node, &adapter_list);
+	dev_dbg(parent, "%s: '%s' added to adapter_list\n", __func__, id);
+	rescan_cores(a);
+fail:
+	mutex_unlock(&core_lock);
+	return rc;
+}
+EXPORT_SYMBOL_GPL(cyttsp4_add_adapter);
+
+int cyttsp4_del_adapter(char const *id)
+{
+	int rc = 0;
+	struct cyttsp4_adapter *adap;
+	struct cyttsp4_core *core;
+
+	mutex_lock(&core_lock);
+	adap = find_adapter(id);
+	if (!adap) {
+		pr_err("%s: adapter '%s' does not exist\n",
+			__func__, id);
+		rc = -ENODEV;
+		goto fail;
+	}
+
+	/* Unregister core and devices linked to this adapter
+	 * This is to prevent core and devices get probed until
+	 * their corresponding adapter is re-added
+	 */
+	list_for_each_entry(core, &core_dev_list, node) {
+		if (core->adap != adap)
+			continue;
+		_cyttsp4_unregister_and_reinitialize_devices(core);
+		_cyttsp4_unregister_core(core);
+		_cyttsp4_reinitialize_core(core);
+	}
+
+	list_del(&adap->node);
+	kfree(adap);
+	pr_debug("%s: '%s' removed from adapter_list\n", __func__, id);
+fail:
+	mutex_unlock(&core_lock);
+	return rc;
+}
+EXPORT_SYMBOL_GPL(cyttsp4_del_adapter);
+
+static struct cyttsp4_device *verify_device_type(struct device *dev)
+{
+	return dev->type == &cyttsp4_dev_type ? to_cyttsp4_device(dev) : NULL;
+}
+
+static struct cyttsp4_core *verify_core_type(struct device *dev)
+{
+	return dev->type == &cyttsp4_core_type ? to_cyttsp4_core(dev) : NULL;
+}
+
+static int cyttsp4_device_match(struct device *dev, struct device_driver *drv)
+{
+	struct cyttsp4_device *cyttsp4_dev = verify_device_type(dev);
+	struct cyttsp4_core *cyttsp4_core;
+	int match;
+
+	if (cyttsp4_dev) {
+		match = strncmp(cyttsp4_dev->name, drv->name, NAME_MAX) == 0;
+		goto exit;
+	}
+	cyttsp4_core = verify_core_type(dev);
+	if (cyttsp4_core) {
+		match = strncmp(cyttsp4_core->name, drv->name, NAME_MAX) == 0;
+		goto exit;
+	}
+	match = 0;
+exit:
+	dev_dbg(dev, "%s: %s matching '%s' driver\n", __func__,
+			match ? "is" : "isn't", drv->name);
+	return match;
+}
+
+static ssize_t modalias_show(struct device *dev, struct device_attribute *a,
+			     char *buf)
+{
+	struct cyttsp4_device *cyttsp4_dev = verify_device_type(dev);
+	struct cyttsp4_core *cyttsp4_core;
+
+	char const *name;
+	int len;
+
+	if (cyttsp4_dev) {
+		name = cyttsp4_dev->name;
+		goto exit;
+	}
+	cyttsp4_core = verify_core_type(dev);
+	if (cyttsp4_core) {
+		name = cyttsp4_core->id;
+		goto exit;
+	}
+	name = "none";
+exit:
+	len = snprintf(buf, PAGE_SIZE, "ttsp4:%s\n", name);
+	return (len >= PAGE_SIZE) ? (PAGE_SIZE - 1) : len;
+}
+
+static struct device_attribute cyttsp4_dev_attrs[] = {
+	__ATTR_RO(modalias),
+	__ATTR_NULL,
+};
+
+#ifdef CONFIG_SUSPEND
+static int cyttsp4_pm_suspend(struct device *dev)
+{
+	struct device_driver *drv = dev->driver;
+
+	dev_dbg(dev, "%s\n", __func__);
+	if (drv && drv->pm && drv->pm->suspend)
+		return drv->pm->suspend(dev);
+	return 0;
+}
+
+static int cyttsp4_pm_resume(struct device *dev)
+{
+	struct device_driver *drv = dev->driver;
+
+	dev_dbg(dev, "%s\n", __func__);
+	if (drv && drv->pm && drv->pm->resume)
+		return drv->pm->resume(dev);
+	return 0;
+}
+#else /* !CONFIG_SUSPEND */
+#define cyttsp4_pm_suspend		NULL
+#define cyttsp4_pm_resume		NULL
+#endif /* !CONFIG_SUSPEND */
+
+#ifdef CONFIG_PM_RUNTIME
+#define cyttsp4_pm_rt_suspend		pm_generic_runtime_suspend
+#define cyytsp4_pm_rt_resume		pm_generic_runtime_resume
+#define cyytsp4_pm_rt_idle		pm_generic_runtime_idle
+#else /* !CONFIG_PM_RUNTIME */
+#define cyttsp4_pm_rt_suspend		NULL
+#define cyytsp4_pm_rt_resume		NULL
+#define cyytsp4_pm_rt_idle		NULL
+#endif /* !CONFIG_PM_RUNTIME */
+
+static const struct dev_pm_ops cyttsp4_dev_pm_ops = {
+	.suspend = cyttsp4_pm_suspend,
+	.resume = cyttsp4_pm_resume,
+	.runtime_suspend = cyttsp4_pm_rt_suspend,
+	.runtime_resume = cyytsp4_pm_rt_resume,
+	.runtime_idle = cyytsp4_pm_rt_idle,
+};
+
+struct bus_type cyttsp4_bus_type = {
+	.name		= "ttsp4",
+	.dev_attrs	= cyttsp4_dev_attrs,
+	.match		= cyttsp4_device_match,
+	.uevent		= NULL,
+	.pm		= &cyttsp4_dev_pm_ops,
+};
+EXPORT_SYMBOL_GPL(cyttsp4_bus_type);
+
+static int cyttsp4_drv_remove(struct device *_dev)
+{
+	struct cyttsp4_driver *drv = to_cyttsp4_driver(_dev->driver);
+	struct cyttsp4_device *dev = to_cyttsp4_device(_dev);
+	struct cyttsp4_core *core = dev->core;
+	int ret;
+
+	ret = drv->remove(dev);
+	/* Decrease usage count of the core driver */
+	module_put(core->dev.driver->owner);
+	return ret;
+}
+
+static int cyttsp4_core_drv_remove(struct device *_dev)
+{
+	struct cyttsp4_core_driver *drv = to_cyttsp4_core_driver(_dev->driver);
+	struct cyttsp4_core *core = to_cyttsp4_core(_dev);
+	struct cyttsp4_adapter *adap = core->adap;
+	int ret;
+
+	ret = drv->remove(core);
+	/* Decrease usage count of the adapter driver */
+	module_put(adap->dev->driver->owner);
+
+	mutex_lock(&core_lock);
+	/* Unregister devices linked to this core
+	 * This is to prevent devices get probed until
+	 * their corresponding core driver is re-added
+	 */
+	_cyttsp4_unregister_and_reinitialize_devices(core);
+	mutex_unlock(&core_lock);
+
+	return ret;
+}
+
+static int cyttsp4_drv_probe(struct device *_dev)
+{
+	struct cyttsp4_driver *drv = to_cyttsp4_driver(_dev->driver);
+	struct cyttsp4_device *dev = to_cyttsp4_device(_dev);
+	struct cyttsp4_core *core = dev->core;
+	int rc;
+
+	if (!core || !core->dev.driver)
+		return -ENODEV;
+
+	/* Increase usage count of the core driver*/
+	__module_get(core->dev.driver->owner);
+
+	rc = drv->probe(dev);
+	if (rc)
+		module_put(core->dev.driver->owner);
+	dev_dbg(_dev, "%s: for %s = %d\n", __func__, dev->name, rc);
+	return rc;
+}
+
+static int cyttsp4_core_drv_probe(struct device *_dev)
+{
+	struct cyttsp4_core_driver *drv = to_cyttsp4_core_driver(_dev->driver);
+	struct cyttsp4_core *dev = to_cyttsp4_core(_dev);
+	struct cyttsp4_adapter *adap = dev->adap;
+	int rc;
+
+	if (!adap || !adap->dev->driver)
+		return -ENODEV;
+
+	/* Increase usage count of the adapter driver*/
+	__module_get(adap->dev->driver->owner);
+
+	rc = drv->probe(dev);
+	dev_dbg(_dev, "%s: for %s = %d\n", __func__, dev->name, rc);
+	if (!rc)
+		rescan_devices(dev);
+	else
+		module_put(adap->dev->driver->owner);
+	return rc;
+}
+
+int cyttsp4_register_driver(struct cyttsp4_driver *drv)
+{
+	int ret;
+
+	drv->driver.bus = &cyttsp4_bus_type;
+	if (drv->probe)
+		drv->driver.probe = cyttsp4_drv_probe;
+	if (drv->remove)
+		drv->driver.remove = cyttsp4_drv_remove;
+	ret = driver_register(&drv->driver);
+	pr_debug("%s: '%s' returned %d\n", __func__, drv->driver.name, ret);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(cyttsp4_register_driver);
+
+int cyttsp4_register_core_driver(struct cyttsp4_core_driver *drv)
+{
+	int ret;
+
+	drv->driver.bus = &cyttsp4_bus_type;
+	if (drv->probe)
+		drv->driver.probe = cyttsp4_core_drv_probe;
+	if (drv->remove)
+		drv->driver.remove = cyttsp4_core_drv_remove;
+	ret = driver_register(&drv->driver);
+	pr_debug("%s: '%s' returned %d\n", __func__, drv->driver.name, ret);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(cyttsp4_register_core_driver);
+
+void cyttsp4_unregister_driver(struct cyttsp4_driver *drv)
+{
+	driver_unregister(&drv->driver);
+}
+EXPORT_SYMBOL_GPL(cyttsp4_unregister_driver);
+
+void cyttsp4_unregister_core_driver(struct cyttsp4_core_driver *drv)
+{
+	driver_unregister(&drv->driver);
+}
+EXPORT_SYMBOL_GPL(cyttsp4_unregister_core_driver);
+
+static int __init cyttsp4_bus_init(void)
+{
+	int error;
+	error =  bus_register(&cyttsp4_bus_type);
+	if (error)
+		pr_err("%s: error %d\n", __func__, error);
+	else
+		pr_debug("%s: ok\n", __func__);
+	return error;
+}
+
+static void __exit cyttsp4_bus_exit(void)
+{
+	pr_debug("%s: ok\n", __func__);
+}
+
+subsys_initcall(cyttsp4_bus_init);
+module_exit(cyttsp4_bus_exit);
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Aleksej Makarov <aleksej.makarov@sonyericsson.com>");
diff --git a/drivers/input/touchscreen/cypress/cyttsp4_core.c b/drivers/input/touchscreen/cypress/cyttsp4_core.c
new file mode 100644
index 0000000..d48c87d
--- /dev/null
+++ b/drivers/input/touchscreen/cypress/cyttsp4_core.c
@@ -0,0 +1,3999 @@
+/*
+ * cyttsp4_core.c
+ * Cypress TrueTouch(TM) Standard Product V4 Core driver module.
+ * For use with Cypress Txx4xx parts.
+ * Supported parts include:
+ * TMA4XX
+ * TMA1036
+ *
+ * Copyright (C) 2012 Cypress Semiconductor
+ * Copyright (C) 2011 Sony Ericsson Mobile Communications AB.
+ *
+ * Author: Aleksej Makarov <aleksej.makarov@sonyericsson.com>
+ * Modified by: Cypress Semiconductor to add device functions
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2, and only version 2, as published by the
+ * Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * Contact Cypress Semiconductor at www.cypress.com <ttdrivers@cypress.com>
+ *
+ */
+
+#include <linux/cyttsp4_bus.h>
+
+#include <asm/unaligned.h>
+#include <linux/delay.h>
+#include <linux/gpio.h>
+#include <linux/input.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/limits.h>
+#include <linux/module.h>
+#include <linux/pm_runtime.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/workqueue.h>
+
+#include <linux/cyttsp4_core.h>
+#include "cyttsp4_regs.h"
+
+/* Timeout in ms. */
+#define CY_CORE_REQUEST_EXCLUSIVE_TIMEOUT	500
+#define CY_CORE_SLEEP_REQUEST_EXCLUSIVE_TIMEOUT	5000
+#define CY_CORE_WAIT_SYSINFO_MODE_TIMEOUT	2000
+#define CY_CORE_MODE_CHANGE_TIMEOUT		1000
+#define CY_CORE_RESET_AND_WAIT_TIMEOUT		500
+#define CY_CORE_WAKEUP_TIMEOUT			50
+
+#define CY_CORE_STARTUP_RETRY_COUNT		3
+
+#define IS_DEEP_SLEEP_CONFIGURED(x) \
+		((x) == 0 || (x) == 0xFF)
+
+#define IS_TMO(t)	((t) == 0)
+
+#define PUT_FIELD16(si, val, addr) \
+do { \
+	if (IS_LITTLEENDIAN((si)->si_ptrs.cydata->device_info)) \
+		put_unaligned_le16(val, addr); \
+	else \
+		put_unaligned_be16(val, addr); \
+} while (0)
+
+#define GET_FIELD16(si, addr) \
+({ \
+	u16 __val; \
+	if (IS_LITTLEENDIAN((si)->si_ptrs.cydata->device_info)) \
+		__val = get_unaligned_le16(addr); \
+	else \
+		__val = get_unaligned_be16(addr); \
+	__val; \
+})
+
+#define RETRY_OR_EXIT(retry_cnt, retry_label, exit_label) \
+do { \
+	if (retry_cnt) \
+		goto retry_label; \
+	goto exit_label; \
+} while (0)
+
+static const u8 security_key[] = {
+	0xA5, 0x01, 0x02, 0x03, 0xFF, 0xFE, 0xFD, 0x5A
+};
+
+static const u8 ldr_exit[] = {
+	0xFF, 0x01, 0x3B, 0x00, 0x00, 0x4F, 0x6D, 0x17
+};
+
+static const u8 ldr_err_app[] = {
+	0x01, 0x02, 0x00, 0x00, 0x55, 0xDD, 0x17
+};
+
+MODULE_FIRMWARE(CY_FW_FILE_NAME);
+
+const char *cy_driver_core_name = CYTTSP4_CORE_NAME;
+const char *cy_driver_core_version = CY_DRIVER_VERSION;
+const char *cy_driver_core_date = CY_DRIVER_DATE;
+
+enum cyttsp4_sleep_state {
+	SS_SLEEP_OFF,
+	SS_SLEEP_ON,
+	SS_SLEEPING,
+	SS_WAKING,
+};
+
+enum cyttsp4_startup_state {
+	STARTUP_NONE,
+	STARTUP_QUEUED,
+	STARTUP_RUNNING,
+};
+
+struct cyttsp4_core_data {
+	struct device *dev;
+	struct cyttsp4_core *core;
+	struct list_head atten_list[CY_ATTEN_NUM_ATTEN];
+	struct mutex system_lock;
+	struct mutex adap_lock;
+	enum cyttsp4_mode mode;
+	enum cyttsp4_sleep_state sleep_state;
+	enum cyttsp4_startup_state startup_state;
+	int int_status;
+	int cmd_toggle;
+	spinlock_t spinlock;
+	struct cyttsp4_core_platform_data *pdata;
+	wait_queue_head_t wait_q;
+	int irq;
+	struct work_struct startup_work;
+	struct cyttsp4_sysinfo sysinfo;
+	void *exclusive_dev;
+	int exclusive_waits;
+	atomic_t ignore_irq;
+	bool irq_enabled;
+	bool irq_wake;
+	bool wake_initiated_by_device;
+	bool invalid_touch_app;
+	int max_xfer;
+	int apa_mc_en;
+	int glove_en;
+	int stylus_en;
+	int proximity_en;
+	u8 default_scantype;
+	u8 easy_wakeup_gesture;
+	unsigned int active_refresh_cycle_ms;
+	u8 heartbeat_count;
+#ifdef VERBOSE_DEBUG
+	u8 pr_buf[CY_MAX_PRBUF_SIZE];
+#endif
+	struct work_struct watchdog_work;
+	struct timer_list watchdog_timer;
+};
+
+struct atten_node {
+	struct list_head node;
+	int (*func)(struct cyttsp4_device *);
+	struct cyttsp4_device *ttsp;
+	int mode;
+};
+
+static int _cyttsp4_put_device_into_deep_sleep(struct cyttsp4_core_data *cd,
+		u8 hst_mode_reg);
+
+static inline size_t merge_bytes(u8 high, u8 low)
+{
+	return (high << 8) + low;
+}
+
+#ifdef VERBOSE_DEBUG
+void cyttsp4_pr_buf(struct device *dev, u8 *pr_buf, u8 *dptr, int size,
+		const char *data_name)
+{
+	int i, k;
+	const char fmt[] = "%02X ";
+	int max;
+
+	if (!size)
+		return;
+
+	max = (CY_MAX_PRBUF_SIZE - 1) - sizeof(CY_PR_TRUNCATED);
+
+	pr_buf[0] = 0;
+	for (i = k = 0; i < size && k < max; i++, k += 3)
+		scnprintf(pr_buf + k, CY_MAX_PRBUF_SIZE, fmt, dptr[i]);
+
+	dev_vdbg(dev, "%s:  %s[0..%d]=%s%s\n", __func__, data_name, size - 1,
+			pr_buf, size <= max ? "" : CY_PR_TRUNCATED);
+}
+EXPORT_SYMBOL_GPL(cyttsp4_pr_buf);
+#endif
+
+static inline int cyttsp4_adap_read(struct cyttsp4_core_data *cd, u16 addr,
+		void *buf, int size)
+{
+	return cd->core->adap->read(cd->core->adap, addr, buf, size,
+			cd->max_xfer);
+}
+
+static inline int cyttsp4_adap_write(struct cyttsp4_core_data *cd, u16 addr,
+		const void *buf, int size)
+{
+	return cd->core->adap->write(cd->core->adap, addr, buf, size,
+			cd->max_xfer);
+}
+
+/* cyttsp4_platform_detect_read()
+ *
+ * This function is passed to platform detect
+ * function to perform a read operation
+ */
+static int cyttsp4_platform_detect_read(struct device *dev, u16 addr,
+		void *buf, int size)
+{
+	struct cyttsp4_core_data *cd = dev_get_drvdata(dev);
+	return cd->core->adap->read(cd->core->adap, addr, buf, size,
+			cd->max_xfer);
+}
+
+static u16 cyttsp4_calc_partial_app_crc(const u8 *data, int size, u16 crc)
+{
+	int i, j;
+
+	for (i = 0; i < size; i++) {
+		crc ^= ((u16)data[i] << 8);
+		for (j = 8; j > 0; j--)
+			if (crc & 0x8000)
+				crc = (crc << 1) ^ 0x1021;
+			else
+				crc <<= 1;
+	}
+
+	return crc;
+}
+
+static inline u16 cyttsp4_calc_app_crc(const u8 *data, int size)
+{
+	return cyttsp4_calc_partial_app_crc(data, size, 0xFFFF);
+}
+
+static const u8 *cyttsp4_get_security_key_(struct cyttsp4_device *ttsp,
+		int *size)
+{
+	if (size)
+		*size = sizeof(security_key);
+
+	return security_key;
+}
+
+static inline void cyttsp4_get_touch_axis(struct cyttsp4_core_data *cd,
+		int *axis, int size, int max, u8 *xy_data, int bofs)
+{
+	int nbyte;
+	int next;
+
+	for (nbyte = 0, *axis = 0, next = 0; nbyte < size; nbyte++) {
+		dev_vdbg(cd->dev,
+			"%s: *axis=%02X(%d) size=%d max=%08X xy_data=%p"
+			" xy_data[%d]=%02X(%d) bofs=%d\n",
+			__func__, *axis, *axis, size, max, xy_data, next,
+			xy_data[next], xy_data[next], bofs);
+		*axis = (*axis * 256) + (xy_data[next] >> bofs);
+		next++;
+	}
+
+	*axis &= max - 1;
+
+	dev_vdbg(cd->dev,
+		"%s: *axis=%02X(%d) size=%d max=%08X xy_data=%p"
+		" xy_data[%d]=%02X(%d)\n",
+		__func__, *axis, *axis, size, max, xy_data, next,
+		xy_data[next], xy_data[next]);
+}
+
+/*
+ * cyttsp4_get_touch_record_()
+ *
+ * Fills touch info for a touch record specified by rec_no
+ * Should only be called in Operational mode IRQ attention and
+ * rec_no should be less than the number of current touch records
+ */
+static void cyttsp4_get_touch_record_(struct cyttsp4_device *ttsp,
+		int rec_no, int *rec_abs)
+{
+	struct cyttsp4_core *core = ttsp->core;
+	struct cyttsp4_core_data *cd = dev_get_drvdata(&core->dev);
+	struct device *dev = cd->dev;
+	struct cyttsp4_sysinfo *si = &cd->sysinfo;
+	u8 *xy_data = si->xy_data + (rec_no * si->si_ofs.tch_rec_size);
+	enum cyttsp4_tch_abs abs;
+
+	memset(rec_abs, 0, CY_TCH_NUM_ABS * sizeof(int));
+	for (abs = CY_TCH_X; abs < CY_TCH_NUM_ABS; abs++) {
+		cyttsp4_get_touch_axis(cd, &rec_abs[abs],
+			si->si_ofs.tch_abs[abs].size,
+			si->si_ofs.tch_abs[abs].max,
+			xy_data + si->si_ofs.tch_abs[abs].ofs,
+			si->si_ofs.tch_abs[abs].bofs);
+		dev_vdbg(dev, "%s: get %s=%04X(%d)\n", __func__,
+			cyttsp4_tch_abs_string[abs],
+			rec_abs[abs], rec_abs[abs]);
+	}
+}
+
+static int cyttsp4_load_status_and_touch_regs(struct cyttsp4_core_data *cd,
+		bool optimize)
+{
+	struct cyttsp4_sysinfo *si = &cd->sysinfo;
+	struct device *dev = cd->dev;
+	int first_read_len;
+	int second_read_off;
+	int num_read_rec;
+	u8 num_cur_rec;
+	u8 hst_mode;
+	u8 rep_len;
+	u8 rep_stat;
+	u8 tt_stat;
+	int rc;
+
+	if (!si->xy_mode) {
+		dev_err(cd->dev, "%s: NULL xy_mode pointer\n",
+			__func__);
+		return -EINVAL;
+	}
+
+	first_read_len = si->si_ofs.rep_hdr_size;
+	/* Read one touch record additionally */
+	if (optimize)
+		first_read_len += si->si_ofs.tch_rec_size;
+
+	rc = cyttsp4_adap_read(cd, si->si_ofs.rep_ofs,
+			&si->xy_mode[si->si_ofs.rep_ofs], first_read_len);
+	if (rc < 0) {
+		dev_err(dev, "%s: fail read mode regs r=%d\n",
+			__func__, rc);
+		return rc;
+	}
+
+	/* print xy data */
+	cyttsp4_pr_buf(dev, cd->pr_buf, si->xy_mode,
+		si->si_ofs.mode_size, "xy_mode");
+
+	hst_mode = si->xy_mode[CY_REG_BASE];
+	rep_len = si->xy_mode[si->si_ofs.rep_ofs];
+	rep_stat = si->xy_mode[si->si_ofs.rep_ofs + 1];
+	tt_stat = si->xy_mode[si->si_ofs.tt_stat_ofs];
+	dev_vdbg(dev, "%s: %s%02X %s%d %s%02X %s%02X\n", __func__,
+		"hst_mode=", hst_mode, "rep_len=", rep_len,
+		"rep_stat=", rep_stat, "tt_stat=", tt_stat);
+
+	num_cur_rec = GET_NUM_TOUCH_RECORDS(tt_stat);
+	dev_vdbg(dev, "%s: num_cur_rec=%d\n", __func__, num_cur_rec);
+
+	if (rep_len == 0 && num_cur_rec > 0) {
+		dev_err(dev, "%s: report length error rep_len=%d num_rec=%d\n",
+			__func__, rep_len, num_cur_rec);
+		return -EIO;
+	}
+
+	num_read_rec = num_cur_rec;
+	second_read_off = si->si_ofs.tt_stat_ofs + 1;
+	if (optimize) {
+		num_read_rec--;
+		second_read_off += si->si_ofs.tch_rec_size;
+	}
+
+	if (num_read_rec <= 0)
+		goto exit_print;
+
+	rc = cyttsp4_adap_read(cd, second_read_off,
+			&si->xy_mode[second_read_off],
+			num_read_rec * si->si_ofs.tch_rec_size);
+	if (rc < 0) {
+		dev_err(dev, "%s: read fail on touch regs r=%d\n",
+			__func__, rc);
+		return rc;
+	}
+
+exit_print:
+	/* print xy data */
+	cyttsp4_pr_buf(dev, cd->pr_buf, si->xy_data,
+		num_cur_rec * si->si_ofs.tch_rec_size, "xy_data");
+
+	return 0;
+}
+
+static int cyttsp4_handshake(struct cyttsp4_core_data *cd, u8 mode)
+{
+	u8 cmd = mode ^ CY_HST_TOGGLE;
+	int rc;
+
+	if (mode & CY_HST_MODE_CHANGE) {
+		dev_err(cd->dev, "%s: Host mode change bit set, NO handshake\n",
+				__func__);
+		return 0;
+	}
+
+	rc = cyttsp4_adap_write(cd, CY_REG_BASE, &cmd, sizeof(cmd));
+	if (rc < 0)
+		dev_err(cd->dev, "%s: bus write fail on handshake (ret=%d)\n",
+				__func__, rc);
+
+	return rc;
+}
+
+static int cyttsp4_toggle_low_power_(struct cyttsp4_core_data *cd, u8 mode)
+{
+	u8 cmd = mode ^ CY_HST_LOWPOW;
+
+	int rc = cyttsp4_adap_write(cd, CY_REG_BASE, &cmd, sizeof(cmd));
+	if (rc < 0)
+		dev_err(cd->dev,
+			"%s: bus write fail on toggle low power (ret=%d)\n",
+			__func__, rc);
+	return rc;
+}
+
+static int cyttsp4_toggle_low_power(struct cyttsp4_core_data *cd, u8 mode)
+{
+	int rc;
+
+	mutex_lock(&cd->system_lock);
+	rc = cyttsp4_toggle_low_power_(cd, mode);
+	mutex_unlock(&cd->system_lock);
+
+	return rc;
+}
+
+static int cyttsp4_hw_soft_reset_(struct cyttsp4_core_data *cd)
+{
+	u8 cmd = CY_HST_RESET;
+
+	int rc = cyttsp4_adap_write(cd, CY_REG_BASE, &cmd, sizeof(cmd));
+	if (rc < 0) {
+		dev_err(cd->dev, "%s: FAILED to execute SOFT reset\n",
+				__func__);
+		return rc;
+	}
+	dev_dbg(cd->dev, "%s: execute SOFT reset\n", __func__);
+	return 0;
+}
+
+static int cyttsp4_hw_soft_reset(struct cyttsp4_core_data *cd)
+{
+	int rc;
+
+	mutex_lock(&cd->system_lock);
+	rc = cyttsp4_hw_soft_reset_(cd);
+	mutex_unlock(&cd->system_lock);
+
+	return rc;
+}
+
+static int cyttsp4_hw_hard_reset_(struct cyttsp4_core_data *cd)
+{
+	if (cd->pdata->xres) {
+		cd->pdata->xres(cd->pdata, cd->dev);
+		dev_dbg(cd->dev, "%s: execute HARD reset\n", __func__);
+		return 0;
+	}
+	dev_err(cd->dev, "%s: FAILED to execute HARD reset\n", __func__);
+	return -ENOSYS;
+}
+
+static int cyttsp4_hw_hard_reset(struct cyttsp4_core_data *cd)
+{
+	int rc;
+
+	mutex_lock(&cd->system_lock);
+	rc = cyttsp4_hw_hard_reset_(cd);
+	mutex_unlock(&cd->system_lock);
+
+	return rc;
+}
+
+static int cyttsp4_hw_reset_(struct cyttsp4_core_data *cd)
+{
+	int rc = cyttsp4_hw_hard_reset_(cd);
+	if (rc == -ENOSYS)
+		rc = cyttsp4_hw_soft_reset_(cd);
+	return rc;
+}
+
+static inline int cyttsp4_bits_2_bytes(int nbits, int *max)
+{
+	*max = 1 << nbits;
+	return (nbits + 7) / 8;
+}
+
+static int cyttsp4_si_data_offsets(struct cyttsp4_core_data *cd)
+{
+	struct cyttsp4_sysinfo *si = &cd->sysinfo;
+	int rc = cyttsp4_adap_read(cd, CY_REG_BASE, &si->si_data,
+				   sizeof(si->si_data));
+	if (rc < 0) {
+		dev_err(cd->dev, "%s: fail read sysinfo data offsets r=%d\n",
+			__func__, rc);
+		return rc;
+	}
+
+	/* Print sysinfo data offsets */
+	cyttsp4_pr_buf(cd->dev, cd->pr_buf, (u8 *)&si->si_data,
+		       sizeof(si->si_data), "sysinfo_data_offsets");
+
+	/* convert sysinfo data offset bytes into integers */
+
+	si->si_ofs.map_sz = merge_bytes(si->si_data.map_szh,
+			si->si_data.map_szl);
+	si->si_ofs.map_sz = merge_bytes(si->si_data.map_szh,
+			si->si_data.map_szl);
+	si->si_ofs.cydata_ofs = merge_bytes(si->si_data.cydata_ofsh,
+			si->si_data.cydata_ofsl);
+	si->si_ofs.test_ofs = merge_bytes(si->si_data.test_ofsh,
+			si->si_data.test_ofsl);
+	si->si_ofs.pcfg_ofs = merge_bytes(si->si_data.pcfg_ofsh,
+			si->si_data.pcfg_ofsl);
+	si->si_ofs.opcfg_ofs = merge_bytes(si->si_data.opcfg_ofsh,
+			si->si_data.opcfg_ofsl);
+	si->si_ofs.ddata_ofs = merge_bytes(si->si_data.ddata_ofsh,
+			si->si_data.ddata_ofsl);
+	si->si_ofs.mdata_ofs = merge_bytes(si->si_data.mdata_ofsh,
+			si->si_data.mdata_ofsl);
+	return rc;
+}
+
+static int cyttsp4_si_get_cydata(struct cyttsp4_core_data *cd)
+{
+	struct cyttsp4_sysinfo *si = &cd->sysinfo;
+	int read_offset;
+	int mfgid_sz, calc_mfgid_sz;
+	void *p;
+	int rc;
+
+	si->si_ofs.cydata_size = si->si_ofs.test_ofs - si->si_ofs.cydata_ofs;
+	dev_dbg(cd->dev, "%s: cydata size: %d\n", __func__,
+			si->si_ofs.cydata_size);
+
+	if (si->si_ofs.cydata_size <= 0)
+		return -EINVAL;
+
+	p = krealloc(si->si_ptrs.cydata, si->si_ofs.cydata_size, GFP_KERNEL);
+	if (p == NULL) {
+		dev_err(cd->dev, "%s: fail alloc cydata memory\n", __func__);
+		return -ENOMEM;
+	}
+	si->si_ptrs.cydata = p;
+
+	read_offset = si->si_ofs.cydata_ofs;
+
+	/* Read the CYDA registers up to MFGID field */
+	rc = cyttsp4_adap_read(cd, read_offset, si->si_ptrs.cydata,
+			offsetof(struct cyttsp4_cydata, mfgid_sz)
+			+ sizeof(si->si_ptrs.cydata->mfgid_sz));
+	if (rc < 0) {
+		dev_err(cd->dev, "%s: fail read cydata r=%d\n",
+			__func__, rc);
+		return rc;
+	}
+
+	/* Check MFGID size */
+	mfgid_sz = si->si_ptrs.cydata->mfgid_sz;
+	calc_mfgid_sz = si->si_ofs.cydata_size - sizeof(struct cyttsp4_cydata);
+	if (mfgid_sz != calc_mfgid_sz) {
+		dev_err(cd->dev, "%s: mismatch in MFGID size, reported:%d calculated:%d\n",
+			__func__, mfgid_sz, calc_mfgid_sz);
+		return -EINVAL;
+	}
+
+	read_offset += offsetof(struct cyttsp4_cydata, mfgid_sz)
+			+ sizeof(si->si_ptrs.cydata->mfgid_sz);
+
+	/* Read the CYDA registers for MFGID field */
+	rc = cyttsp4_adap_read(cd, read_offset, si->si_ptrs.cydata->mfg_id,
+			si->si_ptrs.cydata->mfgid_sz);
+	if (rc < 0) {
+		dev_err(cd->dev, "%s: fail read cydata r=%d\n",
+			__func__, rc);
+		return rc;
+	}
+
+	read_offset += si->si_ptrs.cydata->mfgid_sz;
+
+	/* Read the rest of the CYDA registers */
+	rc = cyttsp4_adap_read(cd, read_offset, &si->si_ptrs.cydata->cyito_idh,
+			sizeof(struct cyttsp4_cydata)
+			- offsetof(struct cyttsp4_cydata, cyito_idh));
+	if (rc < 0) {
+		dev_err(cd->dev, "%s: fail read cydata r=%d\n",
+			__func__, rc);
+		return rc;
+	}
+
+	cyttsp4_pr_buf(cd->dev, cd->pr_buf, (u8 *)si->si_ptrs.cydata,
+		si->si_ofs.cydata_size - mfgid_sz, "sysinfo_cydata");
+	cyttsp4_pr_buf(cd->dev, cd->pr_buf, si->si_ptrs.cydata->mfg_id,
+		mfgid_sz, "sysinfo_cydata_mfgid");
+	return rc;
+}
+
+static int cyttsp4_si_get_test_data(struct cyttsp4_core_data *cd)
+{
+	struct cyttsp4_sysinfo *si = &cd->sysinfo;
+	void *p;
+	int rc;
+
+	si->si_ofs.test_size = si->si_ofs.pcfg_ofs - si->si_ofs.test_ofs;
+
+	if (si->si_ofs.test_size <= 0)
+		return -EINVAL;
+
+	p = krealloc(si->si_ptrs.test, si->si_ofs.test_size, GFP_KERNEL);
+	if (p == NULL) {
+		dev_err(cd->dev, "%s: fail alloc test memory\n", __func__);
+		return -ENOMEM;
+	}
+	si->si_ptrs.test = p;
+
+	rc = cyttsp4_adap_read(cd, si->si_ofs.test_ofs, si->si_ptrs.test,
+			si->si_ofs.test_size);
+	if (rc < 0) {
+		dev_err(cd->dev, "%s: fail read test data r=%d\n",
+			__func__, rc);
+		return rc;
+	}
+
+	cyttsp4_pr_buf(cd->dev, cd->pr_buf,
+		       (u8 *)si->si_ptrs.test, si->si_ofs.test_size,
+		       "sysinfo_test_data");
+	if (si->si_ptrs.test->post_codel &
+	    CY_POST_CODEL_WDG_RST)
+		dev_info(cd->dev, "%s: %s codel=%02X\n",
+			 __func__, "Reset was a WATCHDOG RESET",
+			 si->si_ptrs.test->post_codel);
+
+	if (!(si->si_ptrs.test->post_codel &
+	      CY_POST_CODEL_CFG_DATA_CRC_FAIL))
+		dev_info(cd->dev, "%s: %s codel=%02X\n", __func__,
+			 "Config Data CRC FAIL",
+			 si->si_ptrs.test->post_codel);
+
+	if (!(si->si_ptrs.test->post_codel &
+	      CY_POST_CODEL_PANEL_TEST_FAIL))
+		dev_info(cd->dev, "%s: %s codel=%02X\n",
+			 __func__, "PANEL TEST FAIL",
+			 si->si_ptrs.test->post_codel);
+
+	dev_info(cd->dev, "%s: SCANNING is %s codel=%02X\n",
+		 __func__, si->si_ptrs.test->post_codel & 0x08 ?
+		 "ENABLED" : "DISABLED",
+		 si->si_ptrs.test->post_codel);
+	return rc;
+}
+
+static int cyttsp4_si_get_pcfg_data(struct cyttsp4_core_data *cd)
+{
+	struct cyttsp4_sysinfo *si = &cd->sysinfo;
+	void *p;
+	int rc;
+
+	dev_vdbg(cd->dev, "%s: get pcfg data\n", __func__);
+	si->si_ofs.pcfg_size = si->si_ofs.opcfg_ofs - si->si_ofs.pcfg_ofs;
+
+	if (si->si_ofs.pcfg_size <= 0)
+		return -EINVAL;
+
+	p = krealloc(si->si_ptrs.pcfg, si->si_ofs.pcfg_size, GFP_KERNEL);
+	if (p == NULL) {
+		rc = -ENOMEM;
+		dev_err(cd->dev, "%s: fail alloc pcfg memory r=%d\n",
+			__func__, rc);
+		return rc;
+	}
+	si->si_ptrs.pcfg = p;
+
+	rc = cyttsp4_adap_read(cd, si->si_ofs.pcfg_ofs, si->si_ptrs.pcfg,
+			si->si_ofs.pcfg_size);
+	if (rc < 0) {
+		dev_err(cd->dev, "%s: fail read pcfg data r=%d\n",
+			__func__, rc);
+		return rc;
+	}
+
+	si->si_ofs.max_x = merge_bytes((si->si_ptrs.pcfg->res_xh
+			& CY_PCFG_RESOLUTION_X_MASK), si->si_ptrs.pcfg->res_xl);
+	si->si_ofs.x_origin = !!(si->si_ptrs.pcfg->res_xh
+			& CY_PCFG_ORIGIN_X_MASK);
+	si->si_ofs.max_y = merge_bytes((si->si_ptrs.pcfg->res_yh
+			& CY_PCFG_RESOLUTION_Y_MASK), si->si_ptrs.pcfg->res_yl);
+	si->si_ofs.y_origin = !!(si->si_ptrs.pcfg->res_yh
+			& CY_PCFG_ORIGIN_Y_MASK);
+	si->si_ofs.max_p = merge_bytes(si->si_ptrs.pcfg->max_zh,
+			si->si_ptrs.pcfg->max_zl);
+
+	cyttsp4_pr_buf(cd->dev, cd->pr_buf,
+		       (u8 *)si->si_ptrs.pcfg,
+		       si->si_ofs.pcfg_size, "sysinfo_pcfg_data");
+	return rc;
+}
+
+static int cyttsp4_si_get_opcfg_data(struct cyttsp4_core_data *cd)
+{
+	struct cyttsp4_sysinfo *si = &cd->sysinfo;
+	int i;
+	enum cyttsp4_tch_abs abs;
+	void *p;
+	int rc;
+
+	dev_vdbg(cd->dev, "%s: get opcfg data\n", __func__);
+	si->si_ofs.opcfg_size = si->si_ofs.ddata_ofs - si->si_ofs.opcfg_ofs;
+
+	if (si->si_ofs.opcfg_size <= 0)
+		return -EINVAL;
+
+	p = krealloc(si->si_ptrs.opcfg, si->si_ofs.opcfg_size, GFP_KERNEL);
+	if (p == NULL) {
+		dev_err(cd->dev, "%s: fail alloc opcfg memory\n", __func__);
+		rc = -ENOMEM;
+		goto cyttsp4_si_get_opcfg_data_exit;
+	}
+	si->si_ptrs.opcfg = p;
+
+	rc = cyttsp4_adap_read(cd, si->si_ofs.opcfg_ofs, si->si_ptrs.opcfg,
+			si->si_ofs.opcfg_size);
+	if (rc < 0) {
+		dev_err(cd->dev, "%s: fail read opcfg data r=%d\n",
+			__func__, rc);
+		goto cyttsp4_si_get_opcfg_data_exit;
+	}
+	si->si_ofs.cmd_ofs = si->si_ptrs.opcfg->cmd_ofs;
+	si->si_ofs.rep_ofs = si->si_ptrs.opcfg->rep_ofs;
+	si->si_ofs.rep_sz = (si->si_ptrs.opcfg->rep_szh * 256) +
+		si->si_ptrs.opcfg->rep_szl;
+	si->si_ofs.num_btns = si->si_ptrs.opcfg->num_btns;
+	si->si_ofs.num_btn_regs = (si->si_ofs.num_btns +
+		CY_NUM_BTN_PER_REG - 1) / CY_NUM_BTN_PER_REG;
+	si->si_ofs.tt_stat_ofs = si->si_ptrs.opcfg->tt_stat_ofs;
+	si->si_ofs.obj_cfg0 = si->si_ptrs.opcfg->obj_cfg0;
+	si->si_ofs.max_tchs = si->si_ptrs.opcfg->max_tchs &
+		CY_BYTE_OFS_MASK;
+	si->si_ofs.tch_rec_size = si->si_ptrs.opcfg->tch_rec_size &
+		CY_BYTE_OFS_MASK;
+
+	/* Get the old touch fields */
+	for (abs = CY_TCH_X; abs < CY_NUM_TCH_FIELDS; abs++) {
+		si->si_ofs.tch_abs[abs].ofs =
+			si->si_ptrs.opcfg->tch_rec_old[abs].loc &
+			CY_BYTE_OFS_MASK;
+		si->si_ofs.tch_abs[abs].size =
+			cyttsp4_bits_2_bytes
+			(si->si_ptrs.opcfg->tch_rec_old[abs].size,
+			&si->si_ofs.tch_abs[abs].max);
+		si->si_ofs.tch_abs[abs].bofs =
+			(si->si_ptrs.opcfg->tch_rec_old[abs].loc &
+			CY_BOFS_MASK) >> CY_BOFS_SHIFT;
+	}
+
+	/* button fields */
+	si->si_ofs.btn_rec_size = si->si_ptrs.opcfg->btn_rec_size;
+	si->si_ofs.btn_diff_ofs = si->si_ptrs.opcfg->btn_diff_ofs;
+	si->si_ofs.btn_diff_size = si->si_ptrs.opcfg->btn_diff_size;
+
+	if (IS_TTSP_VER_GE(si, 2, 3)) {
+		/* Get the extended touch fields */
+		for (i = 0; i < CY_NUM_EXT_TCH_FIELDS; abs++, i++) {
+			si->si_ofs.tch_abs[abs].ofs =
+				si->si_ptrs.opcfg->tch_rec_new[i].loc &
+				CY_BYTE_OFS_MASK;
+			si->si_ofs.tch_abs[abs].size =
+				cyttsp4_bits_2_bytes
+				(si->si_ptrs.opcfg->tch_rec_new[i].size,
+				&si->si_ofs.tch_abs[abs].max);
+			si->si_ofs.tch_abs[abs].bofs =
+				(si->si_ptrs.opcfg->tch_rec_new[i].loc
+				& CY_BOFS_MASK) >> CY_BOFS_SHIFT;
+		}
+	}
+
+	if (IS_TTSP_VER_GE(si, 2, 4)) {
+		si->si_ofs.noise_data_ofs = si->si_ptrs.opcfg->noise_data_ofs;
+		si->si_ofs.noise_data_sz = si->si_ptrs.opcfg->noise_data_sz;
+	}
+
+	for (abs = 0; abs < CY_TCH_NUM_ABS; abs++) {
+		dev_dbg(cd->dev, "%s: tch_rec_%s\n", __func__,
+			cyttsp4_tch_abs_string[abs]);
+		dev_dbg(cd->dev, "%s:     ofs =%2d\n", __func__,
+			si->si_ofs.tch_abs[abs].ofs);
+		dev_dbg(cd->dev, "%s:     siz =%2d\n", __func__,
+			si->si_ofs.tch_abs[abs].size);
+		dev_dbg(cd->dev, "%s:     max =%2d\n", __func__,
+			si->si_ofs.tch_abs[abs].max);
+		dev_dbg(cd->dev, "%s:     bofs=%2d\n", __func__,
+			si->si_ofs.tch_abs[abs].bofs);
+	}
+
+	si->si_ofs.mode_size = si->si_ofs.tt_stat_ofs + 1;
+	si->si_ofs.data_size = si->si_ofs.max_tchs *
+		si->si_ptrs.opcfg->tch_rec_size;
+	si->si_ofs.rep_hdr_size = si->si_ofs.mode_size - si->si_ofs.rep_ofs;
+
+	cyttsp4_pr_buf(cd->dev, cd->pr_buf, (u8 *)si->si_ptrs.opcfg,
+		si->si_ofs.opcfg_size, "sysinfo_opcfg_data");
+
+cyttsp4_si_get_opcfg_data_exit:
+	return rc;
+}
+
+static int cyttsp4_si_get_ddata(struct cyttsp4_core_data *cd)
+{
+	struct cyttsp4_sysinfo *si = &cd->sysinfo;
+	void *p;
+	int rc;
+
+	dev_vdbg(cd->dev, "%s: get ddata data\n", __func__);
+	si->si_ofs.ddata_size = si->si_ofs.mdata_ofs - si->si_ofs.ddata_ofs;
+
+	if (si->si_ofs.ddata_size <= 0)
+		return -EINVAL;
+
+	p = krealloc(si->si_ptrs.ddata, si->si_ofs.ddata_size, GFP_KERNEL);
+	if (p == NULL) {
+		dev_err(cd->dev, "%s: fail alloc ddata memory\n", __func__);
+		return -ENOMEM;
+	}
+	si->si_ptrs.ddata = p;
+
+	rc = cyttsp4_adap_read(cd, si->si_ofs.ddata_ofs, si->si_ptrs.ddata,
+			si->si_ofs.ddata_size);
+	if (rc < 0)
+		dev_err(cd->dev, "%s: fail read ddata data r=%d\n",
+			__func__, rc);
+	else
+		cyttsp4_pr_buf(cd->dev, cd->pr_buf,
+			       (u8 *)si->si_ptrs.ddata,
+			       si->si_ofs.ddata_size, "sysinfo_ddata");
+	return rc;
+}
+
+static int cyttsp4_si_get_mdata(struct cyttsp4_core_data *cd)
+{
+	struct cyttsp4_sysinfo *si = &cd->sysinfo;
+	void *p;
+	int rc;
+
+	dev_vdbg(cd->dev, "%s: get mdata data\n", __func__);
+	si->si_ofs.mdata_size = si->si_ofs.map_sz - si->si_ofs.mdata_ofs;
+
+	if (si->si_ofs.mdata_size <= 0)
+		return -EINVAL;
+
+	p = krealloc(si->si_ptrs.mdata, si->si_ofs.mdata_size, GFP_KERNEL);
+	if (p == NULL) {
+		dev_err(cd->dev, "%s: fail alloc mdata memory\n", __func__);
+		return -ENOMEM;
+	}
+	si->si_ptrs.mdata = p;
+
+	rc = cyttsp4_adap_read(cd, si->si_ofs.mdata_ofs, si->si_ptrs.mdata,
+			si->si_ofs.mdata_size);
+	if (rc < 0)
+		dev_err(cd->dev, "%s: fail read mdata data r=%d\n",
+			__func__, rc);
+	else
+		cyttsp4_pr_buf(cd->dev, cd->pr_buf,
+			       (u8 *)si->si_ptrs.mdata,
+			       si->si_ofs.mdata_size, "sysinfo_mdata");
+	return rc;
+}
+
+static int cyttsp4_si_get_btn_data(struct cyttsp4_core_data *cd)
+{
+	struct cyttsp4_sysinfo *si = &cd->sysinfo;
+	int btn;
+	int num_defined_keys;
+	u16 *key_table;
+	void *p;
+	int rc = 0;
+
+	dev_vdbg(cd->dev, "%s: get btn data\n", __func__);
+
+	if (!si->si_ofs.num_btns) {
+		si->si_ofs.btn_keys_size = 0;
+		kfree(si->btn);
+		si->btn = NULL;
+		return rc;
+	}
+
+	si->si_ofs.btn_keys_size = si->si_ofs.num_btns *
+		sizeof(struct cyttsp4_btn);
+
+	if (si->si_ofs.btn_keys_size <= 0)
+		return -EINVAL;
+
+	p = krealloc(si->btn, si->si_ofs.btn_keys_size, GFP_KERNEL|__GFP_ZERO);
+	if (p == NULL) {
+		dev_err(cd->dev, "%s: %s\n", __func__,
+			"fail alloc btn_keys memory");
+		return -ENOMEM;
+	}
+	si->btn = p;
+
+	if (cd->pdata->sett[CY_IC_GRPNUM_BTN_KEYS] == NULL)
+		num_defined_keys = 0;
+	else if (cd->pdata->sett[CY_IC_GRPNUM_BTN_KEYS]->data == NULL)
+		num_defined_keys = 0;
+	else
+		num_defined_keys = cd->pdata->sett[CY_IC_GRPNUM_BTN_KEYS]->size;
+
+	for (btn = 0; btn < si->si_ofs.num_btns
+			&& btn < num_defined_keys; btn++) {
+		key_table = (u16 *)cd->pdata->sett[CY_IC_GRPNUM_BTN_KEYS]->data;
+		si->btn[btn].key_code = key_table[btn];
+		si->btn[btn].state = CY_BTN_RELEASED;
+		si->btn[btn].enabled = true;
+	}
+	for (; btn < si->si_ofs.num_btns; btn++) {
+		si->btn[btn].key_code = KEY_RESERVED;
+		si->btn[btn].state = CY_BTN_RELEASED;
+		si->btn[btn].enabled = true;
+	}
+
+	return rc;
+}
+
+static int cyttsp4_si_get_op_data_ptrs(struct cyttsp4_core_data *cd)
+{
+	struct cyttsp4_sysinfo *si = &cd->sysinfo;
+	void *p;
+	int size;
+
+	p = krealloc(si->xy_mode, si->si_ofs.mode_size +
+			si->si_ofs.data_size, GFP_KERNEL|__GFP_ZERO);
+	if (p == NULL)
+		return -ENOMEM;
+	si->xy_mode = p;
+	si->xy_data = &si->xy_mode[si->si_ofs.tt_stat_ofs + 1];
+
+	size = si->si_ofs.btn_rec_size * si->si_ofs.num_btns;
+	if (!size)
+		return 0;
+
+	p = krealloc(si->btn_rec_data, size, GFP_KERNEL|__GFP_ZERO);
+	if (p == NULL)
+		return -ENOMEM;
+	si->btn_rec_data = p;
+
+	return 0;
+}
+
+static void cyttsp4_si_put_log_data(struct cyttsp4_core_data *cd)
+{
+	struct cyttsp4_sysinfo *si = &cd->sysinfo;
+	dev_dbg(cd->dev, "%s: cydata_ofs =%4d siz=%4d\n", __func__,
+		si->si_ofs.cydata_ofs, si->si_ofs.cydata_size);
+	dev_dbg(cd->dev, "%s: test_ofs   =%4d siz=%4d\n", __func__,
+		si->si_ofs.test_ofs, si->si_ofs.test_size);
+	dev_dbg(cd->dev, "%s: pcfg_ofs   =%4d siz=%4d\n", __func__,
+		si->si_ofs.pcfg_ofs, si->si_ofs.pcfg_size);
+	dev_dbg(cd->dev, "%s: opcfg_ofs  =%4d siz=%4d\n", __func__,
+		si->si_ofs.opcfg_ofs, si->si_ofs.opcfg_size);
+	dev_dbg(cd->dev, "%s: ddata_ofs  =%4d siz=%4d\n", __func__,
+		si->si_ofs.ddata_ofs, si->si_ofs.ddata_size);
+	dev_dbg(cd->dev, "%s: mdata_ofs  =%4d siz=%4d\n", __func__,
+		si->si_ofs.mdata_ofs, si->si_ofs.mdata_size);
+
+	dev_dbg(cd->dev, "%s: cmd_ofs       =%4d\n", __func__,
+		si->si_ofs.cmd_ofs);
+	dev_dbg(cd->dev, "%s: rep_ofs       =%4d\n", __func__,
+		si->si_ofs.rep_ofs);
+	dev_dbg(cd->dev, "%s: rep_sz        =%4d\n", __func__,
+		si->si_ofs.rep_sz);
+	dev_dbg(cd->dev, "%s: num_btns      =%4d\n", __func__,
+		si->si_ofs.num_btns);
+	dev_dbg(cd->dev, "%s: num_btn_regs  =%4d\n", __func__,
+		si->si_ofs.num_btn_regs);
+	dev_dbg(cd->dev, "%s: tt_stat_ofs   =%4d\n", __func__,
+		si->si_ofs.tt_stat_ofs);
+	dev_dbg(cd->dev, "%s: tch_rec_size   =%4d\n", __func__,
+		si->si_ofs.tch_rec_size);
+	dev_dbg(cd->dev, "%s: max_tchs      =%4d\n", __func__,
+		si->si_ofs.max_tchs);
+	dev_dbg(cd->dev, "%s: mode_size     =%4d\n", __func__,
+		si->si_ofs.mode_size);
+	dev_dbg(cd->dev, "%s: data_size     =%4d\n", __func__,
+		si->si_ofs.data_size);
+	dev_dbg(cd->dev, "%s: rep_hdr_size  =%4d\n", __func__,
+		si->si_ofs.rep_hdr_size);
+	dev_dbg(cd->dev, "%s: map_sz        =%4d\n", __func__,
+		si->si_ofs.map_sz);
+
+	dev_dbg(cd->dev, "%s: btn_rec_size   =%2d\n", __func__,
+		si->si_ofs.btn_rec_size);
+	dev_dbg(cd->dev, "%s: btn_diff_ofs  =%2d\n", __func__,
+		si->si_ofs.btn_diff_ofs);
+	dev_dbg(cd->dev, "%s: btn_diff_size  =%2d\n", __func__,
+		si->si_ofs.btn_diff_size);
+
+	dev_dbg(cd->dev, "%s: max_x    = 0x%04X (%d)\n", __func__,
+		si->si_ofs.max_x, si->si_ofs.max_x);
+	dev_dbg(cd->dev, "%s: x_origin = %d (%s)\n", __func__,
+		si->si_ofs.x_origin,
+		si->si_ofs.x_origin == CY_NORMAL_ORIGIN ?
+		"left corner" : "right corner");
+	dev_dbg(cd->dev, "%s: max_y    = 0x%04X (%d)\n", __func__,
+		si->si_ofs.max_y, si->si_ofs.max_y);
+	dev_dbg(cd->dev, "%s: y_origin = %d (%s)\n", __func__,
+		si->si_ofs.y_origin,
+		si->si_ofs.y_origin == CY_NORMAL_ORIGIN ?
+		"upper corner" : "lower corner");
+	dev_dbg(cd->dev, "%s: max_p    = 0x%04X (%d)\n", __func__,
+		si->si_ofs.max_p, si->si_ofs.max_p);
+
+	dev_dbg(cd->dev, "%s: xy_mode=%p xy_data=%p\n", __func__,
+		si->xy_mode, si->xy_data);
+}
+
+static int cyttsp4_get_sysinfo_regs(struct cyttsp4_core_data *cd)
+{
+	struct cyttsp4_sysinfo *si = &cd->sysinfo;
+	int rc;
+
+	rc = cyttsp4_si_data_offsets(cd);
+	if (rc < 0)
+		return rc;
+
+	rc = cyttsp4_si_get_cydata(cd);
+	if (rc < 0)
+		return rc;
+
+	rc = cyttsp4_si_get_test_data(cd);
+	if (rc < 0)
+		return rc;
+
+	rc = cyttsp4_si_get_pcfg_data(cd);
+	if (rc < 0)
+		return rc;
+
+	rc = cyttsp4_si_get_opcfg_data(cd);
+	if (rc < 0)
+		return rc;
+
+	rc = cyttsp4_si_get_ddata(cd);
+	if (rc < 0)
+		return rc;
+
+	rc = cyttsp4_si_get_mdata(cd);
+	if (rc < 0)
+		return rc;
+
+	rc = cyttsp4_si_get_btn_data(cd);
+	if (rc < 0)
+		return rc;
+
+	rc = cyttsp4_si_get_op_data_ptrs(cd);
+	if (rc < 0) {
+		dev_err(cd->dev, "%s: failed to get_op_data\n",
+			__func__);
+		return rc;
+	}
+
+	cyttsp4_si_put_log_data(cd);
+
+	/* provide flow control handshake */
+	rc = cyttsp4_handshake(cd, si->si_data.hst_mode);
+	if (rc < 0)
+		dev_err(cd->dev, "%s: handshake fail on sysinfo reg\n",
+			__func__);
+
+	mutex_lock(&cd->system_lock);
+	si->ready = true;
+	mutex_unlock(&cd->system_lock);
+	return rc;
+}
+
+static void cyttsp4_queue_startup_(struct cyttsp4_core_data *cd)
+{
+	if (cd->startup_state == STARTUP_NONE) {
+		cd->startup_state = STARTUP_QUEUED;
+		schedule_work(&cd->startup_work);
+		dev_info(cd->dev, "%s: cyttsp4_startup queued\n", __func__);
+	} else {
+		dev_dbg(cd->dev, "%s: startup_state = %d\n", __func__,
+			cd->startup_state);
+	}
+}
+
+static void cyttsp4_queue_startup(struct cyttsp4_core_data *cd)
+{
+	dev_vdbg(cd->dev, "%s: enter\n", __func__);
+	mutex_lock(&cd->system_lock);
+	cyttsp4_queue_startup_(cd);
+	mutex_unlock(&cd->system_lock);
+}
+
+static void call_atten_cb(struct cyttsp4_core_data *cd,
+		enum cyttsp4_atten_type type, int mode)
+{
+	struct atten_node *atten, *atten_n;
+
+	dev_vdbg(cd->dev, "%s: check list type=%d mode=%d\n",
+		__func__, type, mode);
+	spin_lock(&cd->spinlock);
+	list_for_each_entry_safe(atten, atten_n,
+			&cd->atten_list[type], node) {
+		if (!mode || atten->mode & mode) {
+			spin_unlock(&cd->spinlock);
+			dev_vdbg(cd->dev, "%s: attention for '%s'", __func__,
+				dev_name(&atten->ttsp->dev));
+			atten->func(atten->ttsp);
+			spin_lock(&cd->spinlock);
+		}
+	}
+	spin_unlock(&cd->spinlock);
+}
+
+static irqreturn_t cyttsp4_hard_irq(int irq, void *handle)
+{
+	struct cyttsp4_core_data *cd = handle;
+
+	/*
+	 * Check whether this IRQ should be ignored (external)
+	 * This should be the very first thing to check since
+	 * ignore_irq may be set for a very short period of time
+	 */
+	if (atomic_read(&cd->ignore_irq)) {
+		dev_vdbg(cd->dev, "%s: Ignoring IRQ\n", __func__);
+		return IRQ_HANDLED;
+	}
+
+	return IRQ_WAKE_THREAD;
+}
+
+static irqreturn_t cyttsp4_irq(int irq, void *handle)
+{
+	struct cyttsp4_core_data *cd = handle;
+	struct device *dev = cd->dev;
+	enum cyttsp4_mode cur_mode;
+	u8 cmd_ofs = cd->sysinfo.si_ofs.cmd_ofs;
+	bool command_complete = false;
+	u8 mode[3];
+	int rc;
+	u8 cat_masked_cmd;
+
+	dev_dbg(dev, "%s int:0x%x\n", __func__, cd->int_status);
+
+	mutex_lock(&cd->system_lock);
+
+	rc = cyttsp4_adap_read(cd, CY_REG_BASE, mode, sizeof(mode));
+	if (rc) {
+		dev_err(cd->dev, "%s: Fail read adapter r=%d\n", __func__, rc);
+		goto cyttsp4_irq_exit;
+	}
+	dev_vdbg(dev, "%s mode[0-2]:0x%X 0x%X 0x%X\n", __func__,
+			mode[0], mode[1], mode[2]);
+
+	if (IS_BOOTLOADER(mode[0], mode[1])) {
+		cur_mode = CY_MODE_BOOTLOADER;
+		dev_vdbg(dev, "%s: bl running\n", __func__);
+		call_atten_cb(cd, CY_ATTEN_IRQ, cur_mode);
+
+		/* switch to bootloader */
+		if (cd->mode != CY_MODE_BOOTLOADER)
+			dev_dbg(dev, "%s: restart switch to bl m=%d -> m=%d\n",
+			__func__, cd->mode, cur_mode);
+
+		/* catch operation->bl glitch */
+		if (cd->mode != CY_MODE_BOOTLOADER
+				&& cd->mode != CY_MODE_UNKNOWN) {
+			/* Incase startup_state do not let startup_() */
+			cd->mode = CY_MODE_UNKNOWN;
+			cyttsp4_queue_startup_(cd);
+			goto cyttsp4_irq_exit;
+		}
+
+		/* Recover if stuck in bootloader idle mode */
+		if (cd->mode == CY_MODE_BOOTLOADER) {
+			if (IS_BOOTLOADER_IDLE(mode[0], mode[1])) {
+				if (cd->heartbeat_count > 3) {
+					cd->heartbeat_count = 0;
+					cyttsp4_queue_startup_(cd);
+					goto cyttsp4_irq_exit;
+				}
+				cd->heartbeat_count++;
+			}
+		}
+
+		cd->mode = cur_mode;
+		/* Signal bootloader heartbeat heard */
+		wake_up(&cd->wait_q);
+		goto cyttsp4_irq_exit;
+	}
+
+	switch (mode[0] & CY_HST_DEVICE_MODE) {
+	case CY_HST_OPERATE:
+		cur_mode = CY_MODE_OPERATIONAL;
+		dev_vdbg(dev, "%s: operational\n", __func__);
+		break;
+	case CY_HST_CAT:
+		cur_mode = CY_MODE_CAT;
+		/* set the start sensor mode state. */
+		cat_masked_cmd = mode[2] & CY_CMD_MASK;
+
+		/* Get the Debug info for the interrupt. */
+		if (cat_masked_cmd != CY_CMD_CAT_NULL &&
+				cat_masked_cmd !=
+					CY_CMD_CAT_RETRIEVE_PANEL_SCAN &&
+				cat_masked_cmd != CY_CMD_CAT_EXEC_PANEL_SCAN)
+			dev_info(cd->dev,
+				"%s: cyttsp4_CaT_IRQ=%02X %02X %02X\n",
+				__func__, mode[0], mode[1], mode[2]);
+		dev_vdbg(dev, "%s: CaT\n", __func__);
+		break;
+	case CY_HST_SYSINFO:
+		cur_mode = CY_MODE_SYSINFO;
+		dev_vdbg(dev, "%s: sysinfo\n", __func__);
+		break;
+	default:
+		cur_mode = CY_MODE_UNKNOWN;
+		dev_err(dev, "%s: unknown HST mode 0x%02X\n", __func__,
+			mode[0]);
+		break;
+	}
+
+	/* Check whether this IRQ should be ignored (internal) */
+	if (cd->int_status & CY_INT_IGNORE) {
+		if (IS_DEEP_SLEEP_CONFIGURED(cd->easy_wakeup_gesture)) {
+			/* Put device back to sleep on premature wakeup */
+			dev_dbg(dev, "%s: Put device back to sleep\n",
+				__func__);
+			_cyttsp4_put_device_into_deep_sleep(cd, mode[0]);
+			goto cyttsp4_irq_exit;
+		}
+		/* Check for Wait for Event command */
+		if ((mode[cmd_ofs] & CY_CMD_MASK) == CY_CMD_OP_WAIT_FOR_EVENT
+				&& mode[cmd_ofs] & CY_CMD_COMPLETE) {
+			cd->wake_initiated_by_device = 1;
+			call_atten_cb(cd, CY_ATTEN_WAKE, 0);
+			goto cyttsp4_irq_handshake;
+		}
+	}
+
+	/* Check for wake up interrupt */
+	if (cd->int_status & CY_INT_AWAKE) {
+		cd->int_status &= ~CY_INT_AWAKE;
+		wake_up(&cd->wait_q);
+		dev_vdbg(dev, "%s: Received wake up interrupt\n", __func__);
+		goto cyttsp4_irq_handshake;
+	}
+
+	/* Expecting mode change interrupt */
+	if ((cd->int_status & CY_INT_MODE_CHANGE)
+			&& (mode[0] & CY_HST_MODE_CHANGE) == 0) {
+		cd->int_status &= ~CY_INT_MODE_CHANGE;
+		dev_dbg(dev, "%s: finish mode switch m=%d -> m=%d\n",
+				__func__, cd->mode, cur_mode);
+		cd->mode = cur_mode;
+		wake_up(&cd->wait_q);
+		goto cyttsp4_irq_handshake;
+	}
+
+	/* compare current core mode to current device mode */
+	dev_vdbg(dev, "%s: cd->mode=%d cur_mode=%d\n",
+			__func__, cd->mode, cur_mode);
+	if ((mode[0] & CY_HST_MODE_CHANGE) == 0 && cd->mode != cur_mode) {
+		/* Unexpected mode change occurred */
+		dev_err(dev, "%s %d->%d 0x%x\n", __func__, cd->mode,
+				cur_mode, cd->int_status);
+		dev_vdbg(dev, "%s: Unexpected mode change, startup\n",
+				__func__);
+		cyttsp4_queue_startup_(cd);
+		goto cyttsp4_irq_exit;
+	}
+
+	/* Expecting command complete interrupt */
+	dev_vdbg(dev, "%s: command byte:0x%x, toggle:0x%x\n",
+			__func__, mode[cmd_ofs], cd->cmd_toggle);
+	if ((cd->int_status & CY_INT_EXEC_CMD)
+			&& mode[cmd_ofs] & CY_CMD_COMPLETE) {
+		command_complete = true;
+		cd->int_status &= ~CY_INT_EXEC_CMD;
+		dev_vdbg(dev, "%s: Received command complete interrupt\n",
+				__func__);
+		wake_up(&cd->wait_q);
+		/*
+		 * It is possible to receive a single interrupt for
+		 * command complete and touch/button status report.
+		 * Continue processing for a possible status report.
+		 */
+	}
+
+	/* Copy the mode registers */
+	if (cd->sysinfo.xy_mode)
+		memcpy(cd->sysinfo.xy_mode, mode, sizeof(mode));
+
+	/* This should be status report, read status and touch regs */
+	if (cd->mode == CY_MODE_OPERATIONAL) {
+		dev_vdbg(dev, "%s: Read status and touch registers\n",
+			__func__);
+		rc = cyttsp4_load_status_and_touch_regs(cd, !command_complete);
+		if (rc < 0)
+			dev_err(dev, "%s: fail read mode/touch regs r=%d\n",
+				__func__, rc);
+	}
+
+	/* attention IRQ */
+	call_atten_cb(cd, CY_ATTEN_IRQ, cd->mode);
+
+cyttsp4_irq_handshake:
+	/* handshake the event */
+	dev_vdbg(dev, "%s: Handshake mode=0x%02X r=%d\n",
+			__func__, mode[0], rc);
+	rc = cyttsp4_handshake(cd, mode[0]);
+	if (rc < 0)
+		dev_err(dev, "%s: Fail handshake mode=0x%02X r=%d\n",
+				__func__, mode[0], rc);
+
+	/*
+	 * a non-zero udelay period is required for using
+	 * IRQF_TRIGGER_LOW in order to delay until the
+	 * device completes isr deassert
+	 */
+	udelay(cd->pdata->level_irq_udelay);
+
+cyttsp4_irq_exit:
+	mutex_unlock(&cd->system_lock);
+	dev_vdbg(dev, "%s: irq done\n", __func__);
+	return IRQ_HANDLED;
+}
+
+static void cyttsp4_start_wd_timer(struct cyttsp4_core_data *cd)
+{
+	if (!CY_WATCHDOG_TIMEOUT)
+		return;
+
+	mod_timer(&cd->watchdog_timer, jiffies +
+			msecs_to_jiffies(CY_WATCHDOG_TIMEOUT));
+}
+
+static void cyttsp4_stop_wd_timer(struct cyttsp4_core_data *cd)
+{
+	if (!CY_WATCHDOG_TIMEOUT)
+		return;
+
+	/*
+	 * Ensure we wait until the watchdog timer
+	 * running on a different CPU finishes
+	 */
+	del_timer_sync(&cd->watchdog_timer);
+	cancel_work_sync(&cd->watchdog_work);
+	del_timer_sync(&cd->watchdog_timer);
+}
+
+static void cyttsp4_watchdog_timer(unsigned long handle)
+{
+	struct cyttsp4_core_data *cd = (struct cyttsp4_core_data *)handle;
+
+	dev_vdbg(cd->dev, "%s: Timer triggered\n", __func__);
+
+	if (!cd)
+		return;
+
+	if (!work_pending(&cd->watchdog_work))
+		schedule_work(&cd->watchdog_work);
+
+	return;
+}
+
+static int cyttsp4_write_(struct cyttsp4_device *ttsp, int mode, u16 addr,
+	const void *buf, int size)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_core *core = ttsp->core;
+	struct cyttsp4_core_data *cd = dev_get_drvdata(&core->dev);
+	int rc = 0;
+
+	mutex_lock(&cd->adap_lock);
+	if (mode != cd->mode) {
+		dev_dbg(dev, "%s: %s (having %x while %x requested)\n",
+			__func__, "attempt to write in missing mode",
+			cd->mode, mode);
+		rc = -EACCES;
+		goto exit;
+	}
+	rc = cyttsp4_adap_write(cd, addr, buf, size);
+exit:
+	mutex_unlock(&cd->adap_lock);
+	return rc;
+}
+
+static int cyttsp4_read_(struct cyttsp4_device *ttsp, int mode, u16 addr,
+	void *buf, int size)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_core *core = ttsp->core;
+	struct cyttsp4_core_data *cd = dev_get_drvdata(&core->dev);
+	int rc = 0;
+
+	mutex_lock(&cd->adap_lock);
+	if (mode != cd->mode) {
+		dev_dbg(dev, "%s: %s (having %x while %x requested)\n",
+			__func__, "attempt to read in missing mode",
+			cd->mode, mode);
+		rc = -EACCES;
+		goto exit;
+	}
+	rc = cyttsp4_adap_read(cd, addr, buf, size);
+exit:
+	mutex_unlock(&cd->adap_lock);
+	return rc;
+}
+
+static int cyttsp4_subscribe_attention_(struct cyttsp4_device *ttsp,
+	enum cyttsp4_atten_type type,
+	int (*func)(struct cyttsp4_device *), int mode)
+{
+	struct cyttsp4_core *core = ttsp->core;
+	struct cyttsp4_core_data *cd = dev_get_drvdata(&core->dev);
+	struct atten_node *atten, *atten_new;
+
+	atten_new = kzalloc(sizeof(*atten_new), GFP_KERNEL);
+	if (!atten_new) {
+		dev_err(cd->dev, "%s: Fail alloc atten node\n", __func__);
+		return -ENOMEM;
+	}
+
+	dev_dbg(cd->dev, "%s from '%s'\n", __func__, dev_name(cd->dev));
+
+	spin_lock(&cd->spinlock);
+	list_for_each_entry(atten, &cd->atten_list[type], node) {
+		if (atten->ttsp == ttsp && atten->mode == mode) {
+			spin_unlock(&cd->spinlock);
+			kfree(atten_new);
+			dev_vdbg(cd->dev, "%s: %s=%p %s=%d\n",
+				 __func__,
+				 "already subscribed attention",
+				 ttsp, "mode", mode);
+
+			return 0;
+		}
+	}
+
+	atten_new->ttsp = ttsp;
+	atten_new->mode = mode;
+	atten_new->func = func;
+
+	list_add(&atten_new->node, &cd->atten_list[type]);
+	spin_unlock(&cd->spinlock);
+
+	return 0;
+}
+
+static int cyttsp4_unsubscribe_attention_(struct cyttsp4_device *ttsp,
+	enum cyttsp4_atten_type type, int (*func)(struct cyttsp4_device *),
+	int mode)
+{
+	struct cyttsp4_core *core = ttsp->core;
+	struct cyttsp4_core_data *cd = dev_get_drvdata(&core->dev);
+	struct atten_node *atten, *atten_n;
+
+	spin_lock(&cd->spinlock);
+	list_for_each_entry_safe(atten, atten_n, &cd->atten_list[type], node) {
+		if (atten->ttsp == ttsp && atten->mode == mode) {
+			list_del(&atten->node);
+			spin_unlock(&cd->spinlock);
+			kfree(atten);
+			dev_vdbg(cd->dev, "%s: %s=%p %s=%d\n",
+				__func__,
+				"unsub for atten->ttsp", atten->ttsp,
+				"atten->mode", atten->mode);
+			return 0;
+		}
+	}
+	spin_unlock(&cd->spinlock);
+
+	return -ENODEV;
+}
+
+static int request_exclusive(struct cyttsp4_core_data *cd, void *ownptr,
+		int timeout_ms)
+{
+	int t = msecs_to_jiffies(timeout_ms);
+	bool with_timeout = (timeout_ms != 0);
+
+	mutex_lock(&cd->system_lock);
+	if (!cd->exclusive_dev && cd->exclusive_waits == 0) {
+		cd->exclusive_dev = ownptr;
+		goto exit;
+	}
+
+	cd->exclusive_waits++;
+wait:
+	mutex_unlock(&cd->system_lock);
+	if (with_timeout) {
+		t = wait_event_timeout(cd->wait_q, !cd->exclusive_dev, t);
+		if (IS_TMO(t)) {
+			dev_err(cd->dev, "%s: tmo waiting exclusive access\n",
+				__func__);
+			mutex_lock(&cd->system_lock);
+			cd->exclusive_waits--;
+			mutex_unlock(&cd->system_lock);
+			return -ETIME;
+		}
+	} else {
+		wait_event(cd->wait_q, !cd->exclusive_dev);
+	}
+	mutex_lock(&cd->system_lock);
+	if (cd->exclusive_dev)
+		goto wait;
+	cd->exclusive_dev = ownptr;
+	cd->exclusive_waits--;
+exit:
+	mutex_unlock(&cd->system_lock);
+	dev_vdbg(cd->dev, "%s: request_exclusive ok=%p\n",
+		__func__, ownptr);
+
+	return 0;
+}
+
+static int cyttsp4_request_exclusive_(struct cyttsp4_device *ttsp,
+		int timeout_ms)
+{
+	struct cyttsp4_core *core = ttsp->core;
+	struct cyttsp4_core_data *cd = dev_get_drvdata(&core->dev);
+	return request_exclusive(cd, (void *)ttsp, timeout_ms);
+}
+
+/*
+ * returns error if was not owned
+ */
+static int release_exclusive(struct cyttsp4_core_data *cd, void *ownptr)
+{
+	mutex_lock(&cd->system_lock);
+	if (cd->exclusive_dev != ownptr) {
+		mutex_unlock(&cd->system_lock);
+		return -EINVAL;
+	}
+
+	dev_vdbg(cd->dev, "%s: exclusive_dev %p freed\n",
+		__func__, cd->exclusive_dev);
+	cd->exclusive_dev = NULL;
+	wake_up(&cd->wait_q);
+	mutex_unlock(&cd->system_lock);
+	return 0;
+}
+
+static int cyttsp4_release_exclusive_(struct cyttsp4_device *ttsp)
+{
+	struct cyttsp4_core *core = ttsp->core;
+	struct cyttsp4_core_data *cd = dev_get_drvdata(&core->dev);
+	return release_exclusive(cd, (void *)ttsp);
+}
+
+static int cyttsp4_wait_bl_heartbeat(struct cyttsp4_core_data *cd)
+{
+	long t;
+	int rc = 0;
+
+	/* wait heartbeat */
+	dev_vdbg(cd->dev, "%s: wait heartbeat...\n", __func__);
+	t = wait_event_timeout(cd->wait_q, cd->mode == CY_MODE_BOOTLOADER,
+			msecs_to_jiffies(CY_CORE_RESET_AND_WAIT_TIMEOUT));
+	if (IS_TMO(t)) {
+		dev_err(cd->dev, "%s: tmo waiting bl heartbeat cd->mode=%d\n",
+			__func__, cd->mode);
+		rc = -ETIME;
+	}
+
+	return rc;
+}
+
+static int cyttsp4_wait_sysinfo_mode(struct cyttsp4_core_data *cd)
+{
+	long t;
+
+	dev_vdbg(cd->dev, "%s: wait sysinfo...\n", __func__);
+
+	t = wait_event_timeout(cd->wait_q, cd->mode == CY_MODE_SYSINFO,
+			msecs_to_jiffies(CY_CORE_WAIT_SYSINFO_MODE_TIMEOUT));
+	if (IS_TMO(t)) {
+		dev_err(cd->dev, "%s: tmo waiting exit bl cd->mode=%d\n",
+			__func__, cd->mode);
+		mutex_lock(&cd->system_lock);
+		cd->int_status &= ~CY_INT_MODE_CHANGE;
+		mutex_unlock(&cd->system_lock);
+		return -ETIME;
+	}
+
+	return 0;
+}
+
+static int cyttsp4_reset_and_wait(struct cyttsp4_core_data *cd)
+{
+	int rc;
+
+	/* reset hardware */
+	mutex_lock(&cd->system_lock);
+	dev_dbg(cd->dev, "%s: reset hw...\n", __func__);
+	rc = cyttsp4_hw_reset_(cd);
+	cd->mode = CY_MODE_UNKNOWN;
+	mutex_unlock(&cd->system_lock);
+	if (rc < 0) {
+		dev_err(cd->dev, "%s: %s adap='%s' r=%d\n", __func__,
+			"Fail hw reset", cd->core->adap->id, rc);
+		return rc;
+	}
+
+	return cyttsp4_wait_bl_heartbeat(cd);
+}
+
+/*
+ * returns err if refused or timeout; block until mode change complete
+ * bit is set (mode change interrupt)
+ */
+static int set_mode(struct cyttsp4_core_data *cd, int new_mode)
+{
+	u8 new_dev_mode;
+	u8 mode;
+	long t;
+	int rc;
+
+	switch (new_mode) {
+	case CY_MODE_OPERATIONAL:
+		new_dev_mode = CY_HST_OPERATE;
+		break;
+	case CY_MODE_SYSINFO:
+		new_dev_mode = CY_HST_SYSINFO;
+		break;
+	case CY_MODE_CAT:
+		new_dev_mode = CY_HST_CAT;
+		break;
+	default:
+		dev_err(cd->dev, "%s: invalid mode: %02X(%d)\n",
+			__func__, new_mode, new_mode);
+		return -EINVAL;
+	}
+
+	/* change mode */
+	dev_dbg(cd->dev, "%s: %s=%p new_dev_mode=%02X new_mode=%d\n",
+			__func__, "have exclusive", cd->exclusive_dev,
+			new_dev_mode, new_mode);
+
+	mutex_lock(&cd->system_lock);
+	rc = cyttsp4_adap_read(cd, CY_REG_BASE, &mode, sizeof(mode));
+	if (rc < 0) {
+		mutex_unlock(&cd->system_lock);
+		dev_err(cd->dev, "%s: Fail read mode r=%d\n",
+			__func__, rc);
+		goto exit;
+	}
+
+	/* Clear device mode bits and set to new mode */
+	mode &= ~CY_HST_DEVICE_MODE;
+	mode |= new_dev_mode | CY_HST_MODE_CHANGE;
+
+	cd->int_status |= CY_INT_MODE_CHANGE;
+	rc = cyttsp4_adap_write(cd, CY_REG_BASE, &mode, sizeof(mode));
+	mutex_unlock(&cd->system_lock);
+	if (rc < 0) {
+		dev_err(cd->dev, "%s: Fail write mode change r=%d\n",
+				__func__, rc);
+		goto exit;
+	}
+
+	/* wait for mode change done interrupt */
+	t = wait_event_timeout(cd->wait_q,
+			(cd->int_status & CY_INT_MODE_CHANGE) == 0,
+			msecs_to_jiffies(CY_CORE_MODE_CHANGE_TIMEOUT));
+	dev_dbg(cd->dev, "%s: back from wait t=%ld cd->mode=%d\n",
+			__func__, t, cd->mode);
+
+	if (IS_TMO(t)) {
+		dev_err(cd->dev, "%s: %s\n", __func__,
+				"tmo waiting mode change");
+		mutex_lock(&cd->system_lock);
+		cd->int_status &= ~CY_INT_MODE_CHANGE;
+		mutex_unlock(&cd->system_lock);
+		rc = -EINVAL;
+	}
+
+exit:
+	return rc;
+}
+
+/*
+ * returns err if refused or timeout(core uses fixed timeout period) occurs;
+ * blocks until ISR occurs
+ */
+static int cyttsp4_request_reset_(struct cyttsp4_device *ttsp)
+{
+	struct cyttsp4_core *core = ttsp->core;
+	struct cyttsp4_core_data *cd = dev_get_drvdata(&core->dev);
+	int rc;
+
+	mutex_lock(&cd->system_lock);
+	cd->sysinfo.ready = false;
+	mutex_unlock(&cd->system_lock);
+
+	rc = cyttsp4_reset_and_wait(cd);
+	if (rc < 0)
+		dev_err(cd->dev, "%s: Error on h/w reset r=%d\n",
+			__func__, rc);
+
+	return rc;
+}
+
+/*
+ * returns err if refused ; if no error then restart has completed
+ * and system is in normal operating mode
+ */
+static int cyttsp4_request_restart_(struct cyttsp4_device *ttsp, bool wait)
+{
+	struct cyttsp4_core *core = ttsp->core;
+	struct cyttsp4_core_data *cd = dev_get_drvdata(&core->dev);
+
+	mutex_lock(&cd->system_lock);
+	cd->sysinfo.ready = false;
+	mutex_unlock(&cd->system_lock);
+
+	cyttsp4_queue_startup(cd);
+
+	if (wait)
+		wait_event(cd->wait_q, cd->startup_state == STARTUP_NONE);
+
+	return 0;
+}
+
+static int cyttsp4_request_set_mode_(struct cyttsp4_device *ttsp, int mode)
+{
+	struct cyttsp4_core *core = ttsp->core;
+	struct cyttsp4_core_data *cd = dev_get_drvdata(&core->dev);
+	int rc;
+
+	rc = set_mode(cd, mode);
+	if (rc < 0)
+		dev_err(cd->dev, "%s: fail set_mode=%02X(%d)\n",
+			__func__, cd->mode, cd->mode);
+
+	return rc;
+}
+
+/*
+ * returns NULL if sysinfo has not been acquired from the device yet
+ */
+static struct cyttsp4_sysinfo *cyttsp4_request_sysinfo_(
+		struct cyttsp4_device *ttsp)
+{
+	struct cyttsp4_core *core = ttsp->core;
+	struct cyttsp4_core_data *cd = dev_get_drvdata(&core->dev);
+	bool ready;
+
+	mutex_lock(&cd->system_lock);
+	ready = cd->sysinfo.ready;
+	mutex_unlock(&cd->system_lock);
+	if (ready)
+		return &cd->sysinfo;
+
+	return NULL;
+}
+
+static struct cyttsp4_loader_platform_data *cyttsp4_request_loader_pdata_(
+		struct cyttsp4_device *ttsp)
+{
+	struct cyttsp4_core *core = ttsp->core;
+	struct cyttsp4_core_data *cd = dev_get_drvdata(&core->dev);
+	return cd->pdata->loader_pdata;
+}
+
+static int cyttsp4_request_handshake_(struct cyttsp4_device *ttsp, u8 mode)
+{
+	struct cyttsp4_core *core = ttsp->core;
+	struct cyttsp4_core_data *cd = dev_get_drvdata(&core->dev);
+	int rc;
+
+	rc = cyttsp4_handshake(cd, mode);
+	if (rc < 0)
+		dev_err(&core->dev, "%s: Fail handshake r=%d\n", __func__, rc);
+
+	return rc;
+}
+
+static int cyttsp4_request_toggle_lowpower_(struct cyttsp4_device *ttsp,
+		u8 mode)
+{
+	struct cyttsp4_core *core = ttsp->core;
+	struct cyttsp4_core_data *cd = dev_get_drvdata(&core->dev);
+	int rc = cyttsp4_toggle_low_power(cd, mode);
+	if (rc < 0)
+		dev_err(&core->dev, "%s: Fail toggle low power r=%d\n",
+				__func__, rc);
+	return rc;
+}
+
+static int _cyttsp4_wait_cmd_exec(struct cyttsp4_core_data *cd, int timeout_ms)
+{
+	struct device *dev = cd->dev;
+	int rc;
+
+	rc = wait_event_timeout(cd->wait_q,
+			(cd->int_status & CY_INT_EXEC_CMD) == 0,
+			msecs_to_jiffies(timeout_ms));
+	if (IS_TMO(rc)) {
+		dev_err(dev, "%s: Command execution timed out\n",
+				__func__);
+		cd->int_status &= ~CY_INT_EXEC_CMD;
+		return -ETIME;
+	}
+	return 0;
+}
+
+static int _get_cmd_offs(struct cyttsp4_core_data *cd, u8 mode)
+{
+	struct cyttsp4_sysinfo *si = &cd->sysinfo;
+	struct device *dev = cd->dev;
+	int cmd_ofs;
+
+	switch (mode) {
+	case CY_MODE_CAT:
+		cmd_ofs = CY_REG_CAT_CMD;
+		break;
+	case CY_MODE_OPERATIONAL:
+		cmd_ofs = si->si_ofs.cmd_ofs;
+		break;
+	default:
+		dev_err(dev, "%s: Unsupported mode %x for exec cmd\n",
+				__func__, mode);
+		return -EACCES;
+	}
+
+	return cmd_ofs;
+}
+
+/*
+ * Send command to device for CAT and OP modes
+ * return negative value on error, 0 on success
+ */
+static int _cyttsp4_exec_cmd(struct cyttsp4_core_data *cd, u8 mode,
+		u8 *cmd_buf, size_t cmd_size)
+{
+	struct device *dev = cd->dev;
+	int cmd_ofs;
+	int cmd_param_ofs;
+	u8 command;
+	u8 *cmd_param_buf;
+	size_t cmd_param_size;
+	int rc;
+
+	if (mode != cd->mode) {
+		dev_err(dev, "%s: %s (having %x while %x requested)\n",
+				__func__, "attempt to exec cmd in missing mode",
+				cd->mode, mode);
+		return -EACCES;
+	}
+
+	cmd_ofs = _get_cmd_offs(cd, mode);
+	if (cmd_ofs < 0)
+		return -EACCES;
+
+	cmd_param_ofs = cmd_ofs + 1;
+	cmd_param_buf = cmd_buf + 1;
+	cmd_param_size = cmd_size - 1;
+
+	/* Check if complete is set, so write new command */
+	rc = cyttsp4_adap_read(cd, cmd_ofs, &command, 1);
+	if (rc < 0) {
+		dev_err(dev, "%s: Error on read r=%d\n", __func__, rc);
+		return rc;
+	}
+
+	cd->cmd_toggle = GET_TOGGLE(command);
+	cd->int_status |= CY_INT_EXEC_CMD;
+
+	if ((command & CY_CMD_COMPLETE_MASK) == 0)
+		return -EBUSY;
+
+	/*
+	 * Write new command
+	 * Only update command bits 0:5
+	 * Clear command complete bit & toggle bit
+	 */
+	cmd_buf[0] = cmd_buf[0] & CY_CMD_MASK;
+	/* Write command parameters first */
+	if (cmd_size > 1) {
+		rc = cyttsp4_adap_write(cd, cmd_param_ofs, cmd_param_buf,
+				cmd_param_size);
+		if (rc < 0) {
+			dev_err(dev, "%s: Error on write command parameters r=%d\n",
+				__func__, rc);
+			return rc;
+		}
+	}
+	/* Write the command */
+	rc = cyttsp4_adap_write(cd, cmd_ofs, cmd_buf, 1);
+	if (rc < 0) {
+		dev_err(dev, "%s: Error on write command r=%d\n",
+				__func__, rc);
+		return rc;
+	}
+
+	return 0;
+}
+
+static int cyttsp4_exec_cmd(struct cyttsp4_core_data *cd, u8 mode,
+		u8 *cmd_buf, size_t cmd_size, u8 *return_buf,
+		size_t return_buf_size, int timeout_ms)
+{
+	struct device *dev = cd->dev;
+	int cmd_ofs;
+	int cmd_return_ofs;
+	int rc;
+
+	mutex_lock(&cd->system_lock);
+	rc = _cyttsp4_exec_cmd(cd, mode, cmd_buf, cmd_size);
+	mutex_unlock(&cd->system_lock);
+
+	if (rc == -EBUSY) {
+		rc = _cyttsp4_wait_cmd_exec(cd, CY_COMMAND_COMPLETE_TIMEOUT);
+		if (rc)
+			return rc;
+		mutex_lock(&cd->system_lock);
+		rc = _cyttsp4_exec_cmd(cd, mode, cmd_buf, cmd_size);
+		mutex_unlock(&cd->system_lock);
+	}
+
+	if (rc < 0)
+		return rc;
+
+	if (timeout_ms == 0)
+		return 0;
+
+	/*
+	 * Wait command to be completed
+	 */
+	rc = _cyttsp4_wait_cmd_exec(cd, timeout_ms);
+	if (rc < 0)
+		return rc;
+
+	if (return_buf_size == 0 || return_buf == NULL)
+		return 0;
+
+	mutex_lock(&cd->system_lock);
+	cmd_ofs = _get_cmd_offs(cd, mode);
+	mutex_unlock(&cd->system_lock);
+	if (cmd_ofs < 0)
+		return -EACCES;
+
+	cmd_return_ofs = cmd_ofs + 1;
+
+	rc = cyttsp4_adap_read(cd, cmd_return_ofs, return_buf, return_buf_size);
+	if (rc < 0) {
+		dev_err(dev, "%s: Error on read 3 r=%d\n", __func__, rc);
+		return rc;
+	}
+
+	return 0;
+}
+
+static int cyttsp4_request_exec_cmd_(struct cyttsp4_device *ttsp, u8 mode,
+		u8 *cmd_buf, size_t cmd_size, u8 *return_buf,
+		size_t return_buf_size, int timeout_ms)
+{
+	struct cyttsp4_core *core = ttsp->core;
+	struct cyttsp4_core_data *cd = dev_get_drvdata(&core->dev);
+	return cyttsp4_exec_cmd(cd, mode, cmd_buf, cmd_size,
+			return_buf, return_buf_size, timeout_ms);
+}
+
+static int cyttsp4_get_parameter(struct cyttsp4_core_data *cd, u8 param_id,
+		u32 *param_value)
+{
+	u8 command_buf[CY_CMD_OP_GET_PARAM_CMD_SZ];
+	u8 return_buf[CY_CMD_OP_GET_PARAM_RET_SZ];
+	u8 param_size;
+	u8 *value_buf;
+	int rc;
+
+	command_buf[0] = CY_CMD_OP_GET_PARAM;
+	command_buf[1] = param_id;
+	rc = cyttsp4_exec_cmd(cd, CY_MODE_OPERATIONAL,
+			command_buf, CY_CMD_OP_GET_PARAM_CMD_SZ,
+			return_buf, CY_CMD_OP_GET_PARAM_RET_SZ,
+			CY_COMMAND_COMPLETE_TIMEOUT);
+	if (rc < 0) {
+		dev_err(cd->dev, "%s: Unable to execute get parameter command.\n",
+			__func__);
+		return rc;
+	}
+
+	if (return_buf[0] != param_id) {
+		dev_err(cd->dev, "%s: Fail to execute get parameter command.\n",
+			__func__);
+		return -EIO;
+	}
+
+	param_size = return_buf[1];
+	value_buf = &return_buf[2];
+
+	*param_value = 0;
+	while (param_size--)
+		*param_value += *(value_buf++) << (8 * param_size);
+
+	return 0;
+}
+
+static int cyttsp4_set_parameter(struct cyttsp4_core_data *cd, u8 param_id,
+		u8 param_size, u32 param_value)
+{
+	u8 command_buf[CY_CMD_OP_SET_PARAM_CMD_SZ];
+	u8 return_buf[CY_CMD_OP_SET_PARAM_RET_SZ];
+	int rc;
+
+	command_buf[0] = CY_CMD_OP_SET_PARAM;
+	command_buf[1] = param_id;
+	command_buf[2] = param_size;
+
+	if (param_size == 1) {
+		command_buf[3] = (u8)param_value;
+	} else if (param_size == 2) {
+		command_buf[3] = (u8)(param_value >> 8);
+		command_buf[4] = (u8)param_value;
+	} else if (param_size == 4) {
+		command_buf[3] = (u8)(param_value >> 24);
+		command_buf[4] = (u8)(param_value >> 16);
+		command_buf[5] = (u8)(param_value >> 8);
+		command_buf[6] = (u8)param_value;
+	} else {
+		dev_err(cd->dev, "%s: Invalid parameter size %d\n",
+			__func__, param_size);
+		return -EINVAL;
+	}
+
+	rc = cyttsp4_exec_cmd(cd, CY_MODE_OPERATIONAL,
+			command_buf, 3 + param_size,
+			return_buf, CY_CMD_OP_SET_PARAM_RET_SZ,
+			CY_COMMAND_COMPLETE_TIMEOUT);
+	if (rc < 0) {
+		dev_err(cd->dev, "%s: Unable to execute set parameter command.\n",
+			__func__);
+		return rc;
+	}
+
+	if (return_buf[0] != param_id || return_buf[1] != param_size) {
+		dev_err(cd->dev, "%s: Fail to execute set parameter command.\n",
+			__func__);
+		return -EIO;
+	}
+
+	return 0;
+}
+
+static int cyttsp4_get_scantype(struct cyttsp4_core_data *cd, u8 *scantype)
+{
+	int rc;
+	u32 value;
+
+	rc = cyttsp4_get_parameter(cd, CY_RAM_ID_SCAN_TYPE, &value);
+	if (!rc)
+		*scantype = (u8)value;
+
+	return rc;
+}
+
+static int cyttsp4_set_scantype(struct cyttsp4_core_data *cd, u8 scantype)
+{
+	int rc;
+
+	rc = cyttsp4_set_parameter(cd, CY_RAM_ID_SCAN_TYPE, 1, scantype);
+
+	return rc;
+}
+
+static u8 _cyttsp4_generate_new_scantype(struct cyttsp4_core_data *cd)
+{
+	u8 new_scantype = cd->default_scantype;
+
+	if (cd->apa_mc_en)
+		new_scantype |= CY_SCAN_TYPE_APA_MC;
+	if (cd->glove_en)
+		new_scantype |= CY_SCAN_TYPE_GLOVE;
+	if (cd->stylus_en)
+		new_scantype |= CY_SCAN_TYPE_STYLUS;
+	if (cd->proximity_en)
+		new_scantype |= CY_SCAN_TYPE_PROXIMITY;
+
+	return new_scantype;
+}
+
+static int cyttsp4_set_new_scan_type(struct cyttsp4_core_data *cd,
+		u8 scan_type, bool enable)
+{
+	int inc = enable ? 1 : -1;
+	int *en;
+	int rc;
+	u8 new_scantype;
+
+	switch (scan_type) {
+	case CY_ST_GLOVE:
+		en = &cd->glove_en;
+		break;
+	case CY_ST_STYLUS:
+		en = &cd->stylus_en;
+		break;
+	case CY_ST_PROXIMITY:
+		en = &cd->proximity_en;
+		break;
+	case CY_ST_APA_MC:
+		en = &cd->apa_mc_en;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	*en += inc;
+
+	new_scantype = _cyttsp4_generate_new_scantype(cd);
+
+	rc = cyttsp4_set_scantype(cd, new_scantype);
+	if (rc)
+		*en -= inc;
+
+	return rc;
+}
+
+static int cyttsp4_request_enable_scan_type_(struct cyttsp4_device *ttsp,
+		u8 scan_type)
+{
+	struct cyttsp4_core *core = ttsp->core;
+	struct cyttsp4_core_data *cd = dev_get_drvdata(&core->dev);
+
+	return cyttsp4_set_new_scan_type(cd, scan_type, true);
+}
+
+static int cyttsp4_request_disable_scan_type_(struct cyttsp4_device *ttsp,
+		u8 scan_type)
+{
+	struct cyttsp4_core *core = ttsp->core;
+	struct cyttsp4_core_data *cd = dev_get_drvdata(&core->dev);
+
+	return cyttsp4_set_new_scan_type(cd, scan_type, false);
+}
+
+static int cyttsp4_read_config_block(struct cyttsp4_core_data *cd, u8 ebid,
+		u16 row, u8 *data, u16 length)
+{
+	u8 command_buf[CY_CMD_CAT_READ_CFG_BLK_CMD_SZ];
+	u8 *return_buf;
+	int return_buf_sz;
+	u16 crc;
+	int rc;
+
+	/* Allocate buffer for read config block command response
+	 * Header(5) + Data(length) + CRC(2)
+	 */
+	return_buf_sz = CY_CMD_CAT_READ_CFG_BLK_RET_SZ + length;
+	return_buf = kmalloc(return_buf_sz, GFP_KERNEL);
+	if (!return_buf) {
+		dev_err(cd->dev, "%s: Cannot allocate buffer\n",
+			__func__);
+		rc = -ENOMEM;
+		goto exit;
+	}
+
+	command_buf[0] = CY_CMD_CAT_READ_CFG_BLK;
+	command_buf[1] = HI_BYTE(row);
+	command_buf[2] = LO_BYTE(row);
+	command_buf[3] = HI_BYTE(length);
+	command_buf[4] = LO_BYTE(length);
+	command_buf[5] = ebid;
+
+	rc = cyttsp4_exec_cmd(cd, CY_MODE_CAT,
+			command_buf, CY_CMD_CAT_READ_CFG_BLK_CMD_SZ,
+			return_buf, return_buf_sz,
+			CY_COMMAND_COMPLETE_TIMEOUT);
+	if (rc) {
+		dev_err(cd->dev, "%s: Error executing command r=%d\n",
+			__func__, rc);
+		goto free_buffer;
+	}
+
+	crc = cyttsp4_calc_app_crc(
+		&return_buf[CY_CMD_CAT_READ_CFG_BLK_RET_HDR_SZ], length);
+
+	/* Validate response */
+	if (return_buf[0] != CY_CMD_STATUS_SUCCESS
+			|| return_buf[1] != ebid
+			|| return_buf[2] != HI_BYTE(length)
+			|| return_buf[3] != LO_BYTE(length)
+			|| return_buf[CY_CMD_CAT_READ_CFG_BLK_RET_HDR_SZ
+				+ length] != HI_BYTE(crc)
+			|| return_buf[CY_CMD_CAT_READ_CFG_BLK_RET_HDR_SZ
+				+ length + 1] != LO_BYTE(crc)) {
+		dev_err(cd->dev, "%s: Fail executing command\n",
+				__func__);
+		rc = -EINVAL;
+		goto free_buffer;
+	}
+
+	memcpy(data, &return_buf[CY_CMD_CAT_READ_CFG_BLK_RET_HDR_SZ], length);
+
+	cyttsp4_pr_buf(cd->dev, cd->pr_buf, data, length, "read_config_block");
+
+free_buffer:
+	kfree(return_buf);
+exit:
+	return rc;
+}
+
+static int cyttsp4_write_config_block(struct cyttsp4_core_data *cd, u8 ebid,
+		u16 row, const u8 *data, u16 length)
+{
+	u8 return_buf[CY_CMD_CAT_WRITE_CFG_BLK_RET_SZ];
+	u8 *command_buf;
+	int command_buf_sz;
+	u16 crc;
+	int rc;
+
+	/* Allocate buffer for write config block command
+	 * Header(6) + Data(length) + Security Key(8) + CRC(2)
+	 */
+	command_buf_sz = CY_CMD_CAT_WRITE_CFG_BLK_CMD_SZ + length
+		+ sizeof(security_key);
+	command_buf = kmalloc(command_buf_sz, GFP_KERNEL);
+	if (!command_buf) {
+		dev_err(cd->dev, "%s: Cannot allocate buffer\n",
+			__func__);
+		rc = -ENOMEM;
+		goto exit;
+	}
+
+	crc = cyttsp4_calc_app_crc(data, length);
+
+	command_buf[0] = CY_CMD_CAT_WRITE_CFG_BLK;
+	command_buf[1] = HI_BYTE(row);
+	command_buf[2] = LO_BYTE(row);
+	command_buf[3] = HI_BYTE(length);
+	command_buf[4] = LO_BYTE(length);
+	command_buf[5] = ebid;
+
+	command_buf[CY_CMD_CAT_WRITE_CFG_BLK_CMD_HDR_SZ + length
+		+ sizeof(security_key)] = HI_BYTE(crc);
+	command_buf[CY_CMD_CAT_WRITE_CFG_BLK_CMD_HDR_SZ + 1 + length
+		+ sizeof(security_key)] = LO_BYTE(crc);
+
+	memcpy(&command_buf[CY_CMD_CAT_WRITE_CFG_BLK_CMD_HDR_SZ], data,
+		length);
+	memcpy(&command_buf[CY_CMD_CAT_WRITE_CFG_BLK_CMD_HDR_SZ + length],
+		security_key, sizeof(security_key));
+
+	cyttsp4_pr_buf(cd->dev, cd->pr_buf, command_buf, command_buf_sz,
+		"write_config_block");
+
+	rc = cyttsp4_exec_cmd(cd, CY_MODE_CAT,
+			command_buf, command_buf_sz,
+			return_buf, CY_CMD_CAT_WRITE_CFG_BLK_RET_SZ,
+			CY_COMMAND_COMPLETE_TIMEOUT);
+	if (rc) {
+		dev_err(cd->dev, "%s: Error executing command r=%d\n",
+			__func__, rc);
+		goto free_buffer;
+	}
+
+	/* Validate response */
+	if (return_buf[0] != CY_CMD_STATUS_SUCCESS
+			|| return_buf[1] != ebid
+			|| return_buf[2] != HI_BYTE(length)
+			|| return_buf[3] != LO_BYTE(length)) {
+		dev_err(cd->dev, "%s: Fail executing command\n",
+				__func__);
+		rc = -EINVAL;
+		goto free_buffer;
+	}
+
+free_buffer:
+	kfree(command_buf);
+exit:
+	return rc;
+}
+
+static int cyttsp4_get_config_row_size(struct cyttsp4_core_data *cd,
+		u16 *config_row_size)
+{
+	u8 command_buf[CY_CMD_CAT_GET_CFG_ROW_SIZE_CMD_SZ];
+	u8 return_buf[CY_CMD_CAT_GET_CFG_ROW_SIZE_RET_SZ];
+	int rc;
+
+	command_buf[0] = CY_CMD_CAT_GET_CFG_ROW_SZ;
+
+	rc = cyttsp4_exec_cmd(cd, CY_MODE_CAT,
+			command_buf, CY_CMD_CAT_GET_CFG_ROW_SIZE_CMD_SZ,
+			return_buf, CY_CMD_CAT_GET_CFG_ROW_SIZE_RET_SZ,
+			CY_COMMAND_COMPLETE_TIMEOUT);
+	if (rc) {
+		dev_err(cd->dev, "%s: Error executing command r=%d\n",
+			__func__, rc);
+		goto exit;
+	}
+
+	*config_row_size = get_unaligned_be16(&return_buf[0]);
+
+exit:
+	return rc;
+}
+
+static int cyttsp4_request_config_row_size_(struct cyttsp4_device *ttsp,
+		u16 *config_row_size)
+{
+	struct cyttsp4_core *core = ttsp->core;
+	struct cyttsp4_core_data *cd = dev_get_drvdata(&core->dev);
+
+	return cyttsp4_get_config_row_size(cd, config_row_size);
+}
+
+static int cyttsp4_verify_config_block_crc(struct cyttsp4_core_data *cd,
+		u8 ebid, u16 *calc_crc, u16 *stored_crc, bool *match)
+{
+	u8 command_buf[CY_CMD_CAT_VERIFY_CFG_BLK_CRC_CMD_SZ];
+	u8 return_buf[CY_CMD_CAT_VERIFY_CFG_BLK_CRC_RET_SZ];
+	int rc;
+
+	command_buf[0] = CY_CMD_CAT_VERIFY_CFG_BLK_CRC;
+	command_buf[1] = ebid;
+
+	rc = cyttsp4_exec_cmd(cd, CY_MODE_CAT,
+			command_buf, CY_CMD_CAT_VERIFY_CFG_BLK_CRC_CMD_SZ,
+			return_buf, CY_CMD_CAT_VERIFY_CFG_BLK_CRC_RET_SZ,
+			CY_COMMAND_COMPLETE_TIMEOUT);
+	if (rc) {
+		dev_err(cd->dev, "%s: Error executing command r=%d\n",
+			__func__, rc);
+		goto exit;
+	}
+
+	*calc_crc = get_unaligned_be16(&return_buf[1]);
+	*stored_crc = get_unaligned_be16(&return_buf[3]);
+	if (match)
+		*match = !return_buf[0];
+exit:
+	return rc;
+}
+
+static int cyttsp4_get_config_block_crc(struct cyttsp4_core_data *cd,
+		u8 ebid, u16 *crc)
+{
+	u8 command_buf[CY_CMD_OP_GET_CFG_BLK_CRC_CMD_SZ];
+	u8 return_buf[CY_CMD_OP_GET_CFG_BLK_CRC_RET_SZ];
+	int rc;
+
+	command_buf[0] = CY_CMD_OP_GET_CRC;
+	command_buf[1] = ebid;
+
+	rc = cyttsp4_exec_cmd(cd, CY_MODE_OPERATIONAL,
+			command_buf, CY_CMD_OP_GET_CFG_BLK_CRC_CMD_SZ,
+			return_buf, CY_CMD_OP_GET_CFG_BLK_CRC_RET_SZ,
+			CY_COMMAND_COMPLETE_TIMEOUT);
+	if (rc) {
+		dev_err(cd->dev, "%s: Error executing command r=%d\n",
+			__func__, rc);
+		goto exit;
+	}
+
+	/* Validate response */
+	if (return_buf[0] != CY_CMD_STATUS_SUCCESS) {
+		dev_err(cd->dev, "%s: Fail executing command\n",
+				__func__);
+		rc = -EINVAL;
+		goto exit;
+	}
+
+	*crc = get_unaligned_be16(&return_buf[1]);
+
+exit:
+	return rc;
+}
+
+static int cyttsp4_get_ttconfig_version(struct cyttsp4_core_data *cd,
+		u16 *version)
+{
+	struct cyttsp4_sysinfo *si = &cd->sysinfo;
+	u8 data[CY_TTCONFIG_VERSION_OFFSET + CY_TTCONFIG_VERSION_SIZE];
+	int rc;
+	bool ready;
+
+	mutex_lock(&cd->system_lock);
+	ready = si->ready;
+	mutex_unlock(&cd->system_lock);
+
+	if (!ready) {
+		rc  = -ENODEV;
+		goto exit;
+	}
+
+	rc = cyttsp4_read_config_block(cd, CY_TCH_PARM_EBID,
+			CY_TTCONFIG_VERSION_ROW, data, sizeof(data));
+	if (rc) {
+		dev_err(cd->dev, "%s: Error on read config block\n",
+			__func__);
+		goto exit;
+	}
+
+	*version = GET_FIELD16(si, &data[CY_TTCONFIG_VERSION_OFFSET]);
+
+exit:
+	return rc;
+}
+
+static int cyttsp4_get_config_length(struct cyttsp4_core_data *cd, u8 ebid,
+		u16 *length, u16 *max_length)
+{
+	struct cyttsp4_sysinfo *si = &cd->sysinfo;
+	u8 data[CY_CONFIG_LENGTH_INFO_SIZE];
+	int rc;
+	bool ready;
+
+	mutex_lock(&cd->system_lock);
+	ready = si->ready;
+	mutex_unlock(&cd->system_lock);
+
+	if (!ready) {
+		rc  = -ENODEV;
+		goto exit;
+	}
+
+	rc = cyttsp4_read_config_block(cd, ebid, CY_CONFIG_LENGTH_INFO_OFFSET,
+			data, sizeof(data));
+	if (rc) {
+		dev_err(cd->dev, "%s: Error on read config block\n",
+			__func__);
+		goto exit;
+	}
+
+	*length = GET_FIELD16(si, &data[CY_CONFIG_LENGTH_OFFSET]);
+	*max_length = GET_FIELD16(si, &data[CY_CONFIG_MAXLENGTH_OFFSET]);
+
+exit:
+	return rc;
+}
+
+static int cyttsp4_write_config_common(struct cyttsp4_core_data *cd, u8 ebid,
+		u16 offset, u8 *data, u16 length)
+{
+	u16 cur_block, cur_off, end_block, end_off;
+	int copy_len;
+	u16 config_row_size = 0;
+	u8 *row_data = NULL;
+	int rc;
+
+	rc = cyttsp4_get_config_row_size(cd, &config_row_size);
+	if (rc) {
+		dev_err(cd->dev, "%s: Cannot get config row size\n",
+			__func__);
+		goto exit;
+	}
+
+	cur_block = offset / config_row_size;
+	cur_off = offset % config_row_size;
+
+	end_block = (offset + length) / config_row_size;
+	end_off = (offset + length) % config_row_size;
+
+	/* Check whether we need to fetch the whole block first */
+	if (cur_off == 0)
+		goto no_offset;
+
+	row_data = kmalloc(config_row_size, GFP_KERNEL);
+	if (!row_data) {
+		dev_err(cd->dev, "%s: Cannot allocate buffer\n", __func__);
+		rc = -ENOMEM;
+		goto exit;
+	}
+
+	copy_len = (cur_block == end_block) ?
+		length : config_row_size - cur_off;
+
+	/* Read up to current offset, append the new data and write it back */
+	rc = cyttsp4_read_config_block(cd, ebid, cur_block, row_data, cur_off);
+	if (rc) {
+		dev_err(cd->dev, "%s: Error on read config block\n", __func__);
+		goto free_row_data;
+	}
+
+	memcpy(&row_data[cur_off], data, copy_len);
+
+	rc = cyttsp4_write_config_block(cd, ebid, cur_block, row_data,
+			cur_off + copy_len);
+	if (rc) {
+		dev_err(cd->dev, "%s: Error on initial write config block\n",
+			__func__);
+		goto free_row_data;
+	}
+
+	data += copy_len;
+	cur_off = 0;
+	cur_block++;
+
+no_offset:
+	while (cur_block < end_block) {
+		rc = cyttsp4_write_config_block(cd, ebid, cur_block, data,
+				config_row_size);
+		if (rc) {
+			dev_err(cd->dev, "%s: Error on write config block\n",
+				__func__);
+			goto free_row_data;
+		}
+
+		data += config_row_size;
+		cur_block++;
+	}
+
+	/* Last block */
+	if (cur_block == end_block) {
+		rc = cyttsp4_write_config_block(cd, ebid, end_block, data,
+				end_off);
+		if (rc) {
+			dev_err(cd->dev, "%s: Error on last write config block\n",
+				__func__);
+			goto free_row_data;
+		}
+	}
+
+free_row_data:
+	kfree(row_data);
+exit:
+	return rc;
+}
+
+static int cyttsp4_write_config(struct cyttsp4_core_data *cd, u8 ebid,
+		u16 offset, u8 *data, u16 length) {
+	struct cyttsp4_sysinfo *si = &cd->sysinfo;
+	u16 crc_new, crc_old;
+	u16 crc_offset;
+	u16 conf_len;
+	u8 crc_data[2];
+	int rc;
+	bool ready;
+
+	mutex_lock(&cd->system_lock);
+	ready = si->ready;
+	mutex_unlock(&cd->system_lock);
+
+	if (!ready) {
+		rc  = -ENODEV;
+		goto exit;
+	}
+
+	/* CRC is stored at config max length offset */
+	rc = cyttsp4_get_config_length(cd, ebid, &conf_len, &crc_offset);
+	if (rc) {
+		dev_err(cd->dev, "%s: Error on get config length\n",
+			__func__);
+		goto exit;
+	}
+
+	/* Allow CRC update also */
+	if (offset + length > crc_offset + 2) {
+		dev_err(cd->dev, "%s: offset + length exceeds max length(%d)\n",
+			__func__, crc_offset + 2);
+		rc = -EINVAL;
+		goto exit;
+	}
+
+	rc = cyttsp4_write_config_common(cd, ebid, offset, data, length);
+	if (rc) {
+		dev_err(cd->dev, "%s: Error on write config\n",
+			__func__);
+		goto exit;
+	}
+
+	/* Verify config block CRC */
+	rc = cyttsp4_verify_config_block_crc(cd, ebid,
+			&crc_new, &crc_old, NULL);
+	if (rc) {
+		dev_err(cd->dev, "%s: Error on verify config block crc\n",
+			__func__);
+		goto exit;
+	}
+
+	dev_vdbg(cd->dev, "%s: crc_new:%04X crc_old:%04X\n",
+		__func__, crc_new, crc_old);
+
+	if (crc_new == crc_old) {
+		dev_vdbg(cd->dev, "%s: Calculated crc matches stored crc\n",
+			__func__);
+		goto exit;
+	}
+
+	PUT_FIELD16(si, crc_new, crc_data);
+
+	rc = cyttsp4_write_config_common(cd, ebid, crc_offset, crc_data, 2);
+	if (rc) {
+		dev_err(cd->dev, "%s: Error on write config crc\n",
+			__func__);
+		goto exit;
+	}
+
+exit:
+	return rc;
+}
+
+static int cyttsp4_request_write_config_(struct cyttsp4_device *ttsp, u8 ebid,
+		u16 offset, u8 *data, u16 length) {
+	struct cyttsp4_core *core = ttsp->core;
+	struct cyttsp4_core_data *cd = dev_get_drvdata(&core->dev);
+
+	return cyttsp4_write_config(cd, ebid, offset, data, length);
+}
+
+#ifdef CYTTSP4_WATCHDOG_NULL_CMD
+static void cyttsp4_watchdog_work(struct work_struct *work)
+{
+	struct cyttsp4_core_data *cd =
+		container_of(work, struct cyttsp4_core_data, watchdog_work);
+	u8 cmd_buf[CY_CMD_OP_NULL_CMD_SZ];
+	bool restart = false;
+	int rc;
+
+	rc = request_exclusive(cd, cd->core, 1);
+	if (rc < 0) {
+		dev_vdbg(cd->dev, "%s: fail get exclusive ex=%p own=%p\n",
+				__func__, cd->exclusive_dev, cd->core);
+		goto exit;
+	}
+
+	cmd_buf[0] = CY_CMD_OP_NULL;
+	rc = cyttsp4_exec_cmd(cd, cd->mode,
+			cmd_buf, CY_CMD_OP_NULL_CMD_SZ,
+			NULL, CY_CMD_OP_NULL_RET_SZ,
+			CY_COMMAND_COMPLETE_TIMEOUT);
+	if (rc < 0) {
+		dev_err(cd->dev, "%s: Watchdog NULL cmd failed.\n", __func__);
+		restart = true;
+	}
+
+	if (release_exclusive(cd, cd->core) < 0)
+		dev_err(cd->dev, "%s: fail to release exclusive\n", __func__);
+	else
+		dev_vdbg(cd->dev, "%s: pass release exclusive\n", __func__);
+exit:
+	if (restart)
+		cyttsp4_queue_startup(cd);
+	else
+		cyttsp4_start_wd_timer(cd);
+}
+#else
+static void cyttsp4_watchdog_work(struct work_struct *work)
+{
+	struct cyttsp4_core_data *cd =
+		container_of(work, struct cyttsp4_core_data, watchdog_work);
+	u8 mode[2];
+	bool restart = false;
+	int rc;
+
+	if (cd == NULL) {
+		dev_err(cd->dev, "%s: NULL context pointer\n", __func__);
+		return;
+	}
+
+	mutex_lock(&cd->system_lock);
+	rc = cyttsp4_adap_read(cd, CY_REG_BASE, &mode, sizeof(mode));
+	if (rc) {
+		dev_err(cd->dev, "%s: failed to access device r=%d\n",
+			__func__, rc);
+		restart = true;
+		goto exit;
+	}
+
+	if (IS_BOOTLOADER(mode[0], mode[1])) {
+		dev_err(cd->dev, "%s: device found in bootloader mode\n",
+			__func__);
+		restart = true;
+		goto exit;
+	}
+exit:
+	if (restart)
+		cyttsp4_queue_startup_(cd);
+	else
+		cyttsp4_start_wd_timer(cd);
+	mutex_unlock(&cd->system_lock);
+}
+#endif
+
+static int cyttsp4_request_stop_wd_(struct cyttsp4_device *ttsp)
+{
+	struct cyttsp4_core *core = ttsp->core;
+	struct cyttsp4_core_data *cd = dev_get_drvdata(&core->dev);
+	cyttsp4_stop_wd_timer(cd);
+	return 0;
+}
+
+static int _cyttsp4_put_device_into_deep_sleep(struct cyttsp4_core_data *cd,
+		u8 hst_mode_reg)
+{
+	int rc;
+
+	hst_mode_reg |= CY_HST_SLEEP;
+
+	dev_vdbg(cd->dev, "%s: write DEEP SLEEP...\n", __func__);
+	rc = cyttsp4_adap_write(cd, CY_REG_BASE, &hst_mode_reg,
+			sizeof(hst_mode_reg));
+	if (rc) {
+		dev_err(cd->dev, "%s: Fail write adapter r=%d\n", __func__, rc);
+		return -EINVAL;
+	}
+	dev_vdbg(cd->dev, "%s: write DEEP SLEEP succeeded\n", __func__);
+
+	if (cd->pdata->power) {
+		dev_dbg(cd->dev, "%s: Power down HW\n", __func__);
+		rc = cd->pdata->power(cd->pdata, 0, cd->dev, &cd->ignore_irq);
+	} else {
+		dev_dbg(cd->dev, "%s: No power function\n", __func__);
+		rc = 0;
+	}
+	if (rc < 0) {
+		dev_err(cd->dev, "%s: HW Power down fails r=%d\n",
+				__func__, rc);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int _cyttsp4_put_device_into_easy_wakeup(struct cyttsp4_core_data *cd)
+{
+	u8 command_buf[CY_CMD_OP_WAIT_FOR_EVENT_CMD_SZ];
+	int rc;
+
+	if (!IS_TTSP_VER_GE(&cd->sysinfo, 2, 5))
+		return -EINVAL;
+
+	command_buf[0] = CY_CMD_OP_WAIT_FOR_EVENT;
+	command_buf[1] = cd->easy_wakeup_gesture;
+
+	rc = _cyttsp4_exec_cmd(cd, CY_MODE_OPERATIONAL, command_buf,
+			CY_CMD_OP_WAIT_FOR_EVENT_CMD_SZ);
+	cd->int_status &= ~CY_INT_EXEC_CMD;
+	if (rc)
+		dev_err(cd->dev, "%s: Error executing command r=%d\n",
+			__func__, rc);
+
+	return rc;
+}
+
+static int _cyttsp4_wait_for_refresh_cycle(struct cyttsp4_core_data *cd,
+		int cycle)
+{
+	int active_refresh_cycle_ms;
+
+	if (cd->active_refresh_cycle_ms)
+		active_refresh_cycle_ms = cd->active_refresh_cycle_ms;
+	else
+		active_refresh_cycle_ms = 20;
+
+	msleep(cycle * active_refresh_cycle_ms);
+
+	return 0;
+}
+
+static int _cyttsp4_put_device_into_sleep(struct cyttsp4_core_data *cd,
+		u8 hst_mode_reg)
+{
+	int rc;
+
+	if (IS_DEEP_SLEEP_CONFIGURED(cd->easy_wakeup_gesture))
+		rc = _cyttsp4_put_device_into_deep_sleep(cd, hst_mode_reg);
+	else
+		rc = _cyttsp4_put_device_into_easy_wakeup(cd);
+
+	return rc;
+}
+
+static int cyttsp4_core_sleep_(struct cyttsp4_core_data *cd)
+{
+	u8 mode[2];
+	int rc = 0;
+
+	cyttsp4_stop_wd_timer(cd);
+
+	/* Wait until currently running IRQ handler exits and disable IRQ */
+	disable_irq(cd->irq);
+
+	mutex_lock(&cd->system_lock);
+	/* Already in sleep mode? */
+	if (cd->sleep_state == SS_SLEEP_ON)
+		goto exit;
+
+	cd->sleep_state = SS_SLEEPING;
+
+	rc = cyttsp4_adap_read(cd, CY_REG_BASE, &mode, sizeof(mode));
+	if (rc) {
+		dev_err(cd->dev, "%s: Fail read adapter r=%d\n", __func__, rc);
+		goto exit;
+	}
+
+	if (IS_BOOTLOADER(mode[0], mode[1])) {
+		dev_err(cd->dev, "%s: Device in BOOTLADER mode.\n", __func__);
+		rc = -EINVAL;
+		goto exit;
+	}
+
+	/* Deep sleep is only allowed in Operating mode */
+	if (GET_HSTMODE(mode[0]) != CY_HST_OPERATE) {
+		dev_err(cd->dev, "%s: Device is not in Operating mode (%02X)\n",
+			__func__, GET_HSTMODE(mode[0]));
+		mutex_unlock(&cd->system_lock);
+		enable_irq(cd->irq);
+		/* Try switching to Operating mode */
+		rc = set_mode(cd, CY_MODE_OPERATIONAL);
+		disable_irq(cd->irq);
+		mutex_lock(&cd->system_lock);
+		if (rc < 0) {
+			dev_err(cd->dev, "%s: failed to set mode to Operational rc=%d\n",
+				__func__, rc);
+			cyttsp4_queue_startup_(cd);
+			rc = 0;
+			goto exit;
+		}
+
+		/* Get the new host mode register value */
+		rc = cyttsp4_adap_read(cd, CY_REG_BASE, &mode, sizeof(mode));
+		if (rc) {
+			dev_err(cd->dev, "%s: Fail read adapter r=%d\n",
+				__func__, rc);
+			goto exit;
+		}
+	}
+
+	rc = _cyttsp4_put_device_into_sleep(cd, mode[0]);
+
+exit:
+	if (rc) {
+		cd->sleep_state = SS_SLEEP_OFF;
+		cyttsp4_start_wd_timer(cd);
+	} else {
+		cd->sleep_state = SS_SLEEP_ON;
+		cd->int_status |= CY_INT_IGNORE;
+	}
+
+	mutex_unlock(&cd->system_lock);
+	enable_irq(cd->irq);
+
+	return rc;
+}
+
+static int cyttsp4_core_sleep(struct cyttsp4_core_data *cd)
+{
+	int rc;
+
+	rc = request_exclusive(cd, cd->core,
+			CY_CORE_SLEEP_REQUEST_EXCLUSIVE_TIMEOUT);
+	if (rc < 0) {
+		dev_err(cd->dev, "%s: fail get exclusive ex=%p own=%p\n",
+				__func__, cd->exclusive_dev, cd->core);
+		return 0;
+	}
+
+	rc = cyttsp4_core_sleep_(cd);
+
+	if (release_exclusive(cd, cd->core) < 0)
+		dev_err(cd->dev, "%s: fail to release exclusive\n", __func__);
+	else
+		dev_vdbg(cd->dev, "%s: pass release exclusive\n", __func__);
+
+	/* Give time to FW to sleep */
+	_cyttsp4_wait_for_refresh_cycle(cd, 2);
+
+	return rc;
+}
+
+static int _cyttsp4_awake_device_from_deep_sleep(struct cyttsp4_core_data *cd,
+		int timeout_ms)
+{
+	struct device *dev = cd->dev;
+	u8 mode;
+	int t;
+	int rc;
+
+	cd->int_status |= CY_INT_AWAKE;
+
+	if (cd->pdata->power) {
+		/* Wake up using platform power function */
+		dev_dbg(dev, "%s: Power up HW\n", __func__);
+		rc = cd->pdata->power(cd->pdata, 1, dev, &cd->ignore_irq);
+	} else {
+		/* Initiate a read transaction to wake up */
+		rc = cyttsp4_adap_read(cd, CY_REG_BASE, &mode, sizeof(mode));
+	}
+	if (rc < 0) {
+		dev_err(dev, "%s: HW Power up fails r=%d\n", __func__, rc);
+		/* Initiate another read transaction to wake up */
+		rc = cyttsp4_adap_read(cd, CY_REG_BASE, &mode, sizeof(mode));
+	} else
+		dev_vdbg(cd->dev, "%s: HW power up succeeds\n", __func__);
+	mutex_unlock(&cd->system_lock);
+
+	t = wait_event_timeout(cd->wait_q,
+			(cd->int_status & CY_INT_AWAKE) == 0,
+			msecs_to_jiffies(timeout_ms));
+	mutex_lock(&cd->system_lock);
+	if (IS_TMO(t)) {
+		dev_dbg(dev, "%s: TMO waiting for wakeup\n", __func__);
+		cd->int_status &= ~CY_INT_AWAKE;
+		/* Perform a read transaction to check if device is awake */
+		rc = cyttsp4_adap_read(cd, CY_REG_BASE, &mode, sizeof(mode));
+		if (rc < 0 || GET_HSTMODE(mode) != CY_HST_OPERATE) {
+			dev_err(dev, "%s: Queueing startup\n", __func__);
+			/* Try starting up */
+			cyttsp4_queue_startup_(cd);
+		}
+	}
+
+	return rc;
+}
+
+static int _cyttsp4_awake_device(struct cyttsp4_core_data *cd)
+{
+	int timeout_ms;
+
+	if (cd->wake_initiated_by_device) {
+		cd->wake_initiated_by_device = 0;
+		/* To prevent sequential wake/sleep caused by ttsp modules */
+		msleep(20);
+		return 0;
+	}
+
+	if (IS_DEEP_SLEEP_CONFIGURED(cd->easy_wakeup_gesture))
+		timeout_ms = CY_CORE_WAKEUP_TIMEOUT;
+	else
+		timeout_ms = CY_CORE_WAKEUP_TIMEOUT * 4;
+
+	return _cyttsp4_awake_device_from_deep_sleep(cd, timeout_ms);
+}
+
+static int cyttsp4_core_wake_(struct cyttsp4_core_data *cd)
+{
+	int rc;
+
+	/* Already woken? */
+	mutex_lock(&cd->system_lock);
+	if (cd->sleep_state == SS_SLEEP_OFF) {
+		mutex_unlock(&cd->system_lock);
+		return 0;
+	}
+
+	cd->int_status &= ~CY_INT_IGNORE;
+	cd->sleep_state = SS_WAKING;
+
+	rc = _cyttsp4_awake_device(cd);
+
+	cd->sleep_state = SS_SLEEP_OFF;
+	mutex_unlock(&cd->system_lock);
+
+	cyttsp4_start_wd_timer(cd);
+
+	return 0;
+}
+
+static int cyttsp4_core_wake(struct cyttsp4_core_data *cd)
+{
+	int rc;
+
+	rc = request_exclusive(cd, cd->core,
+			CY_CORE_REQUEST_EXCLUSIVE_TIMEOUT);
+	if (rc < 0) {
+		dev_err(cd->dev, "%s: fail get exclusive ex=%p own=%p\n",
+				__func__, cd->exclusive_dev, cd->core);
+		return 0;
+	}
+
+	rc = cyttsp4_core_wake_(cd);
+
+	if (release_exclusive(cd, cd->core) < 0)
+		dev_err(cd->dev, "%s: fail to release exclusive\n", __func__);
+	else
+		dev_vdbg(cd->dev, "%s: pass release exclusive\n", __func__);
+
+	/* If a startup queued in wake, wait it to finish */
+	wait_event_timeout(cd->wait_q, cd->startup_state == STARTUP_NONE,
+			msecs_to_jiffies(CY_CORE_RESET_AND_WAIT_TIMEOUT));
+
+	return rc;
+}
+
+static int cyttsp4_get_ttconfig_info(struct cyttsp4_core_data *cd)
+{
+	struct cyttsp4_sysinfo *si = &cd->sysinfo;
+	u16 length, max_length;
+	u16 version = 0;
+	u16 crc = 0;
+	int rc;
+
+	rc = set_mode(cd, CY_MODE_CAT);
+	if (rc < 0) {
+		dev_err(cd->dev, "%s: failed to set mode to CAT rc=%d\n",
+			__func__, rc);
+		return rc;
+	}
+
+	rc = cyttsp4_get_ttconfig_version(cd, &version);
+	if (rc < 0) {
+		dev_err(cd->dev, "%s: failed to get ttconfig version rc=%d\n",
+			__func__, rc);
+		return rc;
+	}
+
+	rc = cyttsp4_get_config_length(cd, CY_TCH_PARM_EBID,
+			&length, &max_length);
+	if (rc < 0) {
+		dev_err(cd->dev, "%s: failed to get ttconfig length rc=%d\n",
+			__func__, rc);
+		return rc;
+	}
+
+	rc = set_mode(cd, CY_MODE_OPERATIONAL);
+	if (rc < 0) {
+		dev_err(cd->dev, "%s: failed to set mode to Operational rc=%d\n",
+			__func__, rc);
+		return rc;
+	}
+
+	rc = cyttsp4_get_config_block_crc(cd, CY_TCH_PARM_EBID, &crc);
+	if (rc < 0) {
+		dev_err(cd->dev, "%s: failed to get ttconfig crc rc=%d\n",
+			__func__, rc);
+		return rc;
+	}
+
+	si->ttconfig.version = version;
+	si->ttconfig.length = length;
+	si->ttconfig.max_length = max_length;
+	si->ttconfig.crc = crc;
+
+	dev_vdbg(cd->dev, "%s: TT Config Version:%04X Length:%d Max Length:%d CRC:%04X\n",
+		__func__, si->ttconfig.version, si->ttconfig.length,
+		si->ttconfig.length, si->ttconfig.crc);
+
+	return 0;
+}
+static int cyttsp4_get_active_refresh_cycle(struct cyttsp4_core_data *cd)
+{
+	int rc;
+	u32 value;
+
+	rc = cyttsp4_get_parameter(cd, CY_RAM_ID_REFRESH_INTERVAL, &value);
+	if (!rc)
+		cd->active_refresh_cycle_ms = (u8)value;
+
+	return rc;
+}
+
+static int cyttsp4_set_initial_scantype(struct cyttsp4_core_data *cd)
+{
+	u8 new_scantype;
+	int rc;
+
+	rc = cyttsp4_get_scantype(cd, &cd->default_scantype);
+	if (rc < 0) {
+		dev_err(cd->dev, "%s: failed to get scantype rc=%d\n",
+			__func__, rc);
+		goto exit;
+	}
+
+	/* Disable proximity sensing by default */
+	cd->default_scantype &= ~CY_SCAN_TYPE_PROXIMITY;
+
+	new_scantype = _cyttsp4_generate_new_scantype(cd);
+
+	rc = cyttsp4_set_scantype(cd, new_scantype);
+	if (rc < 0) {
+		dev_err(cd->dev, "%s: failed to set scantype rc=%d\n",
+			__func__, rc);
+		goto exit;
+	}
+exit:
+	return rc;
+}
+
+static int cyttsp4_startup_(struct cyttsp4_core_data *cd)
+{
+	int retry = CY_CORE_STARTUP_RETRY_COUNT;
+	int rc;
+	bool detected = false;
+
+	dev_dbg(cd->dev, "%s: enter...\n", __func__);
+
+	cyttsp4_stop_wd_timer(cd);
+
+reset:
+	if (retry != CY_CORE_STARTUP_RETRY_COUNT)
+		dev_dbg(cd->dev, "%s: Retry %d\n", __func__,
+			CY_CORE_STARTUP_RETRY_COUNT - retry);
+
+	/* reset hardware and wait for heartbeat */
+	rc = cyttsp4_reset_and_wait(cd);
+	if (rc < 0) {
+		dev_err(cd->dev, "%s: Error on h/w reset r=%d\n", __func__, rc);
+		RETRY_OR_EXIT(retry--, reset, exit);
+	}
+
+	detected = true;
+
+	/* exit bl into sysinfo mode */
+	dev_vdbg(cd->dev, "%s: write exit ldr...\n", __func__);
+	mutex_lock(&cd->system_lock);
+	cd->int_status &= ~CY_INT_IGNORE;
+	cd->int_status |= CY_INT_MODE_CHANGE;
+
+	rc = cyttsp4_adap_write(cd, CY_REG_BASE, (u8 *)ldr_exit,
+			sizeof(ldr_exit));
+	mutex_unlock(&cd->system_lock);
+	if (rc < 0) {
+		dev_err(cd->dev, "%s: Fail write adap='%s' r=%d\n",
+			__func__, cd->core->adap->id, rc);
+		RETRY_OR_EXIT(retry--, reset, exit);
+	}
+	msleep(2000);
+	rc = cyttsp4_wait_sysinfo_mode(cd);
+#if 1
+	if (rc < 0) {
+		u8 buf[sizeof(ldr_err_app)];
+		int rc1;
+
+		/* Check for invalid/corrupted touch application */
+		rc1 = cyttsp4_adap_read(cd, CY_REG_BASE, buf,
+				sizeof(ldr_err_app));
+		if (rc1) {
+			dev_err(cd->dev, "%s: Fail read adap='%s' r=%d\n",
+				__func__, cd->core->adap->id, rc1);
+		} else if (!memcmp(buf, ldr_err_app, sizeof(ldr_err_app))) {
+			dev_err(cd->dev, "%s: Error launching touch application\n",
+				__func__);
+			mutex_lock(&cd->system_lock);
+			cd->invalid_touch_app = true;
+			mutex_unlock(&cd->system_lock);
+			goto exit_no_wd;
+		}
+
+		RETRY_OR_EXIT(retry--, reset, exit);
+	}
+#endif
+#if 0
+        if (rc) {
+		u8 buf[sizeof(ldr_err_app)];
+		int rc1;
+
+		rc1 = cyttsp4_adap_read(cd, CY_REG_BASE,
+			buf, sizeof(ldr_err_app));
+		if (!rc1 && !memcmp(buf, ldr_err_app, sizeof(ldr_err_app)))
+			dev_err(cd->dev, "%s: Invalid touch application\n", __func__);
+
+		cyttsp4_start_wd_timer(cd);
+
+		/*
+		 * Unable to switch to SYSINFO mode,
+		 * Corrupted FW may cause crash, exit here.
+		 */
+		 dev_err(cd->dev, "%s: HGZ: Fail enter sysinfo mode\n",
+			__func__); //hgz
+		//return rc;// return 0 --> return rc
+		return 0;
+	}
+#endif
+	mutex_lock(&cd->system_lock);
+	cd->invalid_touch_app = false;
+	mutex_unlock(&cd->system_lock);
+
+	/* read sysinfo data */
+	dev_vdbg(cd->dev, "%s: get sysinfo regs..\n", __func__);
+	rc = cyttsp4_get_sysinfo_regs(cd);
+	if (rc < 0) {
+		dev_err(cd->dev, "%s: failed to get sysinfo regs rc=%d\n",
+			__func__, rc);
+		RETRY_OR_EXIT(retry--, reset, exit);
+	}
+
+	rc = set_mode(cd, CY_MODE_OPERATIONAL);
+	if (rc < 0) {
+		dev_err(cd->dev, "%s: failed to set mode to operational rc=%d\n",
+			__func__, rc);
+		RETRY_OR_EXIT(retry--, reset, exit);
+	}
+
+	rc = cyttsp4_set_initial_scantype(cd);
+	if (rc < 0) {
+		dev_err(cd->dev, "%s: failed to get scantype rc=%d\n",
+			__func__, rc);
+		RETRY_OR_EXIT(retry--, reset, exit);
+	}
+
+	rc = cyttsp4_get_ttconfig_info(cd);
+	if (rc < 0) {
+		dev_err(cd->dev, "%s: failed to get ttconfig info rc=%d\n",
+			__func__, rc);
+		RETRY_OR_EXIT(retry--, reset, exit);
+	}
+
+	rc = cyttsp4_get_active_refresh_cycle(cd);
+	if (rc < 0)
+		dev_err(cd->dev, "%s: failed to get refresh cycle time rc=%d\n",
+			__func__, rc);
+
+	/* attention startup */
+	call_atten_cb(cd, CY_ATTEN_STARTUP, 0);
+
+	/* restore to sleep if was suspended */
+	mutex_lock(&cd->system_lock);
+	if (cd->sleep_state == SS_SLEEP_ON) {
+		cd->sleep_state = SS_SLEEP_OFF;
+		mutex_unlock(&cd->system_lock);
+		/* watchdog is restarted by cyttsp4_core_sleep_() on error */
+		cyttsp4_core_sleep_(cd);
+		goto exit_no_wd;
+	}
+	mutex_unlock(&cd->system_lock);
+
+exit:
+	cyttsp4_start_wd_timer(cd);
+
+exit_no_wd:
+	if (!detected)
+		rc = -ENODEV;
+
+	/* Required for signal to the TTHE */
+	dev_info(cd->dev, "%s: cyttsp4_exit startup r=%d...\n", __func__, rc);
+
+	return rc;
+}
+
+static int cyttsp4_startup(struct cyttsp4_core_data *cd)
+{
+	int rc;
+
+	mutex_lock(&cd->system_lock);
+	cd->startup_state = STARTUP_RUNNING;
+	mutex_unlock(&cd->system_lock);
+
+	rc = request_exclusive(cd, cd->core,
+			CY_CORE_REQUEST_EXCLUSIVE_TIMEOUT);
+	if (rc < 0) {
+		dev_err(cd->dev, "%s: fail get exclusive ex=%p own=%p\n",
+				__func__, cd->exclusive_dev, cd->core);
+		goto exit;
+	}
+
+	rc = cyttsp4_startup_(cd);
+
+	if (release_exclusive(cd, cd->core) < 0)
+		/* Don't return fail code, mode is already changed. */
+		dev_err(cd->dev, "%s: fail to release exclusive\n", __func__);
+	else
+		dev_vdbg(cd->dev, "%s: pass release exclusive\n", __func__);
+
+exit:
+	mutex_lock(&cd->system_lock);
+	cd->startup_state = STARTUP_NONE;
+	mutex_unlock(&cd->system_lock);
+
+	/* Wake the waiters for end of startup */
+	wake_up(&cd->wait_q);
+
+	return rc;
+}
+
+static void cyttsp4_startup_work_function(struct work_struct *work)
+{
+	struct cyttsp4_core_data *cd =  container_of(work,
+		struct cyttsp4_core_data, startup_work);
+	int rc;
+
+	/*
+	 * Force clear exclusive access
+	 * startup queue is called for abnormal case,
+	 * and when a this called access can be acquired in other context
+	 */
+	mutex_lock(&cd->system_lock);
+	if (cd->exclusive_dev != cd->core)
+		cd->exclusive_dev = NULL;
+	mutex_unlock(&cd->system_lock);
+	rc = cyttsp4_startup(cd);
+	if (rc < 0)
+		dev_err(cd->dev, "%s: Fail queued startup r=%d\n",
+			__func__, rc);
+}
+
+static void cyttsp4_free_si_ptrs(struct cyttsp4_core_data *cd)
+{
+	struct cyttsp4_sysinfo *si = &cd->sysinfo;
+
+	if (!si)
+		return;
+
+	kfree(si->si_ptrs.cydata);
+	kfree(si->si_ptrs.test);
+	kfree(si->si_ptrs.pcfg);
+	kfree(si->si_ptrs.opcfg);
+	kfree(si->si_ptrs.ddata);
+	kfree(si->si_ptrs.mdata);
+	kfree(si->btn);
+	kfree(si->xy_mode);
+	kfree(si->btn_rec_data);
+}
+
+#if defined(CONFIG_PM_RUNTIME)
+static int cyttsp4_core_rt_suspend(struct device *dev)
+{
+	struct cyttsp4_core_data *cd = dev_get_drvdata(dev);
+	int rc;
+
+	rc = cyttsp4_core_sleep(cd);
+	if (rc < 0) {
+		dev_err(dev, "%s: Error on sleep\n", __func__);
+		return -EAGAIN;
+	}
+	return 0;
+}
+
+static int cyttsp4_core_rt_resume(struct device *dev)
+{
+	struct cyttsp4_core_data *cd = dev_get_drvdata(dev);
+	int rc;
+
+	rc = cyttsp4_core_wake(cd);
+	if (rc < 0) {
+		dev_err(dev, "%s: Error on wake\n", __func__);
+		return -EAGAIN;
+	}
+
+	return 0;
+}
+#endif
+
+#if defined(CONFIG_PM_SLEEP)
+static int cyttsp4_core_suspend(struct device *dev)
+{
+	struct cyttsp4_core_data *cd = dev_get_drvdata(dev);
+
+	if (!(cd->pdata->flags & CY_CORE_FLAG_WAKE_ON_GESTURE))
+		return 0;
+
+	/*
+	 * This will not prevent resume
+	 * Required to prevent interrupts before i2c awake
+	 */
+	disable_irq(cd->irq);
+
+	if (device_may_wakeup(dev)) {
+		dev_dbg(dev, "%s Device MAY wakeup\n", __func__);
+		if (!enable_irq_wake(cd->irq))
+			cd->irq_wake = 1;
+	} else {
+		dev_dbg(dev, "%s Device may NOT wakeup\n", __func__);
+	}
+
+	return 0;
+}
+
+static int cyttsp4_core_resume(struct device *dev)
+{
+	struct cyttsp4_core_data *cd = dev_get_drvdata(dev);
+
+	if (!(cd->pdata->flags & CY_CORE_FLAG_WAKE_ON_GESTURE))
+		return 0;
+
+	enable_irq(cd->irq);
+
+	if (device_may_wakeup(dev)) {
+		dev_dbg(dev, "%s Device MAY wakeup\n", __func__);
+		if (cd->irq_wake) {
+			disable_irq_wake(cd->irq);
+			cd->irq_wake = 0;
+		}
+	} else {
+		dev_dbg(dev, "%s Device may NOT wakeup\n", __func__);
+	}
+
+	return 0;
+}
+#endif
+
+static const struct dev_pm_ops cyttsp4_core_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(cyttsp4_core_suspend, cyttsp4_core_resume)
+	SET_RUNTIME_PM_OPS(cyttsp4_core_rt_suspend, cyttsp4_core_rt_resume,
+			NULL)
+};
+
+/*
+ * Show Panel ID via sysfs
+ */
+static ssize_t cyttsp4_panel_id_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct cyttsp4_core_data *cd = dev_get_drvdata(dev);
+
+	if (!cd->sysinfo.ready)
+		return sprintf(buf, "SysInfo not ready!\n");
+
+	return sprintf(buf, "%d\n",
+			GET_PANELID(cd->sysinfo.si_ptrs.pcfg->panel_info0));
+}
+
+/*
+ * Show Firmware version via sysfs
+ */
+static ssize_t cyttsp4_ic_ver_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct cyttsp4_core_data *cd = dev_get_drvdata(dev);
+	struct cyttsp4_cydata *cydata;
+
+	mutex_lock(&cd->system_lock);
+	if (!cd->sysinfo.ready) {
+		if (cd->invalid_touch_app) {
+			mutex_unlock(&cd->system_lock);
+			return snprintf(buf, CY_MAX_PRBUF_SIZE,
+					"Corrupted Touch application!\n");
+		} else {
+			mutex_unlock(&cd->system_lock);
+			return snprintf(buf, CY_MAX_PRBUF_SIZE,
+					"System Information not ready!\n");
+		}
+	}
+	mutex_unlock(&cd->system_lock);
+
+	cydata = cd->sysinfo.si_ptrs.cydata;
+
+	return snprintf(buf, CY_MAX_PRBUF_SIZE,
+		"%s: 0x%02X 0x%02X\n"
+		"%s: 0x%02X\n"
+		"%s: 0x%02X\n"
+		"%s: 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X\n"
+		"%s: 0x%04X\n"
+		"%s: 0x%02X\n"
+		"%s: 0x%02X\n",
+		"TrueTouch Product ID", cydata->ttpidh, cydata->ttpidl,
+		"Firmware Major Version", cydata->fw_ver_major,
+		"Firmware Minor Version", cydata->fw_ver_minor,
+		"Revision Control Number", cydata->revctrl[0],
+		cydata->revctrl[1], cydata->revctrl[2], cydata->revctrl[3],
+		cydata->revctrl[4], cydata->revctrl[5], cydata->revctrl[6],
+		cydata->revctrl[7],
+		"TrueTouch Config Version", cd->sysinfo.ttconfig.version,
+		"Bootloader Major Version", cydata->blver_major,
+		"Bootloader Minor Version", cydata->blver_minor);
+}
+
+/*
+ * Show TT Config version via sysfs
+ */
+static ssize_t cyttsp4_ttconfig_ver_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct cyttsp4_core_data *cd = dev_get_drvdata(dev);
+
+	return snprintf(buf, CY_MAX_PRBUF_SIZE, "0x%04X\n",
+			cd->sysinfo.ttconfig.version);
+}
+
+/*
+ * Show Driver version via sysfs
+ */
+static ssize_t cyttsp4_drv_ver_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	return snprintf(buf, CY_MAX_PRBUF_SIZE,
+		"Driver: %s\nVersion: %s\nDate: %s\n",
+		cy_driver_core_name, cy_driver_core_version,
+		cy_driver_core_date);
+}
+
+/*
+ * HW reset via sysfs
+ */
+static ssize_t cyttsp4_hw_reset_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	struct cyttsp4_core_data *cd = dev_get_drvdata(dev);
+	int rc = 0;
+
+	rc = cyttsp4_startup(cd);
+	if (rc < 0)
+		dev_err(dev, "%s: HW reset failed r=%d\n",
+			__func__, rc);
+
+	return size;
+}
+
+/*
+ * Show IRQ status via sysfs
+ */
+static ssize_t cyttsp4_hw_irq_stat_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct cyttsp4_core_data *cd = dev_get_drvdata(dev);
+	int retval;
+
+	if (cd->pdata->irq_stat) {
+		retval = cd->pdata->irq_stat(cd->pdata, dev);
+		switch (retval) {
+		case 0:
+			return snprintf(buf, CY_MAX_PRBUF_SIZE,
+				"Interrupt line is LOW.\n");
+		case 1:
+			return snprintf(buf, CY_MAX_PRBUF_SIZE,
+				"Interrupt line is HIGH.\n");
+		default:
+			return snprintf(buf, CY_MAX_PRBUF_SIZE,
+				"Function irq_stat() returned %d.\n", retval);
+		}
+	}
+
+	return snprintf(buf, CY_MAX_PRBUF_SIZE,
+		"Function irq_stat() undefined.\n");
+}
+
+/*
+ * Show IRQ enable/disable status via sysfs
+ */
+static ssize_t cyttsp4_drv_irq_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct cyttsp4_core_data *cd = dev_get_drvdata(dev);
+	ssize_t ret;
+
+	mutex_lock(&cd->system_lock);
+	if (cd->irq_enabled)
+		ret = snprintf(buf, CY_MAX_PRBUF_SIZE,
+			"Driver interrupt is ENABLED\n");
+	else
+		ret = snprintf(buf, CY_MAX_PRBUF_SIZE,
+			"Driver interrupt is DISABLED\n");
+	mutex_unlock(&cd->system_lock);
+
+	return ret;
+}
+
+/*
+ * Enable/disable IRQ via sysfs
+ */
+static ssize_t cyttsp4_drv_irq_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	struct cyttsp4_core_data *cd = dev_get_drvdata(dev);
+	unsigned long value;
+	int retval;
+
+	retval = kstrtoul(buf, 10, &value);
+	if (retval < 0) {
+		dev_err(dev, "%s: Invalid value\n", __func__);
+		goto cyttsp4_drv_irq_store_error_exit;
+	}
+
+	mutex_lock(&cd->system_lock);
+	switch (value) {
+	case 0:
+		if (cd->irq_enabled) {
+			cd->irq_enabled = false;
+			/* Disable IRQ */
+			disable_irq_nosync(cd->irq);
+			dev_info(dev, "%s: Driver IRQ now disabled\n",
+				__func__);
+		} else
+			dev_info(dev, "%s: Driver IRQ already disabled\n",
+				__func__);
+		break;
+
+	case 1:
+		if (cd->irq_enabled == false) {
+			cd->irq_enabled = true;
+			/* Enable IRQ */
+			enable_irq(cd->irq);
+			dev_info(dev, "%s: Driver IRQ now enabled\n",
+				__func__);
+		} else
+			dev_info(dev, "%s: Driver IRQ already enabled\n",
+				__func__);
+		break;
+
+	default:
+		dev_err(dev, "%s: Invalid value\n", __func__);
+	}
+	mutex_unlock(&(cd->system_lock));
+
+cyttsp4_drv_irq_store_error_exit:
+
+	return size;
+}
+
+/*
+ * Debugging options via sysfs
+ */
+static ssize_t cyttsp4_drv_debug_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	struct cyttsp4_core_data *cd = dev_get_drvdata(dev);
+	unsigned long value = 0;
+	int rc = 0;
+
+	rc = kstrtoul(buf, 10, &value);
+	if (rc < 0) {
+		dev_err(dev, "%s: Invalid value\n", __func__);
+		goto cyttsp4_drv_debug_store_exit;
+	}
+
+	switch (value) {
+	case CY_DBG_SUSPEND:
+		dev_info(dev, "%s: SUSPEND (cd=%p)\n", __func__, cd);
+		rc = cyttsp4_core_sleep(cd);
+		if (rc)
+			dev_err(dev, "%s: Suspend failed rc=%d\n",
+				__func__, rc);
+		else
+			dev_info(dev, "%s: Suspend succeeded\n", __func__);
+		break;
+
+	case CY_DBG_RESUME:
+		dev_info(dev, "%s: RESUME (cd=%p)\n", __func__, cd);
+		rc = cyttsp4_core_wake(cd);
+		if (rc)
+			dev_err(dev, "%s: Resume failed rc=%d\n",
+				__func__, rc);
+		else
+			dev_info(dev, "%s: Resume succeeded\n", __func__);
+		break;
+	case CY_DBG_SOFT_RESET:
+		dev_info(dev, "%s: SOFT RESET (cd=%p)\n", __func__, cd);
+		rc = cyttsp4_hw_soft_reset(cd);
+		break;
+	case CY_DBG_RESET:
+		dev_info(dev, "%s: HARD RESET (cd=%p)\n", __func__, cd);
+		rc = cyttsp4_hw_hard_reset(cd);
+		break;
+	default:
+		dev_err(dev, "%s: Invalid value\n", __func__);
+	}
+
+cyttsp4_drv_debug_store_exit:
+	return size;
+}
+
+/*
+ * Show system status on deep sleep status via sysfs
+ */
+static ssize_t cyttsp4_sleep_status_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct cyttsp4_core_data *cd = dev_get_drvdata(dev);
+	ssize_t ret;
+
+	mutex_lock(&cd->system_lock);
+	if (cd->sleep_state == SS_SLEEP_ON)
+		ret = snprintf(buf, CY_MAX_PRBUF_SIZE,
+				"Deep Sleep is ENABLED\n");
+	else
+		ret = snprintf(buf, CY_MAX_PRBUF_SIZE,
+				"Deep Sleep is DISABLED\n");
+	mutex_unlock(&cd->system_lock);
+
+	return ret;
+}
+
+static ssize_t cyttsp4_easy_wakeup_gesture_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct cyttsp4_core_data *cd = dev_get_drvdata(dev);
+	ssize_t ret;
+
+	mutex_lock(&cd->system_lock);
+	ret = snprintf(buf, CY_MAX_PRBUF_SIZE, "0x%02X\n",
+			cd->easy_wakeup_gesture);
+	mutex_unlock(&cd->system_lock);
+	return ret;
+}
+
+static ssize_t cyttsp4_easy_wakeup_gesture_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	struct cyttsp4_core_data *cd = dev_get_drvdata(dev);
+	unsigned long value;
+	int ret;
+
+	ret = kstrtoul(buf, 10, &value);
+	if (ret < 0)
+		return ret;
+
+	if (value > 0xFF && value < 0)
+		return -EINVAL;
+
+	pm_runtime_get_sync(dev);
+
+	mutex_lock(&cd->system_lock);
+	if (cd->sysinfo.ready && IS_TTSP_VER_GE(&cd->sysinfo, 2, 5))
+		cd->easy_wakeup_gesture = (u8)value;
+	else
+		ret = -ENODEV;
+	mutex_unlock(&cd->system_lock);
+
+	pm_runtime_put(dev);
+
+	if (ret)
+		return ret;
+
+	return size;
+}
+
+static struct device_attribute attributes[] = {
+	__ATTR(panel_id, S_IRUGO, cyttsp4_panel_id_show, NULL),
+	__ATTR(ic_ver, S_IRUGO, cyttsp4_ic_ver_show, NULL),
+	__ATTR(ttconfig_ver, S_IRUGO, cyttsp4_ttconfig_ver_show, NULL),
+	__ATTR(drv_ver, S_IRUGO, cyttsp4_drv_ver_show, NULL),
+	__ATTR(hw_reset, S_IWUSR, NULL, cyttsp4_hw_reset_store),
+	__ATTR(hw_irq_stat, S_IRUSR, cyttsp4_hw_irq_stat_show, NULL),
+	__ATTR(drv_irq, S_IRUSR | S_IWUSR, cyttsp4_drv_irq_show,
+		cyttsp4_drv_irq_store),
+	__ATTR(drv_debug, S_IWUSR, NULL, cyttsp4_drv_debug_store),
+	__ATTR(sleep_status, S_IRUSR, cyttsp4_sleep_status_show, NULL),
+	__ATTR(easy_wakeup_gesture, S_IRUSR | S_IWUSR,
+		cyttsp4_easy_wakeup_gesture_show,
+		cyttsp4_easy_wakeup_gesture_store),
+};
+
+static int add_sysfs_interfaces(struct cyttsp4_core_data *cd,
+		struct device *dev)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(attributes); i++)
+		if (device_create_file(dev, attributes + i))
+			goto undo;
+
+	return 0;
+undo:
+	for (i--; i >= 0 ; i--)
+		device_remove_file(dev, attributes + i);
+	dev_err(dev, "%s: failed to create sysfs interface\n", __func__);
+	return -ENODEV;
+}
+
+static void remove_sysfs_interfaces(struct cyttsp4_core_data *cd,
+		struct device *dev)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(attributes); i++)
+		device_remove_file(dev, attributes + i);
+}
+
+static int cyttsp4_core_probe(struct cyttsp4_core *core)
+{
+	struct cyttsp4_core_data *cd;
+	struct device *dev = &core->dev;
+	struct cyttsp4_core_platform_data *pdata = dev_get_platdata(dev);
+	enum cyttsp4_atten_type type;
+	unsigned long irq_flags;
+	int rc = 0;
+
+	dev_info(dev, "%s: startup\n", __func__);
+	dev_dbg(dev, "%s: debug on\n", __func__);
+	dev_vdbg(dev, "%s: verbose debug on\n", __func__);
+
+	if (pdata == NULL) {
+		dev_err(dev, "%s: Missing platform data\n", __func__);
+		rc = -ENODEV;
+		goto error_no_pdata;
+	}
+
+	/* get context and debug print buffers */
+	cd = kzalloc(sizeof(*cd), GFP_KERNEL);
+	if (cd == NULL) {
+		dev_err(dev, "%s: Error, kzalloc\n", __func__);
+		rc = -ENOMEM;
+		goto error_alloc_data;
+	}
+
+	/* Initialize device info */
+	cd->core = core;
+	cd->dev = dev;
+	cd->pdata = pdata;
+	cd->max_xfer = CY_DEFAULT_ADAP_MAX_XFER;
+	if (pdata->max_xfer_len) {
+		if (pdata->max_xfer_len < CY_ADAP_MIN_XFER) {
+			dev_err(dev, "%s: max_xfer_len invalid (min=%d)\n",
+				__func__, CY_ADAP_MIN_XFER);
+			rc = -EINVAL;
+			goto error_max_xfer;
+		}
+		cd->max_xfer = pdata->max_xfer_len;
+		dev_dbg(dev, "%s: max_xfer set to %d\n",
+			__func__, cd->max_xfer);
+	}
+
+	/* Initialize mutexes and spinlocks */
+	mutex_init(&cd->system_lock);
+	mutex_init(&cd->adap_lock);
+	spin_lock_init(&cd->spinlock);
+
+	/* Initialize attention lists */
+	for (type = 0; type < CY_ATTEN_NUM_ATTEN; type++)
+		INIT_LIST_HEAD(&cd->atten_list[type]);
+
+	/* Initialize wait queue */
+	init_waitqueue_head(&cd->wait_q);
+
+	/* Initialize works */
+	INIT_WORK(&cd->startup_work, cyttsp4_startup_work_function);
+	INIT_WORK(&cd->watchdog_work, cyttsp4_watchdog_work);
+
+	/* Initialize IRQ */
+	cd->irq = gpio_to_irq(pdata->irq_gpio);
+	if (cd->irq < 0) {
+		rc = -EINVAL;
+		goto error_gpio_irq;
+	}
+	cd->irq_enabled = true;
+
+	dev_set_drvdata(dev, cd);
+
+	/* Call platform init function */
+	if (cd->pdata->init) {
+		dev_info(cd->dev, "%s: Init HW\n", __func__);
+		rc = cd->pdata->init(cd->pdata, 1, cd->dev);
+	} else {
+		dev_info(cd->dev, "%s: No HW INIT function\n", __func__);
+		rc = 0;
+	}
+	if (rc < 0)
+		dev_err(cd->dev, "%s: HW Init fail r=%d\n", __func__, rc);
+
+	/* Call platform detect function */
+	if (cd->pdata->detect) {
+		dev_info(cd->dev, "%s: Detect HW\n", __func__);
+		rc = cd->pdata->detect(cd->pdata, cd->dev,
+				cyttsp4_platform_detect_read);
+		if (rc) {
+			dev_info(cd->dev, "%s: No HW detected\n", __func__);
+			rc = -ENODEV;
+			goto error_detect;
+		}
+	}
+
+	dev_dbg(dev, "%s: initialize threaded irq=%d\n", __func__, cd->irq);
+	if (cd->pdata->level_irq_udelay > 0)
+		/* use level triggered interrupts */
+		irq_flags = IRQF_TRIGGER_LOW | IRQF_ONESHOT;
+	else
+		/* use edge triggered interrupts */
+		irq_flags = IRQF_TRIGGER_FALLING | IRQF_ONESHOT;
+
+	rc = request_threaded_irq(cd->irq, cyttsp4_hard_irq, cyttsp4_irq,
+			irq_flags, dev_name(dev), cd);
+	if (rc < 0) {
+		dev_err(dev, "%s: Error, could not request irq\n", __func__);
+		goto error_request_irq;
+	}
+
+	/* Setup watchdog timer */
+	setup_timer(&cd->watchdog_timer, cyttsp4_watchdog_timer,
+		(unsigned long)cd);
+
+	pm_runtime_enable(dev);
+
+	/*
+	 * call startup directly to ensure that the device
+	 * is tested before leaving the probe
+	 */
+	dev_dbg(dev, "%s: call startup\n", __func__);
+
+	pm_runtime_get_sync(dev);
+	rc = cyttsp4_startup(cd);
+	pm_runtime_put(dev);
+
+	/* Do not fail probe if startup fails but the device is detected */
+	if (rc == -ENODEV) {
+		dev_err(cd->dev, "%s: Fail initial startup r=%d\n",
+			__func__, rc);
+		goto error_startup;
+	}
+
+	if (IS_TTSP_VER_GE(&cd->sysinfo, 2, 5))
+		cd->easy_wakeup_gesture = pdata->easy_wakeup_gesture;
+	else
+		cd->easy_wakeup_gesture = 0xFF;
+
+	dev_dbg(dev, "%s: add sysfs interfaces\n", __func__);
+	rc = add_sysfs_interfaces(cd, dev);
+	if (rc < 0) {
+		dev_err(dev, "%s: Error, fail sysfs init\n", __func__);
+		goto error_startup;
+	}
+
+	device_init_wakeup(dev, 1);
+
+	dev_dbg(dev, "%s: ok\n", __func__);
+	return 0;
+
+error_startup:
+	cancel_work_sync(&cd->startup_work);
+	cyttsp4_stop_wd_timer(cd);
+	pm_runtime_disable(dev);
+	cyttsp4_free_si_ptrs(cd);
+	free_irq(cd->irq, cd);
+error_request_irq:
+error_detect:
+	if (pdata->init)
+		pdata->init(pdata, 0, dev);
+	dev_set_drvdata(dev, NULL);
+error_gpio_irq:
+error_max_xfer:
+	kfree(cd);
+error_alloc_data:
+error_no_pdata:
+	dev_err(dev, "%s failed.\n", __func__);
+	return rc;
+}
+
+static int cyttsp4_core_release(struct cyttsp4_core *core)
+{
+	struct device *dev = &core->dev;
+	struct cyttsp4_core_data *cd = dev_get_drvdata(dev);
+
+	dev_dbg(dev, "%s\n", __func__);
+
+	/*
+	 * Suspend the device before freeing the startup_work and stopping
+	 * the watchdog since sleep function restarts watchdog on failure
+	 */
+	pm_runtime_suspend(dev);
+	pm_runtime_disable(dev);
+
+	cancel_work_sync(&cd->startup_work);
+
+	cyttsp4_stop_wd_timer(cd);
+
+	remove_sysfs_interfaces(cd, dev);
+	free_irq(cd->irq, cd);
+	if (cd->pdata->init)
+		cd->pdata->init(cd->pdata, 0, dev);
+	dev_set_drvdata(dev, NULL);
+	cyttsp4_free_si_ptrs(cd);
+	kfree(cd);
+	return 0;
+}
+
+static struct cyttsp4_core_driver cyttsp4_core_driver = {
+	.probe = cyttsp4_core_probe,
+	.remove = cyttsp4_core_release,
+	.subscribe_attention = cyttsp4_subscribe_attention_,
+	.unsubscribe_attention = cyttsp4_unsubscribe_attention_,
+	.request_exclusive = cyttsp4_request_exclusive_,
+	.release_exclusive = cyttsp4_release_exclusive_,
+	.request_reset = cyttsp4_request_reset_,
+	.request_restart = cyttsp4_request_restart_,
+	.request_set_mode = cyttsp4_request_set_mode_,
+	.request_sysinfo = cyttsp4_request_sysinfo_,
+	.request_loader_pdata = cyttsp4_request_loader_pdata_,
+	.request_handshake = cyttsp4_request_handshake_,
+	.request_exec_cmd = cyttsp4_request_exec_cmd_,
+	.request_stop_wd = cyttsp4_request_stop_wd_,
+	.request_toggle_lowpower = cyttsp4_request_toggle_lowpower_,
+	.request_config_row_size = cyttsp4_request_config_row_size_,
+	.request_write_config = cyttsp4_request_write_config_,
+	.request_enable_scan_type = cyttsp4_request_enable_scan_type_,
+	.request_disable_scan_type = cyttsp4_request_disable_scan_type_,
+	.get_security_key = cyttsp4_get_security_key_,
+	.get_touch_record = cyttsp4_get_touch_record_,
+	.write = cyttsp4_write_,
+	.read = cyttsp4_read_,
+	.driver = {
+		.name = CYTTSP4_CORE_NAME,
+		.bus = &cyttsp4_bus_type,
+		.owner = THIS_MODULE,
+		.pm = &cyttsp4_core_pm_ops,
+	},
+};
+
+static int __init cyttsp4_core_init(void)
+{
+	int rc = 0;
+
+	rc = cyttsp4_register_core_driver(&cyttsp4_core_driver);
+	pr_info("%s: Cypress TTSP v4 core driver (Built %s) rc=%d\n",
+		 __func__, CY_DRIVER_DATE, rc);
+	return rc;
+}
+module_init(cyttsp4_core_init);
+
+static void __exit cyttsp4_core_exit(void)
+{
+	cyttsp4_unregister_core_driver(&cyttsp4_core_driver);
+	pr_info("%s: module exit\n", __func__);
+}
+module_exit(cyttsp4_core_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Cypress TrueTouch(R) Standard touchscreen core driver");
+MODULE_AUTHOR("Aleksej Makarov <aleksej.makarov@sonyericsson.com>");
diff --git a/drivers/input/touchscreen/cypress/cyttsp4_debug.c b/drivers/input/touchscreen/cypress/cyttsp4_debug.c
new file mode 100644
index 0000000..18e56da
--- /dev/null
+++ b/drivers/input/touchscreen/cypress/cyttsp4_debug.c
@@ -0,0 +1,608 @@
+/*
+ * cyttsp4_debug.c
+ * Cypress TrueTouch(TM) Standard Product V4 Core driver module.
+ * For use with Cypress Txx4xx parts.
+ * Supported parts include:
+ * TMA4XX
+ * TMA1036
+ *
+ * Copyright (C) 2012 Cypress Semiconductor
+ * Copyright (C) 2011 Sony Ericsson Mobile Communications AB.
+ *
+ * Author: Aleksej Makarov <aleksej.makarov@sonyericsson.com>
+ * Modified by: Cypress Semiconductor to add device functions
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2, and only version 2, as published by the
+ * Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * Contact Cypress Semiconductor at www.cypress.com <ttdrivers@cypress.com>
+ *
+ */
+
+#include <linux/cyttsp4_bus.h>
+#include <linux/cyttsp4_core.h>
+
+#include <linux/delay.h>
+#include <linux/gpio.h>
+#include <linux/input.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/limits.h>
+#include <linux/module.h>
+#include <linux/pm_runtime.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/workqueue.h>
+
+#include "cyttsp4_regs.h"
+
+#define CYTTSP4_DEBUG_NAME "cyttsp4_debug"
+
+enum cyttsp4_monitor_status {
+	CY_MNTR_DISABLED,
+	CY_MNTR_ENABLED,
+};
+
+struct cyttsp4_sensor_monitor {
+	enum cyttsp4_monitor_status mntr_status;
+	u8 sensor_data[150];		/* operational sensor data */
+};
+
+struct cyttsp4_debug_data {
+	struct cyttsp4_device *ttsp;
+	struct cyttsp4_debug_platform_data *pdata;
+	struct cyttsp4_sysinfo *si;
+	uint32_t interrupt_count;
+	uint32_t formated_output;
+	struct mutex sysfs_lock;
+	struct cyttsp4_sensor_monitor monitor;
+	u8 pr_buf[CY_MAX_PRBUF_SIZE];
+};
+
+struct cyttsp4_debug_platform_data {
+	char const *debug_dev_name;
+};
+
+/*
+ * This function provide output of combined xy_mode and xy_data.
+ * Required by TTHE.
+ */
+static void cyttsp4_pr_buf_op_mode(struct device *dev, u8 *pr_buf,
+		struct cyttsp4_sysinfo *si, u8 cur_touch)
+{
+	int i, k;
+	const char fmt[] = "%02X ";
+	int max = (CY_MAX_PRBUF_SIZE - 1) - sizeof(CY_PR_TRUNCATED);
+	int total_size = si->si_ofs.mode_size
+			+ (cur_touch * si->si_ofs.tch_rec_size);
+	u8 num_btns = si->si_ofs.num_btns;
+
+	pr_buf[0] = 0;
+	for (i = k = 0; i < si->si_ofs.mode_size && i < max; i++, k += 3)
+		scnprintf(pr_buf + k, CY_MAX_PRBUF_SIZE, fmt, si->xy_mode[i]);
+
+	for (i = 0; i < (cur_touch * si->si_ofs.tch_rec_size) && i < max;
+			i++, k += 3)
+		scnprintf(pr_buf + k, CY_MAX_PRBUF_SIZE, fmt, si->xy_data[i]);
+
+	if (num_btns) {
+		/* print btn diff data for TTHE */
+		scnprintf(pr_buf + k, CY_MAX_PRBUF_SIZE, "%s", "=");
+		k++;
+		for (i = 0; i < (num_btns * si->si_ofs.btn_rec_size) && i < max;
+				i++, k += 3)
+			scnprintf(pr_buf + k, CY_MAX_PRBUF_SIZE, fmt,
+					si->btn_rec_data[i]);
+		total_size += num_btns * si->si_ofs.btn_rec_size + 1;
+	}
+	pr_info("%s=%s%s\n", "cyttsp4_OpModeData", pr_buf,
+			total_size <= max ? "" : CY_PR_TRUNCATED);
+}
+
+static void cyttsp4_debug_print(struct device *dev, u8 *pr_buf, u8 *sptr,
+		int size, const char *data_name)
+{
+	int i, j;
+	int elem_size = sizeof("XX ") - 1;
+	int max = (CY_MAX_PRBUF_SIZE - 1) / elem_size;
+	int limit = size < max ? size : max;
+
+	if (limit < 0)
+		limit = 0;
+
+	pr_buf[0] = 0;
+	for (i = j = 0; i < limit; i++, j += elem_size)
+		scnprintf(pr_buf + j, CY_MAX_PRBUF_SIZE - j, "%02X ", sptr[i]);
+
+	pr_info("%s[0..%d]=%s%s\n", data_name, size ? size - 1 : 0, pr_buf,
+			size <= max ? "" : CY_PR_TRUNCATED);
+}
+
+static void cyttsp4_debug_formated(struct device *dev, u8 *pr_buf,
+		struct cyttsp4_sysinfo *si, u8 num_cur_rec)
+{
+	u8 mode_size = si->si_ofs.mode_size;
+	u8 rep_len = si->xy_mode[si->si_ofs.rep_ofs];
+	u8 tch_rec_size = si->si_ofs.tch_rec_size;
+	u8 num_btns = si->si_ofs.num_btns;
+	u8 num_btn_regs = (num_btns + CY_NUM_BTN_PER_REG - 1)
+			/ CY_NUM_BTN_PER_REG;
+	u8 num_btn_tch;
+	u8 data_name[] = "touch[99]";
+	int max_print_length = 18;
+	int i;
+
+	/* xy_mode */
+	cyttsp4_debug_print(dev, pr_buf, si->xy_mode, mode_size, "xy_mode");
+
+	/* xy_data */
+	if (rep_len > max_print_length) {
+		pr_info("xy_data[0..%d]:\n", rep_len);
+		for (i = 0; i < rep_len - max_print_length;
+				i += max_print_length) {
+			cyttsp4_debug_print(dev, pr_buf, si->xy_data + i,
+					max_print_length, " ");
+		}
+		if (rep_len - i)
+			cyttsp4_debug_print(dev, pr_buf, si->xy_data + i,
+					rep_len - i, " ");
+	} else {
+		cyttsp4_debug_print(dev, pr_buf, si->xy_data,
+				rep_len - si->si_ofs.rep_hdr_size, "xy_data");
+	}
+
+	/* touches */
+	for (i = 0; i < num_cur_rec; i++) {
+		scnprintf(data_name, sizeof(data_name) - 1, "touch[%u]", i);
+		cyttsp4_debug_print(dev, pr_buf,
+				si->xy_data + (i * tch_rec_size),
+				tch_rec_size, data_name);
+	}
+
+	/* buttons */
+	if (num_btns) {
+		num_btn_tch = 0;
+		for (i = 0; i < num_btn_regs; i++) {
+			if (si->xy_mode[si->si_ofs.rep_ofs + 2 + i]) {
+				num_btn_tch++;
+				break;
+			}
+		}
+		if (num_btn_tch)
+			cyttsp4_debug_print(dev, pr_buf,
+					&si->xy_mode[si->si_ofs.rep_ofs + 2],
+					num_btn_regs, "button");
+	}
+}
+
+/* read xy_data for all touches for debug */
+static int cyttsp4_xy_worker(struct cyttsp4_debug_data *dd)
+{
+	struct device *dev = &dd->ttsp->dev;
+	struct cyttsp4_sysinfo *si = dd->si;
+	u8 tt_stat = si->xy_mode[si->si_ofs.tt_stat_ofs];
+	u8 num_cur_rec = GET_NUM_TOUCH_RECORDS(tt_stat);
+	uint32_t formated_output;
+	int rc;
+
+	mutex_lock(&dd->sysfs_lock);
+	dd->interrupt_count++;
+	formated_output = dd->formated_output;
+	mutex_unlock(&dd->sysfs_lock);
+
+	/* Read command parameters */
+	rc = cyttsp4_read(dd->ttsp, CY_MODE_OPERATIONAL,
+			si->si_ofs.cmd_ofs + 1,
+			&si->xy_mode[si->si_ofs.cmd_ofs + 1],
+			si->si_ofs.rep_ofs - si->si_ofs.cmd_ofs - 1);
+	if (rc < 0) {
+		dev_err(dev, "%s: read fail on command parameter regs r=%d\n",
+				__func__, rc);
+	}
+
+	if (si->si_ofs.num_btns > 0) {
+		/* read button diff data */
+		rc = cyttsp4_read(dd->ttsp, CY_MODE_OPERATIONAL,
+				/*  replace with btn_diff_ofs when that field
+				 *  becomes supported in the firmware */
+				si->si_ofs.tt_stat_ofs + 1 +
+				si->si_ofs.max_tchs * si->si_ofs.tch_rec_size,
+				si->btn_rec_data,
+				si->si_ofs.num_btns * si->si_ofs.btn_rec_size);
+		if (rc < 0) {
+			dev_err(dev, "%s: read fail on button regs r=%d\n",
+					__func__, rc);
+		}
+	}
+
+	/* Interrupt */
+	pr_info("Interrupt(%u)\n", dd->interrupt_count);
+
+	if (formated_output)
+		cyttsp4_debug_formated(dev, dd->pr_buf, si, num_cur_rec);
+	else
+		/* print data for TTHE */
+		cyttsp4_pr_buf_op_mode(dev, dd->pr_buf, si, num_cur_rec);
+
+	if (dd->monitor.mntr_status == CY_MNTR_ENABLED) {
+		int offset = (si->si_ofs.max_tchs * si->si_ofs.tch_rec_size)
+				+ (si->si_ofs.num_btns
+					* si->si_ofs.btn_rec_size)
+				+ (si->si_ofs.tt_stat_ofs + 1);
+		rc = cyttsp4_read(dd->ttsp, CY_MODE_OPERATIONAL,
+				offset, &(dd->monitor.sensor_data[0]), 150);
+		if (rc < 0)
+			dev_err(dev, "%s: read fail on sensor monitor regs r=%d\n",
+					__func__, rc);
+		/* print data for the sensor monitor */
+		cyttsp4_debug_print(dev, dd->pr_buf, dd->monitor.sensor_data,
+				150, "cyttsp4_sensor_monitor");
+	}
+
+	pr_info("\n");
+
+	dev_vdbg(dev, "%s: done\n", __func__);
+
+	return 0;
+}
+
+static int cyttsp4_debug_op_attention(struct cyttsp4_device *ttsp)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_debug_data *dd = dev_get_drvdata(dev);
+	int rc = 0;
+
+	dev_vdbg(dev, "%s\n", __func__);
+
+	/* core handles handshake */
+	rc = cyttsp4_xy_worker(dd);
+	if (rc < 0)
+		dev_err(dev, "%s: xy_worker error r=%d\n", __func__, rc);
+
+	return rc;
+}
+
+static int cyttsp4_debug_cat_attention(struct cyttsp4_device *ttsp)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_debug_data *dd = dev_get_drvdata(dev);
+	struct cyttsp4_sysinfo *si = dd->si;
+	u8 cat_masked_cmd;
+
+	dev_vdbg(dev, "%s\n", __func__);
+
+	/* Check for CaT command executed */
+	cat_masked_cmd = si->xy_mode[CY_REG_CAT_CMD] & CY_CMD_MASK;
+	if (cat_masked_cmd == CY_CMD_CAT_START_SENSOR_DATA_MODE) {
+		dev_vdbg(dev, "%s: Sensor data mode enabled\n", __func__);
+		dd->monitor.mntr_status = CY_MNTR_ENABLED;
+	} else if (cat_masked_cmd == CY_CMD_CAT_STOP_SENSOR_DATA_MODE) {
+		dev_vdbg(dev, "%s: Sensor data mode disabled\n", __func__);
+		dd->monitor.mntr_status = CY_MNTR_DISABLED;
+	}
+
+	return 0;
+}
+
+static int cyttsp4_debug_startup_attention(struct cyttsp4_device *ttsp)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_debug_data *dd = dev_get_drvdata(dev);
+
+	dev_vdbg(dev, "%s\n", __func__);
+
+	dd->monitor.mntr_status = CY_MNTR_DISABLED;
+
+	return 0;
+}
+
+static ssize_t cyttsp4_interrupt_count_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct cyttsp4_debug_data *dd = dev_get_drvdata(dev);
+	int val;
+
+	mutex_lock(&dd->sysfs_lock);
+	val = dd->interrupt_count;
+	mutex_unlock(&dd->sysfs_lock);
+
+	return scnprintf(buf, CY_MAX_PRBUF_SIZE, "Interrupt Count: %d\n", val);
+}
+
+static ssize_t cyttsp4_interrupt_count_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	struct cyttsp4_debug_data *dd = dev_get_drvdata(dev);
+	mutex_lock(&dd->sysfs_lock);
+	dd->interrupt_count = 0;
+	mutex_unlock(&dd->sysfs_lock);
+	return size;
+}
+
+static DEVICE_ATTR(int_count, S_IRUSR | S_IWUSR,
+	cyttsp4_interrupt_count_show, cyttsp4_interrupt_count_store);
+
+static ssize_t cyttsp4_formated_output_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct cyttsp4_debug_data *dd = dev_get_drvdata(dev);
+	int val;
+
+	mutex_lock(&dd->sysfs_lock);
+	val = dd->formated_output;
+	mutex_unlock(&dd->sysfs_lock);
+
+	return scnprintf(buf, CY_MAX_PRBUF_SIZE,
+			"Formated debug output: %x\n", val);
+}
+
+static ssize_t cyttsp4_formated_output_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	struct cyttsp4_debug_data *dd = dev_get_drvdata(dev);
+	unsigned long value;
+	int rc;
+
+	rc = kstrtoul(buf, 10, &value);
+	if (rc < 0) {
+		dev_err(dev, "%s: Invalid value\n", __func__);
+		return size;
+	}
+
+	/* Expecting only 0 or 1 */
+	if (value != 0 && value != 1) {
+		dev_err(dev, "%s: Invalid value %lu\n", __func__, value);
+		return size;
+	}
+
+	mutex_lock(&dd->sysfs_lock);
+	dd->formated_output = value;
+	mutex_unlock(&dd->sysfs_lock);
+	return size;
+}
+
+static DEVICE_ATTR(formated_output, S_IRUSR | S_IWUSR,
+	cyttsp4_formated_output_show, cyttsp4_formated_output_store);
+
+static int cyttsp4_debug_probe(struct cyttsp4_device *ttsp)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_debug_data *dd;
+	struct cyttsp4_debug_platform_data *pdata = dev_get_platdata(dev);
+	int rc;
+
+	dev_info(dev, "%s: startup\n", __func__);
+	dev_dbg(dev, "%s: debug on\n", __func__);
+	dev_vdbg(dev, "%s: verbose debug on\n", __func__);
+
+	/* get context and debug print buffers */
+	dd = kzalloc(sizeof(*dd), GFP_KERNEL);
+	if (dd == NULL) {
+		dev_err(dev, "%s: Error, kzalloc\n", __func__);
+		rc = -ENOMEM;
+		goto cyttsp4_debug_probe_alloc_failed;
+	}
+
+	rc = device_create_file(dev, &dev_attr_int_count);
+	if (rc) {
+		dev_err(dev, "%s: Error, could not create int_count\n",
+				__func__);
+		goto cyttsp4_debug_probe_create_int_count_failed;
+	}
+
+	rc = device_create_file(dev, &dev_attr_formated_output);
+	if (rc) {
+		dev_err(dev, "%s: Error, could not create formated_output\n",
+				__func__);
+		goto cyttsp4_debug_probe_create_formated_failed;
+	}
+
+	mutex_init(&dd->sysfs_lock);
+	dd->ttsp = ttsp;
+	dd->pdata = pdata;
+	dev_set_drvdata(dev, dd);
+
+	pm_runtime_enable(dev);
+
+	dd->si = cyttsp4_request_sysinfo(ttsp);
+	if (dd->si == NULL) {
+		dev_err(dev, "%s: Fail get sysinfo pointer from core\n",
+				__func__);
+		rc = -ENODEV;
+		goto cyttsp4_debug_probe_sysinfo_failed;
+	}
+
+	rc = cyttsp4_subscribe_attention(ttsp, CY_ATTEN_IRQ,
+		cyttsp4_debug_op_attention, CY_MODE_OPERATIONAL);
+	if (rc < 0) {
+		dev_err(dev, "%s: Error, could not subscribe Operating mode attention cb\n",
+				__func__);
+		goto cyttsp4_debug_probe_subscribe_op_failed;
+	}
+
+	rc = cyttsp4_subscribe_attention(ttsp, CY_ATTEN_IRQ,
+		cyttsp4_debug_cat_attention, CY_MODE_CAT);
+	if (rc < 0) {
+		dev_err(dev, "%s: Error, could not subscribe CaT mode attention cb\n",
+				__func__);
+		goto cyttsp4_debug_probe_subscribe_cat_failed;
+	}
+
+	rc = cyttsp4_subscribe_attention(ttsp, CY_ATTEN_STARTUP,
+		cyttsp4_debug_startup_attention, 0);
+	if (rc < 0) {
+		dev_err(dev, "%s: Error, could not subscribe startup attention cb\n",
+				__func__);
+		goto cyttsp4_debug_probe_subscribe_startup_failed;
+	}
+	return 0;
+
+cyttsp4_debug_probe_subscribe_startup_failed:
+	cyttsp4_unsubscribe_attention(ttsp, CY_ATTEN_IRQ,
+		cyttsp4_debug_cat_attention, CY_MODE_CAT);
+cyttsp4_debug_probe_subscribe_cat_failed:
+	cyttsp4_unsubscribe_attention(ttsp, CY_ATTEN_IRQ,
+		cyttsp4_debug_op_attention, CY_MODE_OPERATIONAL);
+cyttsp4_debug_probe_subscribe_op_failed:
+cyttsp4_debug_probe_sysinfo_failed:
+	pm_runtime_suspend(dev);
+	pm_runtime_disable(dev);
+	dev_set_drvdata(dev, NULL);
+	device_remove_file(dev, &dev_attr_formated_output);
+cyttsp4_debug_probe_create_formated_failed:
+	device_remove_file(dev, &dev_attr_int_count);
+cyttsp4_debug_probe_create_int_count_failed:
+	kfree(dd);
+cyttsp4_debug_probe_alloc_failed:
+	dev_err(dev, "%s failed.\n", __func__);
+	return rc;
+}
+
+static int cyttsp4_debug_release(struct cyttsp4_device *ttsp)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_debug_data *dd = dev_get_drvdata(dev);
+	int rc = 0;
+	dev_dbg(dev, "%s\n", __func__);
+
+	if (dev_get_drvdata(&ttsp->core->dev) == NULL) {
+		dev_err(dev, "%s: Unable to un-subscribe attention\n",
+				__func__);
+		goto cyttsp4_debug_release_exit;
+	}
+
+	/* Unsubscribe from attentions */
+	cyttsp4_unsubscribe_attention(ttsp, CY_ATTEN_IRQ,
+		cyttsp4_debug_op_attention, CY_MODE_OPERATIONAL);
+	cyttsp4_unsubscribe_attention(ttsp, CY_ATTEN_IRQ,
+		cyttsp4_debug_cat_attention, CY_MODE_CAT);
+	cyttsp4_unsubscribe_attention(ttsp, CY_ATTEN_STARTUP,
+		cyttsp4_debug_startup_attention, 0);
+
+cyttsp4_debug_release_exit:
+	pm_runtime_suspend(dev);
+	pm_runtime_disable(dev);
+	device_remove_file(dev, &dev_attr_int_count);
+	dev_set_drvdata(dev, NULL);
+	kfree(dd);
+
+	return rc;
+}
+
+static struct cyttsp4_driver cyttsp4_debug_driver = {
+	.probe = cyttsp4_debug_probe,
+	.remove = cyttsp4_debug_release,
+	.driver = {
+		.name = CYTTSP4_DEBUG_NAME,
+		.bus = &cyttsp4_bus_type,
+		.owner = THIS_MODULE,
+	},
+};
+
+static struct cyttsp4_debug_platform_data
+	_cyttsp4_debug_platform_data = {
+	.debug_dev_name = CYTTSP4_DEBUG_NAME,
+};
+
+static const char cyttsp4_debug_name[] = CYTTSP4_DEBUG_NAME;
+static struct cyttsp4_device_info
+	cyttsp4_debug_infos[CY_MAX_NUM_CORE_DEVS];
+
+static char *core_ids[CY_MAX_NUM_CORE_DEVS] = {
+	CY_DEFAULT_CORE_ID,
+	NULL,
+	NULL,
+	NULL,
+	NULL
+};
+
+static int num_core_ids = 1;
+
+module_param_array(core_ids, charp, &num_core_ids, 0);
+MODULE_PARM_DESC(core_ids,
+	"Core id list of cyttsp4 core devices for debug module");
+
+static int __init cyttsp4_debug_init(void)
+{
+	int rc = 0;
+	int i, j;
+
+	/* Check for invalid or duplicate core_ids */
+	for (i = 0; i < num_core_ids; i++) {
+		if (!strlen(core_ids[i])) {
+			pr_err("%s: core_id %d is empty\n",
+				__func__, i+1);
+			return -EINVAL;
+		}
+		for (j = i+1; j < num_core_ids; j++)
+			if (!strcmp(core_ids[i], core_ids[j])) {
+				pr_err("%s: core_ids %d and %d are same\n",
+					__func__, i+1, j+1);
+				return -EINVAL;
+			}
+	}
+
+	for (i = 0; i < num_core_ids; i++) {
+		cyttsp4_debug_infos[i].name = cyttsp4_debug_name;
+		cyttsp4_debug_infos[i].core_id = core_ids[i];
+		cyttsp4_debug_infos[i].platform_data =
+			&_cyttsp4_debug_platform_data;
+		pr_info("%s: Registering debug device for core_id: %s\n",
+			__func__, cyttsp4_debug_infos[i].core_id);
+		rc = cyttsp4_register_device(&cyttsp4_debug_infos[i]);
+		if (rc < 0) {
+			pr_err("%s: Error, failed registering device\n",
+				__func__);
+			goto fail_unregister_devices;
+		}
+	}
+	rc = cyttsp4_register_driver(&cyttsp4_debug_driver);
+	if (rc) {
+		pr_err("%s: Error, failed registering driver\n", __func__);
+		goto fail_unregister_devices;
+	}
+
+	pr_info("%s: Cypress TTSP Debug (Built %s) rc=%d\n",
+		 __func__, CY_DRIVER_DATE, rc);
+	return 0;
+
+fail_unregister_devices:
+	for (i--; i >= 0; i--) {
+		cyttsp4_unregister_device(cyttsp4_debug_infos[i].name,
+			cyttsp4_debug_infos[i].core_id);
+		pr_info("%s: Unregistering device access device for core_id: %s\n",
+			__func__, cyttsp4_debug_infos[i].core_id);
+	}
+	return rc;
+}
+module_init(cyttsp4_debug_init);
+
+static void __exit cyttsp4_debug_exit(void)
+{
+	int i;
+
+	cyttsp4_unregister_driver(&cyttsp4_debug_driver);
+	for (i = 0; i < num_core_ids; i++) {
+		cyttsp4_unregister_device(cyttsp4_debug_infos[i].name,
+			cyttsp4_debug_infos[i].core_id);
+		pr_info("%s: Unregistering debug device for core_id: %s\n",
+			__func__, cyttsp4_debug_infos[i].core_id);
+	}
+	pr_info("%s: module exit\n", __func__);
+}
+module_exit(cyttsp4_debug_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Cypress TrueTouch(R) Standard touchscreen debug driver");
+MODULE_AUTHOR("Cypress Semiconductor");
diff --git a/drivers/input/touchscreen/cypress/cyttsp4_device_access.c b/drivers/input/touchscreen/cypress/cyttsp4_device_access.c
new file mode 100644
index 0000000..3fd5389
--- /dev/null
+++ b/drivers/input/touchscreen/cypress/cyttsp4_device_access.c
@@ -0,0 +1,2738 @@
+/*
+ * cyttsp4_device_access.c
+ * Cypress TrueTouch(TM) Standard Product V4 Device Access module.
+ * Configuration and Test command/status user interface.
+ * For use with Cypress Txx4xx parts.
+ * Supported parts include:
+ * TMA4XX
+ * TMA1036
+ *
+ * Copyright (C) 2012 Cypress Semiconductor
+ * Copyright (C) 2011 Sony Ericsson Mobile Communications AB.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2, and only version 2, as published by the
+ * Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * Contact Cypress Semiconductor at www.cypress.com <ttdrivers@cypress.com>
+ *
+ */
+
+#include <linux/cyttsp4_bus.h>
+#include <linux/cyttsp4_core.h>
+#include <linux/cyttsp4_mt.h>
+
+#include <linux/delay.h>
+#include <linux/gpio.h>
+#include <linux/input.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/limits.h>
+#include <linux/module.h>
+#include <linux/pm_runtime.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/wait.h>
+#include <linux/workqueue.h>
+#include "cyttsp4_device_access.h"
+#include "cyttsp4_regs.h"
+
+#define CY_MAX_CONFIG_BYTES    256
+#define CY_CMD_INDEX             0
+#define CY_NULL_CMD_INDEX        1
+#define CY_NULL_CMD_MODE_INDEX   2
+#define CY_NULL_CMD_SIZE_INDEX   3
+#define CY_NULL_CMD_SIZEL_INDEX  2
+#define CY_NULL_CMD_SIZEH_INDEX  3
+
+struct heatmap_param {
+	bool scan_start;
+	enum cyttsp4_scan_data_type data_type; /* raw, base, diff */
+	int num_element;
+};
+
+struct cyttsp4_device_access_data {
+	struct cyttsp4_device *ttsp;
+	struct cyttsp4_device_access_platform_data *pdata;
+	struct cyttsp4_sysinfo *si;
+	struct cyttsp4_test_mode_params test;
+	struct mutex sysfs_lock;
+	uint32_t ic_grpnum;
+	uint32_t ic_grpoffset;
+	bool own_exclusive;
+	bool sysfs_nodes_created;
+#ifdef VERBOSE_DEBUG
+	u8 pr_buf[CY_MAX_PRBUF_SIZE];
+#endif
+	wait_queue_head_t wait_q;
+	u8 ic_buf[CY_MAX_PRBUF_SIZE];
+	u8 return_buf[CY_MAX_PRBUF_SIZE];
+	struct heatmap_param heatmap;
+};
+
+/*
+ * Show function prototype.
+ * Returns response length or Linux error code on error.
+ */
+typedef int (*cyttsp4_show_function) (struct device *dev, u8 *ic_buf,
+		size_t length);
+
+/*
+ * Store function prototype.
+ * Returns Linux error code on error.
+ */
+typedef int (*cyttsp4_store_function) (struct device *dev, u8 *ic_buf,
+		size_t length);
+
+/*
+ * grpdata show function to be used by
+ * reserved and not implemented ic group numbers.
+ */
+static int cyttsp4_grpdata_show_void (struct device *dev, u8 *ic_buf,
+		size_t length)
+{
+	return -ENOSYS;
+}
+
+/*
+ * grpdata store function to be used by
+ * reserved and not implemented ic group numbers.
+ */
+static int cyttsp4_grpdata_store_void (struct device *dev, u8 *ic_buf,
+		size_t length)
+{
+	return -ENOSYS;
+}
+
+/*
+ * SysFs group number entry show function.
+ */
+static ssize_t cyttsp4_ic_grpnum_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct cyttsp4_device_access_data *dad = dev_get_drvdata(dev);
+	int val = 0;
+
+	mutex_lock(&dad->sysfs_lock);
+	val = dad->ic_grpnum;
+	mutex_unlock(&dad->sysfs_lock);
+
+	return scnprintf(buf, CY_MAX_PRBUF_SIZE, "Current Group: %d\n", val);
+}
+
+/*
+ * SysFs group number entry store function.
+ */
+static ssize_t cyttsp4_ic_grpnum_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	struct cyttsp4_device_access_data *dad = dev_get_drvdata(dev);
+	unsigned long value;
+	int prev_grpnum;
+	int rc;
+
+	rc = kstrtoul(buf, 10, &value);
+	if (rc < 0) {
+		dev_err(dev, "%s: Invalid value\n", __func__);
+		return size;
+	}
+
+	if (value >= CY_IC_GRPNUM_NUM) {
+		dev_err(dev, "%s: Group %lu does not exist.\n",
+				__func__, value);
+		return size;
+	}
+
+	if (value > 0xFF)
+		value = 0xFF;
+
+	mutex_lock(&dad->sysfs_lock);
+	/*
+	 * Block grpnum change when own_exclusive flag is set
+	 * which means the current grpnum implementation requires
+	 * running exclusively on some consecutive grpdata operations
+	 */
+	if (dad->own_exclusive) {
+		mutex_unlock(&dad->sysfs_lock);
+		dev_err(dev, "%s: own_exclusive\n", __func__);
+		return -EBUSY;
+	}
+	prev_grpnum = dad->ic_grpnum;
+	dad->ic_grpnum = (int) value;
+	mutex_unlock(&dad->sysfs_lock);
+
+	dev_vdbg(dev, "%s: ic_grpnum=%d, return size=%d\n",
+			__func__, (int)value, (int)size);
+	return size;
+}
+
+static DEVICE_ATTR(ic_grpnum, S_IRUSR | S_IWUSR,
+		   cyttsp4_ic_grpnum_show, cyttsp4_ic_grpnum_store);
+
+/*
+ * SysFs group offset entry show function.
+ */
+static ssize_t cyttsp4_ic_grpoffset_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct cyttsp4_device_access_data *dad = dev_get_drvdata(dev);
+	int val = 0;
+
+	mutex_lock(&dad->sysfs_lock);
+	val = dad->ic_grpoffset;
+	mutex_unlock(&dad->sysfs_lock);
+
+	return scnprintf(buf, CY_MAX_PRBUF_SIZE, "Current Offset: %d\n", val);
+}
+
+/*
+ * SysFs group offset entry store function.
+ */
+static ssize_t cyttsp4_ic_grpoffset_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	struct cyttsp4_device_access_data *dad = dev_get_drvdata(dev);
+	unsigned long value;
+	int ret;
+
+	ret = kstrtoul(buf, 10, &value);
+	if (ret < 0) {
+		dev_err(dev, "%s: Invalid value\n", __func__);
+		return size;
+	}
+
+	if (value > 0xFFFF)
+		value = 0xFFFF;
+
+	mutex_lock(&dad->sysfs_lock);
+	dad->ic_grpoffset = (int)value;
+	mutex_unlock(&dad->sysfs_lock);
+
+	dev_vdbg(dev, "%s: ic_grpoffset=%d, return size=%d\n", __func__,
+			(int)value, (int)size);
+	return size;
+}
+
+static DEVICE_ATTR(ic_grpoffset, S_IRUSR | S_IWUSR,
+		   cyttsp4_ic_grpoffset_show, cyttsp4_ic_grpoffset_store);
+
+/*
+ * Prints part of communication registers.
+ */
+static int cyttsp4_grpdata_show_registers(struct device *dev, u8 *ic_buf,
+		size_t length, int num_read, int offset, int mode)
+{
+	struct cyttsp4_device_access_data *dad = dev_get_drvdata(dev);
+	int rc;
+
+	if (dad->ic_grpoffset >= num_read)
+		return -EINVAL;
+
+	num_read -= dad->ic_grpoffset;
+
+	if (length < num_read) {
+		dev_err(dev, "%s: not sufficient buffer req_bug_len=%d, length=%d\n",
+				__func__, num_read, length);
+		return -EINVAL;
+	}
+
+	pm_runtime_get_sync(dev);
+	rc = cyttsp4_read(dad->ttsp, mode, offset + dad->ic_grpoffset, ic_buf,
+			num_read);
+	pm_runtime_put(dev);
+	if (rc < 0)
+		return rc;
+
+	return num_read;
+}
+
+/*
+ * SysFs grpdata show function implementation of group 1.
+ * Prints status register contents of Operational mode registers.
+ */
+static int cyttsp4_grpdata_show_operational_regs(struct device *dev, u8 *ic_buf,
+		size_t length)
+{
+	struct cyttsp4_device_access_data *dad = dev_get_drvdata(dev);
+	int num_read = dad->si->si_ofs.rep_ofs - dad->si->si_ofs.cmd_ofs;
+	int i;
+
+	if (dad->ic_grpoffset >= num_read) {
+		dev_err(dev,
+			"%s: ic_grpoffset bigger than command registers, cmd_registers=%d\n",
+			__func__, num_read);
+		return -EINVAL;
+	}
+
+	num_read -= dad->ic_grpoffset;
+
+	if (length < num_read) {
+		dev_err(dev,
+			"%s: not sufficient buffer req_bug_len=%d, length=%d\n",
+			__func__, num_read, length);
+		return -EINVAL;
+	}
+
+	if (dad->ic_grpoffset + num_read > CY_MAX_PRBUF_SIZE) {
+		dev_err(dev,
+			"%s: not sufficient source buffer req_bug_len=%d, length=%d\n",
+			__func__, dad->ic_grpoffset + num_read,
+			CY_MAX_PRBUF_SIZE);
+		return -EINVAL;
+	}
+
+
+	/* cmd result already put into dad->return_buf */
+	for (i = 0; i < num_read; i++)
+		ic_buf[i] = dad->return_buf[dad->ic_grpoffset + i];
+
+	return num_read;
+}
+
+/*
+ * SysFs grpdata show function implementation of group 2.
+ * Prints current contents of the touch registers (full set).
+ */
+static int cyttsp4_grpdata_show_touch_regs(struct device *dev, u8 *ic_buf,
+		size_t length)
+{
+	struct cyttsp4_device_access_data *dad = dev_get_drvdata(dev);
+	int num_read = dad->si->si_ofs.rep_sz;
+	int offset = dad->si->si_ofs.rep_ofs;
+
+	return cyttsp4_grpdata_show_registers(dev, ic_buf, length, num_read,
+			offset, CY_MODE_OPERATIONAL);
+}
+
+/*
+ * Prints some content of the system information
+ */
+static int cyttsp4_grpdata_show_sysinfo(struct device *dev, u8 *ic_buf,
+		size_t length, int num_read, int offset)
+{
+	struct cyttsp4_device_access_data *dad = dev_get_drvdata(dev);
+	int rc = 0, rc2 = 0, rc3 = 0;
+
+	if (dad->ic_grpoffset >= num_read)
+		return -EINVAL;
+
+	num_read -= dad->ic_grpoffset;
+
+	if (length < num_read) {
+		dev_err(dev, "%s: not sufficient buffer req_bug_len=%d, length=%d\n",
+				__func__, num_read, length);
+		return -EINVAL;
+	}
+
+	pm_runtime_get_sync(dev);
+
+	rc = cyttsp4_request_exclusive(dad->ttsp,
+			CY_DA_REQUEST_EXCLUSIVE_TIMEOUT);
+	if (rc < 0) {
+		dev_err(dev, "%s: Error on request exclusive r=%d\n",
+				__func__, rc);
+		goto cyttsp4_grpdata_show_sysinfo_err_put;
+	}
+
+	rc = cyttsp4_request_set_mode(dad->ttsp, CY_MODE_SYSINFO);
+	if (rc < 0) {
+		dev_err(dev, "%s: Error on request set mode r=%d\n",
+				__func__, rc);
+		goto cyttsp4_grpdata_show_sysinfo_err_release;
+	}
+
+	rc = cyttsp4_read(dad->ttsp, CY_MODE_SYSINFO,
+			offset + dad->ic_grpoffset,
+			ic_buf, num_read);
+	if (rc < 0)
+		dev_err(dev, "%s: Fail read cmd regs r=%d\n",
+				__func__, rc);
+
+	rc2 = cyttsp4_request_set_mode(dad->ttsp, CY_MODE_OPERATIONAL);
+	if (rc2 < 0)
+		dev_err(dev, "%s: Error on request set mode 2 r=%d\n",
+				__func__, rc2);
+
+cyttsp4_grpdata_show_sysinfo_err_release:
+	rc3 = cyttsp4_release_exclusive(dad->ttsp);
+	if (rc3 < 0)
+		dev_err(dev, "%s: Error on release exclusive r=%d\n",
+				__func__, rc3);
+
+cyttsp4_grpdata_show_sysinfo_err_put:
+	pm_runtime_put(dev);
+
+	if (rc < 0)
+		return rc;
+	if (rc2 < 0)
+		return rc2;
+	if (rc3 < 0)
+		return rc3;
+
+	return num_read;
+}
+
+/*
+ * SysFs grpdata show function implementation of group 3.
+ * Prints content of the system information DATA record.
+ */
+static int cyttsp4_grpdata_show_sysinfo_data_rec(struct device *dev, u8 *ic_buf,
+		size_t length)
+{
+	struct cyttsp4_device_access_data *dad = dev_get_drvdata(dev);
+	int num_read = dad->si->si_ofs.cydata_size;
+	int offset = dad->si->si_ofs.cydata_ofs;
+
+	return cyttsp4_grpdata_show_sysinfo(dev, ic_buf, length, num_read,
+			offset);
+}
+
+/*
+ * SysFs grpdata show function implementation of group 4.
+ * Prints content of the system information TEST record.
+ */
+static int cyttsp4_grpdata_show_sysinfo_test_rec(struct device *dev, u8 *ic_buf,
+		size_t length)
+{
+	struct cyttsp4_device_access_data *dad = dev_get_drvdata(dev);
+	int num_read = dad->si->si_ofs.test_size;
+	int offset = dad->si->si_ofs.test_ofs;
+
+	return cyttsp4_grpdata_show_sysinfo(dev, ic_buf, length, num_read,
+			offset);
+}
+
+/*
+ * SysFs grpdata show function implementation of group 5.
+ * Prints content of the system information PANEL data.
+ */
+static int cyttsp4_grpdata_show_sysinfo_panel(struct device *dev, u8 *ic_buf,
+		size_t length)
+{
+	struct cyttsp4_device_access_data *dad = dev_get_drvdata(dev);
+	int num_read = dad->si->si_ofs.pcfg_size;
+	int offset = dad->si->si_ofs.pcfg_ofs;
+
+	return cyttsp4_grpdata_show_sysinfo(dev, ic_buf, length, num_read,
+			offset);
+}
+
+/*
+ * SysFs grpdata show function implementation of group 6.
+ * Prints contents of the touch parameters a row at a time.
+ */
+static int cyttsp4_grpdata_show_touch_params(struct device *dev, u8 *ic_buf,
+		size_t length)
+{
+	struct cyttsp4_device_access_data *dad = dev_get_drvdata(dev);
+	u8 cmd_buf[CY_CMD_CAT_READ_CFG_BLK_CMD_SZ];
+	int return_buf_size = CY_CMD_CAT_READ_CFG_BLK_RET_SZ;
+	u16 config_row_size;
+	int row_offset;
+	int offset_in_single_row = 0;
+	int rc;
+	int rc2 = 0;
+	int rc3;
+	int i, j;
+
+	pm_runtime_get_sync(dev);
+
+	rc = cyttsp4_request_exclusive(dad->ttsp,
+			CY_DA_REQUEST_EXCLUSIVE_TIMEOUT);
+	if (rc < 0) {
+		dev_err(dev, "%s: Error on request exclusive r=%d\n",
+				__func__, rc);
+		goto cyttsp4_grpdata_show_touch_params_err_put;
+	}
+
+	rc = cyttsp4_request_set_mode(dad->ttsp, CY_MODE_CAT);
+	if (rc < 0) {
+		dev_err(dev, "%s: Error on request set mode r=%d\n",
+				__func__, rc);
+		goto cyttsp4_grpdata_show_touch_params_err_release;
+	}
+
+	rc = cyttsp4_request_config_row_size(dad->ttsp, &config_row_size);
+	if (rc < 0) {
+		dev_err(dev, "%s: Error on request config row size r=%d\n",
+				__func__, rc);
+		goto cyttsp4_grpdata_show_touch_params_err_change_mode;
+	}
+
+	/* Perform buffer size check since we have just acquired row size */
+	return_buf_size += config_row_size;
+
+	if (length < return_buf_size) {
+		dev_err(dev, "%s: not sufficient buffer req_buf_len=%d, length=%d\n",
+				__func__, return_buf_size, length);
+		rc = -EINVAL;
+		goto cyttsp4_grpdata_show_touch_params_err_change_mode;
+	}
+
+	row_offset = dad->ic_grpoffset / config_row_size;
+
+	cmd_buf[0] = CY_CMD_CAT_READ_CFG_BLK;
+	cmd_buf[1] = HI_BYTE(row_offset);
+	cmd_buf[2] = LO_BYTE(row_offset);
+	cmd_buf[3] = HI_BYTE(config_row_size);
+	cmd_buf[4] = LO_BYTE(config_row_size);
+	cmd_buf[5] = CY_TCH_PARM_EBID;
+	rc = cyttsp4_request_exec_cmd(dad->ttsp, CY_MODE_CAT,
+			cmd_buf, CY_CMD_CAT_READ_CFG_BLK_CMD_SZ,
+			ic_buf, return_buf_size,
+			CY_COMMAND_COMPLETE_TIMEOUT);
+
+	offset_in_single_row = dad->ic_grpoffset % config_row_size;
+
+	/* Remove Header data from return buffer */
+	for (i = 0, j = CY_CMD_CAT_READ_CFG_BLK_RET_HDR_SZ
+				+ offset_in_single_row;
+			i < (config_row_size - offset_in_single_row);
+			i++, j++)
+		ic_buf[i] = ic_buf[j];
+
+cyttsp4_grpdata_show_touch_params_err_change_mode:
+	rc2 = cyttsp4_request_set_mode(dad->ttsp, CY_MODE_OPERATIONAL);
+	if (rc2 < 0)
+		dev_err(dev, "%s: Error on request set mode r=%d\n",
+				__func__, rc2);
+
+cyttsp4_grpdata_show_touch_params_err_release:
+	rc3 = cyttsp4_release_exclusive(dad->ttsp);
+	if (rc3 < 0)
+		dev_err(dev, "%s: Error on release exclusive r=%d\n",
+				__func__, rc3);
+
+cyttsp4_grpdata_show_touch_params_err_put:
+	pm_runtime_put(dev);
+
+	if (rc < 0)
+		return rc;
+	if (rc2 < 0)
+		return rc2;
+	if (rc3 < 0)
+		return rc3;
+
+	return config_row_size - offset_in_single_row;
+}
+
+/*
+ * SysFs grpdata show function implementation of group 7.
+ * Prints contents of the touch parameters sizes.
+ */
+static int cyttsp4_grpdata_show_touch_params_sizes(struct device *dev,
+		u8 *ic_buf, size_t length)
+{
+	struct cyttsp4_device_access_data *dad = dev_get_drvdata(dev);
+	struct cyttsp4_core_platform_data *pdata =
+			dev_get_platdata(&dad->ttsp->core->dev);
+	int max_size;
+	int block_start;
+	int block_end;
+	int num_read;
+
+	if (pdata->sett[CY_IC_GRPNUM_TCH_PARM_SIZE] == NULL) {
+		dev_err(dev, "%s: Missing platform data Touch Parameters Sizes table\n",
+				__func__);
+		return -EINVAL;
+	}
+
+	if (pdata->sett[CY_IC_GRPNUM_TCH_PARM_SIZE]->data == NULL) {
+		dev_err(dev, "%s: Missing platform data Touch Parameters Sizes table data\n",
+				__func__);
+		return -EINVAL;
+	}
+
+	max_size = pdata->sett[CY_IC_GRPNUM_TCH_PARM_SIZE]->size;
+	max_size *= sizeof(uint16_t);
+	if (dad->ic_grpoffset >= max_size)
+		return -EINVAL;
+
+	block_start = (dad->ic_grpoffset / CYTTSP4_TCH_PARAM_SIZE_BLK_SZ)
+			* CYTTSP4_TCH_PARAM_SIZE_BLK_SZ;
+	block_end = CYTTSP4_TCH_PARAM_SIZE_BLK_SZ + block_start;
+	if (block_end > max_size)
+		block_end = max_size;
+	num_read = block_end - dad->ic_grpoffset;
+	if (length < num_read) {
+		dev_err(dev, "%s: not sufficient buffer %s=%d, %s=%d\n",
+				__func__, "req_buf_len", num_read, "length",
+				length);
+		return -EINVAL;
+	}
+
+	memcpy(ic_buf, (u8 *)pdata->sett[CY_IC_GRPNUM_TCH_PARM_SIZE]->data
+			+ dad->ic_grpoffset, num_read);
+
+	return num_read;
+}
+
+/*
+ * SysFs grpdata show function implementation of group 10.
+ * Prints content of the system information Operational Configuration data.
+ */
+static int cyttsp4_grpdata_show_sysinfo_opcfg(struct device *dev, u8 *ic_buf,
+		size_t length)
+{
+	struct cyttsp4_device_access_data *dad = dev_get_drvdata(dev);
+	int num_read = dad->si->si_ofs.opcfg_size;
+	int offset = dad->si->si_ofs.opcfg_ofs;
+
+	return cyttsp4_grpdata_show_sysinfo(dev, ic_buf, length, num_read,
+			offset);
+}
+
+/*
+ * SysFs grpdata show function implementation of group 11.
+ * Prints content of the system information Design data.
+ */
+static int cyttsp4_grpdata_show_sysinfo_design(struct device *dev, u8 *ic_buf,
+		size_t length)
+{
+	struct cyttsp4_device_access_data *dad = dev_get_drvdata(dev);
+	int num_read = dad->si->si_ofs.ddata_size;
+	int offset = dad->si->si_ofs.ddata_ofs;
+
+	return cyttsp4_grpdata_show_sysinfo(dev, ic_buf, length, num_read,
+			offset);
+}
+
+/*
+ * SysFs grpdata show function implementation of group 12.
+ * Prints content of the system information Manufacturing data.
+ */
+static int cyttsp4_grpdata_show_sysinfo_manufacturing(struct device *dev,
+		u8 *ic_buf, size_t length)
+{
+	struct cyttsp4_device_access_data *dad = dev_get_drvdata(dev);
+	int num_read = dad->si->si_ofs.mdata_size;
+	int offset = dad->si->si_ofs.mdata_ofs;
+
+	return cyttsp4_grpdata_show_sysinfo(dev, ic_buf, length, num_read,
+			offset);
+}
+
+/*
+ * SysFs grpdata show function implementation of group 13.
+ * Prints status register contents of Configuration and
+ * Test registers.
+ */
+static int cyttsp4_grpdata_show_test_regs(struct device *dev, u8 *ic_buf,
+		size_t length)
+{
+	struct cyttsp4_device_access_data *dad = dev_get_drvdata(dev);
+	u8 mode;
+	int rc = 0;
+	int num_read = 0;
+	int i;
+
+	dev_vdbg(dev, "%s: test.cur_cmd=%d test.cur_mode=%d\n",
+			__func__, dad->test.cur_cmd, dad->test.cur_mode);
+
+	if (dad->test.cur_cmd == CY_CMD_CAT_NULL) {
+		num_read = 1;
+		if (length < num_read) {
+			dev_err(dev, "%s: not sufficient buffer %s=%d, %s=%d\n",
+					__func__, "req_buf_len", num_read,
+					"length", length);
+			return -EINVAL;
+		}
+
+		dev_vdbg(dev, "%s: GRP=TEST_REGS: NULL CMD: host_mode=%02X\n",
+				__func__, ic_buf[0]);
+		pm_runtime_get_sync(dev);
+		rc = cyttsp4_read(dad->ttsp,
+				dad->test.cur_mode == CY_TEST_MODE_CAT ?
+					CY_MODE_CAT : CY_MODE_OPERATIONAL,
+				CY_REG_BASE, &mode, sizeof(mode));
+		pm_runtime_put(dev);
+		if (rc < 0) {
+			ic_buf[0] = 0xFF;
+			dev_err(dev, "%s: failed to read host mode r=%d\n",
+					__func__, rc);
+		} else {
+			ic_buf[0] = mode;
+		}
+	} else if (dad->test.cur_mode == CY_TEST_MODE_CAT) {
+		num_read = dad->test.cur_status_size;
+		if (length < num_read) {
+			dev_err(dev, "%s: not sufficient buffer %s=%d, %s=%d\n",
+					__func__, "req_buf_len", num_read,
+					"length", length);
+			return -EINVAL;
+		}
+		if (dad->ic_grpoffset + num_read > CY_MAX_PRBUF_SIZE) {
+			dev_err(dev,
+				"%s: not sufficient source buffer req_bug_len=%d, length=%d\n",
+				__func__, dad->ic_grpoffset + num_read,
+				CY_MAX_PRBUF_SIZE);
+			return -EINVAL;
+		}
+
+		dev_vdbg(dev, "%s: GRP=TEST_REGS: num_rd=%d at ofs=%d + grpofs=%d\n",
+				__func__, num_read, dad->si->si_ofs.cmd_ofs,
+				dad->ic_grpoffset);
+
+		/* cmd result already put into dad->return_buf */
+		for (i = 0; i < num_read; i++)
+			ic_buf[i] = dad->return_buf[dad->ic_grpoffset + i];
+	} else {
+		dev_err(dev, "%s: Not in Config/Test mode\n", __func__);
+	}
+
+	return num_read;
+}
+
+/*
+ * SysFs grpdata show function implementation of group 14.
+ * Prints CapSense button keycodes.
+ */
+static int cyttsp4_grpdata_show_btn_keycodes(struct device *dev, u8 *ic_buf,
+		size_t length)
+{
+	struct cyttsp4_device_access_data *dad = dev_get_drvdata(dev);
+	struct cyttsp4_btn *btn = dad->si->btn;
+	int num_btns = dad->si->si_ofs.num_btns - dad->ic_grpoffset;
+	int n;
+
+	if (num_btns <= 0 || btn == NULL || length < num_btns)
+		return -EINVAL;
+
+	for (n = 0; n < num_btns; n++)
+		ic_buf[n] = (u8) btn[dad->ic_grpoffset + n].key_code;
+
+	return n;
+}
+
+/*
+ * SysFs grpdata show function implementation of group 15.
+ * Prints status register contents of Configuration and
+ * Test registers.
+ */
+static int cyttsp4_grpdata_show_tthe_test_regs(struct device *dev, u8 *ic_buf,
+		size_t length)
+{
+	struct cyttsp4_device_access_data *dad = dev_get_drvdata(dev);
+	int rc = 0;
+	int num_read = 0;
+
+	dev_vdbg(dev, "%s: test.cur_cmd=%d test.cur_mode=%d\n",
+			__func__, dad->test.cur_cmd, dad->test.cur_mode);
+
+	if (dad->test.cur_cmd == CY_CMD_CAT_NULL) {
+		num_read = dad->test.cur_status_size;
+		if (length < num_read) {
+			dev_err(dev, "%s: not sufficient buffer %s=%d, %s=%d\n",
+					__func__, "req_buf_len", num_read,
+					"length", length);
+			return -EINVAL;
+		}
+
+		dev_vdbg(dev, "%s: GRP=TEST_REGS: NULL CMD: host_mode=%02X\n",
+				__func__, ic_buf[0]);
+		rc = cyttsp4_read(dad->ttsp,
+				(dad->test.cur_mode == CY_TEST_MODE_CAT)
+					? CY_MODE_CAT :
+				(dad->test.cur_mode == CY_TEST_MODE_SYSINFO)
+					? CY_MODE_SYSINFO : CY_MODE_OPERATIONAL,
+				CY_REG_BASE, ic_buf, num_read);
+		if (rc < 0) {
+			ic_buf[0] = 0xFF;
+			dev_err(dev, "%s: failed to read host mode r=%d\n",
+					__func__, rc);
+		}
+	} else if (dad->test.cur_mode == CY_TEST_MODE_CAT
+			|| dad->test.cur_mode == CY_TEST_MODE_SYSINFO) {
+		num_read = dad->test.cur_status_size;
+		if (length < num_read) {
+			dev_err(dev, "%s: not sufficient buffer %s=%d, %s=%d\n",
+					__func__, "req_buf_len", num_read,
+					"length", length);
+			return -EINVAL;
+		}
+		dev_vdbg(dev, "%s: GRP=TEST_REGS: num_rd=%d at ofs=%d + grpofs=%d\n",
+				__func__, num_read, dad->si->si_ofs.cmd_ofs,
+				dad->ic_grpoffset);
+		rc = cyttsp4_read(dad->ttsp,
+				(dad->test.cur_mode == CY_TEST_MODE_CAT)
+					? CY_MODE_CAT : CY_MODE_SYSINFO,
+				CY_REG_BASE, ic_buf, num_read);
+		if (rc < 0)
+			return rc;
+	} else {
+		dev_err(dev, "%s: In unsupported mode\n", __func__);
+	}
+
+	return num_read;
+}
+
+static cyttsp4_show_function
+		cyttsp4_grpdata_show_functions[CY_IC_GRPNUM_NUM] = {
+	[CY_IC_GRPNUM_RESERVED] = cyttsp4_grpdata_show_void,
+	[CY_IC_GRPNUM_CMD_REGS] = cyttsp4_grpdata_show_operational_regs,
+	[CY_IC_GRPNUM_TCH_REP] = cyttsp4_grpdata_show_touch_regs,
+	[CY_IC_GRPNUM_DATA_REC] = cyttsp4_grpdata_show_sysinfo_data_rec,
+	[CY_IC_GRPNUM_TEST_REC] = cyttsp4_grpdata_show_sysinfo_test_rec,
+	[CY_IC_GRPNUM_PCFG_REC] = cyttsp4_grpdata_show_sysinfo_panel,
+	[CY_IC_GRPNUM_TCH_PARM_VAL] = cyttsp4_grpdata_show_touch_params,
+	[CY_IC_GRPNUM_TCH_PARM_SIZE] = cyttsp4_grpdata_show_touch_params_sizes,
+	[CY_IC_GRPNUM_RESERVED1] = cyttsp4_grpdata_show_void,
+	[CY_IC_GRPNUM_RESERVED2] = cyttsp4_grpdata_show_void,
+	[CY_IC_GRPNUM_OPCFG_REC] = cyttsp4_grpdata_show_sysinfo_opcfg,
+	[CY_IC_GRPNUM_DDATA_REC] = cyttsp4_grpdata_show_sysinfo_design,
+	[CY_IC_GRPNUM_MDATA_REC] = cyttsp4_grpdata_show_sysinfo_manufacturing,
+	[CY_IC_GRPNUM_TEST_REGS] = cyttsp4_grpdata_show_test_regs,
+	[CY_IC_GRPNUM_BTN_KEYS] = cyttsp4_grpdata_show_btn_keycodes,
+	[CY_IC_GRPNUM_TTHE_REGS] = cyttsp4_grpdata_show_tthe_test_regs,
+};
+
+static ssize_t cyttsp4_ic_grpdata_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct cyttsp4_device_access_data *dad = dev_get_drvdata(dev);
+	int i;
+	ssize_t num_read;
+	int index;
+
+	mutex_lock(&dad->sysfs_lock);
+	dev_vdbg(dev, "%s: grpnum=%d grpoffset=%u\n",
+			__func__, dad->ic_grpnum, dad->ic_grpoffset);
+
+	index = scnprintf(buf, CY_MAX_PRBUF_SIZE,
+			"Group %d, Offset %u:\n", dad->ic_grpnum,
+			dad->ic_grpoffset);
+
+	num_read = cyttsp4_grpdata_show_functions[dad->ic_grpnum] (dev,
+			dad->ic_buf, CY_MAX_PRBUF_SIZE);
+	if (num_read < 0) {
+		index = num_read;
+		if (num_read == -ENOSYS) {
+			dev_err(dev, "%s: Group %d is not implemented.\n",
+				__func__, dad->ic_grpnum);
+			goto cyttsp4_ic_grpdata_show_error;
+		}
+		dev_err(dev, "%s: Cannot read Group %d Data.\n",
+				__func__, dad->ic_grpnum);
+		goto cyttsp4_ic_grpdata_show_error;
+	}
+
+	for (i = 0; i < num_read; i++) {
+		index += scnprintf(buf + index, CY_MAX_PRBUF_SIZE - index,
+				"0x%02X\n", dad->ic_buf[i]);
+	}
+
+	index += scnprintf(buf + index, CY_MAX_PRBUF_SIZE - index,
+			"(%d bytes)\n", num_read);
+
+cyttsp4_ic_grpdata_show_error:
+	mutex_unlock(&dad->sysfs_lock);
+	return index;
+}
+
+static int _cyttsp4_cmd_handshake(struct cyttsp4_device_access_data *dad)
+{
+	struct device *dev = &dad->ttsp->dev;
+	u8 mode;
+	int rc;
+
+	rc = cyttsp4_read(dad->ttsp, CY_MODE_CAT,
+			CY_REG_BASE, &mode, sizeof(mode));
+	if (rc < 0) {
+		dev_err(dev, "%s: Fail read host mode r=%d\n", __func__, rc);
+		return rc;
+	}
+
+	rc = cyttsp4_request_handshake(dad->ttsp, mode);
+	if (rc < 0)
+		dev_err(dev, "%s: Fail cmd handshake r=%d\n", __func__, rc);
+
+	return rc;
+}
+
+static int _cyttsp4_cmd_toggle_lowpower(struct cyttsp4_device_access_data *dad)
+{
+	struct device *dev = &dad->ttsp->dev;
+	u8 mode;
+	int rc = cyttsp4_read(dad->ttsp,
+			(dad->test.cur_mode == CY_TEST_MODE_CAT)
+				? CY_MODE_CAT : CY_MODE_OPERATIONAL,
+			CY_REG_BASE, &mode, sizeof(mode));
+	if (rc < 0) {
+		dev_err(dev, "%s: Fail read host mode r=%d\n",
+				__func__, rc);
+		return rc;
+	}
+
+	rc = cyttsp4_request_toggle_lowpower(dad->ttsp, mode);
+	if (rc < 0)
+		dev_err(dev, "%s: Fail cmd handshake r=%d\n",
+				__func__, rc);
+	return rc;
+}
+
+static int cyttsp4_test_cmd_mode(struct cyttsp4_device_access_data *dad,
+		u8 *ic_buf, size_t length)
+{
+	struct device *dev = &dad->ttsp->dev;
+	int rc = -ENOSYS;
+	u8 mode;
+
+	if (length < CY_NULL_CMD_MODE_INDEX + 1)  {
+		dev_err(dev, "%s: %s length=%d\n", __func__,
+				"Buffer length is not valid", length);
+		return -EINVAL;
+	}
+	mode = ic_buf[CY_NULL_CMD_MODE_INDEX];
+
+	if (mode == CY_HST_CAT) {
+		pm_runtime_get_sync(dev);
+		rc = cyttsp4_request_exclusive(dad->ttsp,
+				CY_DA_REQUEST_EXCLUSIVE_TIMEOUT);
+		if (rc < 0) {
+			dev_err(dev, "%s: Fail rqst exclusive r=%d\n",
+					__func__, rc);
+			pm_runtime_put(dev);
+			goto cyttsp4_test_cmd_mode_exit;
+		}
+		rc = cyttsp4_request_set_mode(dad->ttsp, CY_MODE_CAT);
+		if (rc < 0) {
+			dev_err(dev, "%s: Fail rqst set mode=%02X r=%d\n",
+					__func__, mode, rc);
+			rc = cyttsp4_release_exclusive(dad->ttsp);
+			if (rc < 0)
+				dev_err(dev, "%s: %s r=%d\n", __func__,
+						"Fail release exclusive", rc);
+			pm_runtime_put(dev);
+			goto cyttsp4_test_cmd_mode_exit;
+		}
+		dad->test.cur_mode = CY_TEST_MODE_CAT;
+		dad->own_exclusive = true;
+		dev_vdbg(dev, "%s: %s=%d %s=%02X %s=%d(CaT)\n", __func__,
+				"own_exclusive", dad->own_exclusive == true,
+				"mode", mode, "test.cur_mode",
+				dad->test.cur_mode);
+	} else if (mode == CY_HST_OPERATE) {
+		if (dad->own_exclusive) {
+			rc = cyttsp4_request_set_mode(dad->ttsp,
+					CY_MODE_OPERATIONAL);
+			if (rc < 0)
+				dev_err(dev, "%s: %s=%02X r=%d\n", __func__,
+						"Fail rqst set mode", mode, rc);
+				/* continue anyway */
+
+			rc = cyttsp4_release_exclusive(dad->ttsp);
+			if (rc < 0) {
+				dev_err(dev, "%s: %s r=%d\n", __func__,
+						"Fail release exclusive", rc);
+				/* continue anyway */
+				rc = 0;
+			}
+			dad->test.cur_mode = CY_TEST_MODE_NORMAL_OP;
+			dad->own_exclusive = false;
+			pm_runtime_put(dev);
+			dev_vdbg(dev, "%s: %s=%d %s=%02X %s=%d(Operate)\n",
+					__func__, "own_exclusive",
+					dad->own_exclusive == true,
+					"mode", mode,
+					"test.cur_mode", dad->test.cur_mode);
+		} else
+			dev_vdbg(dev, "%s: %s mode=%02X(Operate)\n", __func__,
+					"do not own exclusive; cannot switch",
+					mode);
+	} else
+		dev_vdbg(dev, "%s: unsupported mode switch=%02X\n",
+				__func__, mode);
+
+cyttsp4_test_cmd_mode_exit:
+	return rc;
+}
+
+static int cyttsp4_test_tthe_cmd_mode(struct cyttsp4_device_access_data *dad,
+		u8 *ic_buf, size_t length)
+{
+	struct device *dev = &dad->ttsp->dev;
+	int rc = -ENOSYS;
+	u8 mode;
+	enum cyttsp4_test_mode test_mode;
+	int new_mode;
+
+	if (length < CY_NULL_CMD_MODE_INDEX + 1)  {
+		dev_err(dev, "%s: %s length=%d\n", __func__,
+				"Buffer length is not valid", length);
+		return -EINVAL;
+	}
+	mode = ic_buf[CY_NULL_CMD_MODE_INDEX];
+
+	switch (mode) {
+	case CY_HST_CAT:
+		new_mode = CY_MODE_CAT;
+		test_mode = CY_TEST_MODE_CAT;
+		break;
+	case CY_HST_OPERATE:
+		new_mode = CY_MODE_OPERATIONAL;
+		test_mode = CY_TEST_MODE_NORMAL_OP;
+		break;
+	case CY_HST_SYSINFO:
+		new_mode = CY_MODE_SYSINFO;
+		test_mode = CY_TEST_MODE_SYSINFO;
+		break;
+	default:
+		dev_vdbg(dev, "%s: unsupported mode switch=%02X\n",
+				__func__, mode);
+		goto cyttsp4_test_tthe_cmd_mode_exit;
+	}
+
+	rc = cyttsp4_request_exclusive(dad->ttsp,
+			CY_DA_REQUEST_EXCLUSIVE_TIMEOUT);
+	if (rc < 0) {
+		dev_err(dev, "%s: Fail rqst exclusive r=%d\n", __func__, rc);
+		goto cyttsp4_test_tthe_cmd_mode_exit;
+	}
+	rc = cyttsp4_request_set_mode(dad->ttsp, new_mode);
+	if (rc < 0)
+		dev_err(dev, "%s: Fail rqst set mode=%02X r=%d\n",
+				__func__, mode, rc);
+	rc = cyttsp4_release_exclusive(dad->ttsp);
+	if (rc < 0) {
+		dev_err(dev, "%s: %s r=%d\n", __func__,
+				"Fail release exclusive", rc);
+		if (mode == CY_HST_OPERATE)
+			rc = 0;
+		else
+			goto cyttsp4_test_tthe_cmd_mode_exit;
+	}
+	dad->test.cur_mode = test_mode;
+	dev_vdbg(dev, "%s: %s=%d %s=%02X %s=%d\n", __func__,
+			"own_exclusive", dad->own_exclusive == true,
+			"mode", mode,
+			"test.cur_mode", dad->test.cur_mode);
+
+cyttsp4_test_tthe_cmd_mode_exit:
+	return rc;
+}
+
+/*
+ * SysFs grpdata store function implementation of group 1.
+ * Stores to command and parameter registers of Operational mode.
+ */
+static int cyttsp4_grpdata_store_operational_regs(struct device *dev,
+		u8 *ic_buf, size_t length)
+{
+	struct cyttsp4_device_access_data *dad = dev_get_drvdata(dev);
+	size_t cmd_ofs = dad->si->si_ofs.cmd_ofs;
+	int num_read = dad->si->si_ofs.rep_ofs - dad->si->si_ofs.cmd_ofs;
+	u8 *return_buf = dad->return_buf;
+	int rc, rc2 = 0;
+
+	if ((cmd_ofs + length) > dad->si->si_ofs.rep_ofs) {
+		dev_err(dev, "%s: %s length=%d\n", __func__,
+				"Buffer length is not valid", length);
+		return -EINVAL;
+	}
+
+	pm_runtime_get_sync(dev);
+
+	rc = cyttsp4_request_exclusive(dad->ttsp,
+			CY_DA_REQUEST_EXCLUSIVE_TIMEOUT);
+	if (rc < 0) {
+		dev_err(dev, "%s: Error on request exclusive r=%d\n",
+				__func__, rc);
+		goto cyttsp4_grpdata_store_operational_regs_err_put;
+	}
+
+	return_buf[0] = ic_buf[0];
+	rc = cyttsp4_request_exec_cmd(dad->ttsp, CY_MODE_OPERATIONAL,
+			ic_buf, length,
+			return_buf + 1, num_read,
+			CY_COMMAND_COMPLETE_TIMEOUT);
+	if (rc < 0)
+		dev_err(dev, "%s: Fail to execute cmd r=%d\n", __func__, rc);
+
+	rc2 = cyttsp4_release_exclusive(dad->ttsp);
+	if (rc2 < 0)
+		dev_err(dev, "%s: Error on release exclusive r=%d\n",
+				__func__, rc2);
+
+cyttsp4_grpdata_store_operational_regs_err_put:
+	pm_runtime_put(dev);
+
+	if (rc < 0)
+		return rc;
+	if (rc2 < 0)
+		return rc2;
+
+	return rc;
+}
+
+/*
+ * SysFs store function of Test Regs group.
+ */
+static int cyttsp4_grpdata_store_test_regs(struct device *dev, u8 *ic_buf,
+		size_t length)
+{
+	struct cyttsp4_device_access_data *dad = dev_get_drvdata(dev);
+	int rc;
+	u8 *return_buf = dad->return_buf;
+
+	/* Caller function guaranties, length is not bigger than ic_buf size */
+	if (length < CY_CMD_INDEX + 1) {
+		dev_err(dev, "%s: %s length=%d\n", __func__,
+				"Buffer length is not valid", length);
+		return -EINVAL;
+	}
+
+	dad->test.cur_cmd = ic_buf[CY_CMD_INDEX];
+	if (dad->test.cur_cmd == CY_CMD_CAT_NULL) {
+		if (length < CY_NULL_CMD_INDEX + 1) {
+			dev_err(dev, "%s: %s length=%d\n", __func__,
+					"Buffer length is not valid", length);
+			return -EINVAL;
+		}
+		dev_vdbg(dev, "%s: test-cur_cmd=%d null-cmd=%d\n", __func__,
+				dad->test.cur_cmd, ic_buf[CY_NULL_CMD_INDEX]);
+		switch (ic_buf[CY_NULL_CMD_INDEX]) {
+		case CY_NULL_CMD_NULL:
+			dev_err(dev, "%s: empty NULL cmd\n", __func__);
+			break;
+		case CY_NULL_CMD_MODE:
+			if (length < CY_NULL_CMD_MODE_INDEX + 1) {
+				dev_err(dev, "%s: %s length=%d\n", __func__,
+						"Buffer length is not valid",
+						length);
+				return -EINVAL;
+			}
+			dev_vdbg(dev, "%s: Set cmd mode=%02X\n", __func__,
+					ic_buf[CY_NULL_CMD_MODE_INDEX]);
+			cyttsp4_test_cmd_mode(dad, ic_buf, length);
+			break;
+		case CY_NULL_CMD_STATUS_SIZE:
+			if (length < CY_NULL_CMD_SIZE_INDEX + 1) {
+				dev_err(dev, "%s: %s length=%d\n", __func__,
+						"Buffer length is not valid",
+						length);
+				return -EINVAL;
+			}
+			dad->test.cur_status_size =
+				ic_buf[CY_NULL_CMD_SIZEL_INDEX]
+				+ (ic_buf[CY_NULL_CMD_SIZEH_INDEX] << 8);
+			dev_vdbg(dev, "%s: test-cur_status_size=%d\n",
+					__func__, dad->test.cur_status_size);
+			break;
+		case CY_NULL_CMD_HANDSHAKE:
+			dev_vdbg(dev, "%s: try null cmd handshake\n",
+					__func__);
+			rc = _cyttsp4_cmd_handshake(dad);
+			if (rc < 0)
+				dev_err(dev, "%s: %s r=%d\n", __func__,
+						"Fail test cmd handshake", rc);
+		default:
+			break;
+		}
+	} else {
+		dev_dbg(dev, "%s: TEST CMD=0x%02X length=%d %s%d\n",
+				__func__, ic_buf[0], length, "cmd_ofs+grpofs=",
+				dad->ic_grpoffset + dad->si->si_ofs.cmd_ofs);
+		cyttsp4_pr_buf(dev, dad->pr_buf, ic_buf, length, "test_cmd");
+		return_buf[0] = ic_buf[0]; /* Save cmd byte to return_buf */
+		rc = cyttsp4_request_exec_cmd(dad->ttsp, CY_MODE_CAT,
+				ic_buf, length,
+				return_buf + 1, dad->test.cur_status_size,
+				max(CY_COMMAND_COMPLETE_TIMEOUT,
+					CY_CALIBRATE_COMPLETE_TIMEOUT));
+		if (rc < 0)
+			dev_err(dev, "%s: Fail to execute cmd r=%d\n",
+					__func__, rc);
+	}
+	return 0;
+}
+
+/*
+ * SysFs store function of Test Regs group.
+ */
+static int cyttsp4_grpdata_store_tthe_test_regs(struct device *dev, u8 *ic_buf,
+		size_t length)
+{
+	struct cyttsp4_device_access_data *dad = dev_get_drvdata(dev);
+	int rc;
+
+	/* Caller function guaranties, length is not bigger than ic_buf size */
+	if (length < CY_CMD_INDEX + 1) {
+		dev_err(dev, "%s: %s length=%d\n", __func__,
+				"Buffer length is not valid", length);
+		return -EINVAL;
+	}
+
+	dad->test.cur_cmd = ic_buf[CY_CMD_INDEX];
+	if (dad->test.cur_cmd == CY_CMD_CAT_NULL) {
+		if (length < CY_NULL_CMD_INDEX + 1) {
+			dev_err(dev, "%s: %s length=%d\n", __func__,
+					"Buffer length is not valid", length);
+			return -EINVAL;
+		}
+		dev_vdbg(dev, "%s: test-cur_cmd=%d null-cmd=%d\n", __func__,
+				dad->test.cur_cmd, ic_buf[CY_NULL_CMD_INDEX]);
+		switch (ic_buf[CY_NULL_CMD_INDEX]) {
+		case CY_NULL_CMD_NULL:
+			dev_err(dev, "%s: empty NULL cmd\n", __func__);
+			break;
+		case CY_NULL_CMD_MODE:
+			if (length < CY_NULL_CMD_MODE_INDEX + 1) {
+				dev_err(dev, "%s: %s length=%d\n", __func__,
+						"Buffer length is not valid",
+						length);
+				return -EINVAL;
+			}
+			dev_vdbg(dev, "%s: Set cmd mode=%02X\n", __func__,
+					ic_buf[CY_NULL_CMD_MODE_INDEX]);
+			cyttsp4_test_tthe_cmd_mode(dad, ic_buf, length);
+			break;
+		case CY_NULL_CMD_STATUS_SIZE:
+			if (length < CY_NULL_CMD_SIZE_INDEX + 1) {
+				dev_err(dev, "%s: %s length=%d\n", __func__,
+						"Buffer length is not valid",
+						length);
+				return -EINVAL;
+			}
+			dad->test.cur_status_size =
+				ic_buf[CY_NULL_CMD_SIZEL_INDEX]
+				+ (ic_buf[CY_NULL_CMD_SIZEH_INDEX] << 8);
+			dev_vdbg(dev, "%s: test-cur_status_size=%d\n",
+					__func__, dad->test.cur_status_size);
+			break;
+		case CY_NULL_CMD_HANDSHAKE:
+			dev_vdbg(dev, "%s: try null cmd handshake\n",
+					__func__);
+			rc = _cyttsp4_cmd_handshake(dad);
+			if (rc < 0)
+				dev_err(dev, "%s: %s r=%d\n", __func__,
+						"Fail test cmd handshake", rc);
+		case CY_NULL_CMD_LOW_POWER:
+			dev_vdbg(dev, "%s: try null cmd low power\n", __func__);
+			rc = _cyttsp4_cmd_toggle_lowpower(dad);
+			if (rc < 0)
+				dev_err(dev, "%s: %s r=%d\n", __func__,
+					"Fail test cmd toggle low power", rc);
+		default:
+			break;
+		}
+	} else {
+		dev_dbg(dev, "%s: TEST CMD=0x%02X length=%d %s%d\n",
+				__func__, ic_buf[0], length, "cmd_ofs+grpofs=",
+				dad->ic_grpoffset + dad->si->si_ofs.cmd_ofs);
+		cyttsp4_pr_buf(dev, dad->pr_buf, ic_buf, length, "test_cmd");
+		/* Support Operating mode command. */
+		/* Write command parameters first */
+		if (length > 1) {
+			rc = cyttsp4_write(dad->ttsp,
+				(dad->test.cur_mode == CY_TEST_MODE_CAT)
+					?  CY_MODE_CAT : CY_MODE_OPERATIONAL,
+				dad->ic_grpoffset + dad->si->si_ofs.cmd_ofs
+					+ 1, ic_buf + 1, length - 1);
+			if (rc < 0) {
+				dev_err(dev, "%s: Fail write cmd param regs r=%d\n",
+					__func__, rc);
+				return 0;
+			}
+		}
+		/* Write command */
+		rc = cyttsp4_write(dad->ttsp,
+				(dad->test.cur_mode == CY_TEST_MODE_CAT)
+					?  CY_MODE_CAT : CY_MODE_OPERATIONAL,
+				dad->ic_grpoffset + dad->si->si_ofs.cmd_ofs,
+				ic_buf, 1);
+		if (rc < 0)
+			dev_err(dev, "%s: Fail write cmd reg r=%d\n",
+					__func__, rc);
+	}
+	return 0;
+}
+
+/*
+ * SysFs grpdata store function implementation of group 6.
+ * Stores the contents of the touch parameters.
+ */
+static int cyttsp4_grpdata_store_touch_params(struct device *dev,
+		u8 *ic_buf, size_t length)
+{
+	struct cyttsp4_device_access_data *dad = dev_get_drvdata(dev);
+	int rc, rc2 = 0, rc3;
+
+	pm_runtime_get_sync(dev);
+
+	rc = cyttsp4_request_exclusive(dad->ttsp,
+			CY_DA_REQUEST_EXCLUSIVE_TIMEOUT);
+	if (rc < 0) {
+		dev_err(dev, "%s: Error on request exclusive r=%d\n",
+				__func__, rc);
+		goto cyttsp4_grpdata_store_touch_params_err_put;
+	}
+
+	rc = cyttsp4_request_set_mode(dad->ttsp, CY_MODE_CAT);
+	if (rc < 0) {
+		dev_err(dev, "%s: Error on request set mode r=%d\n",
+				__func__, rc);
+		goto cyttsp4_grpdata_store_touch_params_err_release;
+	}
+
+	rc = cyttsp4_request_write_config(dad->ttsp, CY_TCH_PARM_EBID,
+			dad->ic_grpoffset, ic_buf, length);
+	if (rc < 0) {
+		dev_err(dev, "%s: Error on request write config r=%d\n",
+				__func__, rc);
+		goto cyttsp4_grpdata_store_touch_params_err_change_mode;
+	}
+
+cyttsp4_grpdata_store_touch_params_err_change_mode:
+	rc2 = cyttsp4_request_set_mode(dad->ttsp, CY_MODE_OPERATIONAL);
+	if (rc2 < 0)
+		dev_err(dev, "%s: Error on request set mode r=%d\n",
+				__func__, rc2);
+
+cyttsp4_grpdata_store_touch_params_err_release:
+	rc3 = cyttsp4_release_exclusive(dad->ttsp);
+	if (rc3 < 0)
+		dev_err(dev, "%s: Error on release exclusive r=%d\n",
+				__func__, rc3);
+
+cyttsp4_grpdata_store_touch_params_err_put:
+	pm_runtime_put(dev);
+
+	if (rc == 0)
+		cyttsp4_request_restart(dad->ttsp, true);
+	else
+		return rc;
+	if (rc2 < 0)
+		return rc2;
+	if (rc3 < 0)
+		return rc3;
+
+	return rc;
+}
+
+/*
+ * Gets user input from sysfs and parse it
+ * return size of parsed output buffer
+ */
+static int cyttsp4_ic_parse_input(struct device *dev, const char *buf,
+		size_t buf_size, u8 *ic_buf, size_t ic_buf_size)
+{
+	const char *pbuf = buf;
+	unsigned long value;
+	char scan_buf[CYTTSP4_INPUT_ELEM_SZ];
+	int i = 0;
+	int j;
+	int last = 0;
+	int ret;
+
+	dev_dbg(dev, "%s: pbuf=%p buf=%p size=%d %s=%d buf=%s\n", __func__,
+			pbuf, buf, (int) buf_size, "scan buf size",
+			CYTTSP4_INPUT_ELEM_SZ, buf);
+
+	while (pbuf <= (buf + buf_size)) {
+		if (i >= CY_MAX_CONFIG_BYTES) {
+			dev_err(dev, "%s: %s size=%d max=%d\n", __func__,
+					"Max cmd size exceeded", i,
+					CY_MAX_CONFIG_BYTES);
+			return -EINVAL;
+		}
+		if (i >= ic_buf_size) {
+			dev_err(dev, "%s: %s size=%d buf_size=%d\n", __func__,
+					"Buffer size exceeded", i, ic_buf_size);
+			return -EINVAL;
+		}
+		while (((*pbuf == ' ') || (*pbuf == ','))
+				&& (pbuf < (buf + buf_size))) {
+			last = *pbuf;
+			pbuf++;
+		}
+
+		if (pbuf >= (buf + buf_size))
+			break;
+
+		memset(scan_buf, 0, CYTTSP4_INPUT_ELEM_SZ);
+		if ((last == ',') && (*pbuf == ',')) {
+			dev_err(dev, "%s: %s \",,\" not allowed.\n", __func__,
+					"Invalid data format.");
+			return -EINVAL;
+		}
+		for (j = 0; j < (CYTTSP4_INPUT_ELEM_SZ - 1)
+				&& (pbuf < (buf + buf_size))
+				&& (*pbuf != ' ')
+				&& (*pbuf != ','); j++) {
+			last = *pbuf;
+			scan_buf[j] = *pbuf++;
+		}
+
+		ret = kstrtoul(scan_buf, 16, &value);
+		if (ret < 0) {
+			dev_err(dev, "%s: %s '%s' %s%s i=%d r=%d\n", __func__,
+					"Invalid data format. ", scan_buf,
+					"Use \"0xHH,...,0xHH\"", " instead.",
+					i, ret);
+			return ret;
+		}
+
+		ic_buf[i] = value;
+		i++;
+	}
+
+	return i;
+}
+
+/*
+ * SysFs store functions of each group member.
+ */
+static cyttsp4_store_function
+		cyttsp4_grpdata_store_functions[CY_IC_GRPNUM_NUM] = {
+	[CY_IC_GRPNUM_RESERVED] = cyttsp4_grpdata_store_void,
+	[CY_IC_GRPNUM_CMD_REGS] = cyttsp4_grpdata_store_operational_regs,
+	[CY_IC_GRPNUM_TCH_REP] = cyttsp4_grpdata_store_void,
+	[CY_IC_GRPNUM_DATA_REC] = cyttsp4_grpdata_store_void,
+	[CY_IC_GRPNUM_TEST_REC] = cyttsp4_grpdata_store_void,
+	[CY_IC_GRPNUM_PCFG_REC] = cyttsp4_grpdata_store_void,
+	[CY_IC_GRPNUM_TCH_PARM_VAL] = cyttsp4_grpdata_store_touch_params,
+	[CY_IC_GRPNUM_TCH_PARM_SIZE] = cyttsp4_grpdata_store_void,
+	[CY_IC_GRPNUM_RESERVED1] = cyttsp4_grpdata_store_void,
+	[CY_IC_GRPNUM_RESERVED2] = cyttsp4_grpdata_store_void,
+	[CY_IC_GRPNUM_OPCFG_REC] = cyttsp4_grpdata_store_void,
+	[CY_IC_GRPNUM_DDATA_REC] = cyttsp4_grpdata_store_void,
+	[CY_IC_GRPNUM_MDATA_REC] = cyttsp4_grpdata_store_void,
+	[CY_IC_GRPNUM_TEST_REGS] = cyttsp4_grpdata_store_test_regs,
+	[CY_IC_GRPNUM_BTN_KEYS] = cyttsp4_grpdata_store_void,
+	[CY_IC_GRPNUM_TTHE_REGS] = cyttsp4_grpdata_store_tthe_test_regs,
+};
+
+static ssize_t cyttsp4_ic_grpdata_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	struct cyttsp4_device_access_data *dad = dev_get_drvdata(dev);
+	ssize_t length;
+	int rc;
+
+	mutex_lock(&dad->sysfs_lock);
+	length = cyttsp4_ic_parse_input(dev, buf, size, dad->ic_buf,
+			CY_MAX_PRBUF_SIZE);
+	if (length <= 0) {
+		dev_err(dev, "%s: %s Group Data store\n", __func__,
+				"Malformed input for");
+		goto cyttsp4_ic_grpdata_store_exit;
+	}
+
+	dev_vdbg(dev, "%s: grpnum=%d grpoffset=%u\n",
+			__func__, dad->ic_grpnum, dad->ic_grpoffset);
+
+	if (dad->ic_grpnum >= CY_IC_GRPNUM_NUM) {
+		dev_err(dev, "%s: Group %d does not exist.\n",
+				__func__, dad->ic_grpnum);
+		goto cyttsp4_ic_grpdata_store_exit;
+	}
+
+	/* write ic_buf to log */
+	cyttsp4_pr_buf(dev, dad->pr_buf, dad->ic_buf, length, "ic_buf");
+
+	/* Call relevant store handler. */
+	rc = cyttsp4_grpdata_store_functions[dad->ic_grpnum] (dev, dad->ic_buf,
+			length);
+	if (rc < 0)
+		dev_err(dev, "%s: Failed to store for grpmun=%d.\n",
+				__func__, dad->ic_grpnum);
+
+cyttsp4_ic_grpdata_store_exit:
+	mutex_unlock(&dad->sysfs_lock);
+	dev_vdbg(dev, "%s: return size=%d\n", __func__, size);
+	return size;
+}
+
+static DEVICE_ATTR(ic_grpdata, S_IRUSR | S_IWUSR,
+	cyttsp4_ic_grpdata_show, cyttsp4_ic_grpdata_store);
+
+/*
+ * Execute scan command
+ */
+static int _cyttsp4_exec_scan_cmd(struct device *dev)
+{
+	struct cyttsp4_device_access_data *dad = dev_get_drvdata(dev);
+	u8 cmd_buf[CY_CMD_CAT_EXECUTE_PANEL_SCAN_CMD_SZ];
+	u8 return_buf[CY_CMD_CAT_EXECUTE_PANEL_SCAN_RET_SZ];
+
+	cmd_buf[0] = CY_CMD_CAT_EXEC_PANEL_SCAN;
+
+	return cyttsp4_request_exec_cmd(dad->ttsp, CY_MODE_CAT,
+			cmd_buf, CY_CMD_CAT_EXECUTE_PANEL_SCAN_CMD_SZ,
+			return_buf, CY_CMD_CAT_EXECUTE_PANEL_SCAN_RET_SZ,
+			CY_COMMAND_COMPLETE_TIMEOUT);
+}
+
+/*
+ * Retrieve panel data command
+ */
+static int _cyttsp4_ret_scan_data_cmd(struct device *dev, int read_offset,
+		int num_element, u8 data_type, u8 *return_buf)
+{
+	struct cyttsp4_device_access_data *dad = dev_get_drvdata(dev);
+	u8 cmd_buf[CY_CMD_CAT_RETRIEVE_PANEL_SCAN_CMD_SZ];
+
+	cmd_buf[0] = CY_CMD_CAT_RETRIEVE_PANEL_SCAN;
+	cmd_buf[1] = HI_BYTE(read_offset);
+	cmd_buf[2] = LO_BYTE(read_offset);
+	cmd_buf[3] = HI_BYTE(num_element);
+	cmd_buf[4] = LO_BYTE(num_element);
+	cmd_buf[5] = data_type;
+
+	return cyttsp4_request_exec_cmd(dad->ttsp, CY_MODE_CAT,
+			cmd_buf, CY_CMD_CAT_RETRIEVE_PANEL_SCAN_CMD_SZ,
+			return_buf, CY_CMD_CAT_RETRIEVE_PANEL_SCAN_RET_SZ,
+			CY_COMMAND_COMPLETE_TIMEOUT);
+}
+
+/*
+ * SysFs grpdata show function implementation of group 6.
+ * Prints contents of the touch parameters a row at a time.
+ */
+static ssize_t cyttsp4_get_panel_data_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct cyttsp4_device_access_data *dad = dev_get_drvdata(dev);
+	u8 return_buf[CY_CMD_CAT_RETRIEVE_PANEL_SCAN_RET_SZ];
+
+	int rc = 0;
+	int rc1 = 0;
+	int data_idx = 0;
+	int i = 0;
+	int print_idx = -1;
+	u8 cmd_param_ofs = dad->si->si_ofs.cmd_ofs + 1;
+	int read_byte = CY_CMD_CAT_RETRIEVE_PANEL_SCAN_RET_SZ + cmd_param_ofs;
+	int left_over_element = dad->heatmap.num_element;
+	int read_element_offset = CY_CMD_IN_DATA_OFFSET_VALUE;
+	int returned_element;
+	u8 element_start_offset = cmd_param_ofs
+		+ CY_CMD_CAT_RETRIEVE_PANEL_SCAN_RET_SZ;
+
+
+	rc = cyttsp4_request_exclusive(dad->ttsp,
+			CY_DA_REQUEST_EXCLUSIVE_TIMEOUT);
+	if (rc < 0) {
+		dev_err(dev, "%s: Error on request exclusive r=%d\n",
+				__func__, rc);
+		goto cyttsp4_get_panel_data_show_err_release;
+	}
+
+	if (dad->heatmap.scan_start)	{
+		/* Start scan */
+		rc = _cyttsp4_exec_scan_cmd(dev);
+		if (rc < 0) {
+			dev_err(dev, "%s: Error on _cyttsp4_exec_scan_cmd()\n",
+				__func__);
+			goto cyttsp4_get_panel_data_show_err_release;
+		}
+	}
+
+	/* retrieve scan data */
+	rc = _cyttsp4_ret_scan_data_cmd(dev, read_element_offset,
+			left_over_element, dad->heatmap.data_type, return_buf);
+	if (rc < 0) {
+		dev_err(dev, "%s: Error on _cyttsp4_ret_scan_data_cmd(), offset=%d num_element:%d\n",
+			__func__, read_element_offset, left_over_element);
+		goto cyttsp4_get_panel_data_show_err_release;
+	}
+	if (return_buf[CY_CMD_OUT_STATUS_OFFSET] != CY_CMD_STATUS_SUCCESS) {
+		dev_err(dev, "%s: Fail on _cyttsp4_ret_scan_data_cmd(), offset=%d num_element:%d\n",
+			__func__, read_element_offset, left_over_element);
+		goto cyttsp4_get_panel_data_show_err_release;
+	}
+
+	returned_element = return_buf[CY_CMD_RET_PNL_OUT_ELMNT_SZ_OFFS_H] * 256
+		+ return_buf[CY_CMD_RET_PNL_OUT_ELMNT_SZ_OFFS_L];
+
+	dev_dbg(dev, "%s: _cyttsp4_ret_scan_data_cmd(): num_element:%d\n",
+		__func__, returned_element);
+
+	/* read data */
+	read_byte += returned_element *
+			(return_buf[CY_CMD_RET_PNL_OUT_DATA_FORMAT_OFFS] &
+				CY_CMD_RET_PANEL_ELMNT_SZ_MASK);
+
+	rc = cyttsp4_read(dad->ttsp, CY_MODE_CAT, 0, dad->ic_buf, read_byte);
+	if (rc < 0) {
+		dev_err(dev, "%s: Error on read r=%d\n", __func__, rc);
+		goto cyttsp4_get_panel_data_show_err_release;
+	}
+
+	left_over_element = dad->heatmap.num_element - returned_element;
+	read_element_offset = returned_element;
+	data_idx = read_byte;
+
+	while (left_over_element > 0) {
+		/* get the data */
+		rc = _cyttsp4_ret_scan_data_cmd(dev, read_element_offset,
+				left_over_element, dad->heatmap.data_type,
+				return_buf);
+		if (rc < 0) {
+			dev_err(dev, "%s: Error %d  on _cyttsp4_ret_scan_data_cmd(), offset=%d num_element:%d\n",
+				__func__, rc, read_element_offset,
+				left_over_element);
+			goto cyttsp4_get_panel_data_show_err_release;
+		}
+		if (return_buf[CY_CMD_OUT_STATUS_OFFSET]
+				!= CY_CMD_STATUS_SUCCESS) {
+			dev_err(dev, "%s: Fail on _cyttsp4_ret_scan_data_cmd(), offset=%d num_element:%d\n",
+				__func__, read_element_offset,
+				left_over_element);
+			goto cyttsp4_get_panel_data_show_err_release;
+		}
+
+		returned_element =
+			return_buf[CY_CMD_RET_PNL_OUT_ELMNT_SZ_OFFS_H] * 256
+			+ return_buf[CY_CMD_RET_PNL_OUT_ELMNT_SZ_OFFS_L];
+
+		dev_dbg(dev, "%s: _cyttsp4_ret_scan_data_cmd(): num_element:%d\n",
+			__func__, returned_element);
+
+		/* Check if we requested more elements than the device has */
+		if (returned_element == 0) {
+			dev_dbg(dev, "%s: returned_element=0, left_over_element=%d\n",
+				__func__, left_over_element);
+			break;
+		}
+
+		/* DO read */
+		read_byte = returned_element *
+			(return_buf[CY_CMD_RET_PNL_OUT_DATA_FORMAT_OFFS]
+				& CY_CMD_RET_PANEL_ELMNT_SZ_MASK);
+
+		rc = cyttsp4_read(dad->ttsp, CY_MODE_CAT,
+				element_start_offset,
+				dad->ic_buf + data_idx,
+				read_byte);
+		if (rc < 0) {
+			dev_err(dev, "%s: Error on read r=%d\n", __func__, rc);
+			goto cyttsp4_get_panel_data_show_err_release;
+		}
+
+		/* Update element status */
+		left_over_element -= returned_element;
+		read_element_offset += returned_element;
+		data_idx += read_byte;
+
+	}
+	/* update on the buffer */
+	dad->ic_buf[CY_CMD_RET_PNL_OUT_ELMNT_SZ_OFFS_H + cmd_param_ofs] =
+		HI_BYTE(read_element_offset);
+	dad->ic_buf[CY_CMD_RET_PNL_OUT_ELMNT_SZ_OFFS_L + cmd_param_ofs] =
+		LO_BYTE(read_element_offset);
+
+cyttsp4_get_panel_data_show_err_release:
+	rc1 = cyttsp4_release_exclusive(dad->ttsp);
+	if (rc1 < 0) {
+		dev_err(dev, "%s: Error on release exclusive r=%d\n",
+				__func__, rc1);
+		goto cyttsp4_get_panel_data_show_err_sysfs;
+	}
+
+	if (rc < 0)
+		goto cyttsp4_get_panel_data_show_err_sysfs;
+
+	print_idx = 0;
+	print_idx += scnprintf(buf, CY_MAX_PRBUF_SIZE, "CY_DATA:");
+	for (i = 0; i < data_idx; i++) {
+		print_idx += scnprintf(buf + print_idx,
+				CY_MAX_PRBUF_SIZE - print_idx,
+				"%02X ", dad->ic_buf[i]);
+	}
+	print_idx += scnprintf(buf + print_idx, CY_MAX_PRBUF_SIZE - print_idx,
+			":(%d bytes)\n", data_idx);
+
+cyttsp4_get_panel_data_show_err_sysfs:
+	return print_idx;
+}
+
+/*
+ * SysFs grpdata show function implementation of group 6.
+ * Prints contents of the touch parameters a row at a time.
+ */
+static int cyttsp4_get_panel_data_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	struct cyttsp4_device_access_data *dad = dev_get_drvdata(dev);
+	ssize_t length;
+
+	mutex_lock(&dad->sysfs_lock);
+
+	length = cyttsp4_ic_parse_input(dev, buf, size, dad->ic_buf,
+			CY_MAX_PRBUF_SIZE);
+	if (length <= 0) {
+		dev_err(dev, "%s: %s Group Data store\n", __func__,
+				"Malformed input for");
+		goto cyttsp4_get_panel_data_store_exit;
+	}
+
+	dev_vdbg(dev, "%s: grpnum=%d grpoffset=%u\n",
+			__func__, dad->ic_grpnum, dad->ic_grpoffset);
+
+	if (dad->ic_grpnum >= CY_IC_GRPNUM_NUM) {
+		dev_err(dev, "%s: Group %d does not exist.\n",
+				__func__, dad->ic_grpnum);
+		goto cyttsp4_get_panel_data_store_exit;
+	}
+
+	pm_runtime_get_sync(dev);
+	/*update parameter value */
+	dad->heatmap.num_element = dad->ic_buf[4] + (dad->ic_buf[3] * 256);
+	dad->heatmap.data_type = dad->ic_buf[5];
+
+	if (dad->ic_buf[6] > 0)
+		dad->heatmap.scan_start = true;
+	else
+		dad->heatmap.scan_start = false;
+	pm_runtime_put(dev);
+
+cyttsp4_get_panel_data_store_exit:
+	mutex_unlock(&dad->sysfs_lock);
+	dev_vdbg(dev, "%s: return size=%d\n", __func__, size);
+	return size;
+}
+
+static DEVICE_ATTR(get_panel_data, S_IRUSR | S_IWUSR,
+	cyttsp4_get_panel_data_show, cyttsp4_get_panel_data_store);
+/* < DTS2013081205521 yangzicheng 20130812 begin */
+/*modify the threshold too large to make sure the V3 mmi can pass*/
+/* < DTS2013072907885 yangzicheng 20130729 begin */
+/* < DTS2013071907628 shenjinming 20130725 begin */
+#define CAP_MUT_LINE_X  28
+#define CAP_MUT_LINE_Y  16
+#define CAP_SELF_LINE   16
+#define CAP_MUT_MIN     -5000 //-2950
+#define CAP_MUT_MAX     5000  //-1500
+#define CAP_SELF_MIN    -5000 //-600
+#define CAP_SELF_MAX    5000  //1300
+/* DTS2013081205521 yangzicheng 20130812 end >*/
+
+static struct device * access_dev = NULL;
+static int getHighPart(int num)
+{
+	switch(num)
+	{
+	case 1:
+		return 0xFF000000;		
+	case 2:
+		return 0xFFFF0000;
+	case 3:
+		return 0xFFFFFF00;
+	default:
+		return 0x0;
+		
+	}
+
+}
+
+#define    MAX_CAPACITANCE_LEN	7 * 315 
+static	int  g_capacitance_count = 0;
+static char *g_touch_capacitance = NULL;
+
+/* save each value of capacitance to buf */
+static void record_tp_capacitance(enum check_data_type type, int value)
+{
+	char buf[7] = {0};
+	sprintf(buf, "%d\t", value);
+	strcat(g_touch_capacitance, buf);
+	g_capacitance_count++;
+	if(0 == g_capacitance_count % 13)
+	{
+		strcat(g_touch_capacitance, "\n");
+	}
+
+	return;
+}
+
+/* check if the value is in the proper rang */
+static int out_of_range(enum check_data_type type, int value)
+{
+
+    record_tp_capacitance(type, value);
+
+	switch(type)
+	{
+    	case CY_CHK_MUT_RAW:    
+    		if(value < CAP_MUT_MIN || value > CAP_MUT_MAX) // mutual capacitance rang for raymond
+    		{
+    			return 1;
+    		}
+    		break;
+
+        case CY_CHK_SELF_RAW:
+    		if(value < CAP_SELF_MIN || value > CAP_SELF_MAX)  // self capacitance rang for raymond
+    		{
+    			return 1;
+    		}
+    		break;
+
+        default:
+    		break;
+	}
+    
+	return 0;
+    
+}
+
+#define B_ENDIAN 0
+#define L_ENDIAN 0x10
+
+static int cyttsp4_check_range(enum check_data_type type, int endian, int datasize, struct cyttsp4_device_access_data* dad, int size)
+{
+	static int temp = 0;
+	int index = 0;
+	int rc = 0;
+
+    printk("cyttsp4_check_range type is %d\n", type);
+
+    /* begin from 8 */
+	for(index = 8; index < size; ++index){
+		if(endian ==B_ENDIAN)
+		{	
+			if(0 == index%datasize) 	//high byte
+			{	
+				if(dad->ic_buf[index]&0x80)	 //extend
+				{
+					temp |= getHighPart(4 -datasize);
+				
+				}
+				temp |= dad->ic_buf[index] << 8*(datasize -1);
+				if(datasize ==1){
+                    /* inspect the date get from the ic buf */
+					if(out_of_range(type, temp))
+					{
+					    //return -1; modified for show all data 0315
+					    rc = -1;
+					}
+					temp = 0;
+				}
+			
+			}
+            else
+			{
+				temp |= dad->ic_buf[index] << 8*(datasize -  index%datasize - 1);
+				if(index%datasize == datasize -1)	//low byte
+				{	
+					if(out_of_range(type, temp))
+					{
+						//return -1; modified for show all data 0315
+					    	rc = -1;
+					}
+					temp = 0;
+				}
+			}
+		}
+        else 
+        {//little endian
+			if( index%datasize == datasize-1 )
+			{	
+				if(dad->ic_buf[index]&0x80)
+				{
+					temp |= getHighPart(4 -datasize);				
+				}
+                
+				temp |= dad->ic_buf[index] << 8*(datasize -1);
+
+                //printk("index = %d datasize = %#x temp = %d\n",index, datasize, temp);
+                /* inspect the date get from the ic buf */
+                if(out_of_range(type, temp))
+				{
+				    printk("the fail element type : %d, value: %d \n", type, temp );
+					rc = -1;
+				}
+
+				temp = 0;
+                
+			}
+            else
+			{
+				//printk("index = %d datasize = %#x temp = %d\n",index, datasize, temp);
+				temp |= dad->ic_buf[index] << 8*( index%datasize);
+			}
+		}
+	}
+
+	return rc;
+}
+
+
+typedef int (* retrieve_func)(struct device *dev, int readOffset,	int num_element, u8 data_type, u8 *return_buf);
+
+/*return value:  >0 means success; <0 means failed; =0 means unknown*/
+static int cyttsp4_get_data_and_check(struct device* dev, retrieve_func ret_func, enum check_data_type type, int offset)
+{
+	struct cyttsp4_device_access_data *dad = dev_get_drvdata(dev);
+	u8 return_buf[CY_CMD_CAT_RETRIEVE_PANEL_SCAN_RET_SZ];
+	int rc = 0;
+	int dataIdx = -1;
+	u8 cmdParam_ofs = dad->si->si_ofs.cmd_ofs + 1;
+	int readByte = CY_CMD_CAT_RETRIEVE_PANEL_SCAN_RET_SZ + cmdParam_ofs;
+	int leftOverElement = 0;
+	int returnedElement = 0;
+	int readElementOffset = 0;
+	u8 elementStartOffset = cmdParam_ofs + CY_CMD_CAT_RETRIEVE_PANEL_SCAN_RET_SZ;
+	int datasize = 0;
+	int endian = 0;
+    int i=0;
+		    
+	/* retrieve scan data */
+	rc = ret_func(dev, offset,
+			dad->heatmap.num_element, dad->heatmap.data_type,
+			return_buf);
+
+    for( i=0; i<CY_CMD_CAT_RETRIEVE_PANEL_SCAN_RET_SZ; i++ )
+    {
+        printk("cyttsp4_get_data_and_check return_buf[i] is:%d\n", return_buf[i]);
+    }
+    
+	if (rc < 0)
+    {
+		dev_err(dev, "%s ret_func error\n", __func__);
+		return 0;
+	}
+    
+	if (return_buf[CY_CMD_OUT_STATUS_OFFSET] != CY_CMD_STATUS_SUCCESS)
+    {
+        dev_err(dev, "%s return status is error\n", __func__);
+        return 0;
+    }   
+	
+
+	datasize = return_buf[CY_CMD_RET_PNL_OUT_DATA_FORMAT_OFFS] &
+				CY_CMD_RET_PANEL_ELMNT_SZ_MASK;
+	endian = return_buf[CY_CMD_RET_PNL_OUT_DATA_FORMAT_OFFS]&0x10;
+
+	/* read data */
+	readByte += dad->heatmap.num_element *datasize;
+
+	if (readByte >= I2C_BUF_MAX_SIZE) {
+		rc = cyttsp4_read(dad->ttsp, CY_MODE_CAT, 0, dad->ic_buf,
+				I2C_BUF_MAX_SIZE);
+		dataIdx = I2C_BUF_MAX_SIZE;
+	} else {
+		rc = cyttsp4_read(dad->ttsp, CY_MODE_CAT, 0, dad->ic_buf,
+				readByte);
+		dataIdx = readByte;
+	}
+	if (rc < 0) {
+		dev_err(dev, "%s: Error on read r=%d\n", __func__, readByte);
+		return 0;
+	}
+    
+	/*
+	if (readByte < I2C_BUF_MAX_SIZE)
+		return 0;*/
+
+	leftOverElement = dad->heatmap.num_element;
+	readElementOffset = 0;
+	returnedElement =
+		return_buf[CY_CMD_RET_PNL_OUT_ELMNT_SZ_OFFS_H] * 256
+		+ return_buf[CY_CMD_RET_PNL_OUT_ELMNT_SZ_OFFS_L];
+
+	leftOverElement -= returnedElement;
+	readElementOffset += returnedElement;
+    
+	while (leftOverElement > 0){
+		/* get the data */
+		rc = ret_func(dev, readElementOffset,
+				leftOverElement, dad->heatmap.data_type,
+				return_buf);
+		if (rc < 0)
+        {
+            dev_err(dev, "%s: get data error r=%d\n", __func__, rc);
+        	return 0;
+        }      
+		
+		dev_err(dev, "%s:_cyttsp4_ret_scan_data_cmd()2: return_buf: 0x%x, 0x%x, 0x%x, 0x%x, 0x%x\n",
+				   __func__, return_buf[0], return_buf[1], return_buf[2], return_buf[3], return_buf[4]);
+
+		if (return_buf[CY_CMD_OUT_STATUS_OFFSET] != CY_CMD_STATUS_SUCCESS)
+        {
+            dev_err(dev, "%s return status is error 2 \n", __func__);
+			return 0;
+        }
+
+		/* DO read */
+		readByte = leftOverElement *
+			(return_buf[CY_CMD_RET_PNL_OUT_DATA_FORMAT_OFFS]
+				& CY_CMD_RET_PANEL_ELMNT_SZ_MASK);
+
+		if (readByte >= (I2C_BUF_MAX_SIZE - elementStartOffset)) {
+			rc = cyttsp4_read(dad->ttsp, CY_MODE_CAT,
+					elementStartOffset,
+					dad->ic_buf + dataIdx,
+					I2C_BUF_MAX_SIZE - elementStartOffset);
+			dataIdx += (I2C_BUF_MAX_SIZE - elementStartOffset);
+		} else {
+			rc = cyttsp4_read(dad->ttsp, CY_MODE_CAT,
+					elementStartOffset,
+					dad->ic_buf + dataIdx, readByte);
+			dataIdx += readByte;
+		}
+		if (rc < 0) {
+			dev_err(dev, "%s: Error on read r=%d\n", __func__, rc);
+			return 0;
+		}
+		returnedElement =
+			return_buf[CY_CMD_RET_PNL_OUT_ELMNT_SZ_OFFS_H] * 256
+			+ return_buf[CY_CMD_RET_PNL_OUT_ELMNT_SZ_OFFS_L];
+		/* Update element status */
+		leftOverElement -= returnedElement;
+		readElementOffset += returnedElement;
+
+	}
+	/* update on the buffer */
+	dad->ic_buf[CY_CMD_RET_PNL_OUT_ELMNT_SZ_OFFS_H + cmdParam_ofs] =
+		HI_BYTE(readElementOffset);
+	dad->ic_buf[CY_CMD_RET_PNL_OUT_ELMNT_SZ_OFFS_L + cmdParam_ofs] =
+		LO_BYTE(readElementOffset);
+
+    /* check capacitor range */
+	rc = cyttsp4_check_range(type, endian, datasize, dad, dataIdx);
+	if(rc < 0)
+	{
+		dev_dbg(dev, "%s cyttsp4_check_range failed!!!\n", __func__);
+		return -1;
+	}
+	
+	/*printIdx += scnprintf(buf + printIdx, CY_MAX_PRBUF_SIZE - printIdx,
+			":(%d bytes)\n", dataIdx);*/    
+
+	return dataIdx;
+    
+}
+
+/*return value:  >0 means success; <0 means failed; =0 means unknown*/
+static int cyttsp4_check_raw_data(struct device *dev)
+{
+	struct cyttsp4_device_access_data *dad = dev_get_drvdata(dev);
+	int rc = 0;
+	int i = 0;
+	
+	enum check_data_type type;
+	
+   	for(i = 0; i < 2; ++i)
+    {
+   		if(0 == i)
+		{	
+			type = CY_CHK_MUT_RAW;
+			dad->heatmap.num_element = (CAP_MUT_LINE_X*CAP_MUT_LINE_Y);  // 28*16 
+			dad->heatmap.data_type = CY_MUT_RAW;
+		}
+        else
+		{	
+			type = CY_CHK_SELF_RAW;
+			dad->heatmap.num_element = CAP_SELF_LINE;
+			dad->heatmap.data_type = CY_SELF_RAW;
+		}
+
+        dev_info(dev, "%s: type is:%d\n", __func__, type);
+        
+		/* Start scan */
+		rc = _cyttsp4_exec_scan_cmd(dev);
+		if (rc < 0)
+        {
+            dev_err(dev, "%s: _cyttsp4_exec_scan_cmd fail!!!!!\n", __func__);
+			return 0;
+		}
+		/* retrieve scan data */
+		rc = cyttsp4_get_data_and_check(dev,  _cyttsp4_ret_scan_data_cmd, type, CY_CMD_IN_DATA_OFFSET_VALUE);
+		if(rc < 0)
+		{	
+		    dev_err(dev, "%s: cyttsp4_get_data_and_check fail!!!!!\n", __func__);
+			return -1;
+		}
+   	}
+
+   return rc;
+}
+
+
+static inline void cyttsp4_out_to_buf(int ret, char ** buf)
+{
+	if(ret <0)
+	{	
+		*buf = "FAIL";
+	}
+    else if(ret > 0)
+    {
+		*buf = "PASS";
+	}
+    else
+	{
+		*buf = "unknown";
+	}
+}
+
+int  cyttsp4_get_panel_data_check(char **buf)
+{
+	int rc = 0;
+	bool need_output = true;
+	char * grpnum = "15";
+	char * grpdata = "0x00,0x01,0x20";
+	char * back_to_op = "0,1,0";
+	struct cyttsp4_device_access_data *dad = dev_get_drvdata(access_dev);
+	struct device * dev = access_dev;
+
+    /* set the TP as test mode */
+	rc = cyttsp4_ic_grpnum_store(dev, NULL, grpnum, strlen(grpnum));
+	if (rc < 0) {
+		rc = 0;//use this to justify what to output to the user-space buf
+		dev_err(dev, "%s: Error on cyttsp4_ic_grpnum_store r=%d\n",
+				__func__, rc);
+		goto exit;
+	}
+	rc = cyttsp4_ic_grpdata_store(dev, NULL, grpdata, strlen(grpdata));
+	if (rc < 0) {
+		rc = 0;//use this to justify what to output to the user-space buf
+		dev_err(dev, "%s: Error on cyttsp4_ic_grpdata_store r=%d\n",
+				__func__, rc);
+		goto exit;
+	}
+	
+	rc = cyttsp4_request_exclusive(dad->ttsp,
+			CY_DA_REQUEST_EXCLUSIVE_TIMEOUT);
+	if (rc < 0) {
+		rc = 0;//use this to justify what to output to the user-space buf
+		dev_err(dev, "%s: Error on request exclusive r=%d\n",
+				__func__, rc);
+		goto cyttsp4_get_panel_data_show_err_release;
+	}
+
+    /* read raw data and check them */
+  	rc = cyttsp4_check_raw_data(dev);
+	if(rc <= 0){	
+        dev_err(dev, "%s: Error on cyttsp4_check_raw_data r=%d\n",
+				__func__, rc);
+		goto cyttsp4_get_panel_data_show_err_release;
+	}
+	
+	//rc = cyttsp4_check_structure(dev);
+
+	cyttsp4_out_to_buf(rc, buf);
+	need_output = false;
+    
+cyttsp4_get_panel_data_show_err_release:
+	if(need_output){
+		cyttsp4_out_to_buf(rc, buf);
+	}
+	rc = cyttsp4_release_exclusive(dad->ttsp);
+	if (rc < 0) {
+		dev_err(dev, "%s: Error on release exclusive r=%d\n",
+				__func__, rc);		
+	}
+	/*back to operational*/
+	rc = cyttsp4_ic_grpdata_store(dev, NULL, back_to_op, strlen(back_to_op));
+	if (rc < 0) {
+		dev_err(dev, "%s: Error on cyttsp4_ic_grpdata_store!!! r=%d\n",
+				__func__, rc);
+		goto exit;
+	}
+ exit:
+	return rc;
+}
+
+EXPORT_SYMBOL(cyttsp4_get_panel_data_check);
+
+
+/*touchpanel mmi test begin*/
+static char *touch_mmi_test_result = NULL;
+static ssize_t cyttsp4_touch_mmi_test_show(struct kobject *kobj, 
+	struct kobj_attribute *attr,char *buf)				
+{
+	int rc = 0;
+
+	/*check if the kobj is null return*/
+	if (kobj == NULL)
+	{
+		pr_err("%s: touch_mmi_test dev is null\n", __func__);
+		return -EINVAL;
+	}
+
+	if(NULL == g_touch_capacitance)
+	{	
+		g_touch_capacitance = kzalloc(sizeof(char) * MAX_CAPACITANCE_LEN, GFP_KERNEL);
+		if(NULL == g_touch_capacitance)
+		{
+		    pr_err("%s: assign memory failed r=%d\n",
+				    __func__, rc);
+			return -EINVAL;
+		}
+	}
+
+	/*reset the g_capacitance_count and g_touch_capacitance */
+	g_capacitance_count= 0;
+	memset(g_touch_capacitance, 0, MAX_CAPACITANCE_LEN);
+    
+	rc = cyttsp4_get_panel_data_check(&touch_mmi_test_result);
+	if(rc < 0){
+	    pr_err( "%s: yttsp4_get_panel_data_check error\n",
+	            __func__);
+	}
+	printk("touch_mmi_test_result : %d\n", rc);
+	printk("touch_mmi_test_result : %s\n", touch_mmi_test_result);
+	
+	/*if someting is error, we still want to report info, because it is useful for debugging*/
+	rc = sprintf(buf, "%s\n%s\n", touch_mmi_test_result,g_touch_capacitance);
+	kfree(g_touch_capacitance);
+	g_touch_capacitance = NULL;
+	return rc;
+    
+}
+
+#if 0
+static DEVICE_ATTR(touch_mmi_test, 0664,
+				   cyttsp4_touch_mmi_test_show, NULL);
+#endif
+
+static struct kobj_attribute touch_mmi_test_attribute = {
+	.attr = {.name = "touch_mmi_test", .mode = 0664},
+	.show = cyttsp4_touch_mmi_test_show,
+	.store = NULL,
+};
+/* DTS2013071907628 shenjinming 20130725 end > */
+/* DTS2013072907885 yangzicheng 20130729 end >*/
+#ifdef CONFIG_PM_SLEEP
+static int cyttsp4_device_access_suspend(struct device *dev)
+{
+	struct cyttsp4_device_access_data *dad = dev_get_drvdata(dev);
+
+	dev_dbg(dev, "%s\n", __func__);
+
+	if (!mutex_trylock(&dad->sysfs_lock))
+		return -EBUSY;
+
+	mutex_unlock(&dad->sysfs_lock);
+	return 0;
+}
+
+static int cyttsp4_device_access_resume(struct device *dev)
+{
+	dev_dbg(dev, "%s\n", __func__);
+
+	return 0;
+}
+#endif
+
+static const struct dev_pm_ops cyttsp4_device_access_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(cyttsp4_device_access_suspend,
+			cyttsp4_device_access_resume)
+};
+
+static int cyttsp4_setup_sysfs(struct cyttsp4_device *ttsp)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_device_access_data *dad = dev_get_drvdata(dev);
+	int rc = 0;
+
+	rc = device_create_file(dev, &dev_attr_ic_grpnum);
+	if (rc) {
+		dev_err(dev, "%s: Error, could not create ic_grpnum\n",
+				__func__);
+		goto exit;
+	}
+
+	rc = device_create_file(dev, &dev_attr_ic_grpoffset);
+	if (rc) {
+		dev_err(dev, "%s: Error, could not create ic_grpoffset\n",
+				__func__);
+		goto unregister_grpnum;
+	}
+
+	rc = device_create_file(dev, &dev_attr_ic_grpdata);
+	if (rc) {
+		dev_err(dev, "%s: Error, could not create ic_grpdata\n",
+				__func__);
+		goto unregister_grpoffset;
+	}
+
+	rc = device_create_file(dev, &dev_attr_get_panel_data);
+	if (rc) {
+		dev_err(dev, "%s: Error, could not create get_panel_data\n",
+				__func__);
+		goto unregister_grpdata;
+	}
+
+	dad->sysfs_nodes_created = true;
+	return rc;
+
+unregister_grpdata:
+	device_remove_file(dev, &dev_attr_get_panel_data);
+unregister_grpoffset:
+	device_remove_file(dev, &dev_attr_ic_grpoffset);
+unregister_grpnum:
+	device_remove_file(dev, &dev_attr_ic_grpnum);
+exit:
+	return rc;
+}
+
+static int cyttsp4_setup_sysfs_attention(struct cyttsp4_device *ttsp)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_device_access_data *dad = dev_get_drvdata(dev);
+	int rc = 0;
+
+	dev_vdbg(dev, "%s\n", __func__);
+
+	dad->si = cyttsp4_request_sysinfo(ttsp);
+	if (!dad->si)
+		return -1;
+
+	rc = cyttsp4_setup_sysfs(ttsp);
+
+	cyttsp4_unsubscribe_attention(ttsp, CY_ATTEN_STARTUP,
+		cyttsp4_setup_sysfs_attention, 0);
+
+	return rc;
+
+}
+
+#ifdef CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_DEVICE_ACCESS_API
+static struct cyttsp4_device *device_access_devices[CY_MAX_NUM_CORE_DEVS];
+static DEFINE_MUTEX(device_access_devices_lock);
+
+static void insert_da_device(struct cyttsp4_device *ttsp)
+{
+	int i;
+
+	mutex_lock(&device_access_devices_lock);
+	for (i = 0; i < ARRAY_SIZE(device_access_devices); i++)
+		if (!device_access_devices[i]) {
+			device_access_devices[i] = ttsp;
+			goto exit;
+		}
+exit:
+	mutex_unlock(&device_access_devices_lock);
+}
+
+static void remove_da_device(struct cyttsp4_device *ttsp)
+{
+	int i;
+
+	mutex_lock(&device_access_devices_lock);
+	for (i = 0; i < ARRAY_SIZE(device_access_devices); i++)
+		if (device_access_devices[i] == ttsp) {
+			device_access_devices[i] = NULL;
+			goto exit;
+		}
+exit:
+	mutex_unlock(&device_access_devices_lock);
+}
+
+static struct cyttsp4_device *_find_da_device(const char *core_name)
+{
+	char ttsp_name[64];
+	int i;
+
+	scnprintf(ttsp_name, 64, "%s.%s", CYTTSP4_DEVICE_ACCESS_NAME,
+			core_name);
+
+	for (i = 0; i < ARRAY_SIZE(device_access_devices); i++) {
+		struct cyttsp4_device *ttsp = device_access_devices[i];
+		if (!ttsp || strncmp(dev_name(&ttsp->dev), ttsp_name, 64))
+			continue;
+
+		return ttsp;
+	}
+
+	return NULL;
+}
+
+int cyttsp4_device_access_read_command(const char *core_name, int ic_grpnum,
+		int ic_grpoffset, u8 *buf, int buf_size)
+{
+	struct cyttsp4_device_access_data *dad;
+	struct cyttsp4_device *ttsp;
+	struct device *dev;
+	int prev_grpnum;
+	int rc;
+
+	might_sleep();
+
+	/* Validate ic_grpnum */
+	if (ic_grpnum >= CY_IC_GRPNUM_NUM) {
+		pr_err("%s: Group %d does not exist.\n", __func__, ic_grpnum);
+		return -EINVAL;
+	}
+
+	/* Validate ic_grpoffset */
+	if (ic_grpoffset > 0xFFFF) {
+		pr_err("%s: Offset %d invalid.\n", __func__, ic_grpoffset);
+		return -EINVAL;
+	}
+
+	if (!core_name)
+		core_name = CY_DEFAULT_CORE_ID;
+
+	mutex_lock(&device_access_devices_lock);
+	/* Find device */
+	ttsp = _find_da_device(core_name);
+	if (!ttsp) {
+		pr_err("%s: No device.\n", __func__);
+		rc = -ENODEV;
+		goto exit_unlock_da;
+	}
+
+	dev = &ttsp->dev;
+	dad = dev_get_drvdata(dev);
+
+	/* Check sysinfo */
+	if (!dad->si) {
+		pr_err("%s: No sysinfo.\n", __func__);
+		rc = -ENODEV;
+		goto exit_unlock_da;
+	}
+
+	mutex_lock(&dad->sysfs_lock);
+	/*
+	 * Block grpnum change when own_exclusive flag is set
+	 * which means the current grpnum implementation requires
+	 * running exclusively on some consecutive grpdata operations
+	 */
+	if (dad->own_exclusive && dad->ic_grpnum != ic_grpnum) {
+		dev_err(dev, "%s: own_exclusive\n", __func__);
+		rc = -EBUSY;
+		goto exit;
+	}
+
+	prev_grpnum = dad->ic_grpnum;
+	dad->ic_grpnum = ic_grpnum;
+	dad->ic_grpoffset = ic_grpoffset;
+
+	rc = cyttsp4_grpdata_show_functions[dad->ic_grpnum] (dev,
+			buf, buf_size);
+
+exit:
+	mutex_unlock(&dad->sysfs_lock);
+exit_unlock_da:
+	mutex_unlock(&device_access_devices_lock);
+	return rc;
+}
+EXPORT_SYMBOL_GPL(cyttsp4_device_access_read_command);
+
+int cyttsp4_device_access_write_command(const char *core_name, int ic_grpnum,
+		int ic_grpoffset, u8 *buf, int length)
+{
+	struct cyttsp4_device_access_data *dad;
+	struct cyttsp4_device *ttsp;
+	struct device *dev;
+	int prev_grpnum;
+	int rc;
+
+	might_sleep();
+
+	/* Validate ic_grpnum */
+	if (ic_grpnum >= CY_IC_GRPNUM_NUM) {
+		pr_err("%s: Group %d does not exist.\n", __func__, ic_grpnum);
+		return -EINVAL;
+	}
+
+	/* Validate ic_grpoffset */
+	if (ic_grpoffset > 0xFFFF) {
+		pr_err("%s: Offset %d invalid.\n", __func__, ic_grpoffset);
+		return -EINVAL;
+	}
+
+	if (!core_name)
+		core_name = CY_DEFAULT_CORE_ID;
+
+	mutex_lock(&device_access_devices_lock);
+	/* Find device */
+	ttsp = _find_da_device(core_name);
+	if (!ttsp) {
+		pr_err("%s: No device.\n", __func__);
+		rc = -ENODEV;
+		goto exit_unlock_da;
+	}
+
+	dev = &ttsp->dev;
+	dad = dev_get_drvdata(dev);
+
+	/* Check sysinfo */
+	if (!dad->si) {
+		pr_err("%s: No sysinfo.\n", __func__);
+		rc = -ENODEV;
+		goto exit_unlock_da;
+	}
+
+	mutex_lock(&dad->sysfs_lock);
+	/*
+	 * Block grpnum change when own_exclusive flag is set
+	 * which means the current grpnum implementation requires
+	 * running exclusively on some consecutive grpdata operations
+	 */
+	if (dad->own_exclusive && dad->ic_grpnum != ic_grpnum) {
+		dev_err(dev, "%s: own_exclusive\n", __func__);
+		rc = -EBUSY;
+		goto exit;
+	}
+
+	prev_grpnum = dad->ic_grpnum;
+	dad->ic_grpnum = ic_grpnum;
+	dad->ic_grpoffset = ic_grpoffset;
+
+	/* write ic_buf to log */
+	cyttsp4_pr_buf(dev, dad->pr_buf, buf, length, "ic_buf");
+
+	/* Call relevant store handler. */
+	rc = cyttsp4_grpdata_store_functions[dad->ic_grpnum] (dev, buf,
+			length);
+	if (rc < 0)
+		dev_err(dev, "%s: Failed to store for grpmun=%d.\n",
+				__func__, dad->ic_grpnum);
+
+exit:
+	mutex_unlock(&dad->sysfs_lock);
+exit_unlock_da:
+	mutex_unlock(&device_access_devices_lock);
+	return rc;
+}
+EXPORT_SYMBOL_GPL(cyttsp4_device_access_write_command);
+#endif
+
+static int cyttsp4_device_access_probe(struct cyttsp4_device *ttsp)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_device_access_data *dad;
+	struct cyttsp4_device_access_platform_data *pdata =
+			dev_get_platdata(dev);
+	int rc = 0;
+	/* < DTS2013072907885 yangzicheng 20130729 begin */
+    /* < DTS2013071907628 shenjinming 20130725 begin */
+    struct kobject *kobject_ts;
+
+	dev_info(dev, "%s\n", __func__);
+	dev_dbg(dev, "%s: debug on\n", __func__);
+	dev_vdbg(dev, "%s: verbose debug on\n", __func__);
+
+	kobject_ts = kobject_create_and_add("touch_screen", NULL);
+	if (!kobject_ts)
+	{
+		printk("create kobjetct error!\n");
+		return -1;
+	}
+
+	dad = kzalloc(sizeof(*dad), GFP_KERNEL);
+	if (dad == NULL) {
+		dev_err(dev, "%s: Error, kzalloc\n", __func__);
+		rc = -ENOMEM;
+		goto cyttsp4_device_access_probe_data_failed;
+	}
+
+
+	access_dev = dev;
+    #if 0
+	rc = device_create_file(dev, &dev_attr_touch_mmi_test);
+	if (rc) {
+		dev_err(dev, "%s: Error, could not create fw_calibration\n",
+				__func__);
+		goto cyttsp4_device_access_probe_data_failed;
+	}
+    #endif
+
+	/*add the node touch_mmi_test for mmi test apk*/
+	rc = sysfs_create_file(kobject_ts, &touch_mmi_test_attribute.attr);
+	if (rc)
+	{
+		kobject_put(kobject_ts);
+		printk("touch_mmi_test create file error\n");
+		return -1;
+	}
+    
+	/* DTS2013071907628 shenjinming 20130725 end > */
+	/* DTS2013072907885 yangzicheng 20130729 end > */
+
+	mutex_init(&dad->sysfs_lock);
+	init_waitqueue_head(&dad->wait_q);
+	dad->ttsp = ttsp;
+	dad->pdata = pdata;
+	dad->ic_grpnum = CY_IC_GRPNUM_TCH_REP;
+	dad->test.cur_cmd = -1;
+	dad->heatmap.num_element = 200;
+	dev_set_drvdata(dev, dad);
+
+	pm_runtime_enable(dev);
+
+	/* get sysinfo */
+	dad->si = cyttsp4_request_sysinfo(ttsp);
+	if (dad->si) {
+		rc = cyttsp4_setup_sysfs(ttsp);
+		if (rc)
+			goto cyttsp4_device_access_setup_sysfs_failed;
+	} else {
+		dev_err(dev, "%s: Fail get sysinfo pointer from core p=%p\n",
+				__func__, dad->si);
+		cyttsp4_subscribe_attention(ttsp, CY_ATTEN_STARTUP,
+			cyttsp4_setup_sysfs_attention, 0);
+	}
+
+#ifdef CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_DEVICE_ACCESS_API
+	insert_da_device(ttsp);
+#endif
+	dev_dbg(dev, "%s: ok\n", __func__);
+	return 0;
+
+ cyttsp4_device_access_setup_sysfs_failed:
+	pm_runtime_suspend(dev);
+	pm_runtime_disable(dev);
+	dev_set_drvdata(dev, NULL);
+	kfree(dad);
+ cyttsp4_device_access_probe_data_failed:
+	dev_err(dev, "%s failed.\n", __func__);
+	return rc;
+}
+
+static int cyttsp4_device_access_release(struct cyttsp4_device *ttsp)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_device_access_data *dad = dev_get_drvdata(dev);
+	u8 ic_buf[CY_NULL_CMD_MODE_INDEX + 1];
+	dev_dbg(dev, "%s\n", __func__);
+
+#ifdef CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_DEVICE_ACCESS_API
+	remove_da_device(ttsp);
+#endif
+
+	if (dad->own_exclusive) {
+		dev_err(dev, "%s: Can't unload in CAT mode. First switch back to Operational mode\n"
+				, __func__);
+		ic_buf[CY_NULL_CMD_MODE_INDEX] = CY_HST_OPERATE;
+		cyttsp4_test_cmd_mode(dad, ic_buf, CY_NULL_CMD_MODE_INDEX + 1);
+	}
+
+	pm_runtime_suspend(dev);
+	pm_runtime_disable(dev);
+
+	if (dad->sysfs_nodes_created) {
+		device_remove_file(dev, &dev_attr_ic_grpnum);
+		device_remove_file(dev, &dev_attr_ic_grpoffset);
+		device_remove_file(dev, &dev_attr_ic_grpdata);
+		device_remove_file(dev, &dev_attr_get_panel_data);
+	} else {
+		cyttsp4_unsubscribe_attention(ttsp, CY_ATTEN_STARTUP,
+			cyttsp4_setup_sysfs_attention, 0);
+	}
+
+	dev_set_drvdata(dev, NULL);
+	kfree(dad);
+	return 0;
+}
+
+static struct cyttsp4_driver cyttsp4_device_access_driver = {
+	.probe = cyttsp4_device_access_probe,
+	.remove = cyttsp4_device_access_release,
+	.driver = {
+		.name = CYTTSP4_DEVICE_ACCESS_NAME,
+		.bus = &cyttsp4_bus_type,
+		.owner = THIS_MODULE,
+		.pm = &cyttsp4_device_access_pm_ops,
+	},
+};
+
+static struct cyttsp4_device_access_platform_data
+	_cyttsp4_device_access_platform_data = {
+	.device_access_dev_name = CYTTSP4_DEVICE_ACCESS_NAME,
+};
+
+static const char cyttsp4_device_access_name[] = CYTTSP4_DEVICE_ACCESS_NAME;
+static struct cyttsp4_device_info
+	cyttsp4_device_access_infos[CY_MAX_NUM_CORE_DEVS];
+
+static char *core_ids[CY_MAX_NUM_CORE_DEVS] = {
+	CY_DEFAULT_CORE_ID,
+	NULL,
+	NULL,
+	NULL,
+	NULL
+};
+
+static int num_core_ids = 1;
+
+module_param_array(core_ids, charp, &num_core_ids, 0);
+MODULE_PARM_DESC(core_ids,
+	"Core id list of cyttsp4 core devices for device access module");
+
+static int __init cyttsp4_device_access_init(void)
+{
+	int rc = 0;
+	int i, j;
+
+	/* Check for invalid or duplicate core_ids */
+	for (i = 0; i < num_core_ids; i++) {
+		if (!strlen(core_ids[i])) {
+			pr_err("%s: core_id %d is empty\n",
+				__func__, i+1);
+			return -EINVAL;
+		}
+		for (j = i+1; j < num_core_ids; j++)
+			if (!strcmp(core_ids[i], core_ids[j])) {
+				pr_err("%s: core_ids %d and %d are same\n",
+					__func__, i+1, j+1);
+				return -EINVAL;
+			}
+	}
+
+	for (i = 0; i < num_core_ids; i++) {
+		cyttsp4_device_access_infos[i].name =
+			cyttsp4_device_access_name;
+		cyttsp4_device_access_infos[i].core_id = core_ids[i];
+		cyttsp4_device_access_infos[i].platform_data =
+			&_cyttsp4_device_access_platform_data;
+		pr_info("%s: Registering device access device for core_id: %s\n",
+			__func__, cyttsp4_device_access_infos[i].core_id);
+		rc = cyttsp4_register_device(&cyttsp4_device_access_infos[i]);
+		if (rc < 0) {
+			pr_err("%s: Error, failed registering device\n",
+				__func__);
+			goto fail_unregister_devices;
+		}
+	}
+	rc = cyttsp4_register_driver(&cyttsp4_device_access_driver);
+	if (rc) {
+		pr_err("%s: Error, failed registering driver\n", __func__);
+		goto fail_unregister_devices;
+	}
+
+	pr_info("%s: Cypress TTSP Device Access (Built %s) rc=%d\n",
+		 __func__, CY_DRIVER_DATE, rc);
+	return 0;
+
+fail_unregister_devices:
+	for (i--; i >= 0; i--) {
+		cyttsp4_unregister_device(cyttsp4_device_access_infos[i].name,
+			cyttsp4_device_access_infos[i].core_id);
+		pr_info("%s: Unregistering device access device for core_id: %s\n",
+			__func__, cyttsp4_device_access_infos[i].core_id);
+	}
+	return rc;
+}
+module_init(cyttsp4_device_access_init);
+
+static void __exit cyttsp4_device_access_exit(void)
+{
+	int i;
+
+	cyttsp4_unregister_driver(&cyttsp4_device_access_driver);
+	for (i = 0; i < num_core_ids; i++) {
+		cyttsp4_unregister_device(cyttsp4_device_access_infos[i].name,
+			cyttsp4_device_access_infos[i].core_id);
+		pr_info("%s: Unregistering device access device for core_id: %s\n",
+			__func__, cyttsp4_device_access_infos[i].core_id);
+	}
+	pr_info("%s: module exit\n", __func__);
+}
+module_exit(cyttsp4_device_access_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Cypress TrueTouch(R) Standard Product Device Access Driver");
+MODULE_AUTHOR("Cypress Semiconductor");
diff --git a/drivers/input/touchscreen/cypress/cyttsp4_device_access.h b/drivers/input/touchscreen/cypress/cyttsp4_device_access.h
new file mode 100644
index 0000000..663cdee
--- /dev/null
+++ b/drivers/input/touchscreen/cypress/cyttsp4_device_access.h
@@ -0,0 +1,79 @@
+/*
+ * cyttsp4_device_access.h
+ * Cypress TrueTouch(TM) Standard Product V4 Device Access module.
+ * Configuration and Test command/status user interface.
+ * For use with Cypress Txx4xx parts.
+ * Supported parts include:
+ * TMA4XX
+ * TMA1036
+ *
+ * Copyright (C) 2012 Cypress Semiconductor
+ * Copyright (C) 2011 Sony Ericsson Mobile Communications AB.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2, and only version 2, as published by the
+ * Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * Contact Cypress Semiconductor at www.cypress.com <ttdrivers@cypress.com>
+ *
+ */
+
+#ifndef _LINUX_CYTTSP4_DEVICE_ACCESS_H
+#define _LINUX_CYTTSP4_DEVICE_ACCESS_H
+
+#define CYTTSP4_DEVICE_ACCESS_NAME "cyttsp4_device_access"
+
+#define CYTTSP4_INPUT_ELEM_SZ (sizeof("0xHH") + 1)
+#define CYTTSP4_TCH_PARAM_SIZE_BLK_SZ 128
+
+/* Timeout values in ms. */
+#define CY_DA_REQUEST_EXCLUSIVE_TIMEOUT	500
+
+struct cyttsp4_device_access_platform_data {
+	char const *device_access_dev_name;
+};
+/* < DTS2013072907885 yangzicheng 20130729 begin */
+/* < DTS2013070806058 shenjinming 20130708 begin */
+#define CY_CMD_IN_DATA_OFFSET_VALUE 0
+#define CY_CMD_LCL_IDAC_OFFSET 1
+
+#define CY_CMD_OUT_STATUS_OFFSET 0
+#define CY_CMD_RET_PNL_OUT_ELMNT_SZ_OFFS_H 2
+#define CY_CMD_RET_PNL_OUT_ELMNT_SZ_OFFS_L 3
+#define CY_CMD_RET_PNL_OUT_DATA_FORMAT_OFFS 4
+
+#define CY_CMD_RET_PANEL_ELMNT_SZ_MASK 0x07
+#define I2C_BUF_MAX_SIZE 250
+
+
+enum cyttsp4_scan_data_type {
+	CY_MUT_RAW,
+	CY_MUT_BASE,
+	CY_MUT_DIFF,
+	CY_SELF_RAW,
+	CY_SELF_BASE,
+	CY_SELF_DIFF,
+	CY_BAL_RAW,
+	CY_BAL_BASE,
+	CY_BAL_DIFF,
+};
+
+enum check_data_type{
+	CY_CHK_MUT_RAW,
+	CY_CHK_SELF_RAW,
+	CY_CHK_MUT_IDAC,
+	CY_CHK_SELF_IDAC,
+};
+/* DTS2013071907628 shenjinming 20130725 end > */
+/* DTS2013072907885 yangzicheng 20130729 end >*/
+#endif /* _LINUX_CYTTSP4_DEVICE_ACCESS_H */
diff --git a/drivers/input/touchscreen/cypress/cyttsp4_devtree.c b/drivers/input/touchscreen/cypress/cyttsp4_devtree.c
new file mode 100644
index 0000000..d593042
--- /dev/null
+++ b/drivers/input/touchscreen/cypress/cyttsp4_devtree.c
@@ -0,0 +1,765 @@
+/*
+ * cyttsp4_devtree.c
+ * Cypress TrueTouch(TM) Standard Product V4 Device Tree Support Driver.
+ * For use with Cypress Txx4xx parts.
+ * Supported parts include:
+ * TMA4XX
+ * TMA1036
+ *
+ * Copyright (C) 2013 Cypress Semiconductor
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2, and only version 2, as published by the
+ * Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * Contact Cypress Semiconductor at www.cypress.com <ttdrivers@cypress.com>
+ *
+ */
+
+#include <linux/device.h>
+#include <linux/err.h>
+#include <linux/of_device.h>
+#include <linux/slab.h>
+
+/* cyttsp */
+#include <linux/cyttsp4_bus.h>
+#include <linux/cyttsp4_core.h>
+#include <linux/cyttsp4_btn.h>
+#include <linux/cyttsp4_mt.h>
+#include <linux/cyttsp4_proximity.h>
+#include <linux/cyttsp4_platform.h>
+
+#include "cyttsp4_regs.h"
+#include "cyttsp4_devtree.h"
+
+#define ENABLE_VIRTUAL_KEYS
+
+#define MAX_NAME_LENGTH		64
+
+enum cyttsp4_device_type {
+	DEVICE_MT,
+	DEVICE_BTN,
+	DEVICE_PROXIMITY,
+	DEVICE_TYPE_MAX,
+};
+
+struct cyttsp4_device_pdata_func {
+	void *(*create_and_get_pdata)(struct device_node *);
+	void (*free_pdata)(void *);
+};
+
+#ifdef ENABLE_VIRTUAL_KEYS
+static struct kobject *board_properties_kobj;
+
+struct cyttsp4_virtual_keys {
+	struct kobj_attribute kobj_attr;
+	u16 *data;
+	int size;
+};
+#endif
+
+struct cyttsp4_extended_mt_platform_data {
+	struct cyttsp4_mt_platform_data pdata;
+#ifdef ENABLE_VIRTUAL_KEYS
+	struct cyttsp4_virtual_keys vkeys;
+#endif
+};
+
+static inline int get_inp_dev_name(struct device_node *dev_node,
+		const char **inp_dev_name)
+{
+	return of_property_read_string(dev_node, "cy,inp_dev_name",
+			inp_dev_name);
+}
+
+static u16 *create_and_get_u16_array(struct device_node *dev_node,
+		const char *name, int *size)
+{
+	const __be32 *values;
+	u16 *val_array;
+	int len;
+	int sz;
+	int rc;
+	int i;
+
+	values = of_get_property(dev_node, name, &len);
+	if (values == NULL)
+		return NULL;
+
+	sz = len / sizeof(u32);
+	pr_debug("%s: %s size:%d\n", __func__, name, sz);
+
+	val_array = kzalloc(sz * sizeof(u16), GFP_KERNEL);
+	if (val_array == NULL) {
+		rc = -ENOMEM;
+		goto fail;
+	}
+
+	for (i = 0; i < sz; i++)
+		val_array[i] = (u16)be32_to_cpup(values++);
+
+	*size = sz;
+
+	return val_array;
+
+fail:
+	return ERR_PTR(rc);
+}
+
+static struct touch_framework *create_and_get_touch_framework(
+		struct device_node *dev_node)
+{
+	struct touch_framework *frmwrk;
+	u16 *abs;
+	int size;
+	int rc;
+
+	abs = create_and_get_u16_array(dev_node, "cy,abs", &size);
+	if (IS_ERR_OR_NULL(abs))
+		return (void *)abs;
+
+	/* Check for valid abs size */
+	if (size % CY_NUM_ABS_SET) {
+		rc = -EINVAL;
+		goto fail_free_abs;
+	}
+
+	frmwrk = kzalloc(sizeof(*frmwrk), GFP_KERNEL);
+	if (frmwrk == NULL) {
+		rc = -ENOMEM;
+		goto fail_free_abs;
+	}
+
+	frmwrk->abs = abs;
+	frmwrk->size = size;
+
+	return frmwrk;
+
+fail_free_abs:
+	kfree(abs);
+
+	return ERR_PTR(rc);
+}
+
+static void free_touch_framework(struct touch_framework *frmwrk)
+{
+	kfree(frmwrk->abs);
+	kfree(frmwrk);
+}
+
+#ifdef ENABLE_VIRTUAL_KEYS
+#define VIRTUAL_KEY_ELEMENT_SIZE	5
+static ssize_t virtual_keys_show(struct kobject *kobj,
+		struct kobj_attribute *attr, char *buf)
+{
+	struct cyttsp4_virtual_keys *vkeys = container_of(attr,
+		struct cyttsp4_virtual_keys, kobj_attr);
+	u16 *data = vkeys->data;
+	int size = vkeys->size;
+	int index;
+	int i;
+
+	index = 0;
+	for (i = 0; i < size; i += VIRTUAL_KEY_ELEMENT_SIZE)
+		index += scnprintf(buf + index, CY_MAX_PRBUF_SIZE - index,
+			"0x01:%d:%d:%d:%d:%d\n",
+			data[i], data[i+1], data[i+2], data[i+3], data[i+4]);
+
+	return index;
+}
+
+static int setup_virtual_keys(struct device_node *dev_node,
+		const char *inp_dev_name, struct cyttsp4_virtual_keys *vkeys)
+{
+	char *name;
+	u16 *data;
+	int size;
+	int rc;
+
+	data = create_and_get_u16_array(dev_node, "cy,virtual_keys", &size);
+	if (data == NULL)
+		return 0;
+	else if (IS_ERR(data)) {
+		rc = PTR_ERR(data);
+		goto fail;
+	}
+
+	/* Check for valid virtual keys size */
+	if (size % VIRTUAL_KEY_ELEMENT_SIZE) {
+		rc = -EINVAL;
+		goto fail_free_data;
+	}
+
+	name = kzalloc(MAX_NAME_LENGTH, GFP_KERNEL);
+	if (name == NULL) {
+		rc = -ENOMEM;
+		goto fail_free_data;
+	}
+
+	snprintf(name, MAX_NAME_LENGTH, "virtualkeys.%s", inp_dev_name);
+
+	vkeys->data = data;
+	vkeys->size = size;
+
+	/* TODO: Instantiate in board file and export it */
+	if (board_properties_kobj == NULL)
+		board_properties_kobj =
+			kobject_create_and_add("board_properties", NULL);
+	if (board_properties_kobj == NULL) {
+		pr_err("%s: Cannot get board_properties kobject!\n", __func__);
+		rc = -EINVAL;
+		goto fail_free_name;
+	}
+
+	/* Initialize dynamic SysFs attribute */
+	sysfs_attr_init(&vkeys->kobj_attr.attr);
+	vkeys->kobj_attr.attr.name = name;
+	vkeys->kobj_attr.attr.mode = S_IRUGO;
+	vkeys->kobj_attr.show = virtual_keys_show;
+
+	rc = sysfs_create_file(board_properties_kobj, &vkeys->kobj_attr.attr);
+	if (rc)
+		goto fail_del_kobj;
+
+	return 0;
+
+fail_del_kobj:
+	kobject_del(board_properties_kobj);
+fail_free_name:
+	kfree(name);
+	vkeys->kobj_attr.attr.name = NULL;
+fail_free_data:
+	kfree(data);
+	vkeys->data = NULL;
+fail:
+	return rc;
+}
+
+static void free_virtual_keys(struct cyttsp4_virtual_keys *vkeys)
+{
+	if (board_properties_kobj)
+		sysfs_remove_file(board_properties_kobj,
+			&vkeys->kobj_attr.attr);
+
+	kfree(vkeys->data);
+	kfree(vkeys->kobj_attr.attr.name);
+}
+#endif
+
+static void *create_and_get_mt_pdata(struct device_node *dev_node)
+{
+	struct cyttsp4_extended_mt_platform_data *ext_pdata;
+	struct cyttsp4_mt_platform_data *pdata;
+	u32 value;
+	int rc;
+
+	ext_pdata = kzalloc(sizeof(*ext_pdata), GFP_KERNEL);
+	if (ext_pdata == NULL) {
+		rc = -ENOMEM;
+		goto fail;
+	}
+
+	pdata = &ext_pdata->pdata;
+
+	rc = get_inp_dev_name(dev_node, &pdata->inp_dev_name);
+	if (rc)
+		goto fail_free_pdata;
+
+	/* Optional fields */
+	rc = of_property_read_u32(dev_node, "cy,flags", &value);
+	if (!rc)
+		pdata->flags = value;
+
+	rc = of_property_read_u32(dev_node, "cy,vkeys_x", &value);
+	if (!rc)
+		pdata->vkeys_x = value;
+
+	rc = of_property_read_u32(dev_node, "cy,vkeys_y", &value);
+	if (!rc)
+		pdata->vkeys_y = value;
+
+	/* Required fields */
+	pdata->frmwrk = create_and_get_touch_framework(dev_node);
+	if (pdata->frmwrk == NULL) {
+		rc = -EINVAL;
+		goto fail_free_pdata;
+	} else if (IS_ERR(pdata->frmwrk)) {
+		rc = PTR_ERR(pdata->frmwrk);
+		goto fail_free_pdata;
+	}
+#ifdef ENABLE_VIRTUAL_KEYS
+	rc = setup_virtual_keys(dev_node, pdata->inp_dev_name,
+			&ext_pdata->vkeys);
+	if (rc) {
+		pr_err("%s: Cannot setup virtual keys!\n", __func__);
+		goto fail_free_pdata;
+	}
+#endif
+	return pdata;
+
+fail_free_pdata:
+	kfree(ext_pdata);
+fail:
+	return ERR_PTR(rc);
+}
+
+static void free_mt_pdata(void *pdata)
+{
+	struct cyttsp4_mt_platform_data *mt_pdata =
+		(struct cyttsp4_mt_platform_data *)pdata;
+	struct cyttsp4_extended_mt_platform_data *ext_mt_pdata =
+		container_of(mt_pdata,
+			struct cyttsp4_extended_mt_platform_data, pdata);
+
+	free_touch_framework(mt_pdata->frmwrk);
+#ifdef ENABLE_VIRTUAL_KEYS
+	free_virtual_keys(&ext_mt_pdata->vkeys);
+#endif
+	kfree(ext_mt_pdata);
+}
+
+static void *create_and_get_btn_pdata(struct device_node *dev_node)
+{
+	struct cyttsp4_btn_platform_data *pdata;
+	int rc;
+
+	pdata = kzalloc(sizeof(*pdata), GFP_KERNEL);
+	if (pdata == NULL) {
+		rc = -ENOMEM;
+		goto fail;
+	}
+
+	rc = get_inp_dev_name(dev_node, &pdata->inp_dev_name);
+	if (rc)
+		goto fail_free_pdata;
+
+	return pdata;
+
+fail_free_pdata:
+	kfree(pdata);
+fail:
+	return ERR_PTR(rc);
+}
+
+static void free_btn_pdata(void *pdata)
+{
+	struct cyttsp4_btn_platform_data *btn_pdata =
+		(struct cyttsp4_btn_platform_data *)pdata;
+
+	kfree(btn_pdata);
+}
+
+static void *create_and_get_proximity_pdata(struct device_node *dev_node)
+{
+	struct cyttsp4_proximity_platform_data *pdata;
+	int rc;
+
+	pdata = kzalloc(sizeof(*pdata), GFP_KERNEL);
+	if (pdata == NULL) {
+		rc = -ENOMEM;
+		goto fail;
+	}
+
+	rc = get_inp_dev_name(dev_node, &pdata->inp_dev_name);
+	if (rc)
+		goto fail_free_pdata;
+
+	pdata->frmwrk = create_and_get_touch_framework(dev_node);
+	if (pdata->frmwrk == NULL) {
+		rc = -EINVAL;
+		goto fail_free_pdata;
+	} else if (IS_ERR(pdata->frmwrk)) {
+		rc = PTR_ERR(pdata->frmwrk);
+		goto fail_free_pdata;
+	}
+
+	return pdata;
+
+fail_free_pdata:
+	kfree(pdata);
+fail:
+	return ERR_PTR(rc);
+}
+
+static void free_proximity_pdata(void *pdata)
+{
+	struct cyttsp4_proximity_platform_data *proximity_pdata =
+		(struct cyttsp4_proximity_platform_data *)pdata;
+
+	free_touch_framework(proximity_pdata->frmwrk);
+
+	kfree(proximity_pdata);
+}
+
+static struct cyttsp4_device_pdata_func device_pdata_funcs[DEVICE_TYPE_MAX] = {
+	[DEVICE_MT] = {
+		.create_and_get_pdata = create_and_get_mt_pdata,
+		.free_pdata = free_mt_pdata,
+	},
+	[DEVICE_BTN] = {
+		.create_and_get_pdata = create_and_get_btn_pdata,
+		.free_pdata = free_btn_pdata,
+	},
+	[DEVICE_PROXIMITY] = {
+		.create_and_get_pdata = create_and_get_proximity_pdata,
+		.free_pdata = free_proximity_pdata,
+	},
+};
+
+static const char *device_names[DEVICE_TYPE_MAX] = {
+	[DEVICE_MT] = "cy,mt",
+	[DEVICE_BTN] = "cy,btn",
+	[DEVICE_PROXIMITY] = "cy,proximity",
+};
+
+static int get_device_type(struct device_node *dev_node,
+		enum cyttsp4_device_type *type)
+{
+	const char *name;
+	enum cyttsp4_device_type t;
+	int rc;
+
+	rc = of_property_read_string(dev_node, "name", &name);
+	if (rc)
+		return rc;
+
+	for (t = 0; t < DEVICE_TYPE_MAX; t++)
+		if (!strncmp(name, device_names[t], MAX_NAME_LENGTH)) {
+			*type = t;
+			return 0;
+		}
+
+	return -EINVAL;
+}
+
+static inline void *create_and_get_device_pdata(struct device_node *dev_node,
+		enum cyttsp4_device_type type)
+{
+	return device_pdata_funcs[type].create_and_get_pdata(dev_node);
+}
+
+static inline void free_device_pdata(void *pdata,
+		enum cyttsp4_device_type type)
+{
+	device_pdata_funcs[type].free_pdata(pdata);
+}
+
+static int register_device(struct device_node *dev_node,
+		const char *core_id)
+{
+	struct cyttsp4_device_info info = {0};
+	enum cyttsp4_device_type type;
+	int rc;
+
+	info.core_id = core_id;
+
+	rc = of_property_read_string(dev_node, "cy,name", &info.name);
+	if (rc) {
+		pr_err("%s: OF error rc=%d\n", __func__, rc);
+		goto fail;
+	} else
+		pr_debug("%s: OF cy,name: %s\n", __func__, info.name);
+
+	rc = get_device_type(dev_node, &type);
+	if (rc)
+		goto fail;
+
+	info.platform_data = create_and_get_device_pdata(dev_node, type);
+	if (IS_ERR(info.platform_data)) {
+		rc = PTR_ERR(info.platform_data);
+		goto fail;
+	}
+
+	rc = cyttsp4_register_device(&info);
+	if (rc)
+		goto fail_free;
+
+	return 0;
+
+fail_free:
+	free_device_pdata(info.platform_data, type);
+fail:
+	return rc;
+}
+
+static struct touch_settings *create_and_get_touch_setting(
+		struct device_node *core_node, const char *name)
+{
+	struct touch_settings *setting;
+	char *tag_name;
+	u32 tag_value;
+	u16 *data;
+	int size;
+	int rc;
+
+	data = create_and_get_u16_array(core_node, name, &size);
+	if (IS_ERR_OR_NULL(data))
+		return (void *)data;
+
+	pr_debug("%s: Touch setting:'%s' size:%d\n", __func__, name, size);
+
+	setting = kzalloc(sizeof(*setting), GFP_KERNEL);
+	if (setting == NULL) {
+		rc = -ENOMEM;
+		goto fail_free_data;
+	}
+
+	setting->data = (u8 *)data;
+	setting->size = size;
+
+	tag_name = kzalloc(MAX_NAME_LENGTH, GFP_KERNEL);
+	if (tag_name == NULL) {
+		rc = -ENOMEM;
+		goto fail_free_setting;
+	}
+
+	snprintf(tag_name, MAX_NAME_LENGTH, "%s-tag", name);
+
+	rc = of_property_read_u32(core_node, tag_name, &tag_value);
+	if (!rc)
+		setting->tag = tag_value;
+
+	kfree(tag_name);
+
+	return setting;
+
+fail_free_setting:
+	kfree(setting);
+fail_free_data:
+	kfree(data);
+
+	return ERR_PTR(rc);
+}
+
+static void free_touch_setting(struct touch_settings *setting)
+{
+	if (setting) {
+		kfree(setting->data);
+		kfree(setting);
+	}
+}
+
+static char *touch_setting_names[CY_IC_GRPNUM_NUM] = {
+	NULL,			/* CY_IC_GRPNUM_RESERVED */
+	"cy,cmd_regs",		/* CY_IC_GRPNUM_CMD_REGS */
+	"cy,tch_rep",		/* CY_IC_GRPNUM_TCH_REP */
+	"cy,data_rec",		/* CY_IC_GRPNUM_DATA_REC */
+	"cy,test_rec",		/* CY_IC_GRPNUM_TEST_REC */
+	"cy,pcfg_rec",		/* CY_IC_GRPNUM_PCFG_REC */
+	"cy,tch_parm_val",	/* CY_IC_GRPNUM_TCH_PARM_VAL */
+	"cy,tch_parm_size",	/* CY_IC_GRPNUM_TCH_PARM_SIZE */
+	NULL,			/* CY_IC_GRPNUM_RESERVED1 */
+	NULL,			/* CY_IC_GRPNUM_RESERVED2 */
+	"cy,opcfg_rec",		/* CY_IC_GRPNUM_OPCFG_REC */
+	"cy,ddata_rec",		/* CY_IC_GRPNUM_DDATA_REC */
+	"cy,mdata_rec",		/* CY_IC_GRPNUM_MDATA_REC */
+	"cy,test_regs",		/* CY_IC_GRPNUM_TEST_REGS */
+	"cy,btn_keys",		/* CY_IC_GRPNUM_BTN_KEYS */
+	NULL,			/* CY_IC_GRPNUM_TTHE_REGS */
+};
+
+static struct cyttsp4_core_platform_data *create_and_get_core_pdata(
+		struct device_node *core_node)
+{
+	struct cyttsp4_core_platform_data *pdata;
+	u32 value;
+	int rc;
+	int i;
+
+	pdata = kzalloc(sizeof(*pdata), GFP_KERNEL);
+	if (pdata == NULL) {
+		rc = -ENOMEM;
+		goto fail;
+	}
+
+	/* Required fields */
+	rc = of_property_read_u32(core_node, "cy,irq_gpio", &value);
+	if (rc)
+		goto fail_free;
+	pdata->irq_gpio = value;
+
+	/* Optional fields */
+	/* rst_gpio is optional since a platform may use
+	 * power cycling instead of using the XRES pin
+	 */
+	rc = of_property_read_u32(core_node, "cy,rst_gpio", &value);
+	if (!rc)
+		pdata->rst_gpio = value;
+
+	rc = of_property_read_u32(core_node, "cy,level_irq_udelay", &value);
+	if (!rc)
+		pdata->level_irq_udelay = value;
+
+	rc = of_property_read_u32(core_node, "cy,max_xfer_len", &value);
+	if (!rc)
+		pdata->max_xfer_len = value;
+
+	rc = of_property_read_u32(core_node, "cy,flags", &value);
+	if (!rc)
+		pdata->flags = value;
+
+	rc = of_property_read_u32(core_node, "cy,easy_wakeup_gesture", &value);
+	if (!rc)
+		pdata->easy_wakeup_gesture = (u8)value;
+
+	for (i = 0; (unsigned int)i < ARRAY_SIZE(touch_setting_names); i++) {
+		if (touch_setting_names[i] == NULL)
+			continue;
+
+		pdata->sett[i] = create_and_get_touch_setting(core_node,
+				touch_setting_names[i]);
+		if (IS_ERR(pdata->sett[i])) {
+			rc = PTR_ERR(pdata->sett[i]);
+			goto fail_free_sett;
+		} else if (pdata->sett[i] == NULL)
+			pr_debug("%s: No data for setting '%s'\n", __func__,
+				touch_setting_names[i]);
+	}
+
+	pr_debug("%s: irq_gpio:%d rst_gpio:%d level_irq_udelay:%d\n"
+		"max_xfer_len:%d flags:%d easy_wakeup_gesture:%d\n", __func__,
+		pdata->irq_gpio, pdata->rst_gpio, pdata->level_irq_udelay,
+		pdata->max_xfer_len, pdata->flags, pdata->easy_wakeup_gesture);
+
+	pdata->xres = cyttsp4_xres;
+	pdata->init = cyttsp4_init;
+	pdata->power = cyttsp4_power;
+#ifdef CYTTSP4_DETECT_HW
+	pdata->detect = cyttsp4_detect;
+#endif
+	pdata->irq_stat = cyttsp4_irq_stat;
+
+	pdata->loader_pdata = &_cyttsp4_loader_platform_data;
+
+	return pdata;
+
+fail_free_sett:
+	for (i--; i >= 0; i--)
+		free_touch_setting(pdata->sett[i]);
+fail_free:
+	kfree(pdata);
+fail:
+	return ERR_PTR(rc);
+}
+
+static void free_core_pdata(struct cyttsp4_core_platform_data *pdata)
+{
+	int i;
+
+	for (i = 0; i < CY_TOUCH_SETTINGS_MAX; i++)
+		free_touch_setting(pdata->sett[i]);
+
+	kfree(pdata);
+}
+
+static int register_core_device(struct device_node *core_node,
+		const char *adap_id, const char **core_id)
+{
+	struct cyttsp4_core_info info = {0};
+	int rc;
+
+	rc = of_property_read_string(core_node, "cy,name", &info.name);
+	if (rc) {
+		pr_err("%s: OF error rc=%d\n", __func__, rc);
+		goto fail;
+	} else
+		pr_debug("%s: OF cy,name: %s\n", __func__, info.name);
+
+	rc = of_property_read_string(core_node, "cy,id", &info.id);
+	if (rc) {
+		pr_err("%s: OF error rc=%d\n", __func__, rc);
+		goto fail;
+	} else
+		pr_debug("%s: OF cy,id: %s\n", __func__, info.id);
+
+	info.platform_data = create_and_get_core_pdata(core_node);
+	if (IS_ERR(info.platform_data)) {
+		rc = PTR_ERR(info.platform_data);
+		goto fail;
+	}
+
+	info.adap_id = adap_id;
+
+	rc = cyttsp4_register_core_device(&info);
+	if (rc)
+		goto fail_free;
+
+	*core_id = info.id;
+
+	return 0;
+
+fail_free:
+	free_core_pdata(info.platform_data);
+fail:
+	return rc;
+}
+
+int cyttsp4_devtree_register_devices(struct device *adap_dev)
+{
+	struct device_node *core_node, *dev_node;
+	const char *adap_id;
+	int count = 0;
+	int rc;
+
+	if (!adap_dev->of_node)
+		return 0;
+
+	rc = of_property_read_string(adap_dev->of_node, "cy,adapter_id",
+			&adap_id);
+	if (rc)
+		return rc;
+
+	/* There should be only one core node */
+	for_each_child_of_node(adap_dev->of_node, core_node) {
+		const char *core_id = NULL;
+		const char *name;
+
+		rc = of_property_read_string(core_node, "name", &name);
+		if (!rc)
+			pr_debug("%s: name:%s\n", __func__, name);
+
+		rc = register_core_device(core_node, adap_id, &core_id);
+		if (rc)
+			break;
+		/* Increment reference count */
+		of_node_get(core_node);
+
+		for_each_child_of_node(core_node, dev_node) {
+			count++;
+			rc = register_device(dev_node, core_id);
+			if (rc)
+				break;
+			/* Increment reference count */
+			of_node_get(dev_node);
+		}
+	}
+
+	pr_debug("%s: %d child node(s) found\n", __func__, count);
+
+	return rc;
+}
+EXPORT_SYMBOL_GPL(cyttsp4_devtree_register_devices);
+
+static int __init cyttsp4_devtree_init(void)
+{
+	return 0;
+}
+module_init(cyttsp4_devtree_init);
+
+static void __exit cyttsp4_devtree_exit(void)
+{
+}
+module_exit(cyttsp4_devtree_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Cypress Semiconductor");
diff --git a/drivers/input/touchscreen/cypress/cyttsp4_devtree.h b/drivers/input/touchscreen/cypress/cyttsp4_devtree.h
new file mode 100644
index 0000000..2464d75
--- /dev/null
+++ b/drivers/input/touchscreen/cypress/cyttsp4_devtree.h
@@ -0,0 +1,36 @@
+/*
+ * cyttsp4_devtree.h
+ * Cypress TrueTouch(TM) Standard Product V4 Device Tree Support Driver
+ * For use with Cypress Txx4xx parts.
+ * Supported parts include:
+ * TMA4XX
+ * TMA1036
+ *
+ * Copyright (C) 2013 Cypress Semiconductor
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2, and only version 2, as published by the
+ * Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * Contact Cypress Semiconductor at www.cypress.com <ttdrivers@cypress.com>
+ *
+ */
+
+#ifdef CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_DEVICETREE_SUPPORT
+extern int cyttsp4_devtree_register_devices(struct device *adap_dev);
+#else
+static inline int cyttsp4_devtree_register_devices(struct device *adap_dev)
+{
+	return 0;
+}
+#endif
diff --git a/drivers/input/touchscreen/cypress/cyttsp4_i2c.c b/drivers/input/touchscreen/cypress/cyttsp4_i2c.c
new file mode 100644
index 0000000..7ba8cd0
--- /dev/null
+++ b/drivers/input/touchscreen/cypress/cyttsp4_i2c.c
@@ -0,0 +1,326 @@
+/*
+ * cyttsp4_i2c.c
+ * Cypress TrueTouch(TM) Standard Product V4 I2C Driver module.
+ * For use with Cypress Txx4xx parts.
+ * Supported parts include:
+ * TMA4XX
+ * TMA1036
+ *
+ * Copyright (C) 2012 Cypress Semiconductor
+ * Copyright (C) 2011 Sony Ericsson Mobile Communications AB.
+ *
+ * Author: Aleksej Makarov <aleksej.makarov@sonyericsson.com>
+ * Modified by: Cypress Semiconductor for test with device
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2, and only version 2, as published by the
+ * Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * Contact Cypress Semiconductor at www.cypress.com <ttdrivers@cypress.com>
+ *
+ */
+
+#include <linux/cyttsp4_bus.h>
+#include <linux/cyttsp4_core.h>
+#include "cyttsp4_i2c.h"
+
+#include <linux/delay.h>
+#include <linux/hrtimer.h>
+#include <linux/i2c.h>
+#include <linux/init.h>
+#include <linux/of_device.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/pm_runtime.h>
+#include <linux/slab.h>
+ #include <linux/regulator/consumer.h>
+
+#include "cyttsp4_devtree.h"
+
+#define CY_I2C_DATA_SIZE  (3 * 256)
+
+struct cyttsp4_i2c {
+	struct i2c_client *client;
+	u8 wr_buf[CY_I2C_DATA_SIZE];
+	char const *id;
+	struct mutex lock;
+};
+
+static int cyttsp4_i2c_read_block_data(struct cyttsp4_i2c *ts_i2c, u16 addr,
+		int length, void *values, int max_xfer)
+{
+	int rc = -EINVAL;
+	int trans_len;
+	u8 client_addr;
+	u8 addr_lo;
+	struct i2c_msg msgs[2];
+
+	while (length > 0) {
+		client_addr = ts_i2c->client->addr | ((addr >> 8) & 0x1);
+		addr_lo = addr & 0xFF;
+		trans_len = min(length, max_xfer);
+
+		memset(msgs, 0, sizeof(msgs));
+		msgs[0].addr = client_addr;
+		msgs[0].flags = 0;
+		msgs[0].len = 1;
+		msgs[0].buf = &addr_lo;
+
+		msgs[1].addr = client_addr;
+		msgs[1].flags = I2C_M_RD;
+		msgs[1].len = trans_len;
+		msgs[1].buf = values;
+
+		rc = i2c_transfer(ts_i2c->client->adapter, msgs, 2);
+		if (rc != 2)
+			goto exit;
+
+		length -= trans_len;
+		values += trans_len;
+		addr += trans_len;
+	}
+
+exit:
+	return (rc < 0) ? rc : rc != ARRAY_SIZE(msgs) ? -EIO : 0;
+}
+
+static int cyttsp4_i2c_write_block_data(struct cyttsp4_i2c *ts_i2c, u16 addr,
+		int length, const void *values, int max_xfer)
+{
+	int rc = -EINVAL;
+	u8 client_addr;
+	u8 addr_lo;
+	int trans_len;
+	struct i2c_msg msg;
+
+	if (sizeof(ts_i2c->wr_buf) < (length + 1))
+		return -ENOMEM;
+
+	while (length > 0) {
+		client_addr = ts_i2c->client->addr | ((addr >> 8) & 0x1);
+		addr_lo = addr & 0xFF;
+		trans_len = min(length, max_xfer);
+
+		memset(&msg, 0, sizeof(msg));
+		msg.addr = client_addr;
+		msg.flags = 0;
+		msg.len = trans_len + 1;
+		msg.buf = ts_i2c->wr_buf;
+
+		ts_i2c->wr_buf[0] = addr_lo;
+		memcpy(&ts_i2c->wr_buf[1], values, trans_len);
+
+		/* write data */
+		rc = i2c_transfer(ts_i2c->client->adapter, &msg, 1);
+		if (rc != 1)
+			goto exit;
+
+		length -= trans_len;
+		values += trans_len;
+		addr += trans_len;
+	}
+
+exit:
+	return (rc < 0) ? rc : rc != 1 ? -EIO : 0;
+}
+
+static int cyttsp4_i2c_write(struct cyttsp4_adapter *adap, u16 addr,
+	const void *buf, int size, int max_xfer)
+{
+	struct cyttsp4_i2c *ts = dev_get_drvdata(adap->dev);
+	int rc;
+
+	pm_runtime_get_noresume(adap->dev);
+	mutex_lock(&ts->lock);
+	rc = cyttsp4_i2c_write_block_data(ts, addr, size, buf, max_xfer);
+	mutex_unlock(&ts->lock);
+	pm_runtime_put_noidle(adap->dev);
+
+	return rc;
+}
+
+static int cyttsp4_i2c_read(struct cyttsp4_adapter *adap, u16 addr,
+	void *buf, int size, int max_xfer)
+{
+	struct cyttsp4_i2c *ts = dev_get_drvdata(adap->dev);
+	int rc;
+
+	pm_runtime_get_noresume(adap->dev);
+	mutex_lock(&ts->lock);
+	rc = cyttsp4_i2c_read_block_data(ts, addr, size, buf, max_xfer);
+	mutex_unlock(&ts->lock);
+	pm_runtime_put_noidle(adap->dev);
+
+	return rc;
+}
+
+static struct cyttsp4_ops ops = {
+	.write = cyttsp4_i2c_write,
+	.read = cyttsp4_i2c_read,
+};
+
+static struct of_device_id cyttsp4_i2c_of_match[] = {
+	{ .compatible = "cy,cyttsp4_i2c_adapter", }, { }
+};
+MODULE_DEVICE_TABLE(of, cyttsp4_i2c_of_match);
+
+static int __devinit cyttsp4_i2c_probe(struct i2c_client *client,
+	const struct i2c_device_id *i2c_id)
+{
+	struct cyttsp4_i2c *ts_i2c;
+	struct device *dev = &client->dev;
+	const struct of_device_id *match;
+	char const *adap_id;
+	int rc;
+#if 1 
+	struct regulator *vdd;
+    struct regulator *vcc_i2c;
+#endif
+
+	dev_info(dev, "%s: Starting %s probe...\n", __func__, CYTTSP4_I2C_NAME);
+
+	dev_dbg(dev, "%s: debug on\n", __func__);
+	dev_vdbg(dev, "%s: verbose debug on\n", __func__);
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		dev_err(dev, "%s: fail check I2C functionality\n", __func__);
+		rc = -EIO;
+		goto error_alloc_data_failed;
+	}
+#if 1 
+	vdd = regulator_get(&client->dev, "vdd");
+	vcc_i2c = regulator_get(&client->dev, "vcc_i2c");
+	rc = regulator_set_voltage(vdd,2600000,3300000);
+	if (rc < 0){
+		dev_dbg(dev, "%s:regulator_set_voltage vdd failed \n", __func__);
+		}
+	rc = regulator_set_voltage(vcc_i2c,1800000,1800000);
+	if (rc < 0){
+		dev_dbg(dev, "%s:regulator_set_voltage vcc_i2c failed \n", __func__);
+		}
+	rc = regulator_enable(vdd);
+	if (rc < 0){
+		dev_dbg(dev, "%s:regulator_enable vdd failed \n", __func__);
+		}
+	rc = regulator_enable(vcc_i2c);
+	if (rc < 0){
+		dev_dbg(dev, "%s:regulator_enable vcc_i2c failed \n", __func__);
+		}
+#endif
+	msleep(200);
+
+	ts_i2c = kzalloc(sizeof(struct cyttsp4_i2c), GFP_KERNEL);
+	if (ts_i2c == NULL) {
+		dev_err(dev, "%s: Error, kzalloc.\n", __func__);
+		rc = -ENOMEM;
+		goto error_alloc_data_failed;
+	}
+
+	match = of_match_device(of_match_ptr(cyttsp4_i2c_of_match), dev);
+	if (match) {
+		rc = of_property_read_string(dev->of_node, "cy,adapter_id",
+				&adap_id);
+		if (rc) {
+			dev_err(dev, "%s: OF error rc=%d\n", __func__, rc);
+			goto error_free_data;
+		}
+		cyttsp4_devtree_register_devices(dev);
+	} else {
+		adap_id = dev_get_platdata(dev);
+	}
+
+	mutex_init(&ts_i2c->lock);
+	ts_i2c->client = client;
+	ts_i2c->id = (adap_id) ? adap_id : CYTTSP4_I2C_NAME;
+	client->dev.bus = &i2c_bus_type;
+	i2c_set_clientdata(client, ts_i2c);
+	dev_set_drvdata(&client->dev, ts_i2c);
+
+	dev_dbg(dev, "%s: add adap='%s' (CYTTSP4_I2C_NAME=%s)\n", __func__,
+		ts_i2c->id, CYTTSP4_I2C_NAME);
+
+	pm_runtime_enable(&client->dev);
+
+	rc = cyttsp4_add_adapter(ts_i2c->id, &ops, dev);
+	if (rc) {
+		dev_err(dev, "%s: Error on probe %s\n", __func__,
+			CYTTSP4_I2C_NAME);
+		goto add_adapter_err;
+	}
+
+	dev_info(dev, "%s: Successful probe %s\n", __func__, CYTTSP4_I2C_NAME);
+
+	return 0;
+
+add_adapter_err:
+	pm_runtime_disable(&client->dev);
+	dev_set_drvdata(&client->dev, NULL);
+	i2c_set_clientdata(client, NULL);
+error_free_data:
+	kfree(ts_i2c);
+error_alloc_data_failed:
+	return rc;
+}
+
+/* registered in driver struct */
+static int __devexit cyttsp4_i2c_remove(struct i2c_client *client)
+{
+	struct device *dev = &client->dev;
+	struct cyttsp4_i2c *ts_i2c = dev_get_drvdata(dev);
+
+	dev_info(dev, "%s\n", __func__);
+	cyttsp4_del_adapter(ts_i2c->id);
+	pm_runtime_disable(&client->dev);
+	dev_set_drvdata(&client->dev, NULL);
+	i2c_set_clientdata(client, NULL);
+	kfree(ts_i2c);
+	return 0;
+}
+
+static const struct i2c_device_id cyttsp4_i2c_id[] = {
+	{ CYTTSP4_I2C_NAME, 0 },  { }
+};
+MODULE_DEVICE_TABLE(i2c, cyttsp4_i2c_id);
+
+static struct i2c_driver cyttsp4_i2c_driver = {
+	.driver = {
+		.name = CYTTSP4_I2C_NAME,
+		.owner = THIS_MODULE,
+		.of_match_table = cyttsp4_i2c_of_match,
+	},
+	.probe = cyttsp4_i2c_probe,
+	.remove = __devexit_p(cyttsp4_i2c_remove),
+	.id_table = cyttsp4_i2c_id,
+};
+
+static int __init cyttsp4_i2c_init(void)
+{
+	int rc = i2c_add_driver(&cyttsp4_i2c_driver);
+
+	pr_info("%s: Cypress TTSP I2C Touchscreen Driver (Built %s) rc=%d\n",
+		 __func__, CY_DRIVER_DATE, rc);
+	return rc;
+}
+module_init(cyttsp4_i2c_init);
+
+static void __exit cyttsp4_i2c_exit(void)
+{
+	i2c_del_driver(&cyttsp4_i2c_driver);
+	pr_info("%s: module exit\n", __func__);
+}
+module_exit(cyttsp4_i2c_exit);
+
+MODULE_ALIAS(CYTTSP4_I2C_NAME);
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Cypress TrueTouch(R) Standard Product (TTSP) I2C driver");
+MODULE_AUTHOR("Cypress");
diff --git a/drivers/input/touchscreen/cypress/cyttsp4_i2c.h b/drivers/input/touchscreen/cypress/cyttsp4_i2c.h
new file mode 100644
index 0000000..94fd104
--- /dev/null
+++ b/drivers/input/touchscreen/cypress/cyttsp4_i2c.h
@@ -0,0 +1,35 @@
+/*
+ * cyttsp4_i2c.h
+ * Cypress TrueTouch(TM) Standard Product V4 I2C driver module.
+ * For use with Cypress Txx4xx parts.
+ * Supported parts include:
+ * TMA4XX
+ * TMA1036
+ *
+ * Copyright (C) 2012 Cypress Semiconductor
+ * Copyright (C) 2011 Sony Ericsson Mobile Communications AB.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2, and only version 2, as published by the
+ * Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * Contact Cypress Semiconductor at www.cypress.com <ttdrivers@cypress.com>
+ *
+ */
+
+#ifndef _LINUX_CYTTSP4_I2C_H
+#define _LINUX_CYTTSP4_I2C_H
+
+#define CYTTSP4_I2C_NAME "cyttsp4_i2c_adapter"
+
+#endif /* _LINUX_CYTTSP4_I2C_H */
diff --git a/drivers/input/touchscreen/cypress/cyttsp4_img.h b/drivers/input/touchscreen/cypress/cyttsp4_img.h
new file mode 100644
index 0000000..52248bc
--- /dev/null
+++ b/drivers/input/touchscreen/cypress/cyttsp4_img.h
@@ -0,0 +1,3990 @@
+/* < DTS2013050605374 shenjinming 20130508 begin */
+
+/*< DTS2013012402104 houming 20130124 beging */
+/* Update the new firmware, support ofilm and truly */
+static u8 cyttsp4_ver[] = {
+	0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x68, 0xB6
+};
+static u8 cyttsp4_img[] = {
+	0x00, 0x00, 0x24, 0x00, 0x80, 0x00, 0x20, 0x00, 0x20, 0x25, 0x13, 0x00, 0x00, 0x55, 0x16, 0x00,
+	0x00, 0x55, 0x16, 0x00, 0x00, 0x55, 0x16, 0x00, 0x00, 0x55, 0x16, 0x00, 0x00, 0x55, 0x16, 0x00,
+	0x00, 0x55, 0x16, 0x00, 0x00, 0x55, 0x16, 0x00, 0x00, 0x55, 0x16, 0x00, 0x00, 0x55, 0x16, 0x00,
+	0x00, 0x55, 0x16, 0x00, 0x00, 0x55, 0x16, 0x00, 0x00, 0x55, 0x16, 0x00, 0x00, 0x55, 0x16, 0x00,
+	0x00, 0x55, 0x16, 0x00, 0x00, 0x55, 0x16, 0x00, 0x00, 0x55, 0x16, 0x00, 0x00, 0x55, 0x16, 0x00,
+	0x00, 0x55, 0x16, 0x00, 0x00, 0x55, 0x16, 0x00, 0x00, 0x55, 0x16, 0x00, 0x00, 0x55, 0x16, 0x00,
+	0x00, 0x55, 0x16, 0x00, 0x00, 0x55, 0x16, 0x00, 0x00, 0x55, 0x16, 0x00, 0x00, 0x55, 0x16, 0x00,
+	0x00, 0x55, 0x16, 0x00, 0x00, 0x55, 0x16, 0x00, 0x00, 0x55, 0x16, 0x00, 0x00, 0x55, 0x16, 0x00,
+	0x00, 0x55, 0x16, 0x00, 0x00, 
+	0x00, 0x00, 0x25, 0x00, 0x80, 0x00, 0xF0, 0x02, 0xF8, 0x00, 0xF0, 0x40, 0xF8, 0x0C, 0xA0, 0x30,
+	0xC8, 0x08, 0x38, 0x24, 0x18, 0x2D, 0x18, 0xA2, 0x46, 0x67, 0x1E, 0xAB, 0x46, 0x54, 0x46, 0x5D,
+	0x46, 0xAC, 0x42, 0x01, 0xD1, 0x00, 0xF0, 0x32, 0xF8, 0x7E, 0x46, 0x0F, 0x3E, 0x0F, 0xCC, 0xB6,
+	0x46, 0x01, 0x26, 0x33, 0x42, 0x00, 0xD0, 0xFB, 0x1A, 0xA2, 0x46, 0xAB, 0x46, 0x33, 0x43, 0x18,
+	0x47, 0xA0, 0xCE, 0x00, 0x00, 0xD0, 0xCE, 0x00, 0x00, 0x10, 0x3A, 0x02, 0xD3, 0x78, 0xC8, 0x78,
+	0xC1, 0xFA, 0xD8, 0x52, 0x07, 0x01, 0xD3, 0x30, 0xC8, 0x30, 0xC1, 0x01, 0xD5, 0x04, 0x68, 0x0C,
+	0x60, 0x70, 0x47, 0x00, 0x00, 0x00, 0x23, 0x00, 0x24, 0x00, 0x25, 0x00, 0x26, 0x10, 0x3A, 0x01,
+	0xD3, 0x78, 0xC1, 0xFB, 0xD8, 0x52, 0x07, 0x00, 0xD3, 0x30, 0xC1, 0x00, 0xD5, 0x0B, 0x60, 0x70,
+	0x47, 0x1F, 0xB5, 0xC0, 0x46, 
+	0x00, 0x00, 0x26, 0x00, 0x80, 0xC0, 0x46, 0x1F, 0xBD, 0x10, 0xB5, 0x10, 0xBD, 0x03, 0x48, 0x85,
+	0x46, 0xFF, 0xF7, 0xF6, 0xFF, 0x00, 0xF0, 0xB9, 0xF9, 0x0C, 0xF0, 0x7E, 0xFC, 0x00, 0x20, 0x00,
+	0x20, 0xFF, 0xF7, 0xF2, 0xFF, 0x0C, 0xF0, 0x7E, 0xFC, 0x01, 0x4B, 0x9D, 0x46, 0x01, 0x48, 0x00,
+	0x47, 0x00, 0x20, 0x00, 0x20, 0x81, 0x12, 0x00, 0x00, 0x70, 0xB5, 0x05, 0x46, 0x0C, 0x46, 0x16,
+	0x46, 0x02, 0xE0, 0x0F, 0xCC, 0x0F, 0xC5, 0x10, 0x3E, 0x10, 0x2E, 0xFA, 0xD2, 0x08, 0x2E, 0x02,
+	0xD3, 0x03, 0xCC, 0x03, 0xC5, 0x08, 0x3E, 0x04, 0x2E, 0x07, 0xD3, 0x01, 0xCC, 0x01, 0xC5, 0x36,
+	0x1F, 0x03, 0xE0, 0x21, 0x78, 0x29, 0x70, 0x64, 0x1C, 0x6D, 0x1C, 0x76, 0x1E, 0xF9, 0xD2, 0x70,
+	0xBD, 0x10, 0xB5, 0x19, 0x4C, 0x19, 0x4B, 0x00, 0x20, 0x21, 0x5C, 0x00, 0x29, 0x0F, 0xD0, 0x4A,
+	0x07, 0x52, 0x0F, 0x52, 0x1C, 
+	0x00, 0x00, 0x27, 0x00, 0x80, 0x09, 0x06, 0xC9, 0x0E, 0x05, 0xD1, 0x07, 0x2A, 0x03, 0xD9, 0x20,
+	0x18, 0x00, 0x7A, 0xD8, 0x61, 0x03, 0xE0, 0x80, 0x18, 0x40, 0x1C, 0x80, 0x28, 0xEC, 0xD3, 0x0E,
+	0x49, 0x0E, 0x4A, 0x00, 0x20, 0x80, 0x31, 0x20, 0x32, 0x84, 0x00, 0x0C, 0x59, 0x94, 0x42, 0x04,
+	0xD1, 0x80, 0x00, 0x40, 0x18, 0x40, 0x68, 0x18, 0x62, 0x02, 0xE0, 0x80, 0x1C, 0x10, 0x28, 0xF3,
+	0xD3, 0x03, 0x20, 0x01, 0x21, 0x00, 0x04, 0x89, 0x07, 0x48, 0x61, 0x04, 0xF0, 0xDF, 0xFD, 0x04,
+	0xF0, 0x47, 0xFC, 0x04, 0xF0, 0xA9, 0xFC, 0xFE, 0xE7, 0x80, 0xF0, 0xFF, 0x0F, 0x00, 0xFF, 0x00,
+	0x40, 0x12, 0x1F, 0x42, 0x60, 0x09, 0x1D, 0x01, 0x60, 0x00, 0x22, 0x40, 0x39, 0xCA, 0x63, 0x70,
+	0x47, 0xC9, 0x1D, 0x89, 0x08, 0x02, 0x68, 0x89, 0x00, 0x53, 0x18, 0x03, 0x60, 0x40, 0x3B, 0xD9,
+	0x63, 0x43, 0x68, 0x59, 0x1A, 
+	0x00, 0x00, 0x28, 0x00, 0x80, 0x41, 0x60, 0x10, 0x46, 0x70, 0x47, 0x02, 0x68, 0x11, 0x46, 0x40,
+	0x39, 0xC9, 0x6B, 0x52, 0x1A, 0x02, 0x60, 0x42, 0x68, 0x51, 0x18, 0x41, 0x60, 0x70, 0x47, 0x00,
+	0x00, 0xF0, 0xB5, 0x8C, 0x46, 0x05, 0x46, 0x3C, 0x49, 0x00, 0x20, 0x03, 0x46, 0x8A, 0x60, 0x89,
+	0x15, 0x29, 0x40, 0x3A, 0x4F, 0x0C, 0x04, 0x96, 0x07, 0xE4, 0x19, 0x00, 0x2E, 0x11, 0x46, 0x13,
+	0xD0, 0xFF, 0x27, 0xCE, 0x07, 0x01, 0x37, 0x2F, 0x40, 0x34, 0x49, 0x3F, 0x04, 0x7F, 0x18, 0x3F,
+	0x0C, 0x00, 0x2E, 0x06, 0xD0, 0x14, 0x70, 0x26, 0x0A, 0x56, 0x70, 0x97, 0x70, 0x24, 0x0E, 0xD4,
+	0x70, 0x03, 0xE0, 0x14, 0x80, 0x57, 0x80, 0x00, 0xE0, 0x0C, 0x60, 0x11, 0x1D, 0x8E, 0x07, 0x7F,
+	0x24, 0x00, 0x2E, 0x0B, 0xD0, 0xCE, 0x07, 0x00, 0x27, 0x00, 0x2E, 0x04, 0xD0, 0x0C, 0x70, 0x4F,
+	0x70, 0x8F, 0x70, 0xCF, 0x70, 
+	0x00, 0x00, 0x29, 0x00, 0x80, 0x03, 0xE0, 0x0C, 0x80, 0x4F, 0x80, 0x00, 0xE0, 0x0C, 0x60, 0x61,
+	0x46, 0xC9, 0x5C, 0xD4, 0x18, 0x5B, 0x1C, 0xDB, 0xB2, 0x21, 0x72, 0x80, 0x2B, 0xF7, 0xD3, 0x1E,
+	0x4B, 0x1F, 0x49, 0x59, 0x60, 0x59, 0x68, 0x00, 0x29, 0xFC, 0xDB, 0x99, 0x68, 0x05, 0x24, 0x64,
+	0x07, 0xA1, 0x42, 0x01, 0xD1, 0x00, 0x20, 0x0A, 0xE0, 0x0E, 0x0F, 0x0F, 0x2E, 0x02, 0xD1, 0x09,
+	0x20, 0xF0, 0xBD, 0x99, 0x68, 0x09, 0x0F, 0x0A, 0x29, 0xFB, 0xD1, 0x00, 0x28, 0xF8, 0xD1, 0x9A,
+	0x60, 0x14, 0x49, 0x2F, 0x04, 0x96, 0x07, 0x79, 0x18, 0x00, 0x2E, 0x10, 0xD0, 0x11, 0x4F, 0x2D,
+	0x04, 0xED, 0x19, 0xD6, 0x07, 0x2D, 0x0C, 0x00, 0x2E, 0x06, 0xD0, 0x11, 0x70, 0x0E, 0x0A, 0x56,
+	0x70, 0x95, 0x70, 0x09, 0x0E, 0xD1, 0x70, 0x03, 0xE0, 0x11, 0x80, 0x55, 0x80, 0x00, 0xE0, 0x11,
+	0x60, 0x07, 0x49, 0x49, 0x1C, 
+	0x00, 0x00, 0x2A, 0x00, 0x80, 0x59, 0x60, 0x59, 0x68, 0x00, 0x29, 0xFC, 0xDB, 0x99, 0x68, 0xA1,
+	0x42, 0xD6, 0xD0, 0x08, 0x46, 0xF0, 0xBD, 0x00, 0x00, 0x00, 0x00, 0x10, 0x40, 0xB6, 0xD7, 0x00,
+	0x00, 0x04, 0x00, 0x00, 0x80, 0xB6, 0xD8, 0x00, 0x00, 0x01, 0x46, 0x00, 0x20, 0xC9, 0x1E, 0x04,
+	0x29, 0x00, 0xD8, 0x02, 0x20, 0x70, 0x47, 0x00, 0xB5, 0x0A, 0x46, 0x00, 0x23, 0xFF, 0xF7, 0xF4,
+	0xFF, 0x00, 0x28, 0x06, 0xD0, 0x82, 0x42, 0x04, 0xD2, 0x06, 0x20, 0x42, 0x43, 0x0B, 0x48, 0x13,
+	0x18, 0x9B, 0x1C, 0x18, 0x46, 0x00, 0xBD, 0x01, 0x46, 0x00, 0x20, 0x89, 0x1E, 0x05, 0x29, 0x00,
+	0xD8, 0x06, 0x48, 0x70, 0x47, 0x05, 0x49, 0x88, 0x79, 0x09, 0x7B, 0x00, 0x07, 0x00, 0x0F, 0x09,
+	0x07, 0x09, 0x0F, 0x88, 0x42, 0x00, 0xD2, 0x08, 0x46, 0x70, 0x47, 0x00, 0x00, 0x50, 0xE7, 0x00,
+	0x00, 0x06, 0x48, 0x40, 0x7E, 
+	0x00, 0x00, 0x2B, 0x00, 0x80, 0x06, 0x49, 0xC0, 0x07, 0xC0, 0x0F, 0x08, 0x70, 0x70, 0x47, 0x04,
+	0x49, 0x00, 0x20, 0x08, 0x70, 0x70, 0x47, 0x02, 0x48, 0x00, 0x78, 0x70, 0x47, 0x80, 0xE8, 0x00,
+	0x00, 0x84, 0x00, 0x00, 0x20, 0xF0, 0xB5, 0x29, 0x4D, 0x84, 0x46, 0x00, 0x24, 0xAF, 0x88, 0x9E,
+	0x46, 0x20, 0x46, 0x27, 0x4E, 0x8F, 0x42, 0x04, 0xD8, 0xF3, 0x68, 0xEF, 0x88, 0xDF, 0x1B, 0x8F,
+	0x42, 0x08, 0xD2, 0x2F, 0x8A, 0x97, 0x42, 0x05, 0xD2, 0x33, 0x69, 0x6F, 0x8A, 0xDF, 0x1B, 0x97,
+	0x42, 0x00, 0xD9, 0x01, 0x24, 0x2F, 0x89, 0x8F, 0x42, 0x0D, 0xD2, 0xF7, 0x68, 0x6B, 0x89, 0xFF,
+	0x1A, 0x8F, 0x42, 0x08, 0xD9, 0xA9, 0x89, 0x91, 0x42, 0x04, 0xD8, 0x31, 0x69, 0xEB, 0x89, 0xC9,
+	0x1A, 0x91, 0x42, 0x00, 0xD2, 0x01, 0x24, 0x17, 0x49, 0x01, 0x26, 0x67, 0x46, 0x73, 0x46, 0x0A,
+	0x88, 0xBE, 0x40, 0x01, 0x2B, 
+	0x00, 0x00, 0x2C, 0x00, 0x80, 0x03, 0xD1, 0x01, 0x2C, 0x08, 0xD1, 0x32, 0x43, 0x05, 0xE0, 0x00,
+	0x2C, 0x04, 0xD1, 0x6B, 0x7D, 0x00, 0x2B, 0x01, 0xD1, 0xB2, 0x43, 0x0A, 0x80, 0x62, 0x46, 0x00,
+	0x2A, 0x02, 0xD1, 0x2A, 0x7D, 0x01, 0x2A, 0x0E, 0xD0, 0x01, 0x2C, 0x03, 0xD1, 0x0A, 0x88, 0x16,
+	0x42, 0x09, 0xD0, 0x07, 0xE0, 0x00, 0x2C, 0x06, 0xD1, 0x0A, 0x88, 0x16, 0x42, 0x03, 0xD0, 0x6A,
+	0x7D, 0x01, 0x2A, 0x00, 0xD1, 0x01, 0x20, 0x00, 0x22, 0x4A, 0x80, 0xF0, 0xBD, 0x60, 0xE6, 0x00,
+	0x00, 0xD0, 0xE7, 0x00, 0x00, 0x86, 0x00, 0x00, 0x20, 0xFE, 0xE7, 0x70, 0xB5, 0x0D, 0x4A, 0x0E,
+	0x4B, 0x00, 0x20, 0x81, 0x00, 0x54, 0x58, 0x40, 0x1C, 0x5C, 0x50, 0x20, 0x28, 0xF9, 0xD3, 0x0B,
+	0x49, 0x01, 0x20, 0x08, 0x60, 0x0A, 0x49, 0x80, 0x04, 0x08, 0x60, 0x0A, 0x4C, 0xE5, 0x69, 0x26,
+	0x6A, 0x04, 0xF0, 0xDF, 0xFC, 
+	0x00, 0x00, 0x2D, 0x00, 0x80, 0xE5, 0x61, 0x26, 0x62, 0x70, 0xBD, 0xFF, 0xF7, 0xE6, 0xFF, 0xFF,
+	0xF7, 0x6F, 0xFE, 0xFE, 0xE7, 0x00, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x10,
+	0x40, 0x00, 0x00, 0x01, 0x40, 0x00, 0xFF, 0x00, 0x40, 0x10, 0xB5, 0x00, 0xF0, 0xCB, 0xFE, 0x10,
+	0xBD, 0xF0, 0xB5, 0xFC, 0x48, 0xC2, 0x68, 0x10, 0x78, 0x0B, 0x28, 0x01, 0xD9, 0x0B, 0x20, 0x10,
+	0x70, 0x00, 0x20, 0xF9, 0x4F, 0xF9, 0x4D, 0x3E, 0xE0, 0x11, 0x18, 0xC7, 0x23, 0x5B, 0x5C, 0x00,
+	0x2B, 0x13, 0xD0, 0x43, 0x00, 0x9E, 0x18, 0x62, 0x23, 0x9C, 0x5B, 0xC3, 0x00, 0xC3, 0x18, 0x5B,
+	0x19, 0x9C, 0x70, 0x24, 0x0A, 0xDC, 0x70, 0x40, 0x36, 0x74, 0x88, 0x1C, 0x71, 0x24, 0x0A, 0x5C,
+	0x71, 0x10, 0x24, 0xDC, 0x71, 0x80, 0x31, 0x89, 0x78, 0x0E, 0xE0, 0xC3, 0x00, 0xC3, 0x18, 0x8C,
+	0x78, 0x5B, 0x19, 0x9C, 0x70, 
+	0x00, 0x00, 0x2E, 0x00, 0x80, 0x24, 0x0A, 0xDC, 0x70, 0x8C, 0x7C, 0x1C, 0x71, 0x24, 0x0A, 0x5C,
+	0x71, 0x20, 0x24, 0xDC, 0x71, 0x80, 0x31, 0xC9, 0x7C, 0x19, 0x72, 0x39, 0x78, 0x01, 0x29, 0x07,
+	0xD1, 0xC1, 0x00, 0x41, 0x18, 0x49, 0x19, 0x8B, 0x79, 0x1B, 0x09, 0x1B, 0x01, 0x1B, 0x1D, 0x07,
+	0xE0, 0x00, 0x29, 0x06, 0xD1, 0xC1, 0x00, 0x41, 0x18, 0x49, 0x19, 0x8B, 0x79, 0x1B, 0x09, 0x1B,
+	0x01, 0x8B, 0x71, 0x40, 0x1C, 0xC0, 0xB2, 0x11, 0x78, 0x81, 0x42, 0xBD, 0xD8, 0xD8, 0x48, 0x40,
+	0x78, 0x02, 0x28, 0x03, 0xD1, 0xC0, 0x32, 0xD7, 0x49, 0x10, 0x7E, 0x08, 0x70, 0xF0, 0xBD, 0x30,
+	0xB5, 0xD0, 0x4C, 0x13, 0xE0, 0x41, 0x1C, 0x80, 0x32, 0x0B, 0x46, 0x52, 0x6A, 0xC9, 0xB2, 0x55,
+	0x5C, 0x15, 0x54, 0xE2, 0x68, 0x80, 0x32, 0x92, 0x6A, 0x55, 0x5C, 0x15, 0x54, 0xE2, 0x68, 0x49,
+	0x00, 0x80, 0x32, 0xD2, 0x6A, 
+	0x00, 0x00, 0x2F, 0x00, 0x80, 0x40, 0x00, 0x51, 0x5A, 0x11, 0x52, 0xD8, 0xB2, 0xE2, 0x68, 0x11,
+	0x78, 0x49, 0x1E, 0x81, 0x42, 0xE6, 0xDC, 0x30, 0xBD, 0x70, 0xB5, 0x00, 0xF0, 0x9B, 0xFD, 0x01,
+	0x24, 0xC0, 0x4D, 0x0A, 0xE0, 0x00, 0x19, 0xA0, 0x30, 0xC0, 0x7D, 0xFF, 0xF7, 0xD8, 0xFF, 0xE8,
+	0x68, 0x01, 0x78, 0x49, 0x1E, 0x64, 0x1C, 0x01, 0x70, 0xE4, 0xB2, 0xE8, 0x68, 0xB6, 0x21, 0x09,
+	0x5C, 0xA1, 0x42, 0xEF, 0xD8, 0x70, 0xBD, 0x00, 0x28, 0x0B, 0xD0, 0xBB, 0x4A, 0x12, 0x78, 0x52,
+	0x1E, 0x82, 0x42, 0x06, 0xD0, 0x00, 0x29, 0x04, 0xD0, 0xB8, 0x48, 0x00, 0x78, 0x40, 0x1E, 0x88,
+	0x42, 0x01, 0xD1, 0x01, 0x20, 0x70, 0x47, 0x00, 0x20, 0x70, 0x47, 0x70, 0xB5, 0x00, 0x24, 0xAD,
+	0x4D, 0x0B, 0xE0, 0x01, 0x19, 0xA0, 0x31, 0xC9, 0x7D, 0x41, 0x18, 0x88, 0x78, 0x89, 0x7C, 0xFF,
+	0xF7, 0xE2, 0xFF, 0x00, 0x28, 
+	0x00, 0x00, 0x30, 0x00, 0x80, 0x07, 0xD0, 0x64, 0x1C, 0xE4, 0xB2, 0xE8, 0x68, 0xB6, 0x21, 0x09,
+	0x5C, 0xA1, 0x42, 0xEE, 0xD8, 0x01, 0x20, 0x70, 0xBD, 0x70, 0xB5, 0xA2, 0x4D, 0x04, 0x46, 0x28,
+	0x78, 0x20, 0x42, 0x0C, 0xD1, 0xFF, 0xF7, 0xE1, 0xFF, 0x00, 0x28, 0x02, 0xD0, 0x68, 0x78, 0x20,
+	0x43, 0x01, 0xE0, 0x68, 0x78, 0xA0, 0x43, 0x68, 0x70, 0x68, 0x78, 0x20, 0x40, 0x70, 0xBD, 0xFF,
+	0xF7, 0xD4, 0xFF, 0x00, 0x28, 0xF8, 0xD1, 0xF4, 0xE7, 0xFE, 0xB5, 0x05, 0x46, 0x95, 0x48, 0x9B,
+	0x4A, 0x84, 0x68, 0x12, 0x78, 0x61, 0x68, 0x52, 0x1E, 0x91, 0x42, 0x02, 0xD1, 0x22, 0x68, 0x52,
+	0x1C, 0x22, 0x60, 0x95, 0x4B, 0xE2, 0x68, 0x1B, 0x78, 0x5B, 0x1E, 0x9A, 0x42, 0x02, 0xD1, 0xA3,
+	0x68, 0x5B, 0x1C, 0xA3, 0x60, 0x20, 0x68, 0x40, 0x18, 0x40, 0x08, 0x01, 0x90, 0xA3, 0x68, 0x01,
+	0x9E, 0x98, 0x18, 0x40, 0x08, 
+	0x00, 0x00, 0x31, 0x00, 0x80, 0x00, 0x90, 0x27, 0x68, 0xF7, 0x1B, 0x02, 0x2F, 0x09, 0xD8, 0x85,
+	0x4F, 0x89, 0x1B, 0x02, 0x29, 0x05, 0xD8, 0xC1, 0x1A, 0x02, 0x29, 0x02, 0xD8, 0x11, 0x1A, 0x02,
+	0x29, 0x4E, 0xD9, 0x83, 0x48, 0x40, 0x69, 0x00, 0x28, 0x04, 0xD1, 0xE0, 0x6C, 0x01, 0x90, 0x21,
+	0x6D, 0xE1, 0x64, 0x20, 0x65, 0x82, 0x4E, 0xE0, 0x6C, 0x82, 0x4A, 0x61, 0x6D, 0xB0, 0x42, 0x02,
+	0xDD, 0x49, 0x11, 0x40, 0x11, 0xFF, 0xE7, 0x17, 0x68, 0x78, 0x43, 0x0C, 0xF0, 0x02, 0xF9, 0x79,
+	0x10, 0x40, 0x18, 0x00, 0x12, 0x01, 0x90, 0x20, 0x6D, 0x72, 0x4F, 0x7B, 0x4A, 0x61, 0x6D, 0xB0,
+	0x42, 0x02, 0xDD, 0x49, 0x11, 0x40, 0x11, 0xFF, 0xE7, 0x14, 0x68, 0x60, 0x43, 0x0C, 0xF0, 0xF1,
+	0xF8, 0x61, 0x10, 0x40, 0x18, 0x00, 0x12, 0x00, 0x90, 0x69, 0x46, 0x01, 0xA8, 0x02, 0xF0, 0xF5,
+	0xFA, 0xB8, 0x68, 0x6B, 0x4A, 
+	0x00, 0x00, 0x32, 0x00, 0x80, 0x41, 0x6D, 0x92, 0x69, 0x51, 0x43, 0x50, 0x22, 0x51, 0x43, 0xC9,
+	0x0B, 0x41, 0x65, 0xF9, 0x68, 0x68, 0x00, 0x41, 0x18, 0x01, 0x9A, 0x40, 0x31, 0x4A, 0x80, 0xFA,
+	0x68, 0x00, 0x99, 0x80, 0x18, 0x60, 0x30, 0x41, 0x80, 0xB9, 0x68, 0xFF, 0x20, 0x49, 0x6D, 0xFF,
+	0x29, 0x00, 0xDC, 0xC8, 0xB2, 0xF9, 0x68, 0x49, 0x19, 0x80, 0x31, 0x88, 0x70, 0x01, 0x20, 0xFE,
+	0xBD, 0xA1, 0x69, 0x05, 0x29, 0x06, 0xD9, 0xF9, 0x68, 0x49, 0x19, 0x88, 0x70, 0xF9, 0x68, 0x01,
+	0x98, 0x49, 0x19, 0x88, 0x74, 0x00, 0x20, 0xFE, 0xBD, 0xF8, 0xB5, 0x52, 0x4C, 0x01, 0x27, 0xE0,
+	0x68, 0xFD, 0x25, 0x80, 0x30, 0x80, 0x7C, 0xFB, 0x26, 0x01, 0x28, 0x13, 0xD0, 0x02, 0x28, 0x23,
+	0xD0, 0x04, 0x28, 0x47, 0xD0, 0x08, 0x28, 0x1E, 0xD1, 0xFF, 0xF7, 0x4E, 0xFF, 0x60, 0x78, 0x28,
+	0x40, 0xC0, 0xB2, 0x30, 0x40, 
+	0x00, 0x00, 0x33, 0x00, 0x80, 0x60, 0x70, 0xE0, 0x68, 0xC0, 0x30, 0xC1, 0x7D, 0x0A, 0x07, 0x4C,
+	0xD5, 0x80, 0x22, 0x4B, 0xE0, 0x01, 0x20, 0xFF, 0xF7, 0x3F, 0xFF, 0x60, 0x78, 0x28, 0x40, 0xC0,
+	0xB2, 0x30, 0x40, 0x60, 0x70, 0xE0, 0x68, 0xC0, 0x30, 0xC1, 0x7D, 0xCA, 0x07, 0x01, 0xD0, 0x10,
+	0x22, 0x39, 0xE0, 0x39, 0x43, 0xC1, 0x75, 0xF8, 0xBD, 0x44, 0x49, 0x05, 0x20, 0x08, 0x70, 0x02,
+	0x20, 0xFF, 0xF7, 0x2A, 0xFF, 0x60, 0x78, 0xF7, 0x21, 0x30, 0x40, 0xC0, 0xB2, 0x40, 0x08, 0x40,
+	0x00, 0xC0, 0xB2, 0x08, 0x40, 0x60, 0x70, 0xE0, 0x68, 0xC0, 0x30, 0xC1, 0x7D, 0x8A, 0x07, 0x01,
+	0xD5, 0x20, 0x22, 0x00, 0xE0, 0x02, 0x22, 0x11, 0x43, 0xC1, 0x75, 0xFF, 0xF7, 0xD5, 0xFE, 0xE0,
+	0x68, 0x40, 0x78, 0xFF, 0xF7, 0x29, 0xFF, 0x00, 0x28, 0xDD, 0xD0, 0xE0, 0x68, 0x41, 0x78, 0xC7,
+	0x30, 0x0F, 0x54, 0xF8, 0xBD, 
+	0x00, 0x00, 0x34, 0x00, 0x80, 0x04, 0x20, 0xFF, 0xF7, 0x07, 0xFF, 0x60, 0x78, 0x28, 0x40, 0xC0,
+	0xB2, 0x40, 0x08, 0x40, 0x00, 0x60, 0x70, 0xE0, 0x68, 0xC0, 0x30, 0xC1, 0x7D, 0x4A, 0x07, 0x01,
+	0xD5, 0x40, 0x22, 0x00, 0xE0, 0x04, 0x22, 0x11, 0x43, 0xC4, 0xE7, 0x08, 0x22, 0x11, 0x43, 0xC1,
+	0x75, 0xFF, 0xF7, 0xB2, 0xFE, 0xE0, 0x68, 0x40, 0x78, 0xFF, 0xF7, 0x91, 0xFE, 0xE0, 0x68, 0x41,
+	0x78, 0x49, 0x1E, 0x41, 0x70, 0x01, 0x78, 0x49, 0x1E, 0x01, 0x70, 0xC0, 0x30, 0x01, 0x7E, 0x49,
+	0x1C, 0x01, 0x76, 0xF8, 0xBD, 0xF0, 0xB5, 0x8C, 0x46, 0x51, 0x1E, 0x00, 0x25, 0x52, 0x1C, 0x4C,
+	0xB2, 0x96, 0x46, 0x3F, 0xE0, 0x14, 0x49, 0x0A, 0x78, 0x61, 0x46, 0x62, 0x43, 0x97, 0xB2, 0x62,
+	0x46, 0x52, 0x1E, 0x53, 0xB2, 0x49, 0x1C, 0x31, 0xE0, 0x0F, 0x4E, 0x36, 0x78, 0xB3, 0x42, 0x27,
+	0xDA, 0x0E, 0x4E, 0x36, 0x78, 
+	0x00, 0x00, 0x35, 0x00, 0x80, 0xB4, 0x42, 0x23, 0xDA, 0x00, 0x2B, 0x21, 0xDB, 0x00, 0x2C, 0x1F,
+	0xDB, 0x04, 0x4E, 0xDA, 0x19, 0xF6, 0x68, 0x52, 0x00, 0x80, 0x36, 0x36, 0x6B, 0xB6, 0x5A, 0x72,
+	0x19, 0x15, 0xB2, 0x19, 0xE0, 0x8C, 0x00, 0x00, 0x20, 0xE9, 0x00, 0x00, 0x20, 0x88, 0x03, 0x00,
+	0x20, 0xD0, 0xE7, 0x00, 0x00, 0xEF, 0x00, 0x00, 0x20, 0x9E, 0x00, 0x00, 0x20, 0x9D, 0x00, 0x00,
+	0x20, 0xFF, 0xFF, 0x01, 0x00, 0x04, 0x01, 0x00, 0x20, 0x08, 0x01, 0x00, 0x20, 0xE6, 0x00, 0x00,
+	0x20, 0x06, 0x78, 0x40, 0x22, 0x16, 0x43, 0x06, 0x70, 0x5B, 0x1C, 0x5B, 0xB2, 0x8B, 0x42, 0xCB,
+	0xDD, 0x64, 0x1C, 0x64, 0xB2, 0x74, 0x45, 0xBD, 0xDD, 0xA8, 0xB2, 0xF0, 0xBD, 0xF0, 0xB5, 0x81,
+	0x7A, 0xC2, 0x7A, 0x91, 0xB0, 0x04, 0x46, 0xFF, 0x4E, 0xF0, 0x68, 0x41, 0x18, 0x8B, 0x78, 0x03,
+	0x93, 0x89, 0x7C, 0x80, 0x18, 
+	0x00, 0x00, 0x36, 0x00, 0x80, 0x02, 0x91, 0x81, 0x78, 0x01, 0x91, 0x80, 0x7C, 0x00, 0x90, 0x58,
+	0x18, 0xC0, 0xB2, 0x07, 0x90, 0x02, 0x99, 0x00, 0x98, 0x08, 0x18, 0xC0, 0xB2, 0x06, 0x90, 0x20,
+	0x78, 0xBF, 0x21, 0x08, 0x40, 0x20, 0x70, 0x07, 0x98, 0x40, 0x08, 0xA0, 0x70, 0x06, 0x98, 0x40,
+	0x08, 0xE0, 0x70, 0xA0, 0x78, 0x05, 0x90, 0xE0, 0x78, 0x04, 0x90, 0x02, 0x46, 0x20, 0x46, 0x05,
+	0x99, 0xFF, 0xF7, 0x88, 0xFF, 0x05, 0xB2, 0x0A, 0x95, 0xF0, 0x68, 0x01, 0x27, 0x80, 0x30, 0x02,
+	0x6B, 0xE9, 0x48, 0x01, 0x78, 0x04, 0x98, 0x41, 0x43, 0x05, 0x98, 0x08, 0x18, 0x40, 0x00, 0x16,
+	0x5E, 0x07, 0x98, 0x09, 0x96, 0x08, 0x96, 0xC0, 0x07, 0x29, 0xD0, 0x05, 0x98, 0x04, 0x9A, 0x40,
+	0x1C, 0xC1, 0xB2, 0x10, 0x90, 0x20, 0x46, 0xFF, 0xF7, 0x6D, 0xFF, 0x01, 0xB2, 0xDD, 0x48, 0x04,
+	0x9B, 0xC0, 0x68, 0x02, 0x27, 
+	0x00, 0x00, 0x37, 0x00, 0x80, 0x80, 0x30, 0x02, 0x6B, 0xDB, 0x48, 0x00, 0x78, 0x58, 0x43, 0x05,
+	0x9B, 0xC0, 0x18, 0x40, 0x00, 0x80, 0x1C, 0x10, 0x5E, 0x32, 0x18, 0x16, 0xB2, 0x8D, 0x42, 0x02,
+	0xDA, 0x10, 0x9A, 0xA2, 0x70, 0x0D, 0x46, 0x0A, 0x9A, 0x8A, 0x42, 0x00, 0xDD, 0x0A, 0x91, 0x09,
+	0x99, 0x81, 0x42, 0x00, 0xDA, 0x09, 0x90, 0x08, 0x99, 0x81, 0x42, 0x00, 0xDD, 0x08, 0x90, 0x06,
+	0x98, 0xC0, 0x07, 0x2A, 0xD0, 0x04, 0x98, 0x40, 0x1C, 0x0F, 0x90, 0xC2, 0xB2, 0x0E, 0x90, 0x20,
+	0x46, 0x05, 0x99, 0xFF, 0xF7, 0x3F, 0xFF, 0x01, 0xB2, 0xC6, 0x48, 0x7F, 0x1C, 0xC0, 0x68, 0xFF,
+	0xB2, 0x80, 0x30, 0x02, 0x6B, 0xC4, 0x48, 0x03, 0x78, 0x0E, 0x98, 0x43, 0x43, 0x05, 0x98, 0x18,
+	0x18, 0x40, 0x00, 0x10, 0x5E, 0x32, 0x18, 0x16, 0xB2, 0x8D, 0x42, 0x02, 0xDA, 0x0F, 0x9A, 0xE2,
+	0x70, 0x0D, 0x46, 0x0A, 0x9A, 
+	0x00, 0x00, 0x38, 0x00, 0x80, 0x8A, 0x42, 0x00, 0xDD, 0x0A, 0x91, 0x09, 0x99, 0x81, 0x42, 0x00,
+	0xDA, 0x09, 0x90, 0x08, 0x99, 0x81, 0x42, 0x00, 0xDD, 0x08, 0x90, 0x07, 0x99, 0x06, 0x98, 0x08,
+	0x40, 0xC0, 0x07, 0x24, 0xD0, 0x04, 0x99, 0x05, 0x98, 0x49, 0x1C, 0x40, 0x1C, 0x0D, 0x91, 0xCA,
+	0xB2, 0x0C, 0x91, 0xC1, 0xB2, 0x0B, 0x90, 0x20, 0x46, 0xFF, 0xF7, 0x0C, 0xFF, 0xAD, 0x49, 0x7F,
+	0x1C, 0xC9, 0x68, 0x00, 0xB2, 0x80, 0x31, 0x0B, 0x6B, 0xAB, 0x49, 0xFF, 0xB2, 0x0A, 0x78, 0x0C,
+	0x99, 0x4A, 0x43, 0x05, 0x99, 0x51, 0x18, 0x49, 0x00, 0x89, 0x1C, 0x59, 0x5E, 0x72, 0x18, 0x16,
+	0xB2, 0x85, 0x42, 0x04, 0xDA, 0x0B, 0x9A, 0xA2, 0x70, 0x0D, 0x9A, 0xE2, 0x70, 0x05, 0x46, 0x01,
+	0x2F, 0x04, 0xD0, 0x02, 0x2F, 0x01, 0xD1, 0x76, 0x10, 0x00, 0xE0, 0xB6, 0x10, 0x01, 0x9A, 0x03,
+	0x98, 0x9E, 0x49, 0x90, 0x42, 
+	0x00, 0x00, 0x39, 0x00, 0x80, 0x00, 0x9A, 0x02, 0x98, 0x22, 0xD1, 0x90, 0x42, 0x02, 0xD9, 0x10,
+	0x46, 0x02, 0x9B, 0x00, 0xE0, 0x13, 0x46, 0x61, 0x82, 0x97, 0x49, 0x03, 0x9A, 0x09, 0x78, 0x8C,
+	0x46, 0x41, 0x43, 0x89, 0x18, 0x93, 0x4A, 0x40, 0x1C, 0xD7, 0x68, 0x89, 0xB2, 0xC0, 0xB2, 0x80,
+	0x37, 0x0B, 0xE0, 0x61, 0x44, 0x89, 0xB2, 0x3A, 0x6B, 0x4E, 0x00, 0x92, 0x5F, 0x12, 0x26, 0xA6,
+	0x5F, 0xB2, 0x42, 0x00, 0xDA, 0x62, 0x82, 0x40, 0x1C, 0xC0, 0xB2, 0x98, 0x42, 0xF1, 0xD3, 0x26,
+	0xE0, 0x90, 0x42, 0x23, 0xD1, 0x03, 0x9A, 0x01, 0x98, 0x82, 0x42, 0x01, 0xD9, 0x13, 0x46, 0x01,
+	0xE0, 0x01, 0x9B, 0x10, 0x46, 0x61, 0x82, 0x84, 0x49, 0x02, 0x9A, 0x09, 0x78, 0x51, 0x43, 0x09,
+	0x18, 0x80, 0x4A, 0x40, 0x1C, 0xD7, 0x68, 0x89, 0xB2, 0xC0, 0xB2, 0x80, 0x37, 0x0B, 0xE0, 0x49,
+	0x1C, 0x89, 0xB2, 0x3A, 0x6B, 
+	0x00, 0x00, 0x3A, 0x00, 0x80, 0x4E, 0x00, 0x92, 0x5F, 0x12, 0x26, 0xA6, 0x5F, 0xB2, 0x42, 0x00,
+	0xDA, 0x62, 0x82, 0x40, 0x1C, 0xC0, 0xB2, 0x98, 0x42, 0xF1, 0xD3, 0x00, 0xE0, 0x66, 0x82, 0x25,
+	0x82, 0x12, 0x20, 0x06, 0x21, 0x20, 0x5E, 0x61, 0x5E, 0x88, 0x42, 0x03, 0xDA, 0x80, 0x01, 0x0B,
+	0xF0, 0xC6, 0xFE, 0x00, 0xE0, 0x40, 0x20, 0x20, 0x75, 0x28, 0x46, 0x11, 0xB0, 0xF0, 0xBD, 0x70,
+	0xB5, 0x6F, 0x48, 0x6C, 0x4C, 0x02, 0x78, 0x00, 0x21, 0xE0, 0x68, 0x86, 0xB0, 0x01, 0x2A, 0x02,
+	0xD1, 0xA1, 0x70, 0x02, 0x21, 0x54, 0xE0, 0xA1, 0x68, 0x6B, 0x46, 0x8A, 0x69, 0xA0, 0x30, 0x5A,
+	0x70, 0x80, 0x7D, 0x58, 0x71, 0x48, 0x6D, 0xD8, 0x82, 0x00, 0x25, 0x10, 0xE0, 0x41, 0x19, 0xA0,
+	0x31, 0xC9, 0x7D, 0x41, 0x18, 0x88, 0x78, 0x89, 0x7C, 0xFF, 0xF7, 0x25, 0xFD, 0x00, 0x28, 0x04,
+	0xD0, 0x6B, 0x46, 0x18, 0x78, 
+	0x00, 0x00, 0x3B, 0x00, 0x80, 0x80, 0x21, 0x08, 0x43, 0x0A, 0xE0, 0x6D, 0x1C, 0xED, 0xB2, 0xE0,
+	0x68, 0xB6, 0x21, 0x09, 0x5C, 0xA9, 0x42, 0xE9, 0xD8, 0x6B, 0x46, 0x18, 0x78, 0x40, 0x06, 0x40,
+	0x0E, 0x6B, 0x46, 0x18, 0x70, 0xE0, 0x68, 0x01, 0x46, 0xA0, 0x31, 0xCA, 0x7D, 0x9A, 0x72, 0x09,
+	0x7E, 0xD9, 0x72, 0x52, 0x00, 0x01, 0x46, 0x16, 0x18, 0xDB, 0x7A, 0x80, 0x31, 0x5B, 0x00, 0x72,
+	0x8C, 0x18, 0x18, 0x0D, 0x6B, 0x43, 0x8C, 0x52, 0x00, 0xAA, 0x5E, 0x5B, 0x00, 0xED, 0x5E, 0x6B,
+	0x46, 0xAA, 0x42, 0x05, 0xDD, 0xDD, 0x80, 0x08, 0x6B, 0x71, 0x8C, 0x49, 0x00, 0x40, 0x5A, 0x04,
+	0xE0, 0xDA, 0x80, 0x40, 0x8C, 0x09, 0x6B, 0x40, 0x00, 0x08, 0x5A, 0x6B, 0x46, 0x18, 0x81, 0x68,
+	0x46, 0xFF, 0xF7, 0x7C, 0xFE, 0x68, 0x46, 0x00, 0xF0, 0x5A, 0xFB, 0x6B, 0x46, 0x19, 0x79, 0xE0,
+	0x68, 0x80, 0x30, 0x81, 0x74, 
+	0x00, 0x00, 0x3C, 0x00, 0x80, 0x06, 0xB0, 0x70, 0xBD, 0xFE, 0xB5, 0x3A, 0x48, 0x00, 0x25, 0xC2,
+	0x68, 0xAE, 0x46, 0x11, 0x46, 0xA0, 0x31, 0x02, 0x91, 0x89, 0x7D, 0x2C, 0x46, 0x8C, 0x46, 0x02,
+	0x29, 0x51, 0xD9, 0x00, 0x21, 0x26, 0xE0, 0x50, 0x18, 0xA0, 0x30, 0xC0, 0x7D, 0x10, 0x18, 0x83,
+	0x78, 0x01, 0x93, 0x80, 0x7C, 0x00, 0x90, 0x00, 0x20, 0x18, 0xE0, 0x13, 0x18, 0xA0, 0x33, 0xDB,
+	0x7D, 0x00, 0x9E, 0xD3, 0x18, 0x9F, 0x78, 0x9B, 0x7C, 0xF3, 0x1A, 0x01, 0x9E, 0xF6, 0x1B, 0x00,
+	0x2B, 0x00, 0xDA, 0x5B, 0x42, 0x00, 0x2E, 0x00, 0xDA, 0x76, 0x42, 0x9B, 0x19, 0xDB, 0xB2, 0x9D,
+	0x42, 0x02, 0xD2, 0x1D, 0x46, 0x8E, 0x46, 0x04, 0x46, 0x40, 0x1C, 0xC0, 0xB2, 0x84, 0x45, 0xE4,
+	0xD8, 0x49, 0x1C, 0xC9, 0xB2, 0x8C, 0x45, 0xD6, 0xD8, 0x00, 0x2D, 0x24, 0xD0, 0x02, 0x98, 0x1D,
+	0x4D, 0xC1, 0x7D, 0x70, 0x46, 
+	0x00, 0x00, 0x3D, 0x00, 0x80, 0x10, 0x18, 0xA0, 0x30, 0x02, 0x9A, 0xC3, 0x7D, 0xD3, 0x75, 0xC1,
+	0x75, 0x00, 0x2C, 0x00, 0xD1, 0x74, 0x46, 0xE8, 0x68, 0xB6, 0x21, 0x0A, 0x5C, 0x41, 0x18, 0x00,
+	0x19, 0xA0, 0x30, 0x53, 0x5C, 0xC0, 0x7D, 0x50, 0x54, 0xE8, 0x68, 0x00, 0x19, 0xA0, 0x30, 0xC3,
+	0x75, 0xE8, 0x68, 0xA0, 0x30, 0x81, 0x7D, 0x49, 0x1E, 0x81, 0x75, 0xFF, 0xF7, 0x6D, 0xFC, 0xE8,
+	0x68, 0x02, 0x21, 0xA0, 0x30, 0x81, 0x75, 0xFE, 0xBD, 0xF0, 0xB5, 0x00, 0x28, 0x7E, 0xDB, 0x0D,
+	0x4A, 0x12, 0x78, 0x90, 0x42, 0x7A, 0xDA, 0x00, 0x29, 0x78, 0xDB, 0x07, 0x4A, 0x12, 0x78, 0x91,
+	0x42, 0x7C, 0xDA, 0x42, 0x43, 0x03, 0x4E, 0x52, 0x18, 0xB3, 0x68, 0x54, 0x11, 0xA4, 0x00, 0x5A,
+	0x61, 0xE3, 0x18, 0x09, 0xE0, 0x8C, 0x00, 0x00, 0x20, 0x9E, 0x00, 0x00, 0x20, 0xFF, 0x7F, 0x00,
+	0x00, 0xE9, 0x00, 0x00, 0x20, 
+	0x00, 0x00, 0x3E, 0x00, 0x80, 0x9D, 0x00, 0x00, 0x20, 0xD5, 0x06, 0xED, 0x0E, 0x01, 0x22, 0x1C,
+	0x6A, 0xAA, 0x40, 0x25, 0x46, 0x15, 0x42, 0x61, 0xD1, 0x14, 0x43, 0x1C, 0x62, 0xB2, 0x68, 0xFE,
+	0x4C, 0x53, 0x69, 0x5B, 0x00, 0xE3, 0x5E, 0x53, 0x61, 0x14, 0x69, 0xA3, 0x42, 0x45, 0xDD, 0xD2,
+	0x69, 0x03, 0x02, 0x0B, 0x43, 0x9D, 0xB2, 0xD3, 0x88, 0x17, 0x89, 0xDC, 0x1B, 0x02, 0xD5, 0x94,
+	0x88, 0x1C, 0x19, 0xE4, 0x1B, 0xA7, 0xB2, 0x94, 0x88, 0xA7, 0x42, 0x0B, 0xD2, 0x5C, 0x00, 0x5B,
+	0x1C, 0xD3, 0x80, 0x13, 0x68, 0x1D, 0x53, 0xD3, 0x88, 0x94, 0x88, 0xA3, 0x42, 0x15, 0xD1, 0x00,
+	0x23, 0xD3, 0x80, 0x12, 0xE0, 0x5C, 0x00, 0x5B, 0x1C, 0xD3, 0x80, 0x13, 0x68, 0x1D, 0x53, 0xD4,
+	0x88, 0x93, 0x88, 0x9C, 0x42, 0x01, 0xD1, 0x00, 0x24, 0xD4, 0x80, 0xD4, 0x88, 0x64, 0x1C, 0xA4,
+	0xB2, 0x14, 0x81, 0x9C, 0x42, 
+	0x00, 0x00, 0x3F, 0x00, 0x80, 0x01, 0xD1, 0x00, 0x23, 0x13, 0x81, 0xB2, 0x68, 0x93, 0x69, 0x5B,
+	0x1C, 0x93, 0x61, 0x54, 0x69, 0x93, 0x6D, 0x1B, 0x19, 0x93, 0x65, 0x13, 0x68, 0x83, 0x42, 0x00,
+	0xD9, 0x10, 0x60, 0x53, 0x68, 0x83, 0x42, 0x00, 0xD2, 0x50, 0x60, 0x93, 0x68, 0x8B, 0x42, 0x00,
+	0xD9, 0x91, 0x60, 0xD3, 0x68, 0x8B, 0x42, 0x00, 0xD2, 0xD1, 0x60, 0xB2, 0x68, 0x53, 0x69, 0x00,
+	0x2B, 0x0C, 0xDD, 0x54, 0x6D, 0xE4, 0x18, 0x54, 0x65, 0x58, 0x43, 0x00, 0xE0, 0x06, 0xE0, 0xD4,
+	0x6C, 0x4B, 0x43, 0x20, 0x18, 0xD0, 0x64, 0x10, 0x6D, 0xC0, 0x18, 0x10, 0x65, 0xF0, 0xBD, 0xF1,
+	0xB5, 0x3C, 0x21, 0x00, 0x98, 0xFF, 0xF7, 0x04, 0xFA, 0xCC, 0x49, 0xCD, 0x4E, 0x08, 0x60, 0x1E,
+	0x20, 0x88, 0x80, 0x00, 0x20, 0x08, 0x81, 0xC8, 0x80, 0xB2, 0x68, 0xD1, 0x61, 0x01, 0x21, 0x91,
+	0x61, 0xF3, 0x68, 0x18, 0x46, 
+	0x00, 0x00, 0x40, 0x00, 0x80, 0x80, 0x30, 0x5B, 0x78, 0x44, 0x6A, 0x85, 0x6A, 0xE4, 0x5C, 0xED,
+	0x5C, 0xC0, 0x6A, 0x5B, 0x00, 0xC0, 0x5A, 0x43, 0x09, 0x9B, 0x00, 0x9A, 0x18, 0x94, 0x46, 0xC7,
+	0x06, 0x13, 0x6A, 0xFF, 0x0E, 0x0A, 0x46, 0xBA, 0x40, 0x13, 0x43, 0x62, 0x46, 0x13, 0x62, 0xF2,
+	0x68, 0xB6, 0x23, 0x99, 0x54, 0x53, 0x78, 0xB6, 0x32, 0x8B, 0x54, 0xB1, 0x68, 0x43, 0x00, 0x8C,
+	0x60, 0x0D, 0x60, 0x4D, 0x60, 0xCC, 0x60, 0xF2, 0x68, 0x80, 0x32, 0x17, 0x6B, 0xF8, 0x5E, 0xB3,
+	0x4F, 0x0C, 0x37, 0x3F, 0x79, 0x78, 0x43, 0xC0, 0x11, 0x08, 0x61, 0x10, 0x6B, 0xC0, 0x5E, 0x48,
+	0x61, 0x17, 0x6B, 0xFF, 0x5E, 0x4F, 0x65, 0x12, 0x6B, 0xD2, 0x5E, 0x8A, 0x65, 0x02, 0x46, 0x6A,
+	0x43, 0x60, 0x43, 0xCA, 0x64, 0x08, 0x65, 0x21, 0x46, 0x68, 0x1C, 0xFF, 0xF7, 0x25, 0xFF, 0x21,
+	0x46, 0x68, 0x1E, 0xFF, 0xF7, 
+	0x00, 0x00, 0x41, 0x00, 0x80, 0x21, 0xFF, 0x61, 0x1C, 0x28, 0x46, 0xFF, 0xF7, 0x1D, 0xFF, 0x61,
+	0x1E, 0x28, 0x46, 0xFF, 0xF7, 0x19, 0xFF, 0x61, 0x1C, 0x68, 0x1C, 0xFF, 0xF7, 0x15, 0xFF, 0x61,
+	0x1E, 0x68, 0x1E, 0xFF, 0xF7, 0x11, 0xFF, 0x61, 0x1E, 0x68, 0x1C, 0xFF, 0xF7, 0x0D, 0xFF, 0x61,
+	0x1C, 0x68, 0x1E, 0xFF, 0xF7, 0x09, 0xFF, 0xB0, 0x68, 0xC0, 0x69, 0x01, 0x89, 0xC2, 0x88, 0x91,
+	0x42, 0x14, 0xD0, 0x4B, 0x00, 0x49, 0x1C, 0x8A, 0xB2, 0x02, 0x81, 0x01, 0x68, 0xC9, 0x5A, 0x83,
+	0x88, 0x9A, 0x42, 0x01, 0xD1, 0x00, 0x22, 0x02, 0x81, 0x92, 0x48, 0x0D, 0x12, 0x00, 0x78, 0xCC,
+	0xB2, 0x68, 0x43, 0x00, 0x19, 0x87, 0xB2, 0xF0, 0x68, 0x40, 0x78, 0x11, 0xE0, 0x00, 0x98, 0xFF,
+	0xF7, 0x8C, 0xF9, 0xF8, 0xBD, 0xAC, 0x22, 0x52, 0x58, 0x43, 0x00, 0xD2, 0x5A, 0xBA, 0x42, 0x07,
+	0xD1, 0x0B, 0x46, 0xA0, 0x33, 
+	0x00, 0x00, 0x42, 0x00, 0x80, 0x9A, 0x7D, 0x52, 0x1C, 0xD2, 0xB2, 0x9A, 0x75, 0xB6, 0x31, 0x50,
+	0x54, 0xF1, 0x68, 0x40, 0x1C, 0x0A, 0x78, 0xC0, 0xB2, 0x82, 0x42, 0xEB, 0xD8, 0xAB, 0xE7, 0xF0,
+	0xB5, 0x00, 0x21, 0x3F, 0xE0, 0x80, 0x1E, 0x38, 0xE0, 0x7D, 0x4A, 0x44, 0x00, 0xD5, 0x68, 0xA6,
+	0x1C, 0x80, 0x35, 0xEB, 0x6A, 0xB6, 0x46, 0x9C, 0x46, 0x1A, 0x5B, 0x9B, 0x5B, 0x2E, 0x6B, 0x55,
+	0x00, 0x75, 0x5F, 0x5F, 0x00, 0xF6, 0x5F, 0xB5, 0x42, 0x26, 0xDD, 0x75, 0x4D, 0x66, 0x46, 0x33,
+	0x53, 0xEB, 0x68, 0x80, 0x33, 0xDC, 0x6A, 0x73, 0x46, 0xE2, 0x52, 0xEA, 0x68, 0x80, 0x32, 0x53,
+	0x6A, 0x42, 0x1C, 0x1C, 0x5C, 0x9E, 0x5C, 0x1E, 0x54, 0xEB, 0x68, 0x80, 0x33, 0x5B, 0x6A, 0x9C,
+	0x54, 0xEB, 0x68, 0x80, 0x33, 0x9B, 0x6A, 0x1C, 0x5C, 0x9E, 0x5C, 0x1E, 0x54, 0xEB, 0x68, 0x80,
+	0x33, 0x9B, 0x6A, 0x9C, 0x54, 
+	0x00, 0x00, 0x43, 0x00, 0x80, 0xEA, 0x68, 0x12, 0x18, 0x80, 0x32, 0xD3, 0x7C, 0x14, 0x7D, 0xD4,
+	0x74, 0xEA, 0x68, 0x12, 0x18, 0x80, 0x32, 0x13, 0x75, 0x40, 0x1E, 0x40, 0xB2, 0x88, 0x42, 0xC3,
+	0xDA, 0x49, 0x1C, 0x49, 0xB2, 0x5E, 0x4B, 0xD8, 0x68, 0x00, 0x78, 0x42, 0x1E, 0x8A, 0x42, 0xB9,
+	0xDC, 0xF0, 0xBD, 0xF7, 0xB5, 0x00, 0x24, 0x5A, 0x4D, 0x0E, 0x46, 0x17, 0x46, 0x00, 0x29, 0x04,
+	0xD1, 0x2C, 0x70, 0x6C, 0x70, 0xAC, 0x70, 0xAC, 0x80, 0xEC, 0x70, 0xDC, 0x21, 0x00, 0x98, 0xFF,
+	0xF7, 0x0F, 0xF9, 0xE8, 0x60, 0x60, 0x21, 0x00, 0x98, 0xFF, 0xF7, 0x0A, 0xF9, 0xA8, 0x60, 0xE8,
+	0x68, 0x01, 0x46, 0xC0, 0x30, 0x04, 0x76, 0xC4, 0x75, 0x92, 0x20, 0x44, 0x54, 0x00, 0x20, 0xE9,
+	0x68, 0x09, 0x18, 0xC0, 0x31, 0xCC, 0x71, 0xEA, 0x68, 0x41, 0x00, 0x8A, 0x18, 0x40, 0x32, 0x54,
+	0x80, 0xEA, 0x68, 0x40, 0x1C, 
+	0x00, 0x00, 0x44, 0x00, 0x80, 0x89, 0x18, 0x60, 0x31, 0x4C, 0x80, 0x10, 0x28, 0xEF, 0xD3, 0x39,
+	0x46, 0x30, 0x46, 0x00, 0xF0, 0xDF, 0xF8, 0x00, 0xF0, 0xB9, 0xF8, 0xFF, 0xF7, 0x80, 0xFF, 0x00,
+	0x20, 0x81, 0x00, 0xAA, 0x68, 0x40, 0x1C, 0x89, 0x18, 0x0C, 0x62, 0x0B, 0x28, 0xF8, 0xD3, 0xE8,
+	0x68, 0x44, 0x70, 0x22, 0xE0, 0x0B, 0x29, 0x25, 0xD2, 0x49, 0x00, 0x08, 0x18, 0x40, 0x8C, 0xAA,
+	0x68, 0x41, 0x09, 0x89, 0x00, 0x89, 0x18, 0xC2, 0x06, 0x09, 0x6A, 0xD2, 0x0E, 0x01, 0x20, 0x90,
+	0x40, 0x01, 0x42, 0x0E, 0xD1, 0x00, 0x20, 0x81, 0x00, 0xAA, 0x68, 0x40, 0x1C, 0x89, 0x18, 0x0C,
+	0x62, 0x0B, 0x28, 0xF8, 0xD3, 0x00, 0x98, 0xFF, 0xF7, 0xBA, 0xFE, 0x00, 0xF0, 0x5F, 0xF8, 0xFF,
+	0xF7, 0x73, 0xFB, 0xE8, 0x68, 0x41, 0x78, 0x49, 0x1C, 0x41, 0x70, 0xE8, 0x68, 0x41, 0x78, 0x02,
+	0x78, 0x91, 0x42, 0xD7, 0xD3, 
+	0x00, 0x00, 0x45, 0x00, 0x80, 0xFF, 0xF7, 0x14, 0xFA, 0xE8, 0x68, 0xC0, 0x30, 0xC0, 0x7D, 0x41,
+	0x07, 0x89, 0x0F, 0x04, 0xD0, 0xA9, 0x78, 0xFA, 0x29, 0x01, 0xD2, 0x49, 0x1C, 0xA9, 0x70, 0x28,
+	0x70, 0x81, 0x07, 0x01, 0xD5, 0x41, 0x07, 0x09, 0xD4, 0x81, 0x06, 0x07, 0xD4, 0x41, 0x06, 0x05,
+	0xD4, 0x08, 0x28, 0x03, 0xD0, 0x1C, 0x48, 0x00, 0x78, 0x01, 0x28, 0x02, 0xD1, 0xAC, 0x70, 0xEC,
+	0x70, 0x2C, 0x70, 0x00, 0x98, 0xFF, 0xF7, 0xA1, 0xF8, 0x00, 0x98, 0xFF, 0xF7, 0x9E, 0xF8, 0xE8,
+	0x68, 0x00, 0x78, 0xFE, 0xBD, 0x30, 0xB5, 0x01, 0x21, 0x11, 0x4D, 0x16, 0xE0, 0x01, 0x20, 0x0C,
+	0xE0, 0x14, 0x18, 0xA0, 0x34, 0xE2, 0x7D, 0x23, 0x7E, 0x9A, 0x42, 0x04, 0xD2, 0xE3, 0x75, 0xEB,
+	0x68, 0x1B, 0x18, 0xA0, 0x33, 0x1A, 0x76, 0x40, 0x1C, 0xC0, 0xB2, 0xEA, 0x68, 0xB6, 0x23, 0x9B,
+	0x5C, 0x5B, 0x1A, 0x83, 0x42, 
+	0x00, 0x00, 0x46, 0x00, 0x80, 0xEC, 0xDC, 0x49, 0x1C, 0xC9, 0xB2, 0xE8, 0x68, 0xA0, 0x30, 0x80,
+	0x7D, 0x40, 0x1E, 0x88, 0x42, 0xE2, 0xDC, 0x30, 0xBD, 0x92, 0x08, 0x00, 0x20, 0x20, 0x03, 0x00,
+	0x20, 0x8C, 0x00, 0x00, 0x20, 0x9E, 0x00, 0x00, 0x20, 0xE9, 0x00, 0x00, 0x20, 0x10, 0xB5, 0x41,
+	0x4C, 0xA0, 0x68, 0x82, 0x69, 0xE0, 0x68, 0x01, 0x46, 0xA0, 0x31, 0x4B, 0x7D, 0x80, 0x30, 0x9A,
+	0x42, 0x01, 0xD9, 0x08, 0x21, 0x20, 0xE0, 0x89, 0x7D, 0x01, 0x29, 0x1C, 0xD9, 0xFF, 0xF7, 0x5C,
+	0xFD, 0xA0, 0x78, 0x05, 0x28, 0x14, 0xD3, 0x21, 0x78, 0x48, 0x07, 0x02, 0xD4, 0xE0, 0x78, 0x04,
+	0x28, 0x04, 0xD1, 0x04, 0x21, 0xE1, 0x70, 0xE0, 0x68, 0x80, 0x30, 0x0D, 0xE0, 0x89, 0x07, 0x01,
+	0xD4, 0x02, 0x28, 0x05, 0xD1, 0x02, 0x20, 0xE0, 0x70, 0xE1, 0x68, 0x80, 0x31, 0x88, 0x74, 0x10,
+	0xBD, 0xFF, 0xF7, 0xDD, 0xFC, 
+	0x00, 0x00, 0x47, 0x00, 0x80, 0x10, 0xBD, 0x01, 0x21, 0x81, 0x74, 0x10, 0xBD, 0x10, 0xB5, 0x29,
+	0x48, 0x00, 0x23, 0x01, 0x78, 0xC0, 0x68, 0x8C, 0x07, 0xA0, 0x30, 0x27, 0x4A, 0x00, 0x2C, 0x54,
+	0x88, 0x06, 0xDA, 0x02, 0x2C, 0x02, 0xD9, 0x54, 0x88, 0xA4, 0x1E, 0x01, 0xE0, 0x03, 0x75, 0x00,
+	0xE0, 0x04, 0x75, 0x0C, 0x07, 0x0B, 0xD5, 0x0C, 0x06, 0x09, 0xD4, 0x89, 0x07, 0x07, 0xD4, 0x11,
+	0x88, 0x06, 0x29, 0x02, 0xD9, 0x11, 0x88, 0x89, 0x1F, 0x02, 0xE0, 0x43, 0x75, 0x10, 0xBD, 0x11,
+	0x88, 0x41, 0x75, 0x10, 0xBD, 0xF0, 0xB5, 0x84, 0x46, 0x00, 0x22, 0x16, 0x4C, 0x19, 0xE0, 0x53,
+	0x00, 0xE5, 0x68, 0x58, 0x18, 0x40, 0x78, 0xAD, 0x18, 0xA8, 0x70, 0xE5, 0x68, 0xC8, 0x5C, 0xAD,
+	0x18, 0xA8, 0x74, 0xE5, 0x68, 0xA8, 0x18, 0x86, 0x78, 0x87, 0x7C, 0x10, 0x48, 0x5B, 0x19, 0x00,
+	0x78, 0x47, 0x43, 0xF0, 0x19, 
+	0x00, 0x00, 0x48, 0x00, 0x80, 0x58, 0x84, 0xE0, 0x68, 0x80, 0x18, 0x80, 0x30, 0xC2, 0x74, 0x52,
+	0x1C, 0xD2, 0xB2, 0x62, 0x45, 0xE3, 0xD3, 0xE0, 0x68, 0x61, 0x46, 0x01, 0x70, 0x01, 0x46, 0x82,
+	0x1C, 0x80, 0x31, 0x4A, 0x62, 0x10, 0x32, 0x22, 0x30, 0x8A, 0x62, 0xC8, 0x62, 0x04, 0x48, 0x08,
+	0x63, 0xF0, 0xBD, 0x00, 0x00, 0x8C, 0x00, 0x00, 0x20, 0x2C, 0x03, 0x00, 0x20, 0x9E, 0x00, 0x00,
+	0x20, 0x92, 0x08, 0x00, 0x20, 0x70, 0x47, 0x70, 0xB5, 0x20, 0x4D, 0x41, 0x78, 0x2B, 0x88, 0x02,
+	0x22, 0x99, 0x42, 0x02, 0xD8, 0x41, 0x79, 0x05, 0x29, 0x01, 0xD9, 0x02, 0x71, 0x70, 0xBD, 0x01,
+	0x78, 0x04, 0x23, 0x8C, 0x09, 0x1A, 0x49, 0x00, 0x2C, 0x0D, 0xD1, 0x10, 0x24, 0x04, 0x5F, 0x2E,
+	0x89, 0xB4, 0x42, 0x06, 0xDB, 0xED, 0x88, 0xAC, 0x42, 0xEF, 0xDC, 0x04, 0x7D, 0xC9, 0x79, 0x8C,
+	0x42, 0xEB, 0xD8, 0x03, 0x71, 
+	0x00, 0x00, 0x49, 0x00, 0x80, 0x70, 0xBD, 0x04, 0x7D, 0xCD, 0x79, 0xAC, 0x42, 0xF9, 0xD9, 0x16,
+	0x24, 0x04, 0x5F, 0x49, 0x8B, 0x8C, 0x42, 0xF4, 0xDB, 0x02, 0x71, 0x08, 0x21, 0x41, 0x5E, 0x06,
+	0x22, 0x1B, 0x24, 0x82, 0x5E, 0x61, 0x43, 0x49, 0x11, 0x8A, 0x42, 0xEA, 0xDB, 0x70, 0xBD, 0x41,
+	0x79, 0x01, 0x29, 0x00, 0xD9, 0xC7, 0xE7, 0x05, 0x4A, 0x41, 0x78, 0x12, 0x88, 0x91, 0x42, 0x01,
+	0xD3, 0x08, 0x21, 0x00, 0xE0, 0x01, 0x21, 0x01, 0x71, 0x70, 0x47, 0x00, 0x00, 0x2C, 0x03, 0x00,
+	0x20, 0x10, 0xE8, 0x00, 0x00, 0x70, 0x47, 0xFE, 0xB5, 0xFE, 0x4C, 0x25, 0x68, 0x03, 0x21, 0x09,
+	0x02, 0x28, 0x46, 0x88, 0x43, 0x20, 0x60, 0xFB, 0x48, 0x40, 0x30, 0x80, 0x68, 0x01, 0x90, 0xE0,
+	0x6B, 0x00, 0x90, 0x01, 0x98, 0xF7, 0x4A, 0x06, 0x0C, 0x00, 0x98, 0x36, 0x04, 0x07, 0x0C, 0xFF,
+	0x36, 0x02, 0x36, 0x3F, 0x04, 
+	0x00, 0x00, 0x4A, 0x00, 0x80, 0xFF, 0x37, 0xA0, 0x03, 0x31, 0x46, 0x02, 0x37, 0x41, 0x40, 0x40,
+	0x32, 0x91, 0x60, 0x78, 0x40, 0xE0, 0x63, 0x01, 0x20, 0x03, 0xF0, 0x10, 0xFE, 0xED, 0x48, 0x40,
+	0x30, 0x86, 0x60, 0xE7, 0x63, 0x01, 0x20, 0x03, 0xF0, 0x09, 0xFE, 0xEA, 0x49, 0x01, 0x98, 0x40,
+	0x31, 0x88, 0x60, 0x00, 0x98, 0xE0, 0x63, 0x25, 0x60, 0xFE, 0xBD, 0x10, 0xB5, 0xE6, 0x49, 0xC8,
+	0x68, 0x4A, 0x02, 0x10, 0x43, 0xC8, 0x60, 0xE5, 0x48, 0x81, 0x68, 0x05, 0x20, 0x28, 0x29, 0x03,
+	0xD3, 0x06, 0x20, 0x30, 0x29, 0x00, 0xD3, 0x07, 0x20, 0xE1, 0x49, 0x0A, 0x7C, 0x12, 0x09, 0x10,
+	0x18, 0x42, 0x00, 0x08, 0x7C, 0x40, 0x07, 0x40, 0x0F, 0x05, 0x28, 0x00, 0xD9, 0x00, 0x20, 0xDD,
+	0x4B, 0x80, 0x00, 0x1B, 0x58, 0xD7, 0x48, 0x13, 0x43, 0xC0, 0x30, 0x03, 0x61, 0x89, 0x7C, 0xDA,
+	0x4A, 0x09, 0x07, 0x09, 0x0F, 
+	0x00, 0x00, 0x4B, 0x00, 0x80, 0x89, 0x18, 0x41, 0x60, 0x03, 0x21, 0x81, 0x60, 0xD1, 0x49, 0x92,
+	0x0C, 0x40, 0x31, 0x8A, 0x62, 0xD2, 0x4A, 0x60, 0x3A, 0x92, 0x69, 0xCE, 0x4B, 0x80, 0x33, 0x9A,
+	0x63, 0x01, 0x22, 0x12, 0x03, 0x02, 0x60, 0x09, 0x20, 0x00, 0x07, 0x88, 0x61, 0xC9, 0x4C, 0x20,
+	0x68, 0x49, 0x06, 0x08, 0x43, 0x20, 0x60, 0x05, 0x20, 0x03, 0xF0, 0xE7, 0xFD, 0x05, 0x20, 0x03,
+	0xF0, 0xD5, 0xFD, 0x20, 0x68, 0x00, 0x06, 0x80, 0x0F, 0x01, 0xD0, 0xFF, 0xF7, 0x84, 0xFF, 0x10,
+	0xBD, 0x70, 0xB5, 0xC6, 0x48, 0x01, 0x7E, 0x00, 0x29, 0x17, 0xD0, 0xC5, 0x4A, 0x80, 0x8D, 0x51,
+	0x43, 0x80, 0x03, 0x0B, 0xF0, 0x6C, 0xFA, 0xBE, 0x4B, 0x00, 0x21, 0xC2, 0x4C, 0xC2, 0x4D, 0x20,
+	0x3B, 0xDE, 0x69, 0x64, 0x22, 0x00, 0x2E, 0x01, 0xD0, 0x0A, 0x19, 0x12, 0x78, 0x4E, 0x00, 0x42,
+	0x43, 0x12, 0x12, 0x49, 0x1C, 
+	0x00, 0x00, 0x4C, 0x00, 0x80, 0xAA, 0x53, 0x08, 0x29, 0xF2, 0xD3, 0x70, 0xBD, 0xF8, 0xB5, 0x00,
+	0x21, 0x05, 0x20, 0x03, 0xF0, 0xA1, 0xFD, 0xB2, 0x4F, 0x60, 0x3F, 0xF8, 0x69, 0xB3, 0x4C, 0x60,
+	0x70, 0x38, 0x6A, 0xA0, 0x70, 0x00, 0x20, 0xB5, 0x4D, 0x60, 0x77, 0xE8, 0x68, 0xF0, 0x21, 0x08,
+	0x40, 0x20, 0x77, 0x28, 0x6A, 0x20, 0x75, 0xA8, 0x68, 0xA0, 0x75, 0xA8, 0x68, 0x3E, 0x46, 0x00,
+	0x0A, 0x20, 0x76, 0x40, 0x36, 0x70, 0x68, 0xA0, 0x85, 0xFF, 0xF7, 0xC2, 0xFF, 0x68, 0x6F, 0x60,
+	0x75, 0xE8, 0x6D, 0xE0, 0x75, 0xE8, 0x6D, 0xE9, 0x1D, 0x00, 0x0A, 0x60, 0x76, 0xF9, 0x31, 0x49,
+	0x68, 0xC0, 0xB2, 0x0D, 0x0A, 0x39, 0x69, 0x0F, 0x0A, 0x64, 0x21, 0x41, 0x43, 0xB0, 0x68, 0x00,
+	0x03, 0x0B, 0xF0, 0x25, 0xFA, 0xA0, 0x84, 0x29, 0x46, 0x64, 0x20, 0x41, 0x43, 0x30, 0x69, 0x00,
+	0x03, 0x0B, 0xF0, 0x1D, 0xFA, 
+	0x00, 0x00, 0x4D, 0x00, 0x80, 0xE0, 0x84, 0x39, 0x46, 0x64, 0x20, 0x41, 0x43, 0x30, 0x69, 0x00,
+	0x03, 0x0B, 0xF0, 0x15, 0xFA, 0x20, 0x85, 0x92, 0x48, 0xC0, 0x7A, 0xC0, 0x07, 0x02, 0xD0, 0x04,
+	0xF0, 0xDF, 0xFC, 0xF8, 0xBD, 0x04, 0xF0, 0xE0, 0xFC, 0xF8, 0xBD, 0x10, 0xB5, 0x8F, 0x4C, 0x20,
+	0x78, 0x00, 0x28, 0x03, 0xD1, 0xFF, 0xF7, 0xAA, 0xFF, 0x01, 0x20, 0x20, 0x70, 0xFF, 0xF7, 0x3D,
+	0xFF, 0x10, 0xBD, 0x84, 0x49, 0x8E, 0x48, 0x48, 0x61, 0x82, 0x49, 0x8E, 0x48, 0x40, 0x31, 0x48,
+	0x62, 0x01, 0x21, 0x80, 0x48, 0xC9, 0x03, 0xC0, 0x30, 0x01, 0x60, 0x41, 0x68, 0x49, 0x00, 0x49,
+	0x08, 0x41, 0x60, 0x81, 0x68, 0x49, 0x08, 0x49, 0x00, 0x81, 0x60, 0x01, 0x69, 0x01, 0x22, 0x89,
+	0x00, 0x89, 0x08, 0x92, 0x07, 0x89, 0x18, 0x01, 0x61, 0x70, 0x47, 0x10, 0xB5, 0x75, 0x48, 0x01,
+	0x68, 0x49, 0x00, 0x49, 0x08, 
+	0x00, 0x00, 0x4E, 0x00, 0x80, 0x01, 0x60, 0x05, 0x20, 0x03, 0xF0, 0x37, 0xFD, 0x05, 0x20, 0x03,
+	0xF0, 0x3C, 0xFD, 0x10, 0xBD, 0x7C, 0x48, 0x00, 0x88, 0xC0, 0xB2, 0x70, 0x47, 0x30, 0xB5, 0x05,
+	0x68, 0x6C, 0x4C, 0x25, 0x60, 0x45, 0x68, 0xA5, 0x60, 0x85, 0x68, 0x65, 0x61, 0xC5, 0x68, 0xA5,
+	0x61, 0xC5, 0x69, 0xA5, 0x62, 0x05, 0x69, 0xE5, 0x61, 0x45, 0x69, 0x25, 0x62, 0x85, 0x69, 0x65,
+	0x62, 0xC5, 0x69, 0xA5, 0x62, 0x05, 0x6A, 0xE5, 0x62, 0x45, 0x6A, 0x25, 0x63, 0x85, 0x6A, 0x65,
+	0x63, 0xC5, 0x6A, 0xA5, 0x63, 0x05, 0x6B, 0xE5, 0x63, 0x45, 0x6B, 0x5E, 0x4C, 0x40, 0x34, 0x25,
+	0x60, 0x85, 0x6B, 0x65, 0x60, 0xC5, 0x6B, 0xA5, 0x60, 0x05, 0x6C, 0xE5, 0x60, 0x45, 0x6C, 0x25,
+	0x61, 0x85, 0x6C, 0x65, 0x61, 0xC0, 0x6C, 0x60, 0x62, 0x59, 0x48, 0x60, 0x38, 0x40, 0x69, 0x85,
+	0x09, 0xAD, 0x01, 0x54, 0x48, 
+	0x00, 0x00, 0x4F, 0x00, 0x80, 0x0D, 0x43, 0x80, 0x30, 0xC5, 0x63, 0xA2, 0x61, 0x03, 0x61, 0x30,
+	0xBD, 0x02, 0x46, 0x00, 0x20, 0x01, 0x2A, 0x07, 0xD0, 0x02, 0x2A, 0x05, 0xD0, 0x08, 0x2A, 0x02,
+	0xD1, 0x4F, 0x48, 0x60, 0x38, 0xC0, 0x6B, 0x70, 0x47, 0x08, 0x46, 0x70, 0x47, 0x49, 0x48, 0xC0,
+	0x30, 0x01, 0x69, 0x8A, 0x00, 0x92, 0x08, 0x41, 0x06, 0x52, 0x18, 0x02, 0x61, 0x42, 0x68, 0x0A,
+	0x43, 0x42, 0x60, 0x81, 0x68, 0x01, 0x22, 0x11, 0x43, 0x81, 0x60, 0x70, 0x47, 0x70, 0xB5, 0xFF,
+	0xF7, 0xED, 0xFF, 0x01, 0x24, 0x45, 0x4D, 0x00, 0x21, 0xEC, 0x72, 0x20, 0x46, 0xFF, 0xF7, 0xD8,
+	0xFF, 0xE8, 0x70, 0x04, 0xF0, 0x45, 0xFC, 0x00, 0x28, 0x01, 0xD0, 0x48, 0x48, 0x04, 0x70, 0x3C,
+	0x4C, 0x20, 0x3C, 0x20, 0x6A, 0x02, 0x28, 0x01, 0xD1, 0x45, 0x49, 0x00, 0xE0, 0x45, 0x49, 0x05,
+	0x20, 0x03, 0xF0, 0xA3, 0xFC, 
+	0x00, 0x00, 0x50, 0x00, 0x80, 0x00, 0x20, 0x44, 0x4A, 0x28, 0x71, 0x50, 0x69, 0x43, 0x49, 0x01,
+	0x23, 0x09, 0x78, 0x1B, 0x03, 0x00, 0x02, 0xC9, 0x18, 0x08, 0x43, 0x2E, 0x49, 0xC0, 0x31, 0x08,
+	0x60, 0x00, 0x20, 0x3F, 0x4B, 0x0F, 0x21, 0x86, 0x00, 0xF6, 0x18, 0x31, 0x60, 0x40, 0x1C, 0x41,
+	0x28, 0xF9, 0xD3, 0x53, 0x6B, 0x31, 0x4E, 0x0F, 0x22, 0x12, 0x07, 0x00, 0x21, 0x30, 0x1D, 0xFF,
+	0xF7, 0x6D, 0xFF, 0x71, 0x68, 0x68, 0x7F, 0x00, 0x28, 0x05, 0xD0, 0x05, 0x20, 0x81, 0x43, 0xC8,
+	0x06, 0x01, 0xD4, 0xC0, 0x20, 0x81, 0x43, 0xFF, 0xF7, 0x5D, 0xFF, 0x02, 0x09, 0x31, 0x48, 0x03,
+	0xD0, 0x1F, 0x4A, 0x92, 0x7A, 0x01, 0x2A, 0x03, 0xD0, 0x62, 0x69, 0x52, 0x07, 0x00, 0xD0, 0x00,
+	0x20, 0x18, 0x4A, 0x81, 0x43, 0x11, 0x60, 0x28, 0x7E, 0xA9, 0x7D, 0x00, 0x02, 0x08, 0x43, 0x90,
+	0x60, 0x31, 0x6A, 0x29, 0x48, 
+	0x00, 0x00, 0x51, 0x00, 0x80, 0x01, 0x40, 0x28, 0x7D, 0x01, 0x43, 0x00, 0x04, 0x01, 0x43, 0x91,
+	0x62, 0xF0, 0x68, 0xF0, 0x21, 0x88, 0x43, 0x29, 0x7F, 0x08, 0x43, 0x50, 0x61, 0x0D, 0x4B, 0x00,
+	0x20, 0x22, 0x49, 0x40, 0x33, 0x85, 0x00, 0xED, 0x18, 0xE9, 0x62, 0x40, 0x1C, 0x09, 0x28, 0xF9,
+	0xD3, 0x60, 0x69, 0x00, 0x28, 0x05, 0xD1, 0x07, 0x48, 0x80, 0x30, 0xC1, 0x68, 0x49, 0x00, 0x49,
+	0x08, 0xC1, 0x60, 0x20, 0x6A, 0x02, 0x28, 0x04, 0xD1, 0x50, 0x69, 0x01, 0x21, 0xC9, 0x02, 0x08,
+	0x43, 0x50, 0x61, 0x70, 0xBD, 0x00, 0x00, 0x11, 0x40, 0x00, 0x00, 0x01, 0x40, 0x00, 0xFF, 0x01,
+	0x40, 0x50, 0xEA, 0x00, 0x00, 0xB8, 0xDC, 0x00, 0x00, 0x40, 0x40, 0x00, 0x80, 0x9C, 0x00, 0x00,
+	0x20, 0x71, 0x02, 0x00, 0x00, 0x60, 0xF1, 0xFF, 0x0F, 0x76, 0x03, 0x00, 0x20, 0xB0, 0xE8, 0x00,
+	0x00, 0xFF, 0x00, 0xAF, 0x40, 
+	0x00, 0x00, 0x52, 0x00, 0x80, 0x0A, 0xA0, 0x00, 0x00, 0xF8, 0x01, 0x00, 0x20, 0xB4, 0x01, 0x00,
+	0x20, 0xBD, 0x65, 0x00, 0x00, 0x17, 0x63, 0x00, 0x00, 0x80, 0xEA, 0x00, 0x00, 0xC8, 0x01, 0x00,
+	0x20, 0x00, 0x04, 0x11, 0x40, 0x00, 0x00, 0x00, 0x01, 0x00, 0xFF, 0x00, 0xFF, 0x01, 0x00, 0x00,
+	0xC0, 0x10, 0xB5, 0x00, 0x22, 0xFF, 0x4B, 0x04, 0xE0, 0x94, 0x00, 0xE4, 0x18, 0xE1, 0x62, 0x52,
+	0x1C, 0xD2, 0xB2, 0x82, 0x42, 0xF8, 0xD3, 0x10, 0xBD, 0x70, 0xB5, 0xFF, 0xF7, 0x2F, 0xFF, 0x02,
+	0x26, 0xF9, 0x4D, 0x00, 0x21, 0xEE, 0x72, 0x30, 0x46, 0xFF, 0xF7, 0x1A, 0xFF, 0xE8, 0x70, 0x04,
+	0xF0, 0x87, 0xFB, 0x00, 0x28, 0x02, 0xD0, 0xF5, 0x48, 0x01, 0x21, 0x01, 0x70, 0xF4, 0x4C, 0x20,
+	0x6A, 0x02, 0x28, 0x68, 0x78, 0x03, 0xD1, 0xC0, 0x1C, 0x80, 0x08, 0x80, 0x00, 0xFF, 0xE7, 0xF0,
+	0x49, 0x40, 0x39, 0x09, 0x6B, 
+	0x00, 0x00, 0x53, 0x00, 0x80, 0x41, 0x43, 0x29, 0x71, 0xEE, 0x49, 0x05, 0x20, 0x03, 0xF0, 0xDD,
+	0xFB, 0xED, 0x49, 0x88, 0x69, 0x01, 0x22, 0x00, 0x02, 0x12, 0x03, 0x10, 0x43, 0xE5, 0x4A, 0x80,
+	0x32, 0x10, 0x60, 0xEA, 0x4A, 0x00, 0x20, 0x83, 0x00, 0x9B, 0x18, 0x1E, 0x60, 0x40, 0x1C, 0x41,
+	0x28, 0xF9, 0xD3, 0x8B, 0x6B, 0x0D, 0x22, 0x12, 0x07, 0x32, 0x21, 0xE5, 0x48, 0xFF, 0xF7, 0xAE,
+	0xFE, 0xE3, 0x4A, 0x58, 0x3A, 0x91, 0x6D, 0x68, 0x7F, 0x00, 0x28, 0x05, 0xD0, 0x05, 0x20, 0x81,
+	0x43, 0xC8, 0x06, 0x01, 0xD4, 0xC0, 0x20, 0x81, 0x43, 0xFF, 0xF7, 0x9C, 0xFE, 0x03, 0x09, 0xDD,
+	0x48, 0x04, 0xD0, 0xD7, 0x4B, 0x20, 0x33, 0x9B, 0x7A, 0x01, 0x2B, 0x03, 0xD0, 0x63, 0x69, 0x5B,
+	0x07, 0x00, 0xD0, 0x00, 0x20, 0xCF, 0x4B, 0x81, 0x43, 0x40, 0x3B, 0x19, 0x60, 0x68, 0x7E, 0xE9,
+	0x7D, 0x00, 0x02, 0x08, 0x43, 
+	0x00, 0x00, 0x54, 0x00, 0x80, 0x98, 0x60, 0x51, 0x6F, 0xD3, 0x48, 0x01, 0x40, 0x68, 0x7D, 0x01,
+	0x43, 0x00, 0x04, 0x01, 0x43, 0x99, 0x62, 0xD1, 0x49, 0x09, 0x20, 0xFF, 0xF7, 0x89, 0xFF, 0xCF,
+	0x49, 0xC4, 0x48, 0x89, 0x1E, 0x40, 0x30, 0xC1, 0x60, 0x61, 0x69, 0x00, 0x29, 0x03, 0xD1, 0xC1,
+	0x68, 0x49, 0x00, 0x49, 0x08, 0xC1, 0x60, 0x4C, 0xE7, 0xC4, 0x4A, 0x00, 0x21, 0x8B, 0x00, 0x9B,
+	0x18, 0x18, 0x60, 0x49, 0x1C, 0xC9, 0xB2, 0x41, 0x29, 0xF8, 0xD3, 0x70, 0x47, 0xF8, 0xB5, 0xFF,
+	0xF7, 0xBD, 0xFE, 0xB9, 0x4F, 0xB7, 0x4D, 0x38, 0x7E, 0x01, 0x24, 0x24, 0x03, 0x40, 0x3D, 0x10,
+	0x28, 0x05, 0xD9, 0xBB, 0x48, 0x58, 0x38, 0x80, 0x68, 0xC0, 0xB2, 0x00, 0x19, 0xA8, 0x60, 0x0F,
+	0x20, 0xFF, 0xF7, 0xE2, 0xFF, 0x00, 0x26, 0xB0, 0x48, 0xFE, 0x74, 0x7E, 0x85, 0x20, 0x30, 0x46,
+	0x70, 0x86, 0x70, 0xAF, 0x48, 
+	0x00, 0x00, 0x55, 0x00, 0x80, 0x3E, 0x64, 0x40, 0x38, 0xC0, 0x6B, 0xF8, 0x70, 0x10, 0x20, 0xF8,
+	0x72, 0xB3, 0x49, 0x05, 0x20, 0x03, 0xF0, 0x59, 0xFB, 0xA9, 0x48, 0x40, 0x69, 0xA5, 0x49, 0x40,
+	0x31, 0x02, 0x28, 0x03, 0xD0, 0xC8, 0x68, 0x40, 0x00, 0x40, 0x08, 0xC8, 0x60, 0x00, 0x20, 0x82,
+	0x00, 0x52, 0x18, 0x56, 0x61, 0x40, 0x1C, 0x09, 0x28, 0xF9, 0xD3, 0x9E, 0x48, 0x80, 0x30, 0x04,
+	0x60, 0xA9, 0x6A, 0xA5, 0x4A, 0xD2, 0x43, 0x11, 0x40, 0xA9, 0x62, 0x0D, 0x21, 0x99, 0x4A, 0x09,
+	0x07, 0x91, 0x61, 0x9B, 0x49, 0x20, 0x31, 0x09, 0x7D, 0x00, 0x29, 0x07, 0xD0, 0x01, 0x69, 0xA1,
+	0x4A, 0x11, 0x40, 0x01, 0x61, 0x01, 0x69, 0xA0, 0x4A, 0x11, 0x43, 0x01, 0x61, 0xF8, 0xBD, 0xF0,
+	0xB5, 0x04, 0x46, 0x0F, 0x20, 0xFF, 0xF7, 0xA0, 0xFF, 0x21, 0x46, 0x02, 0x20, 0xFF, 0xF7, 0x48,
+	0xFE, 0x16, 0x21, 0x9A, 0x4D, 
+	0x00, 0x00, 0x56, 0x00, 0x80, 0x48, 0x43, 0x2A, 0x5A, 0x8B, 0x49, 0x44, 0x19, 0x4A, 0x85, 0xA2,
+	0x78, 0xCA, 0x74, 0x97, 0x4E, 0x8D, 0x4F, 0x00, 0x21, 0x2A, 0x5A, 0x01, 0x23, 0x8B, 0x40, 0x1A,
+	0x42, 0x06, 0xD0, 0x62, 0x18, 0x53, 0x7B, 0x12, 0x79, 0xB2, 0x5C, 0x92, 0x00, 0xD2, 0x19, 0x13,
+	0x60, 0x49, 0x1C, 0x08, 0x29, 0xF0, 0xD3, 0xF0, 0xBD, 0x70, 0xB5, 0x7F, 0x49, 0x7D, 0x4D, 0x09,
+	0x79, 0x00, 0x24, 0x0E, 0x18, 0x40, 0x35, 0x21, 0x46, 0x30, 0x46, 0x05, 0xF0, 0xA1, 0xF8, 0x01,
+	0x02, 0x01, 0x43, 0xA0, 0x00, 0x40, 0x19, 0x41, 0x61, 0x64, 0x1C, 0x09, 0x2C, 0xF3, 0xD3, 0xB8,
+	0xE6, 0xF0, 0xB5, 0x77, 0x4A, 0x83, 0x49, 0x40, 0x3A, 0x53, 0x6A, 0x81, 0x4A, 0x52, 0x1E, 0x9A,
+	0x5C, 0x93, 0x00, 0x76, 0x4A, 0x9A, 0x18, 0x13, 0x68, 0x96, 0x46, 0x9C, 0x46, 0x0C, 0x23, 0x13,
+	0x60, 0x6C, 0x4A, 0x40, 0x3A, 
+	0x00, 0x00, 0x57, 0x00, 0x80, 0x13, 0x68, 0x97, 0x68, 0x94, 0x6A, 0x15, 0x68, 0x01, 0x26, 0xB6,
+	0x02, 0xB5, 0x43, 0x15, 0x60, 0xFF, 0x25, 0x02, 0x35, 0x95, 0x60, 0x00, 0x28, 0x06, 0xD0, 0x95,
+	0x6A, 0x6D, 0x4E, 0x35, 0x40, 0x05, 0x43, 0x00, 0x04, 0x05, 0x43, 0x95, 0x62, 0x07, 0x20, 0xD0,
+	0x60, 0x15, 0x68, 0x01, 0x26, 0xB6, 0x07, 0x35, 0x43, 0x15, 0x60, 0xD5, 0x68, 0xED, 0x07, 0x01,
+	0xD1, 0x49, 0x1E, 0xFA, 0xD2, 0xD0, 0x60, 0x60, 0x46, 0x71, 0x46, 0x08, 0x60, 0x13, 0x60, 0x97,
+	0x60, 0x94, 0x62, 0xF0, 0xBD, 0xF0, 0xB5, 0x58, 0x4B, 0x01, 0x46, 0xD8, 0x7A, 0xFF, 0xF7, 0xD8,
+	0xFD, 0x04, 0x46, 0xD8, 0x7A, 0x02, 0x28, 0x00, 0xD0, 0x0F, 0x20, 0xFF, 0xF7, 0x25, 0xFF, 0x16,
+	0x21, 0x4C, 0x43, 0x5E, 0x49, 0x00, 0x20, 0x01, 0x26, 0x5D, 0x4F, 0x54, 0x4D, 0x62, 0x18, 0x5B,
+	0x49, 0x0B, 0x5B, 0x31, 0x46, 
+	0x00, 0x00, 0x58, 0x00, 0x80, 0x81, 0x40, 0x0B, 0x42, 0x06, 0xD0, 0x11, 0x18, 0x4B, 0x7B, 0x09,
+	0x79, 0x79, 0x5C, 0x89, 0x00, 0x49, 0x19, 0x0B, 0x60, 0x40, 0x1C, 0x08, 0x28, 0xEF, 0xD3, 0x46,
+	0x48, 0xC1, 0x7A, 0x02, 0x29, 0x06, 0xD1, 0xD0, 0x78, 0xFF, 0x28, 0x03, 0xD0, 0x0C, 0x22, 0x80,
+	0x00, 0x40, 0x19, 0x02, 0x60, 0x08, 0x29, 0x0E, 0xD1, 0x41, 0x48, 0x40, 0x38, 0x01, 0x6A, 0xC2,
+	0x69, 0xC0, 0x6A, 0x89, 0x18, 0x08, 0x18, 0x3E, 0x49, 0x49, 0x6A, 0x01, 0x29, 0x03, 0xD0, 0x38,
+	0x5C, 0x80, 0x00, 0x40, 0x19, 0x06, 0x60, 0xF0, 0xBD, 0xFE, 0xB5, 0x39, 0x4A, 0x14, 0x25, 0x40,
+	0x3A, 0x10, 0x6B, 0x01, 0x90, 0x34, 0x48, 0x00, 0x21, 0x44, 0x78, 0x86, 0x78, 0x01, 0x73, 0xC1,
+	0x71, 0x41, 0x71, 0x81, 0x71, 0x81, 0x73, 0x01, 0x74, 0x63, 0x1E, 0x43, 0x74, 0x81, 0x74, 0x81,
+	0x72, 0x51, 0x6A, 0x49, 0x1E, 
+	0x00, 0x00, 0x59, 0x00, 0x80, 0x41, 0x72, 0x00, 0x20, 0xFF, 0xF7, 0xA4, 0xFF, 0x00, 0x20, 0xFF,
+	0xF7, 0x53, 0xFF, 0x04, 0xF0, 0xF3, 0xF9, 0x00, 0x20, 0x04, 0xF0, 0x1A, 0xFA, 0x04, 0xF0, 0x0A,
+	0xFA, 0x27, 0x4F, 0x78, 0x69, 0x00, 0x28, 0x08, 0xD0, 0x23, 0x4A, 0x31, 0x49, 0x52, 0x7A, 0x0C,
+	0x20, 0x89, 0x5C, 0x26, 0x4A, 0x89, 0x00, 0x89, 0x18, 0x08, 0x60, 0x38, 0x6A, 0x02, 0x28, 0x07,
+	0xD1, 0x00, 0x21, 0x30, 0x46, 0x03, 0xF0, 0x60, 0xFC, 0xE4, 0x1C, 0xA4, 0x08, 0xA4, 0x00, 0x06,
+	0xE0, 0x27, 0x49, 0x1E, 0x4A, 0x89, 0x5D, 0x01, 0x20, 0x89, 0x00, 0x89, 0x18, 0x08, 0x60, 0x01,
+	0x98, 0x60, 0x43, 0x15, 0x4C, 0x60, 0x73, 0x16, 0x48, 0x20, 0x30, 0xC0, 0x7C, 0xFF, 0xF7, 0x38,
+	0xFF, 0x10, 0x48, 0x21, 0x49, 0x40, 0x38, 0xC1, 0x60, 0x03, 0xF0, 0x18, 0xFA, 0x00, 0x90, 0x0D,
+	0x48, 0x40, 0x38, 0x00, 0x68, 
+	0x00, 0x00, 0x5A, 0x00, 0x80, 0x03, 0x21, 0x49, 0x07, 0x08, 0x43, 0x0A, 0x49, 0x40, 0x39, 0x08,
+	0x60, 0x08, 0x48, 0x40, 0x38, 0x00, 0x68, 0x80, 0x00, 0x01, 0xD5, 0x6D, 0x1E, 0xF8, 0xD2, 0x38,
+	0x6A, 0x02, 0x28, 0x2B, 0xD1, 0x01, 0x21, 0x30, 0x46, 0x03, 0xF0, 0x2E, 0xFC, 0x00, 0x20, 0x20,
+	0x72, 0x32, 0xE0, 0x00, 0x00, 0x40, 0x00, 0x11, 0x40, 0x9C, 0x00, 0x00, 0x20, 0xB4, 0x01, 0x00,
+	0x20, 0x30, 0xEA, 0x00, 0x00, 0xC1, 0x68, 0x00, 0x00, 0x80, 0xEA, 0x00, 0x00, 0x00, 0x04, 0x11,
+	0x40, 0x08, 0xE9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0xFF, 0x00, 0xFF, 0x03, 0x00, 0x00,
+	0xC0, 0xC7, 0x69, 0x00, 0x00, 0xFF, 0xE0, 0xE3, 0xF1, 0x00, 0x0F, 0x08, 0x08, 0x00, 0xEC, 0x00,
+	0x00, 0x00, 0xEB, 0x00, 0x00, 0x88, 0x90, 0x00, 0x00, 0xFF, 0x03, 0x00, 0x00, 0xFB, 0x48, 0x0F,
+	0x21, 0x82, 0x5D, 0x93, 0x00, 
+	0x00, 0x00, 0x5B, 0x00, 0x80, 0xFA, 0x4A, 0x9B, 0x18, 0x19, 0x60, 0x80, 0x19, 0x40, 0x78, 0x01,
+	0x21, 0x80, 0x00, 0x80, 0x18, 0x01, 0x60, 0x21, 0x72, 0x01, 0x20, 0xFF, 0xF7, 0xCD, 0xFE, 0xF5,
+	0x48, 0x01, 0x68, 0x03, 0x22, 0x52, 0x07, 0x11, 0x43, 0x01, 0x60, 0x01, 0x69, 0x02, 0x22, 0x11,
+	0x43, 0x01, 0x61, 0x00, 0x98, 0x03, 0xF0, 0xBE, 0xF9, 0xFE, 0xBD, 0x10, 0xB5, 0xEE, 0x4C, 0x00,
+	0x21, 0xA1, 0x72, 0xA1, 0x74, 0xED, 0x49, 0x89, 0x69, 0x01, 0x22, 0x12, 0x03, 0x09, 0x02, 0x80,
+	0x18, 0x01, 0x43, 0xE8, 0x48, 0xC0, 0x30, 0x01, 0x60, 0x04, 0xF0, 0x50, 0xF9, 0x60, 0x79, 0xFF,
+	0xF7, 0xF9, 0xFE, 0x60, 0x79, 0xFF, 0xF7, 0xA8, 0xFE, 0x60, 0x79, 0x04, 0xF0, 0x71, 0xF9, 0x04,
+	0xF0, 0x61, 0xF9, 0xE0, 0x4C, 0x20, 0x68, 0x00, 0x06, 0x80, 0x0F, 0x02, 0xD0, 0x00, 0x20, 0xFF,
+	0xF7, 0xAF, 0xFE, 0xDF, 0x48, 
+	0x00, 0x00, 0x5C, 0x00, 0x80, 0xE0, 0x60, 0x03, 0xF0, 0x91, 0xF9, 0x21, 0x69, 0x02, 0x22, 0x11,
+	0x43, 0x21, 0x61, 0x21, 0x68, 0x03, 0x22, 0x52, 0x07, 0x11, 0x43, 0x21, 0x60, 0x03, 0xF0, 0x8A,
+	0xF9, 0x10, 0xBD, 0xD8, 0x49, 0x02, 0x20, 0x08, 0x70, 0xD7, 0x48, 0x81, 0x6B, 0x42, 0x6B, 0x8A,
+	0x18, 0xD1, 0x49, 0x4A, 0x73, 0x40, 0x6B, 0x48, 0x71, 0xC0, 0xB2, 0x40, 0x1C, 0x88, 0x71, 0xD3,
+	0x48, 0x00, 0x78, 0xBA, 0xE7, 0xCF, 0x48, 0x01, 0x21, 0x01, 0x70, 0xCF, 0x48, 0x42, 0x6B, 0xCA,
+	0x48, 0x42, 0x73, 0x00, 0x22, 0x42, 0x71, 0x81, 0x71, 0xCD, 0x48, 0x00, 0x78, 0xAD, 0xE7, 0xCD,
+	0x49, 0x08, 0x70, 0xC1, 0x07, 0x00, 0xD0, 0xED, 0xE7, 0x80, 0x07, 0x00, 0xD5, 0xD9, 0xE7, 0x70,
+	0x47, 0x70, 0xB5, 0x05, 0x46, 0xC4, 0x48, 0x42, 0x6B, 0xBF, 0x49, 0x20, 0x31, 0x48, 0x78, 0x82,
+	0x42, 0x00, 0xD8, 0x88, 0x78, 
+	0x00, 0x00, 0x5D, 0x00, 0x80, 0xFF, 0xF7, 0x33, 0xFE, 0x04, 0xF0, 0xF8, 0xF8, 0xBA, 0x4E, 0x70,
+	0x8D, 0x04, 0xF0, 0x10, 0xF9, 0xB7, 0x4C, 0x20, 0x68, 0x00, 0x06, 0x80, 0x0F, 0x02, 0xD0, 0x00,
+	0x20, 0xFF, 0xF7, 0x5E, 0xFE, 0x04, 0xF0, 0xE4, 0xF8, 0x00, 0x21, 0x00, 0x28, 0x03, 0xD0, 0xBA,
+	0x48, 0x00, 0x78, 0x01, 0x28, 0x05, 0xD1, 0xB1, 0x76, 0xF1, 0x85, 0xF1, 0x76, 0xB7, 0x48, 0x71,
+	0x63, 0x01, 0x60, 0x00, 0x2D, 0x15, 0xD0, 0xB1, 0x74, 0xB1, 0x72, 0x75, 0x73, 0x00, 0x20, 0xFF,
+	0xF7, 0x47, 0xFE, 0xE0, 0x69, 0xF0, 0x21, 0x88, 0x43, 0xE0, 0x61, 0xA9, 0x48, 0xE0, 0x60, 0x20,
+	0x68, 0x03, 0x21, 0x49, 0x07, 0x08, 0x43, 0x20, 0x60, 0x20, 0x69, 0x02, 0x21, 0x08, 0x43, 0x20,
+	0x61, 0xEF, 0xE4, 0x01, 0x20, 0xB0, 0x74, 0xEC, 0xE4, 0x10, 0xB5, 0x9E, 0x48, 0x41, 0x68, 0x9E,
+	0x4C, 0x09, 0x07, 0x09, 0x0F, 
+	0x00, 0x00, 0x5E, 0x00, 0x80, 0x01, 0x29, 0x04, 0xD0, 0x9A, 0x49, 0xC0, 0x31, 0x49, 0x68, 0xC9,
+	0x00, 0x0C, 0xD4, 0x01, 0x69, 0x02, 0x22, 0x91, 0x43, 0x01, 0x61, 0xD1, 0x1E, 0xC1, 0x60, 0x05,
+	0x20, 0x03, 0xF0, 0x33, 0xF9, 0x9E, 0x48, 0x20, 0x63, 0x01, 0x20, 0x10, 0xBD, 0xA0, 0x7C, 0x10,
+	0xBD, 0xF3, 0xB5, 0x8E, 0x46, 0x90, 0x48, 0x00, 0x21, 0xC1, 0x73, 0xFF, 0x21, 0x81, 0x73, 0x92,
+	0x48, 0x00, 0x22, 0x84, 0x46, 0x1E, 0xE0, 0x16, 0x21, 0x16, 0x46, 0x4E, 0x43, 0x95, 0x49, 0x00,
+	0x20, 0x77, 0x18, 0xD3, 0xB2, 0x3C, 0x18, 0x25, 0x79, 0x00, 0x99, 0x8D, 0x42, 0x0E, 0xD3, 0x91,
+	0x4D, 0x24, 0x79, 0x74, 0x45, 0x0A, 0xD8, 0xAC, 0x5B, 0x01, 0x25, 0x85, 0x40, 0x2C, 0x42, 0x05,
+	0xD0, 0x81, 0x4C, 0xA5, 0x7B, 0xFF, 0x2D, 0x00, 0xD1, 0xA3, 0x73, 0xE3, 0x73, 0x40, 0x1C, 0x08,
+	0x28, 0xE8, 0xD3, 0x52, 0x1C, 
+	0x00, 0x00, 0x5F, 0x00, 0x80, 0x60, 0x46, 0x00, 0x6B, 0x90, 0x42, 0xDC, 0xD8, 0xFC, 0xBD, 0xFF,
+	0xB5, 0x05, 0x46, 0x79, 0x4C, 0x10, 0x46, 0xA2, 0x78, 0x87, 0xB0, 0x19, 0x46, 0x14, 0x26, 0x57,
+	0x19, 0x02, 0x92, 0xFF, 0xF7, 0xC5, 0xFF, 0x00, 0x21, 0x21, 0x73, 0xE8, 0xB2, 0x06, 0x90, 0xE0,
+	0x71, 0xA0, 0x7B, 0x60, 0x71, 0xA0, 0x71, 0x06, 0x98, 0x20, 0x74, 0x08, 0x98, 0x60, 0x74, 0xA1,
+	0x74, 0xA1, 0x72, 0x60, 0x79, 0xFF, 0xF7, 0x06, 0xFE, 0x60, 0x78, 0xA1, 0x7B, 0x48, 0x43, 0x40,
+	0x19, 0x03, 0x90, 0xFF, 0xF7, 0xB1, 0xFD, 0x04, 0xF0, 0x51, 0xF8, 0x6B, 0x48, 0x40, 0x30, 0x05,
+	0x90, 0x40, 0x69, 0x00, 0x28, 0x11, 0xD0, 0x60, 0x78, 0x40, 0x08, 0xA8, 0x42, 0x03, 0xD9, 0x66,
+	0x48, 0x40, 0x6A, 0x40, 0x1E, 0x00, 0xE0, 0x02, 0x98, 0x60, 0x72, 0x5C, 0x49, 0x62, 0x7A, 0x0C,
+	0x20, 0x89, 0x5C, 0x5B, 0x4A, 
+	0x00, 0x00, 0x60, 0x00, 0x80, 0x89, 0x00, 0x89, 0x18, 0x08, 0x60, 0x05, 0x98, 0x01, 0x6A, 0x08,
+	0x98, 0x40, 0x1B, 0x04, 0x90, 0x02, 0x29, 0x0E, 0xD1, 0x00, 0x21, 0x38, 0x46, 0x03, 0xF0, 0xB4,
+	0xFA, 0x04, 0x98, 0xE1, 0x7B, 0x00, 0x1D, 0xA2, 0x7B, 0x80, 0x08, 0x89, 0x1A, 0x80, 0x00, 0x49,
+	0x1C, 0x41, 0x43, 0x61, 0x73, 0x0E, 0xE0, 0x4D, 0x49, 0x4D, 0x4A, 0xC9, 0x5D, 0x01, 0x20, 0x89,
+	0x00, 0x89, 0x18, 0x08, 0x60, 0xE0, 0x7B, 0xA1, 0x7B, 0x40, 0x1A, 0x04, 0x99, 0x40, 0x1C, 0x49,
+	0x1C, 0x48, 0x43, 0x60, 0x73, 0x4C, 0x48, 0x60, 0x30, 0xC0, 0x7C, 0xFF, 0xF7, 0x81, 0xFD, 0x45,
+	0x49, 0x47, 0x48, 0xC8, 0x60, 0x03, 0xF0, 0x62, 0xF8, 0x01, 0x90, 0x42, 0x48, 0x00, 0x68, 0x03,
+	0x21, 0x49, 0x07, 0x08, 0x43, 0x3F, 0x49, 0x08, 0x60, 0x3E, 0x48, 0x00, 0x68, 0x80, 0x00, 0x01,
+	0xD5, 0x76, 0x1E, 0xF9, 0xD2, 
+	0x00, 0x00, 0x61, 0x00, 0x80, 0x03, 0x98, 0x40, 0x1C, 0xFF, 0xF7, 0x56, 0xFD, 0x05, 0x98, 0x00,
+	0x6A, 0x0F, 0x26, 0x02, 0x28, 0x06, 0xD1, 0x01, 0x21, 0x38, 0x46, 0x03, 0xF0, 0x75, 0xFA, 0x06,
+	0x98, 0x20, 0x72, 0x0D, 0xE0, 0x31, 0x4A, 0xD0, 0x5D, 0x81, 0x00, 0x31, 0x48, 0x09, 0x18, 0x0E,
+	0x60, 0xD2, 0x19, 0x52, 0x78, 0x01, 0x21, 0x92, 0x00, 0x10, 0x18, 0x01, 0x60, 0x6D, 0x1C, 0x25,
+	0x72, 0x05, 0x98, 0x40, 0x69, 0x00, 0x28, 0x13, 0xD0, 0x60, 0x78, 0x21, 0x7A, 0x40, 0x08, 0x88,
+	0x42, 0x0E, 0xD1, 0x26, 0x49, 0x60, 0x7A, 0x26, 0x4A, 0x08, 0x5C, 0x80, 0x00, 0x80, 0x18, 0x06,
+	0x60, 0x02, 0x98, 0x0C, 0x23, 0xC0, 0xB2, 0x60, 0x72, 0x08, 0x5C, 0x80, 0x00, 0x80, 0x18, 0x03,
+	0x60, 0x20, 0x48, 0x01, 0x68, 0x03, 0x22, 0x52, 0x07, 0x11, 0x43, 0x01, 0x60, 0x01, 0x69, 0x02,
+	0x22, 0x11, 0x43, 0x01, 0x61, 
+	0x00, 0x00, 0x62, 0x00, 0x80, 0x01, 0x98, 0x03, 0xF0, 0x15, 0xF8, 0x0B, 0xB0, 0xF0, 0xBD, 0x1A,
+	0x49, 0x00, 0x28, 0x00, 0xD1, 0x22, 0x48, 0x08, 0x63, 0x70, 0x47, 0x00, 0x28, 0x01, 0xD0, 0x16,
+	0x49, 0x88, 0x63, 0x70, 0x47, 0x00, 0x28, 0x01, 0xD0, 0x13, 0x49, 0xC8, 0x63, 0x70, 0x47, 0x12,
+	0x49, 0x08, 0x75, 0x48, 0x75, 0x1C, 0x48, 0x02, 0x6A, 0x1C, 0x48, 0x02, 0x40, 0x08, 0x7D, 0x02,
+	0x43, 0x00, 0x04, 0x02, 0x43, 0x0B, 0x48, 0x82, 0x62, 0x70, 0x47, 0x0B, 0x49, 0x16, 0x4A, 0x88,
+	0x75, 0xD3, 0x6D, 0xDB, 0xB2, 0x83, 0x42, 0x00, 0xD3, 0xD0, 0x6D, 0xC8, 0x75, 0x05, 0x48, 0x82,
+	0x68, 0x89, 0x7D, 0x12, 0x0A, 0x12, 0x02, 0x0A, 0x43, 0x82, 0x60, 0x70, 0x47, 0x00, 0xEB, 0x00,
+	0x00, 0x00, 0x04, 0x11, 0x40, 0x00, 0x00, 0x11, 0x40, 0x9C, 0x00, 0x00, 0x20, 0x80, 0xEA, 0x00,
+	0x00, 0xFF, 0x03, 0x00, 0x00, 
+	0x00, 0x00, 0x63, 0x00, 0x80, 0xB8, 0x01, 0x00, 0x20, 0xF0, 0xE9, 0x00, 0x00, 0xCA, 0x01, 0x00,
+	0x20, 0xC9, 0x01, 0x00, 0x20, 0xB7, 0x01, 0x00, 0x20, 0xB4, 0x01, 0x00, 0x20, 0xBC, 0x01, 0x00,
+	0x20, 0xD1, 0x24, 0x00, 0x00, 0x00, 0xEC, 0x00, 0x00, 0xB0, 0xE8, 0x00, 0x00, 0x00, 0xFF, 0x00,
+	0xFF, 0x10, 0xB5, 0x68, 0x49, 0x68, 0x4A, 0x08, 0x76, 0x90, 0x68, 0xFF, 0x23, 0x09, 0x7E, 0x1B,
+	0x02, 0x98, 0x43, 0x09, 0x02, 0x08, 0x43, 0x90, 0x60, 0xFF, 0xF7, 0x02, 0xFA, 0x10, 0xBD, 0x10,
+	0xB5, 0x60, 0x4C, 0x61, 0x4A, 0x60, 0x76, 0x91, 0x68, 0xFF, 0x23, 0x1B, 0x02, 0x99, 0x43, 0xC3,
+	0xB2, 0x1B, 0x02, 0x19, 0x43, 0x91, 0x60, 0x64, 0x21, 0x41, 0x43, 0x5C, 0x48, 0x80, 0x68, 0x00,
+	0x03, 0x0A, 0xF0, 0x65, 0xFC, 0xA0, 0x84, 0x10, 0xBD, 0x56, 0x48, 0x80, 0x7E, 0xB5, 0xE7, 0x55,
+	0x48, 0x80, 0x7F, 0xB2, 0xE7, 
+	0x00, 0x00, 0x64, 0x00, 0x80, 0x53, 0x48, 0xC0, 0x7F, 0xAF, 0xE7, 0x52, 0x48, 0x20, 0x30, 0x00,
+	0x78, 0xAB, 0xE7, 0x50, 0x48, 0xC0, 0x7E, 0xC0, 0x07, 0xC0, 0x0F, 0xA6, 0xE7, 0x4D, 0x48, 0xC0,
+	0x8D, 0xC0, 0xB2, 0xA2, 0xE7, 0x4B, 0x48, 0x02, 0x21, 0xC0, 0x7E, 0x08, 0x40, 0x9D, 0xE7, 0x10,
+	0xB5, 0x04, 0x00, 0x04, 0xD0, 0x20, 0x78, 0xFF, 0xF7, 0xBB, 0xFF, 0x64, 0x78, 0x0F, 0xE0, 0x48,
+	0x48, 0x80, 0x68, 0x00, 0x04, 0x00, 0x0E, 0xFF, 0xF7, 0xB3, 0xFF, 0x44, 0x48, 0x20, 0x30, 0xC0,
+	0x7A, 0xC0, 0x07, 0x01, 0xD0, 0x04, 0x24, 0x00, 0xE0, 0x00, 0x24, 0x02, 0x20, 0x04, 0x43, 0x60,
+	0x07, 0x02, 0xD5, 0x03, 0xF0, 0xFD, 0xFE, 0x01, 0xE0, 0x03, 0xF0, 0xFE, 0xFE, 0x39, 0x48, 0xA1,
+	0x07, 0x01, 0xD4, 0x01, 0x21, 0x00, 0xE0, 0x00, 0x21, 0x41, 0x77, 0x10, 0xBD, 0x70, 0xB5, 0x35,
+	0x4D, 0x04, 0x00, 0x0B, 0xD0, 
+	0x00, 0x00, 0x65, 0x00, 0x80, 0x20, 0x78, 0xFF, 0xF7, 0x52, 0xFF, 0x20, 0x79, 0x00, 0x07, 0x00,
+	0x0E, 0x28, 0x77, 0x60, 0x79, 0xFF, 0xF7, 0x59, 0xFF, 0x60, 0x88, 0x0E, 0xE0, 0x30, 0x4B, 0x18,
+	0x6A, 0xC0, 0xB2, 0xFF, 0xF7, 0x44, 0xFF, 0xD8, 0x68, 0xF0, 0x21, 0x08, 0x40, 0x28, 0x77, 0x98,
+	0x68, 0xC0, 0xB2, 0xFF, 0xF7, 0x4A, 0xFF, 0x29, 0x48, 0x40, 0x68, 0x00, 0xF0, 0x44, 0xF8, 0x4E,
+	0xE4, 0x30, 0xB5, 0x26, 0x49, 0x00, 0x22, 0x40, 0x39, 0x0B, 0x6B, 0x83, 0x42, 0x01, 0xD9, 0x02,
+	0x46, 0x28, 0xE0, 0x0B, 0x6B, 0xCC, 0x6B, 0x1B, 0x19, 0x83, 0x42, 0x01, 0xD9, 0x09, 0x6B, 0x20,
+	0xE0, 0x0B, 0x6B, 0xCC, 0x6B, 0x1C, 0x19, 0x1D, 0x4B, 0x1D, 0x68, 0x64, 0x19, 0x84, 0x42, 0x05,
+	0xD9, 0x0A, 0x6B, 0xC9, 0x6B, 0x80, 0x1A, 0x40, 0x1A, 0x42, 0x08, 0x13, 0xE0, 0x0C, 0x6B, 0xCD,
+	0x6B, 0x65, 0x19, 0x1C, 0x68, 
+	0x00, 0x00, 0x66, 0x00, 0x80, 0x64, 0x1C, 0x2C, 0x19, 0x84, 0x42, 0x07, 0xD8, 0x0C, 0x6B, 0xCD,
+	0x6B, 0x65, 0x19, 0x1C, 0x68, 0xA4, 0x1C, 0x2C, 0x19, 0x84, 0x42, 0x03, 0xD9, 0x09, 0x6B, 0x40,
+	0x1A, 0x19, 0x68, 0x42, 0x1A, 0x10, 0x46, 0x30, 0xBD, 0x00, 0x20, 0x1E, 0xE7, 0x0A, 0x4B, 0x10,
+	0xB5, 0x00, 0x22, 0x80, 0x33, 0x04, 0xE0, 0x94, 0x00, 0xE4, 0x18, 0x61, 0x61, 0x52, 0x1C, 0xD2,
+	0xB2, 0x82, 0x42, 0xF8, 0xD3, 0x10, 0xBD, 0x10, 0xB5, 0x02, 0x49, 0x88, 0x85, 0xFF, 0xF7, 0x40,
+	0xF9, 0x10, 0xBD, 0x00, 0x00, 0x9C, 0x00, 0x00, 0x20, 0x00, 0x00, 0x11, 0x40, 0x30, 0xEA, 0x00,
+	0x00, 0xB0, 0xE8, 0x00, 0x00, 0xF8, 0xB5, 0xFF, 0x4A, 0xFF, 0x4E, 0x00, 0x27, 0xFF, 0x49, 0x14,
+	0x46, 0x40, 0x34, 0x0D, 0x68, 0x00, 0x28, 0x48, 0xD1, 0xFD, 0x48, 0x77, 0x71, 0x01, 0x88, 0xB1,
+	0x82, 0x10, 0x89, 0x70, 0x82, 
+	0x00, 0x00, 0x67, 0x00, 0x80, 0x10, 0x46, 0x60, 0x30, 0x40, 0x7A, 0xFA, 0x4B, 0x1B, 0x68, 0x98,
+	0x42, 0xF0, 0x89, 0x08, 0xDA, 0x32, 0x30, 0xF0, 0x81, 0x0E, 0x20, 0x30, 0x5E, 0xC8, 0x28, 0x09,
+	0xDD, 0xC8, 0x20, 0xF0, 0x81, 0x06, 0xE0, 0x40, 0x1E, 0xF0, 0x81, 0x0E, 0x20, 0x30, 0x5E, 0x00,
+	0x28, 0x00, 0xDA, 0xF7, 0x81, 0xEB, 0x4B, 0x9A, 0x78, 0xEF, 0x48, 0x02, 0x80, 0xE2, 0x79, 0x42,
+	0x71, 0x22, 0x89, 0xC2, 0x80, 0x62, 0x89, 0x02, 0x81, 0xDA, 0x78, 0x42, 0x80, 0xA2, 0x79, 0x02,
+	0x71, 0x0E, 0x20, 0x30, 0x5E, 0x03, 0x28, 0x17, 0xDD, 0xB0, 0x8A, 0x00, 0x01, 0x0A, 0xF0, 0x6F,
+	0xFB, 0xE0, 0x49, 0x0A, 0x89, 0x50, 0x43, 0x00, 0x03, 0x00, 0x0C, 0x70, 0x82, 0xE8, 0x03, 0x00,
+	0x0C, 0xB0, 0x82, 0xE1, 0x48, 0xFF, 0x22, 0x02, 0x80, 0x40, 0x22, 0x42, 0x71, 0xC7, 0x80, 0x07,
+	0x81, 0xC9, 0x78, 0x41, 0x80, 
+	0x00, 0x00, 0x68, 0x00, 0x80, 0xA1, 0x79, 0x01, 0x71, 0xF8, 0xBD, 0x02, 0x28, 0x04, 0xD1, 0x77,
+	0x71, 0xD0, 0x8B, 0xB0, 0x82, 0x10, 0x89, 0x0C, 0xE0, 0x04, 0x28, 0x0C, 0xD1, 0x01, 0x20, 0x70,
+	0x71, 0xE0, 0x8A, 0xB0, 0x82, 0x80, 0xB2, 0xA9, 0x10, 0x81, 0x42, 0x00, 0xDD, 0x08, 0x46, 0xB0,
+	0x82, 0xA0, 0x8A, 0x70, 0x82, 0xF8, 0xBD, 0x0F, 0x28, 0xFC, 0xD1, 0x77, 0x71, 0xCF, 0x48, 0xB0,
+	0x82, 0xF7, 0xE7, 0xF8, 0xB5, 0xC7, 0x4A, 0xD0, 0x68, 0x11, 0x46, 0x20, 0x31, 0x03, 0x23, 0xCB,
+	0x56, 0xC0, 0x18, 0x04, 0x23, 0xCB, 0x56, 0xC4, 0x4D, 0xC0, 0x18, 0x00, 0x02, 0x28, 0x62, 0x13,
+	0x69, 0x05, 0x24, 0x0C, 0x57, 0x1B, 0x19, 0x06, 0x24, 0x0C, 0x57, 0x19, 0x19, 0x0F, 0x02, 0x6F,
+	0x62, 0x51, 0x69, 0xC3, 0x4C, 0x01, 0x29, 0x14, 0xD1, 0xE1, 0x69, 0x0A, 0xF0, 0x20, 0xFB, 0x28,
+	0x62, 0x21, 0x6A, 0x06, 0x46, 
+	0x00, 0x00, 0x69, 0x00, 0x80, 0x38, 0x46, 0x0A, 0xF0, 0x1A, 0xFB, 0x05, 0x27, 0x04, 0x46, 0xFF,
+	0x01, 0x68, 0x62, 0x39, 0x46, 0x30, 0x46, 0x0A, 0xF0, 0x1C, 0xFB, 0x28, 0x63, 0x39, 0x46, 0x20,
+	0x46, 0x11, 0xE0, 0x21, 0x6A, 0x0A, 0xF0, 0x0B, 0xFB, 0x28, 0x62, 0xE1, 0x69, 0x06, 0x46, 0x38,
+	0x46, 0x0A, 0xF0, 0x05, 0xFB, 0x05, 0x24, 0xE4, 0x01, 0x21, 0x46, 0x68, 0x62, 0x0A, 0xF0, 0x09,
+	0xFB, 0x28, 0x63, 0x21, 0x46, 0x30, 0x46, 0x0A, 0xF0, 0x04, 0xFB, 0x68, 0x63, 0x28, 0x6B, 0x00,
+	0x24, 0x40, 0x10, 0xA8, 0x62, 0x68, 0x6B, 0x40, 0x10, 0xE8, 0x62, 0xAC, 0x72, 0x20, 0x46, 0xFF,
+	0xF7, 0x41, 0xFF, 0xA9, 0x4A, 0x6C, 0x73, 0x00, 0x20, 0xA6, 0x49, 0x12, 0x78, 0x03, 0xE0, 0x83,
+	0x00, 0x40, 0x1C, 0xCC, 0x50, 0xC0, 0xB2, 0x90, 0x42, 0xF9, 0xD3, 0xAC, 0x63, 0xF8, 0xBD, 0x10,
+	0xB5, 0x99, 0x4C, 0x20, 0x78, 
+	0x00, 0x00, 0x6A, 0x00, 0x80, 0x00, 0x28, 0x05, 0xD1, 0xFF, 0xF7, 0x9B, 0xFF, 0x01, 0x20, 0x20,
+	0x70, 0xFE, 0xF7, 0xCA, 0xF8, 0x10, 0xBD, 0x94, 0x49, 0x00, 0x28, 0x01, 0xD1, 0x03, 0x20, 0x02,
+	0xE0, 0x03, 0x28, 0x01, 0xD1, 0x01, 0x20, 0x48, 0x72, 0x70, 0x47, 0xF0, 0xB5, 0x8C, 0x46, 0x97,
+	0x49, 0x95, 0x4D, 0x09, 0x78, 0x8C, 0x4C, 0x07, 0x46, 0x02, 0x20, 0x8E, 0x46, 0x64, 0x8A, 0x2D,
+	0x78, 0x89, 0x07, 0x1D, 0xD5, 0x00, 0x26, 0xB9, 0x1A, 0x00, 0x29, 0x00, 0xDD, 0x0E, 0x46, 0xF1,
+	0xB2, 0x8F, 0x4E, 0xBA, 0x18, 0x36, 0x78, 0x76, 0x1E, 0xB2, 0x42, 0x00, 0xDC, 0x16, 0x46, 0x0A,
+	0x46, 0xF6, 0xB2, 0x8C, 0x49, 0x09, 0xE0, 0xAF, 0x18, 0x7F, 0x00, 0xCF, 0x5F, 0xA7, 0x42, 0x02,
+	0xDB, 0x40, 0x1E, 0xC0, 0xB2, 0x05, 0xE0, 0x52, 0x1C, 0xD2, 0xB2, 0xB2, 0x42, 0xF3, 0xD9, 0x00,
+	0xE0, 0x01, 0x20, 0x71, 0x46, 
+	0x00, 0x00, 0x6B, 0x00, 0x80, 0xC9, 0x07, 0x18, 0xD0, 0x62, 0x46, 0x00, 0x21, 0xD2, 0x1A, 0x00,
+	0x2A, 0x00, 0xDD, 0x11, 0x46, 0x62, 0x46, 0x6D, 0x1E, 0xD2, 0x18, 0xC9, 0xB2, 0xAA, 0x42, 0x00,
+	0xDC, 0x15, 0x46, 0xEA, 0xB2, 0x7B, 0x4B, 0x05, 0xE0, 0x4D, 0x00, 0x5D, 0x5F, 0xA5, 0x42, 0x04,
+	0xDA, 0x49, 0x1C, 0xC9, 0xB2, 0x91, 0x42, 0xF7, 0xD9, 0xF0, 0xBD, 0x40, 0x1E, 0xC0, 0xB2, 0xF0,
+	0xBD, 0xF0, 0xB5, 0x04, 0x46, 0x21, 0x78, 0x00, 0x20, 0x03, 0x46, 0x8C, 0x46, 0x1E, 0xE0, 0x00,
+	0x22, 0x59, 0x00, 0x09, 0x19, 0x4F, 0x78, 0x89, 0x78, 0x8E, 0x46, 0x11, 0x46, 0x10, 0xE0, 0x8B,
+	0x42, 0x0D, 0xD0, 0x4D, 0x00, 0x2D, 0x19, 0x6E, 0x78, 0xF6, 0x1B, 0xF6, 0x1C, 0x07, 0x2E, 0x06,
+	0xD2, 0xAD, 0x78, 0x76, 0x46, 0xAD, 0x1B, 0xED, 0x1C, 0x07, 0x2D, 0x00, 0xD2, 0x52, 0x1C, 0x49,
+	0x1C, 0x8C, 0x45, 0xEC, 0xD8, 
+	0x00, 0x00, 0x6C, 0x00, 0x80, 0x82, 0x42, 0x00, 0xD9, 0x10, 0x46, 0x5B, 0x1C, 0x9C, 0x45, 0xDE,
+	0xD8, 0xF0, 0xBD, 0xF0, 0xB5, 0x04, 0x46, 0x00, 0x20, 0x89, 0xB0, 0x05, 0x90, 0x06, 0x46, 0x04,
+	0x90, 0x51, 0x48, 0x0F, 0x46, 0x05, 0x8A, 0x81, 0x8A, 0x02, 0x91, 0x80, 0x78, 0xB9, 0xB2, 0x08,
+	0x91, 0x00, 0x28, 0x03, 0xD0, 0x4C, 0x49, 0x40, 0x1E, 0x88, 0x70, 0x07, 0xE0, 0x20, 0x46, 0xFF,
+	0xF7, 0xBF, 0xFF, 0x49, 0x49, 0x4A, 0x78, 0x90, 0x42, 0x02, 0xD3, 0x48, 0x70, 0x08, 0x98, 0x06,
+	0xE0, 0x45, 0x48, 0x00, 0x7B, 0x03, 0x90, 0x04, 0x28, 0x04, 0xD9, 0x43, 0x49, 0x08, 0x98, 0x08,
+	0x82, 0x09, 0xB0, 0xF0, 0xBD, 0x21, 0x78, 0x81, 0x42, 0x0C, 0xD2, 0x02, 0x28, 0x01, 0xD1, 0xAE,
+	0x08, 0x08, 0xE0, 0x03, 0x28, 0x03, 0xD1, 0x28, 0x09, 0x81, 0x10, 0x0E, 0x18, 0x02, 0xE0, 0x04,
+	0x28, 0x00, 0xD1, 0x2E, 0x09, 
+	0x00, 0x00, 0x6D, 0x00, 0x80, 0xB8, 0x19, 0xA8, 0x42, 0xE7, 0xD9, 0x67, 0xE0, 0x02, 0x98, 0x00,
+	0x26, 0x84, 0x46, 0x51, 0xE0, 0x70, 0x00, 0x00, 0x19, 0x41, 0x78, 0x01, 0x91, 0x80, 0x78, 0x00,
+	0x25, 0x00, 0x90, 0x00, 0x21, 0x00, 0x2D, 0x05, 0xD0, 0x04, 0x2D, 0x03, 0xD0, 0x00, 0x29, 0x01,
+	0xD0, 0x04, 0x29, 0x3A, 0xD1, 0x01, 0x98, 0x2A, 0x18, 0x00, 0x98, 0x92, 0x1E, 0x0B, 0x18, 0x34,
+	0x48, 0x9B, 0x1E, 0x00, 0x78, 0x40, 0x1E, 0x82, 0x42, 0x2F, 0xD2, 0x00, 0x2A, 0x2D, 0xD0, 0x2E,
+	0x48, 0x00, 0x78, 0x07, 0x46, 0x40, 0x1E, 0x83, 0x42, 0x27, 0xD2, 0x00, 0x2B, 0x25, 0xD0, 0x38,
+	0x46, 0x50, 0x43, 0xC0, 0x18, 0x40, 0x00, 0x2C, 0x4F, 0x07, 0x90, 0x38, 0x5E, 0x60, 0x45, 0x1C,
+	0xDD, 0x00, 0x20, 0x10, 0xE0, 0xB0, 0x42, 0x0D, 0xD0, 0x47, 0x00, 0x3F, 0x19, 0x06, 0x97, 0x7F,
+	0x78, 0xBF, 0x1A, 0x7F, 0x1C, 
+	0x00, 0x00, 0x6E, 0x00, 0x80, 0x03, 0x2F, 0x05, 0xD2, 0x06, 0x9F, 0xBF, 0x78, 0xFF, 0x1A, 0x7F,
+	0x1C, 0x03, 0x2F, 0x0A, 0xD3, 0x40, 0x1C, 0x86, 0x45, 0xEC, 0xD8, 0x64, 0x28, 0x05, 0xD0, 0x1E,
+	0x4F, 0x07, 0x98, 0x38, 0x5E, 0x04, 0x93, 0x84, 0x46, 0x05, 0x92, 0x49, 0x1C, 0x05, 0x29, 0xB9,
+	0xD3, 0x6D, 0x1C, 0x05, 0x2D, 0xB5, 0xD3, 0x76, 0x1C, 0xB6, 0x45, 0xAB, 0xD8, 0x02, 0x99, 0x8C,
+	0x45, 0x2F, 0xDD, 0x71, 0x46, 0x49, 0x00, 0x09, 0x19, 0x05, 0x98, 0x48, 0x70, 0x21, 0x78, 0x04,
+	0x98, 0x49, 0x00, 0x09, 0x19, 0x88, 0x70, 0x20, 0x78, 0x40, 0x1C, 0x20, 0x70, 0x20, 0x78, 0x03,
+	0x99, 0x86, 0x46, 0x1B, 0xE0, 0xD0, 0xE7, 0x00, 0x00, 0xE4, 0x00, 0x00, 0x20, 0x7C, 0x01, 0x00,
+	0x20, 0x76, 0x02, 0x00, 0x20, 0x84, 0x01, 0x00, 0x20, 0x2C, 0x03, 0x00, 0x20, 0xFF, 0xFF, 0x00,
+	0x00, 0xF0, 0xE9, 0x00, 0x00, 
+	0x00, 0x00, 0x6F, 0x00, 0x80, 0x50, 0x04, 0x00, 0x20, 0x9E, 0x00, 0x00, 0x20, 0x2A, 0x01, 0x00,
+	0x20, 0x9D, 0x00, 0x00, 0x20, 0x32, 0x0B, 0x00, 0x20, 0x92, 0x08, 0x00, 0x20, 0x88, 0x42, 0x00,
+	0xD2, 0x74, 0xE7, 0x20, 0x46, 0xFF, 0xF7, 0x0C, 0xFF, 0xF9, 0x49, 0x4E, 0xE7, 0xF7, 0xB5, 0xF8,
+	0x49, 0x8A, 0xB0, 0x00, 0x22, 0xCA, 0x72, 0x0C, 0x98, 0x02, 0x70, 0xF6, 0x48, 0x02, 0x92, 0x00,
+	0x78, 0x40, 0x1E, 0x04, 0x90, 0xF4, 0x48, 0x01, 0x26, 0x00, 0x78, 0x03, 0x90, 0x88, 0x8A, 0x06,
+	0x90, 0x0B, 0x99, 0x10, 0x46, 0x09, 0x78, 0x01, 0xE0, 0x76, 0x00, 0x40, 0x1C, 0x81, 0x42, 0xFB,
+	0xD8, 0x0B, 0x98, 0xEE, 0x49, 0x80, 0x78, 0x09, 0x91, 0x05, 0xE0, 0x0C, 0x99, 0x00, 0x22, 0x09,
+	0x18, 0x40, 0x31, 0x8A, 0x70, 0x40, 0x1C, 0x0B, 0x99, 0xC9, 0x78, 0x81, 0x42, 0xF5, 0xD2, 0x53,
+	0xE1, 0x03, 0x99, 0x48, 0x43, 
+	0x00, 0x00, 0x70, 0x00, 0x80, 0x0B, 0x99, 0x8D, 0x78, 0x40, 0x19, 0x40, 0x1E, 0x05, 0x90, 0x3C,
+	0xE1, 0x05, 0x98, 0x40, 0x1C, 0x05, 0x90, 0x09, 0x98, 0xC0, 0x8B, 0x00, 0x28, 0x58, 0xD0, 0x09,
+	0x98, 0x1E, 0x21, 0x41, 0x5E, 0xDD, 0x48, 0x20, 0x30, 0x00, 0x22, 0x82, 0x5E, 0x88, 0x18, 0x05,
+	0x99, 0xDB, 0x4A, 0x49, 0x00, 0x54, 0x5E, 0x40, 0x42, 0xA0, 0x42, 0x33, 0xDD, 0xD9, 0x49, 0xAB,
+	0x00, 0xC8, 0x58, 0x72, 0x00, 0x07, 0x46, 0x17, 0x42, 0x01, 0xD0, 0x30, 0x43, 0x28, 0xE0, 0x01,
+	0x46, 0x31, 0x42, 0x20, 0xD1, 0x00, 0x21, 0x01, 0x91, 0x0B, 0x9A, 0x03, 0x9F, 0x12, 0x78, 0x7A,
+	0x43, 0x64, 0x42, 0xA4, 0x46, 0x07, 0xE0, 0xCE, 0x4F, 0x54, 0x00, 0x3C, 0x5F, 0x64, 0x45, 0x2F,
+	0xDC, 0x49, 0x1C, 0xC9, 0xB2, 0x52, 0x1C, 0x03, 0x9C, 0xA1, 0x42, 0xF4, 0xD3, 0x01, 0x99, 0x00,
+	0x29, 0x26, 0xD1, 0xC8, 0x49, 
+	0x00, 0x00, 0x71, 0x00, 0x80, 0x30, 0x43, 0xC8, 0x50, 0x0C, 0x98, 0x40, 0x19, 0x40, 0x30, 0x81,
+	0x78, 0x49, 0x1C, 0x81, 0x70, 0x1C, 0xE0, 0xC3, 0x49, 0xB4, 0x00, 0x20, 0x42, 0x18, 0xD1, 0x10,
+	0x43, 0xC8, 0x50, 0x15, 0xE0, 0x09, 0x98, 0x1E, 0x21, 0x41, 0x5E, 0x48, 0x42, 0x84, 0x42, 0x0F,
+	0xDD, 0xBC, 0x4B, 0xA9, 0x00, 0x58, 0x58, 0x72, 0x00, 0x04, 0x46, 0x14, 0x42, 0x01, 0xD0, 0x34,
+	0x42, 0x01, 0xD0, 0xB0, 0x43, 0x03, 0xE0, 0xB4, 0x00, 0x20, 0x42, 0x01, 0xD0, 0x90, 0x43, 0x58,
+	0x50, 0x05, 0x98, 0xB3, 0x4A, 0x40, 0x00, 0x08, 0x90, 0x11, 0x5E, 0x06, 0x98, 0x81, 0x42, 0x7A,
+	0xDB, 0x02, 0x9A, 0x00, 0x20, 0x52, 0x18, 0x02, 0x92, 0x03, 0x9A, 0x01, 0x27, 0x52, 0x1E, 0x0C,
+	0x46, 0x95, 0x42, 0x00, 0xD3, 0x00, 0x27, 0x0B, 0x9A, 0x04, 0x9B, 0x12, 0x78, 0x07, 0x92, 0x9A,
+	0x42, 0x2B, 0xD2, 0x03, 0x9B, 
+	0x00, 0x00, 0x72, 0x00, 0x80, 0x05, 0x9A, 0xD2, 0x18, 0x52, 0x1C, 0x94, 0x46, 0x00, 0x2F, 0x0A,
+	0xD0, 0xA3, 0x4B, 0x62, 0x46, 0x52, 0x00, 0x9A, 0x5E, 0x91, 0x42, 0xE0, 0xDB, 0x00, 0x2A, 0x01,
+	0xDD, 0x14, 0x19, 0x00, 0xE0, 0x10, 0x46, 0x62, 0x46, 0x52, 0x1E, 0x94, 0x46, 0x9C, 0x4B, 0x52,
+	0x00, 0x9A, 0x5E, 0x91, 0x42, 0xD3, 0xDB, 0x00, 0x2A, 0x01, 0xDD, 0x14, 0x19, 0x00, 0xE0, 0x10,
+	0x18, 0x00, 0x2D, 0x0A, 0xD0, 0x62, 0x46, 0x52, 0x1E, 0x52, 0x00, 0x9A, 0x5E, 0x91, 0x42, 0xC6,
+	0xDB, 0x00, 0x2A, 0x01, 0xDD, 0x14, 0x19, 0x00, 0xE0, 0x10, 0x18, 0x00, 0x2F, 0x0B, 0xD0, 0x90,
+	0x4B, 0x08, 0x9A, 0xD3, 0x18, 0x02, 0x22, 0x9A, 0x5E, 0x91, 0x42, 0xB8, 0xDB, 0x00, 0x2A, 0x01,
+	0xDD, 0x14, 0x19, 0x00, 0xE0, 0x10, 0x18, 0x00, 0x2D, 0x0C, 0xD0, 0x89, 0x4B, 0x08, 0x9A, 0xD3,
+	0x18, 0x20, 0x3B, 0x1E, 0x22, 
+	0x00, 0x00, 0x73, 0x00, 0x80, 0x9A, 0x5E, 0x91, 0x42, 0x7E, 0xDD, 0x00, 0x2A, 0x01, 0xDD, 0x14,
+	0x19, 0x00, 0xE0, 0x10, 0x18, 0x07, 0x9A, 0x00, 0x2A, 0x2C, 0xD0, 0x03, 0x9B, 0x05, 0x9A, 0xD2,
+	0x1A, 0x52, 0x1C, 0x94, 0x46, 0x00, 0x2F, 0x0A, 0xD0, 0x7D, 0x4B, 0x62, 0x46, 0x52, 0x00, 0x9A,
+	0x5E, 0x91, 0x42, 0x69, 0xDD, 0x00, 0x2A, 0x01, 0xDD, 0x14, 0x19, 0x00, 0xE0, 0x10, 0x18, 0x62,
+	0x46, 0x52, 0x1E, 0x94, 0x46, 0x76, 0x4B, 0x52, 0x00, 0x9A, 0x5E, 0x91, 0x42, 0x5C, 0xDD, 0x00,
+	0x2A, 0x02, 0xDD, 0x14, 0x19, 0x01, 0xE0, 0x57, 0xE0, 0x10, 0x18, 0x00, 0x2D, 0x0A, 0xD0, 0x62,
+	0x46, 0x52, 0x1E, 0x52, 0x00, 0x9A, 0x5E, 0x91, 0x42, 0x4E, 0xDD, 0x00, 0x2A, 0x01, 0xDD, 0x14,
+	0x19, 0x00, 0xE0, 0x10, 0x18, 0x01, 0x22, 0x00, 0x2D, 0x02, 0xD0, 0x00, 0x2F, 0x00, 0xD0, 0x00,
+	0x22, 0x07, 0x9B, 0x00, 0x2B, 
+	0x00, 0x00, 0x74, 0x00, 0x80, 0x02, 0xD0, 0x04, 0x9F, 0xBB, 0x42, 0x00, 0xD1, 0x52, 0x1C, 0x02,
+	0x23, 0x9B, 0x1A, 0x06, 0x9A, 0x9A, 0x40, 0xA2, 0x42, 0x36, 0xDC, 0x61, 0x1A, 0x60, 0x4F, 0x49,
+	0x10, 0x40, 0x42, 0x81, 0x42, 0x30, 0xDB, 0xFD, 0xF7, 0xB6, 0xFD, 0x01, 0x28, 0x09, 0xD1, 0x58,
+	0x4A, 0x0B, 0x98, 0x53, 0x7A, 0xE9, 0xB2, 0x00, 0x78, 0x1A, 0x46, 0xFF, 0xF7, 0x76, 0xFD, 0x00,
+	0x28, 0x22, 0xD1, 0x08, 0x98, 0x00, 0x21, 0x38, 0x5E, 0x20, 0x1A, 0x00, 0x28, 0x00, 0xDD, 0x01,
+	0x46, 0x0C, 0x98, 0x00, 0x78, 0x42, 0x00, 0x0C, 0x98, 0x10, 0x18, 0x41, 0x84, 0x0C, 0x99, 0x0B,
+	0x98, 0x09, 0x78, 0x0C, 0x9A, 0x49, 0x00, 0x00, 0x78, 0x89, 0x18, 0x48, 0x70, 0x0C, 0x98, 0x0C,
+	0x99, 0x00, 0x78, 0x40, 0x00, 0x40, 0x18, 0x85, 0x70, 0x0C, 0x98, 0x0C, 0x99, 0x00, 0x78, 0x40,
+	0x1C, 0xC0, 0xB2, 0x08, 0x70, 
+	0x00, 0x00, 0x75, 0x00, 0x80, 0x10, 0x28, 0x16, 0xD0, 0x6D, 0x1C, 0x0B, 0x98, 0xC0, 0x78, 0xA8,
+	0x42, 0x00, 0xD3, 0xBD, 0xE6, 0x0C, 0x98, 0x00, 0x78, 0x10, 0x28, 0x0C, 0xD0, 0x0B, 0x98, 0x76,
+	0x00, 0x00, 0x78, 0x0B, 0x99, 0x40, 0x1C, 0x08, 0x70, 0x0B, 0x98, 0x0B, 0x99, 0x00, 0x78, 0x49,
+	0x78, 0x88, 0x42, 0x00, 0xD8, 0xA4, 0xE6, 0x36, 0x48, 0x80, 0x6B, 0x00, 0x28, 0x03, 0xD1, 0x02,
+	0x99, 0x0C, 0x98, 0xFF, 0xF7, 0xA6, 0xFD, 0x0D, 0xB0, 0xF0, 0xBD, 0x38, 0xB5, 0x00, 0x25, 0x6B,
+	0x46, 0x30, 0x4A, 0x1D, 0x70, 0x14, 0x78, 0x30, 0x4A, 0x64, 0x1E, 0x5C, 0x70, 0x9D, 0x70, 0x14,
+	0x78, 0x0A, 0x46, 0x64, 0x1E, 0xDC, 0x70, 0x69, 0x46, 0xFF, 0xF7, 0x60, 0xFE, 0x38, 0xBD, 0xF3,
+	0xB5, 0x00, 0x20, 0x84, 0x46, 0x03, 0x46, 0x81, 0xB0, 0x2B, 0x48, 0x00, 0x90, 0x32, 0xE0, 0x2B,
+	0x4A, 0x16, 0x20, 0x54, 0x0C, 
+	0x00, 0x00, 0x76, 0x00, 0x80, 0x1D, 0x46, 0x45, 0x43, 0x29, 0x48, 0x40, 0x5B, 0x86, 0x46, 0x00,
+	0x20, 0x71, 0x46, 0xC1, 0x40, 0xC9, 0x07, 0x1D, 0xD0, 0x1F, 0x4E, 0x01, 0x99, 0x36, 0x78, 0x71,
+	0x43, 0x23, 0x4E, 0xAE, 0x19, 0x36, 0x18, 0x37, 0x79, 0xC9, 0x19, 0x1D, 0x4F, 0x49, 0x00, 0x79,
+	0x5E, 0x91, 0x42, 0x00, 0xDD, 0x0A, 0x46, 0xA1, 0x42, 0x00, 0xDA, 0x0C, 0x46, 0x1C, 0x4F, 0x31,
+	0x79, 0x02, 0x9E, 0xB1, 0x42, 0x06, 0xD1, 0x79, 0x5B, 0x01, 0x26, 0x86, 0x40, 0x31, 0x42, 0x01,
+	0xD0, 0x01, 0x21, 0x8C, 0x46, 0x40, 0x1C, 0x08, 0x28, 0xDA, 0xD3, 0x60, 0x46, 0x00, 0x28, 0x05,
+	0xD1, 0x00, 0x98, 0x5B, 0x1C, 0x00, 0x6B, 0x98, 0x42, 0xC9, 0xD8, 0x07, 0xE0, 0x10, 0x1B, 0x00,
+	0xD5, 0x40, 0x42, 0xD1, 0x10, 0x88, 0x42, 0x01, 0xDA, 0x01, 0x20, 0xFE, 0xBD, 0x00, 0x20, 0xFE,
+	0xBD, 0x10, 0xB5, 0x02, 0x78, 
+	0x00, 0x00, 0x77, 0x00, 0x80, 0x10, 0x23, 0x10, 0x2A, 0x00, 0xD8, 0x13, 0x46, 0xCA, 0xB2, 0x1B,
+	0xE0, 0xE4, 0x00, 0x00, 0x20, 0x9D, 0x00, 0x00, 0x20, 0x9E, 0x00, 0x00, 0x20, 0x10, 0xE8, 0x00,
+	0x00, 0x92, 0x08, 0x00, 0x20, 0x50, 0x04, 0x00, 0x20, 0xF0, 0xE9, 0x00, 0x00, 0x00, 0x80, 0xFF,
+	0xFF, 0x00, 0xEC, 0x00, 0x00, 0x51, 0x00, 0x09, 0x18, 0xCC, 0x78, 0x4C, 0x70, 0x0C, 0x79, 0x8C,
+	0x70, 0x8C, 0x8C, 0x52, 0x1C, 0x4C, 0x84, 0xD2, 0xB2, 0x9A, 0x42, 0xF3, 0xD3, 0x01, 0x78, 0x49,
+	0x1E, 0x01, 0x70, 0x10, 0xBD, 0xF3, 0xB5, 0x87, 0xB0, 0x00, 0x20, 0x05, 0x90, 0xFA, 0x48, 0x0C,
+	0x46, 0x41, 0x7B, 0xFA, 0x48, 0x06, 0x90, 0x00, 0x29, 0x55, 0xD0, 0xF7, 0x49, 0x20, 0x78, 0x89,
+	0x7A, 0x88, 0x42, 0x50, 0xD0, 0x00, 0x28, 0x4E, 0xD0, 0x06, 0x98, 0x80, 0x7C, 0x03, 0x90, 0x64,
+	0x28, 0x01, 0xDD, 0x64, 0x20, 
+	0x00, 0x00, 0x78, 0x00, 0x80, 0x03, 0x90, 0x00, 0x26, 0x42, 0xE0, 0x70, 0x00, 0x00, 0x19, 0x41,
+	0x8C, 0x04, 0x91, 0x80, 0x78, 0x37, 0x46, 0x84, 0x46, 0x00, 0x20, 0x12, 0xE0, 0xB0, 0x42, 0x0F,
+	0xD0, 0x41, 0x00, 0x0B, 0x19, 0x99, 0x78, 0x62, 0x46, 0x52, 0x1A, 0x00, 0xD5, 0x52, 0x42, 0x04,
+	0x2A, 0x06, 0xDA, 0x5A, 0x8C, 0x04, 0x9B, 0x9A, 0x42, 0x02, 0xD9, 0x07, 0x46, 0x8C, 0x46, 0x04,
+	0x92, 0x40, 0x1C, 0x85, 0x42, 0xEA, 0xD8, 0x00, 0x25, 0x1E, 0xE0, 0xBD, 0x42, 0x1B, 0xD0, 0x68,
+	0x00, 0x01, 0x19, 0x88, 0x78, 0x62, 0x46, 0x10, 0x1A, 0x00, 0xD5, 0x40, 0x42, 0x04, 0x28, 0x12,
+	0xDA, 0x48, 0x8C, 0x64, 0x21, 0x48, 0x43, 0x04, 0x9A, 0x03, 0x99, 0x51, 0x43, 0x88, 0x42, 0x0A,
+	0xD2, 0x29, 0x46, 0x20, 0x46, 0xFF, 0xF7, 0x84, 0xFF, 0xBD, 0x42, 0x00, 0xD2, 0x7F, 0x1E, 0xB5,
+	0x42, 0x00, 0xD2, 0x76, 0x1E, 
+	0x00, 0x00, 0x79, 0x00, 0x80, 0x6D, 0x1E, 0x6D, 0x1C, 0x20, 0x78, 0xA8, 0x42, 0xDD, 0xD8, 0x76,
+	0x1C, 0x25, 0x78, 0xB5, 0x42, 0xB9, 0xD8, 0x20, 0x78, 0xCC, 0x4D, 0x00, 0x26, 0x20, 0x35, 0x84,
+	0x46, 0x00, 0x28, 0x79, 0xD0, 0x00, 0x20, 0x03, 0x90, 0xFF, 0x20, 0x02, 0x90, 0x00, 0x20, 0x01,
+	0x90, 0x06, 0x98, 0xC0, 0x8B, 0x00, 0x28, 0x62, 0xD0, 0xC5, 0x4A, 0x00, 0x20, 0x23, 0x46, 0x16,
+	0x78, 0x42, 0x33, 0x12, 0xE0, 0x41, 0x00, 0x09, 0x19, 0x4A, 0x78, 0x89, 0x78, 0x72, 0x43, 0x52,
+	0x18, 0xC0, 0x4F, 0x52, 0x00, 0xBA, 0x5E, 0xAF, 0x88, 0xBA, 0x42, 0x05, 0xDA, 0xC9, 0x5C, 0x00,
+	0x29, 0x02, 0xD0, 0x01, 0x20, 0x05, 0x90, 0x02, 0xE0, 0x40, 0x1C, 0x84, 0x45, 0xEA, 0xD8, 0xB6,
+	0x48, 0x80, 0x6B, 0x3C, 0x28, 0x2B, 0xD9, 0x00, 0x26, 0x26, 0xE0, 0x70, 0x00, 0xB4, 0x4A, 0x01,
+	0x19, 0x48, 0x78, 0x12, 0x78, 
+	0x00, 0x00, 0x7A, 0x00, 0x80, 0x89, 0x78, 0x42, 0x43, 0x52, 0x18, 0xB2, 0x4B, 0x52, 0x00, 0x9A,
+	0x5E, 0xAB, 0x88, 0x9A, 0x42, 0x03, 0xDB, 0xFF, 0xF7, 0xEA, 0xFE, 0x00, 0x28, 0x13, 0xD0, 0xF1,
+	0xB2, 0x09, 0xE0, 0x48, 0x00, 0x00, 0x19, 0xC2, 0x78, 0x42, 0x70, 0x02, 0x79, 0x82, 0x70, 0x82,
+	0x8C, 0x49, 0x1C, 0x42, 0x84, 0xC9, 0xB2, 0x20, 0x78, 0x40, 0x1E, 0x88, 0x42, 0xF1, 0xDC, 0x20,
+	0x78, 0x40, 0x1E, 0x20, 0x70, 0x00, 0xE0, 0x76, 0x1C, 0x20, 0x78, 0xB0, 0x42, 0xD5, 0xD8, 0x22,
+	0x78, 0x00, 0x20, 0x0B, 0xE0, 0x41, 0x00, 0x09, 0x19, 0x89, 0x78, 0x01, 0x9B, 0x99, 0x42, 0x00,
+	0xD9, 0x01, 0x91, 0x02, 0x9B, 0x99, 0x42, 0x00, 0xD2, 0x02, 0x91, 0x40, 0x1C, 0x90, 0x42, 0xF1,
+	0xD3, 0x02, 0x99, 0x01, 0x98, 0x40, 0x1A, 0x02, 0x28, 0x01, 0xDD, 0x01, 0x20, 0x03, 0x90, 0x93,
+	0x48, 0x40, 0x38, 0x40, 0x78, 
+	0x00, 0x00, 0x7B, 0x00, 0x80, 0x94, 0x4F, 0x00, 0x28, 0x07, 0xD0, 0x21, 0x78, 0x62, 0x1C, 0x07,
+	0x98, 0xFE, 0xF7, 0x0F, 0xFA, 0x06, 0x46, 0x19, 0xE0, 0x6E, 0xE0, 0x20, 0x78, 0x0B, 0x26, 0x0B,
+	0x28, 0x00, 0xD8, 0x06, 0x46, 0x00, 0x20, 0x0F, 0xE0, 0x41, 0x00, 0x0B, 0x19, 0xC1, 0x00, 0x41,
+	0x18, 0x5A, 0x78, 0xC9, 0x19, 0x0A, 0x71, 0x12, 0x0A, 0x4A, 0x71, 0x9A, 0x78, 0x8A, 0x70, 0x12,
+	0x0A, 0xCA, 0x70, 0x20, 0x22, 0xCA, 0x71, 0x40, 0x1C, 0xB0, 0x42, 0xED, 0xD3, 0x06, 0x99, 0x00,
+	0x20, 0xC9, 0x8B, 0x00, 0x29, 0x1E, 0xD0, 0x7C, 0x4A, 0x91, 0x7A, 0x01, 0x29, 0x02, 0xD8, 0x03,
+	0x99, 0x01, 0x29, 0x02, 0xD1, 0x00, 0x21, 0x91, 0x63, 0x14, 0xE0, 0x91, 0x6B, 0x00, 0x29, 0x06,
+	0xD0, 0x05, 0x98, 0x00, 0x28, 0x09, 0xD0, 0xFF, 0x20, 0x2D, 0x30, 0x90, 0x63, 0x09, 0xE0, 0x05,
+	0x99, 0x00, 0x29, 0x07, 0xD0, 
+	0x00, 0x00, 0x7C, 0x00, 0x80, 0x3C, 0x20, 0x90, 0x63, 0x01, 0xE0, 0x3C, 0x29, 0x01, 0xD8, 0xA8,
+	0x78, 0x00, 0xE0, 0xE8, 0x78, 0x71, 0x49, 0x09, 0x78, 0x00, 0x29, 0x0A, 0xD1, 0x6A, 0x49, 0x89,
+	0x7A, 0x00, 0x29, 0x0C, 0xD0, 0x69, 0x49, 0x40, 0x39, 0x4A, 0x7F, 0x82, 0x42, 0x07, 0xD9, 0x48,
+	0x7F, 0x05, 0xE0, 0x06, 0x99, 0x09, 0x7E, 0x81, 0x42, 0x01, 0xD9, 0x06, 0x98, 0x00, 0x7E, 0x62,
+	0x49, 0x4A, 0x7B, 0x00, 0x2A, 0x08, 0xD0, 0x89, 0x7A, 0x00, 0x29, 0x05, 0xD0, 0x5F, 0x49, 0x20,
+	0x39, 0x8A, 0x78, 0x82, 0x42, 0x00, 0xD9, 0x88, 0x78, 0x00, 0x21, 0x00, 0x07, 0x02, 0x0E, 0x08,
+	0xE0, 0xC8, 0x00, 0x08, 0x18, 0xC0, 0x19, 0x83, 0x79, 0x1B, 0x07, 0x1B, 0x0F, 0x13, 0x43, 0x83,
+	0x71, 0x49, 0x1C, 0xB1, 0x42, 0xF4, 0xD3, 0x1A, 0xE0, 0x59, 0x48, 0x00, 0x68, 0x41, 0x42, 0x00,
+	0x28, 0x00, 0xDB, 0x01, 0x46, 
+	0x00, 0x00, 0x7D, 0x00, 0x80, 0x06, 0x98, 0xC2, 0x8A, 0x56, 0x48, 0x00, 0x68, 0x82, 0x42, 0x09,
+	0xDD, 0x05, 0x98, 0x00, 0x28, 0x06, 0xD1, 0x06, 0x98, 0xC0, 0x8B, 0x88, 0x42, 0x02, 0xDD, 0x4A,
+	0x49, 0x00, 0x20, 0x88, 0x63, 0x21, 0x78, 0x62, 0x1C, 0x07, 0x98, 0xFE, 0xF7, 0x82, 0xF9, 0x46,
+	0x49, 0x88, 0x6B, 0x00, 0x28, 0x01, 0xD0, 0x40, 0x1E, 0x88, 0x63, 0xC8, 0x7A, 0x00, 0x28, 0x07,
+	0xD1, 0xC8, 0x78, 0x00, 0x28, 0x07, 0xD0, 0x40, 0x1E, 0xC8, 0x70, 0x08, 0x79, 0xC8, 0x72, 0x02,
+	0xE0, 0xAA, 0x7A, 0xCA, 0x70, 0x08, 0x71, 0xE8, 0x7A, 0x00, 0x28, 0x03, 0xD1, 0xC8, 0x7A, 0x00,
+	0x28, 0x00, 0xD0, 0x00, 0x26, 0x30, 0x46, 0x09, 0xB0, 0xF0, 0xBD, 0xF0, 0xB5, 0x37, 0x4C, 0x06,
+	0x46, 0x02, 0x68, 0x00, 0x20, 0x20, 0x3C, 0x03, 0x23, 0xE3, 0x56, 0x0F, 0x68, 0xD2, 0x1A, 0x03,
+	0xD5, 0x00, 0x22, 0x00, 0x2B, 
+	0x00, 0x00, 0x7E, 0x00, 0x80, 0x00, 0xD0, 0x01, 0x20, 0x05, 0x25, 0x65, 0x57, 0x7B, 0x1B, 0x03,
+	0xD5, 0x00, 0x23, 0x00, 0x2D, 0x00, 0xD0, 0x01, 0x20, 0x2C, 0x4F, 0x40, 0x3F, 0xFD, 0x68, 0x6D,
+	0x1E, 0xAA, 0x42, 0x05, 0xD9, 0x2A, 0x46, 0x04, 0x25, 0x65, 0x57, 0x00, 0x2D, 0x00, 0xDD, 0x01,
+	0x20, 0x3D, 0x69, 0x6D, 0x1E, 0xAB, 0x42, 0x05, 0xD9, 0x2B, 0x46, 0x06, 0x25, 0x65, 0x57, 0x00,
+	0x2D, 0x00, 0xDD, 0x01, 0x20, 0x32, 0x60, 0x0B, 0x60, 0xF0, 0xBD, 0xFF, 0xB5, 0xC3, 0x00, 0xC3,
+	0x18, 0x21, 0x48, 0x83, 0xB0, 0x18, 0x18, 0x00, 0x7A, 0x83, 0x07, 0x9B, 0x0F, 0x00, 0x93, 0x00,
+	0x07, 0x85, 0x0F, 0x1B, 0x48, 0x00, 0x23, 0x07, 0x78, 0x08, 0x46, 0x78, 0x43, 0x80, 0x18, 0x9E,
+	0x46, 0x9C, 0x46, 0x1E, 0x46, 0x1C, 0x46, 0x00, 0x2D, 0x12, 0xD0, 0x13, 0x49, 0x00, 0x2A, 0xCB,
+	0x6A, 0x49, 0x6B, 0x9C, 0x46, 
+	0x00, 0x00, 0x7F, 0x00, 0x80, 0x8E, 0x46, 0x01, 0xD0, 0x43, 0x1E, 0x02, 0xE0, 0x43, 0x1C, 0x00,
+	0x24, 0xE4, 0x43, 0x7F, 0x1E, 0xBA, 0x42, 0x01, 0xD2, 0x46, 0x1C, 0x30, 0xE0, 0x46, 0x1E, 0x2D,
+	0xE0, 0x00, 0x9F, 0x00, 0x2F, 0x2B, 0xD0, 0x08, 0x4B, 0x9E, 0x6A, 0x1B, 0x6B, 0xB4, 0x46, 0x9E,
+	0x46, 0x07, 0x4B, 0x0E, 0x46, 0x1B, 0x78, 0x5E, 0x43, 0xB2, 0x18, 0xD6, 0x1A, 0xD7, 0x18, 0x00,
+	0x29, 0x12, 0xD0, 0x33, 0x46, 0x13, 0xE0, 0x00, 0x00, 0xE4, 0x00, 0x00, 0x20, 0x10, 0xE8, 0x00,
+	0x00, 0x9E, 0x00, 0x00, 0x20, 0x92, 0x08, 0x00, 0x20, 0x88, 0x03, 0x00, 0x20, 0x28, 0x01, 0x00,
+	0x20, 0x80, 0x01, 0x00, 0x20, 0x7C, 0x01, 0x00, 0x20, 0x00, 0x24, 0x3B, 0x46, 0xE4, 0x43, 0xFA,
+	0x4A, 0x12, 0x78, 0x52, 0x1E, 0x91, 0x42, 0x01, 0xD2, 0x3E, 0x46, 0x00, 0xE0, 0x01, 0x24, 0x00,
+	0x99, 0x29, 0x43, 0x02, 0x91, 
+	0x00, 0x00, 0x80, 0x00, 0x80, 0x36, 0xD0, 0xF5, 0x4F, 0x40, 0x00, 0x38, 0x5E, 0x5A, 0x00, 0x81,
+	0x10, 0x40, 0x1A, 0x01, 0x90, 0x73, 0x00, 0xBA, 0x5E, 0xFB, 0x5E, 0x00, 0x20, 0x9A, 0x42, 0x01,
+	0xDD, 0x44, 0x1E, 0x03, 0xE0, 0x1A, 0x46, 0x00, 0x2C, 0x00, 0xD1, 0x01, 0x24, 0x8A, 0x42, 0x0B,
+	0xDD, 0x52, 0x1A, 0x60, 0x46, 0x02, 0x99, 0x50, 0x43, 0x01, 0x29, 0x02, 0xD0, 0x10, 0x46, 0x71,
+	0x46, 0x48, 0x43, 0x01, 0x99, 0x09, 0xF0, 0x45, 0xFD, 0x44, 0x43, 0xE5, 0x48, 0x00, 0x21, 0x40,
+	0x69, 0x00, 0x2D, 0x11, 0xD0, 0x01, 0x28, 0x06, 0xD1, 0x0C, 0x98, 0x00, 0x68, 0x00, 0x19, 0x00,
+	0xD4, 0x01, 0x46, 0x0C, 0x98, 0x05, 0xE0, 0x06, 0x98, 0x00, 0x68, 0x00, 0x19, 0x00, 0xD4, 0x01,
+	0x46, 0x06, 0x98, 0x01, 0x60, 0x07, 0xB0, 0xF0, 0xBD, 0x01, 0x28, 0xF4, 0xD0, 0xEC, 0xE7, 0xFF,
+	0xB5, 0x10, 0x26, 0x01, 0x27, 
+	0x00, 0x00, 0x81, 0x00, 0x80, 0x87, 0xB0, 0x04, 0x46, 0x00, 0x29, 0x05, 0xD0, 0xD2, 0x48, 0x00,
+	0x78, 0x40, 0x1E, 0x81, 0x42, 0x00, 0xD0, 0x00, 0x27, 0x98, 0x00, 0x05, 0x19, 0x03, 0x90, 0x68,
+	0x69, 0x06, 0x90, 0xE8, 0x6B, 0x05, 0x90, 0xA8, 0x6A, 0x04, 0x90, 0x00, 0x2F, 0x0C, 0xD1, 0x00,
+	0x28, 0x0A, 0xD0, 0x05, 0x99, 0x06, 0x98, 0x40, 0x18, 0x00, 0x01, 0x04, 0x99, 0x09, 0xF0, 0x09,
+	0xFD, 0x10, 0x26, 0x10, 0x28, 0x00, 0xDB, 0x06, 0x46, 0xC5, 0x48, 0x41, 0x69, 0x40, 0x30, 0x01,
+	0x29, 0x01, 0xD0, 0xC0, 0x7B, 0x00, 0xE0, 0x40, 0x7B, 0x00, 0x90, 0x03, 0x98, 0x06, 0x99, 0x20,
+	0x58, 0x02, 0x90, 0x41, 0x18, 0x04, 0x9A, 0x05, 0x98, 0x10, 0x18, 0x08, 0x18, 0x29, 0x6D, 0x41,
+	0x18, 0xA0, 0x68, 0x01, 0x90, 0xE2, 0x69, 0x63, 0x6C, 0x80, 0x18, 0x22, 0x6B, 0xD2, 0x18, 0x80,
+	0x18, 0xA2, 0x6D, 0x80, 0x18, 
+	0x00, 0x00, 0x82, 0x00, 0x80, 0x08, 0x18, 0x01, 0x21, 0x00, 0x28, 0x00, 0xDD, 0x01, 0x46, 0xB5,
+	0x48, 0x40, 0x68, 0x80, 0x02, 0x09, 0xF0, 0xDD, 0xFC, 0x00, 0x99, 0x48, 0x43, 0x81, 0x11, 0x20,
+	0x20, 0x20, 0x29, 0x00, 0xDC, 0x08, 0x46, 0x01, 0x99, 0x8A, 0x10, 0x02, 0x99, 0x51, 0x1A, 0x41,
+	0x43, 0x0A, 0x11, 0x09, 0x99, 0x89, 0x00, 0x62, 0x50, 0xE2, 0x69, 0x6B, 0x69, 0x72, 0x43, 0x12,
+	0x11, 0xD2, 0x1A, 0x42, 0x43, 0x12, 0x11, 0x09, 0x19, 0x4A, 0x61, 0x00, 0x2F, 0x05, 0xD1, 0x63,
+	0x6C, 0xE2, 0x69, 0xD2, 0x18, 0x23, 0x6B, 0x9A, 0x42, 0x00, 0xDA, 0x22, 0x6B, 0xAB, 0x6A, 0xD2,
+	0x1A, 0x42, 0x43, 0x12, 0x11, 0x8A, 0x62, 0x62, 0x6C, 0xEB, 0x6B, 0x72, 0x43, 0x12, 0x11, 0xD2,
+	0x1A, 0x42, 0x43, 0x12, 0x11, 0xCA, 0x63, 0xA2, 0x6D, 0x2B, 0x6D, 0x92, 0x10, 0xD2, 0x1A, 0x42,
+	0x43, 0x10, 0x11, 0x08, 0x65, 
+	0x00, 0x00, 0x83, 0x00, 0x80, 0x0B, 0xB0, 0xF0, 0xBD, 0xFF, 0xB5, 0x10, 0x26, 0x01, 0x27, 0x87,
+	0xB0, 0x04, 0x46, 0x00, 0x29, 0x05, 0xD0, 0x94, 0x48, 0x00, 0x78, 0x40, 0x1E, 0x81, 0x42, 0x00,
+	0xD0, 0x00, 0x27, 0x14, 0x20, 0x43, 0x43, 0x1D, 0x19, 0x03, 0x93, 0x68, 0x68, 0x06, 0x90, 0xE8,
+	0x68, 0x05, 0x90, 0xA8, 0x68, 0x04, 0x90, 0x00, 0x2F, 0x0C, 0xD1, 0x00, 0x28, 0x0A, 0xD0, 0x06,
+	0x99, 0x05, 0x98, 0x08, 0x18, 0x00, 0x01, 0x04, 0x99, 0x09, 0xF0, 0x83, 0xFC, 0x10, 0x26, 0x10,
+	0x28, 0x00, 0xDB, 0x06, 0x46, 0x82, 0x48, 0x41, 0x69, 0x40, 0x30, 0x01, 0x29, 0x01, 0xD0, 0x40,
+	0x7B, 0x00, 0xE0, 0xC0, 0x7B, 0x00, 0x90, 0x03, 0x98, 0x06, 0x99, 0x20, 0x58, 0x02, 0x90, 0x41,
+	0x18, 0x04, 0x9A, 0x05, 0x98, 0x10, 0x18, 0x08, 0x18, 0x29, 0x69, 0x41, 0x18, 0xA0, 0x6A, 0x01,
+	0x90, 0xE2, 0x6A, 0x63, 0x6B, 
+	0x00, 0x00, 0x84, 0x00, 0x80, 0x80, 0x18, 0x22, 0x6B, 0xD2, 0x18, 0x80, 0x18, 0xA2, 0x6B, 0x80,
+	0x18, 0x08, 0x18, 0x01, 0x21, 0x00, 0x28, 0x00, 0xDD, 0x01, 0x46, 0x72, 0x48, 0x40, 0x68, 0x80,
+	0x02, 0x09, 0xF0, 0x57, 0xFC, 0x00, 0x99, 0x48, 0x43, 0x81, 0x11, 0x20, 0x20, 0x20, 0x29, 0x00,
+	0xDC, 0x08, 0x46, 0x01, 0x99, 0x02, 0x9A, 0x89, 0x10, 0x89, 0x1A, 0x41, 0x43, 0x0A, 0x11, 0x09,
+	0x99, 0x14, 0x23, 0x59, 0x43, 0x62, 0x50, 0xE2, 0x6A, 0x6B, 0x68, 0x72, 0x43, 0x12, 0x11, 0xD2,
+	0x1A, 0x42, 0x43, 0x12, 0x11, 0x09, 0x19, 0x4A, 0x60, 0x00, 0x2F, 0x05, 0xD1, 0x63, 0x6B, 0xE2,
+	0x6A, 0xD2, 0x18, 0x23, 0x6B, 0x9A, 0x42, 0x00, 0xDA, 0x22, 0x6B, 0xAB, 0x68, 0xD2, 0x1A, 0x42,
+	0x43, 0x12, 0x11, 0x8A, 0x60, 0x62, 0x6B, 0xEB, 0x68, 0x72, 0x43, 0x12, 0x11, 0xD2, 0x1A, 0x42,
+	0x43, 0x12, 0x11, 0xCA, 0x60, 
+	0x00, 0x00, 0x85, 0x00, 0x80, 0xA2, 0x6B, 0x2B, 0x69, 0x92, 0x10, 0xD2, 0x1A, 0x42, 0x43, 0x10,
+	0x11, 0x08, 0x61, 0x77, 0xE7, 0xFF, 0xB5, 0x87, 0xB0, 0x84, 0x21, 0x07, 0x98, 0xFD, 0xF7, 0xA8,
+	0xF8, 0x04, 0x46, 0x08, 0x98, 0x02, 0x90, 0xC1, 0x00, 0x45, 0x18, 0x29, 0x46, 0x07, 0x98, 0xFD,
+	0xF7, 0x9F, 0xF8, 0x2A, 0x46, 0x4D, 0x49, 0x01, 0x90, 0x09, 0xF0, 0x90, 0xFB, 0x00, 0x20, 0x09,
+	0xE0, 0xC1, 0x00, 0x4A, 0x4A, 0x41, 0x18, 0x89, 0x18, 0xCA, 0x79, 0x20, 0x2A, 0x01, 0xD1, 0x00,
+	0x22, 0x0A, 0x72, 0x40, 0x1C, 0x08, 0x99, 0x88, 0x42, 0xF2, 0xD3, 0x41, 0x48, 0x40, 0x30, 0x06,
+	0x90, 0xEF, 0xE1, 0x40, 0x1E, 0xC1, 0x00, 0x41, 0x18, 0x08, 0x90, 0x40, 0x48, 0x0D, 0x18, 0xE8,
+	0x79, 0x10, 0x28, 0xF5, 0xD0, 0xE8, 0x78, 0xA9, 0x78, 0x00, 0x02, 0x08, 0x43, 0x60, 0x66, 0x68,
+	0x79, 0x29, 0x79, 0x00, 0x02, 
+	0x00, 0x00, 0x86, 0x00, 0x80, 0x08, 0x43, 0xA0, 0x66, 0x00, 0x20, 0x33, 0xE0, 0xC1, 0x00, 0x01,
+	0x9A, 0x41, 0x18, 0x8A, 0x18, 0xD1, 0x79, 0x10, 0x29, 0x2B, 0xD0, 0x51, 0x79, 0x16, 0x79, 0x09,
+	0x02, 0xA3, 0x6E, 0x31, 0x43, 0x59, 0x1A, 0x00, 0xD5, 0x49, 0x42, 0xE1, 0x67, 0xD6, 0x78, 0x97,
+	0x78, 0x32, 0x02, 0x63, 0x6E, 0x3A, 0x43, 0x9A, 0x1A, 0x00, 0xD5, 0x52, 0x42, 0x23, 0x46, 0x80,
+	0x33, 0x1A, 0x60, 0x00, 0x29, 0x02, 0xD1, 0x00, 0x2A, 0x13, 0xD0, 0x01, 0xE0, 0x03, 0x29, 0x10,
+	0xDC, 0x03, 0x2A, 0x0E, 0xDC, 0x02, 0x29, 0x02, 0xDA, 0x29, 0x7A, 0x09, 0x1D, 0x29, 0x72, 0x19,
+	0x68, 0x02, 0x29, 0x02, 0xDA, 0x29, 0x7A, 0x49, 0x1C, 0x29, 0x72, 0x29, 0x7A, 0xF0, 0x22, 0x11,
+	0x43, 0x29, 0x72, 0x40, 0x1C, 0x02, 0x99, 0x88, 0x42, 0xC8, 0xDB, 0xA2, 0x6E, 0xD2, 0x1E, 0x00,
+	0x20, 0x84, 0x46, 0x52, 0x1C, 
+	0x00, 0x00, 0x87, 0x00, 0x80, 0x03, 0xD4, 0x14, 0x48, 0x00, 0x78, 0x82, 0x42, 0x0B, 0xDB, 0x00,
+	0x20, 0x63, 0x46, 0x14, 0x26, 0x73, 0x43, 0x01, 0x46, 0x1B, 0x19, 0x86, 0x00, 0x40, 0x1C, 0x99,
+	0x51, 0x05, 0x28, 0xFA, 0xDB, 0x38, 0xE0, 0x10, 0x48, 0x61, 0x6E, 0x00, 0x78, 0x89, 0x1E, 0x50,
+	0x43, 0x40, 0x18, 0x03, 0x90, 0x63, 0x46, 0x14, 0x26, 0x00, 0x20, 0x73, 0x43, 0x1B, 0x19, 0x05,
+	0x93, 0x00, 0x29, 0x03, 0xDB, 0x08, 0x4B, 0x1B, 0x78, 0x99, 0x42, 0x11, 0xDB, 0x00, 0x23, 0x05,
+	0x9E, 0x87, 0x00, 0xF3, 0x51, 0x19, 0xE0, 0x00, 0x00, 0x9D, 0x00, 0x00, 0x20, 0x92, 0x08, 0x00,
+	0x20, 0xD0, 0xE7, 0x00, 0x00, 0x30, 0xEA, 0x00, 0x00, 0x9E, 0x00, 0x00, 0x20, 0x88, 0x03, 0x00,
+	0x20, 0x03, 0x9B, 0xFA, 0x4E, 0x5B, 0x00, 0xF3, 0x5E, 0x05, 0x9E, 0x87, 0x00, 0xF3, 0x51, 0x00,
+	0x26, 0x05, 0x2B, 0x00, 0xDD, 
+	0x00, 0x00, 0x88, 0x00, 0x80, 0x5E, 0x1F, 0x05, 0x9B, 0xDE, 0x51, 0x03, 0x9B, 0x49, 0x1C, 0x5B,
+	0x1C, 0x40, 0x1C, 0x03, 0x93, 0x05, 0x28, 0xD3, 0xDB, 0x60, 0x46, 0x40, 0x1C, 0x84, 0x46, 0x05,
+	0x28, 0xAF, 0xDB, 0xA0, 0x6E, 0x01, 0x28, 0x1A, 0xDC, 0x00, 0x28, 0x05, 0xD1, 0x01, 0x22, 0x20,
+	0x46, 0x03, 0x23, 0x61, 0x6E, 0xFF, 0xF7, 0xA8, 0xFE, 0xE9, 0x48, 0x40, 0x69, 0x01, 0x28, 0x06,
+	0x98, 0x01, 0xD0, 0x02, 0x7B, 0x00, 0xE0, 0x82, 0x7B, 0x00, 0x20, 0x81, 0x00, 0x0B, 0x19, 0x5B,
+	0x69, 0x40, 0x1C, 0x53, 0x43, 0x9B, 0x11, 0x63, 0x50, 0x05, 0x28, 0xF6, 0xDB, 0x1F, 0xE0, 0xE1,
+	0x49, 0x09, 0x78, 0x8A, 0x1E, 0x90, 0x42, 0x1A, 0xDB, 0x49, 0x1E, 0x88, 0x42, 0x05, 0xD1, 0x03,
+	0x22, 0x20, 0x46, 0x01, 0x23, 0x61, 0x6E, 0xFF, 0xF7, 0x87, 0xFE, 0xD9, 0x48, 0x40, 0x69, 0x01,
+	0x28, 0x06, 0x98, 0x01, 0xD0, 
+	0x00, 0x00, 0x89, 0x00, 0x80, 0x02, 0x7B, 0x00, 0xE0, 0x82, 0x7B, 0x00, 0x20, 0x81, 0x00, 0x09,
+	0x19, 0xCB, 0x6B, 0x40, 0x1C, 0x53, 0x43, 0x9B, 0x11, 0x0B, 0x65, 0x05, 0x28, 0xF6, 0xDB, 0x60,
+	0x6E, 0x01, 0x28, 0x1B, 0xDC, 0x00, 0x28, 0x05, 0xD1, 0x01, 0x22, 0x20, 0x46, 0x03, 0x23, 0xA1,
+	0x6E, 0xFF, 0xF7, 0xE5, 0xFD, 0xCA, 0x48, 0x40, 0x69, 0x01, 0x28, 0x06, 0x98, 0x01, 0xD0, 0x82,
+	0x7B, 0x00, 0xE0, 0x02, 0x7B, 0x00, 0x20, 0x14, 0x21, 0x41, 0x43, 0x0B, 0x19, 0x5B, 0x68, 0x40,
+	0x1C, 0x53, 0x43, 0x9B, 0x11, 0x63, 0x50, 0x05, 0x28, 0xF5, 0xDB, 0x20, 0xE0, 0xC2, 0x49, 0x09,
+	0x78, 0x8A, 0x1E, 0x90, 0x42, 0x1B, 0xDB, 0x49, 0x1E, 0x88, 0x42, 0x05, 0xD1, 0x03, 0x22, 0x20,
+	0x46, 0x01, 0x23, 0xA1, 0x6E, 0xFF, 0xF7, 0xC3, 0xFD, 0xB9, 0x48, 0x40, 0x69, 0x01, 0x28, 0x06,
+	0x98, 0x01, 0xD0, 0x82, 0x7B, 
+	0x00, 0x00, 0x8A, 0x00, 0x80, 0x00, 0xE0, 0x02, 0x7B, 0x00, 0x20, 0x14, 0x21, 0x41, 0x43, 0x09,
+	0x19, 0xCB, 0x68, 0x40, 0x1C, 0x53, 0x43, 0x9B, 0x11, 0x0B, 0x61, 0x05, 0x28, 0xF5, 0xDB, 0xE1,
+	0x69, 0xA0, 0x69, 0xE2, 0x6A, 0x40, 0x18, 0x21, 0x6A, 0x89, 0x18, 0x40, 0x18, 0x21, 0x6B, 0x40,
+	0x18, 0x61, 0x6B, 0x40, 0x18, 0x21, 0x6C, 0x40, 0x18, 0x61, 0x6C, 0x40, 0x18, 0xA1, 0x6C, 0x40,
+	0x18, 0x00, 0x21, 0x21, 0x67, 0xA1, 0x67, 0x61, 0x67, 0xE0, 0x66, 0x29, 0x7A, 0x00, 0x29, 0x3A,
+	0xD1, 0x00, 0x20, 0x82, 0x00, 0x11, 0x19, 0xA3, 0x58, 0x4E, 0x69, 0xCF, 0x6B, 0x9B, 0x19, 0x8E,
+	0x6A, 0xF6, 0x19, 0x9B, 0x19, 0x0E, 0x6D, 0x9B, 0x19, 0x26, 0x6F, 0x9B, 0x19, 0x23, 0x67, 0x14,
+	0x23, 0x43, 0x43, 0x1E, 0x19, 0x36, 0x69, 0xE3, 0x58, 0x40, 0x1C, 0xF3, 0x1A, 0xA6, 0x6F, 0x9B,
+	0x19, 0xA3, 0x67, 0x09, 0x6D, 
+	0x00, 0x00, 0x8B, 0x00, 0x80, 0xA2, 0x58, 0x89, 0x1A, 0x62, 0x6F, 0x89, 0x18, 0x61, 0x67, 0x05,
+	0x28, 0xDF, 0xDB, 0x58, 0x00, 0xA0, 0x67, 0x48, 0x00, 0x60, 0x67, 0x00, 0x20, 0x14, 0x21, 0x41,
+	0x43, 0x09, 0x19, 0xCA, 0x68, 0x49, 0x68, 0x51, 0x1A, 0xA2, 0x6F, 0x89, 0x18, 0xA1, 0x67, 0x81,
+	0x00, 0x09, 0x19, 0xCA, 0x6B, 0x49, 0x69, 0x40, 0x1C, 0x51, 0x1A, 0x62, 0x6F, 0x89, 0x18, 0x61,
+	0x67, 0x05, 0x28, 0xEB, 0xDB, 0x15, 0xE0, 0x20, 0x67, 0x01, 0x20, 0x14, 0x21, 0x41, 0x43, 0x09,
+	0x19, 0xCA, 0x68, 0x49, 0x68, 0x51, 0x1A, 0xA2, 0x6F, 0x89, 0x18, 0xA1, 0x67, 0x81, 0x00, 0x09,
+	0x19, 0xCA, 0x6B, 0x49, 0x69, 0x40, 0x1C, 0x51, 0x1A, 0x62, 0x6F, 0x89, 0x18, 0x61, 0x67, 0x04,
+	0x28, 0xEB, 0xDB, 0xA0, 0x6F, 0x26, 0x6F, 0x00, 0x02, 0x31, 0x46, 0x09, 0xF0, 0x6A, 0xFA, 0x01,
+	0x46, 0x60, 0x6E, 0x04, 0x90, 
+	0x00, 0x00, 0x8C, 0x00, 0x80, 0x00, 0x02, 0x0F, 0x18, 0x80, 0x37, 0xA7, 0x67, 0x60, 0x6F, 0x31,
+	0x46, 0x00, 0x02, 0x09, 0xF0, 0x5E, 0xFA, 0xA1, 0x6E, 0x00, 0x23, 0x0A, 0x02, 0x82, 0x18, 0x80,
+	0x32, 0x18, 0x46, 0x62, 0x67, 0x00, 0x2F, 0x00, 0xDB, 0x38, 0x46, 0xA0, 0x67, 0x00, 0x2A, 0x00,
+	0xDB, 0x13, 0x46, 0x6B, 0x4F, 0x63, 0x67, 0x7A, 0x69, 0x01, 0x2A, 0x01, 0xD0, 0xA3, 0x67, 0x60,
+	0x67, 0x6A, 0x4E, 0xA0, 0x6F, 0x72, 0x6A, 0x50, 0x43, 0x00, 0x14, 0xA0, 0x67, 0x60, 0x6F, 0x32,
+	0x6A, 0x50, 0x43, 0x00, 0x14, 0x60, 0x67, 0x28, 0x7A, 0x00, 0x07, 0x07, 0xD0, 0x22, 0x46, 0x78,
+	0x32, 0x13, 0x1F, 0x00, 0x92, 0x04, 0x9A, 0x08, 0x98, 0xFF, 0xF7, 0x6F, 0xFC, 0x21, 0x46, 0x78,
+	0x31, 0x08, 0x1F, 0xFF, 0xF7, 0x3A, 0xFC, 0xA0, 0x6F, 0xA8, 0x70, 0x00, 0x0A, 0xE8, 0x70, 0x60,
+	0x6F, 0x28, 0x71, 0x00, 0x0A, 
+	0x00, 0x00, 0x8D, 0x00, 0x80, 0x68, 0x71, 0xE0, 0x6E, 0xB9, 0x69, 0x48, 0x43, 0x50, 0x21, 0x48,
+	0x43, 0xC1, 0x0B, 0xE1, 0x66, 0x70, 0x79, 0x00, 0x28, 0x01, 0xD1, 0xC9, 0x10, 0xE1, 0x66, 0xFF,
+	0x22, 0xFF, 0x29, 0x00, 0xD8, 0xCA, 0xB2, 0x2A, 0x72, 0x01, 0x28, 0x04, 0xD1, 0xA8, 0x79, 0x00,
+	0x09, 0x00, 0x01, 0x00, 0x1D, 0x04, 0xE0, 0x00, 0x28, 0x03, 0xD1, 0xA8, 0x79, 0x00, 0x09, 0x00,
+	0x01, 0xA8, 0x71, 0x08, 0x98, 0x00, 0x28, 0x00, 0xD0, 0x0B, 0xE6, 0x07, 0x98, 0xFC, 0xF7, 0x9D,
+	0xFE, 0x07, 0x98, 0xFC, 0xF7, 0x9A, 0xFE, 0x55, 0xE5, 0x70, 0xB5, 0x44, 0x4C, 0x15, 0x46, 0xA2,
+	0x69, 0x00, 0x2A, 0x04, 0xD1, 0x0A, 0x78, 0x4B, 0x1C, 0x29, 0x46, 0xFF, 0xF7, 0xD3, 0xFD, 0xA5,
+	0x72, 0x70, 0xBD, 0xF0, 0xB5, 0x3E, 0x48, 0xC1, 0xB0, 0xC1, 0x69, 0x38, 0x91, 0x05, 0x6A, 0x3D,
+	0x48, 0x16, 0x21, 0x40, 0x90, 
+	0x00, 0x00, 0x8E, 0x00, 0x80, 0x41, 0x5E, 0x37, 0x91, 0x14, 0x21, 0x41, 0x5E, 0x34, 0x48, 0x36,
+	0x91, 0x40, 0x69, 0x84, 0x21, 0xC7, 0xB2, 0x15, 0xA8, 0x09, 0xF0, 0xBF, 0xF9, 0x00, 0x21, 0x13,
+	0xA8, 0x0A, 0x46, 0x06, 0xC0, 0x11, 0xA8, 0x06, 0xC0, 0x0E, 0xA8, 0x0B, 0x46, 0x0E, 0xC0, 0x0C,
+	0xA8, 0x06, 0xC0, 0x00, 0x20, 0x37, 0x99, 0x0B, 0x91, 0x08, 0x90, 0x06, 0x90, 0x2B, 0x4A, 0x05,
+	0x90, 0x03, 0x90, 0x02, 0x90, 0x01, 0x90, 0xD0, 0x71, 0x2B, 0x4A, 0x2A, 0x4B, 0x12, 0x78, 0x20,
+	0x33, 0x84, 0x46, 0x01, 0x46, 0x06, 0x46, 0x3E, 0x93, 0x3F, 0x92, 0x00, 0x2A, 0x01, 0xD0, 0xEC,
+	0xB2, 0x20, 0xE0, 0xDC, 0x78, 0x25, 0x4A, 0x26, 0x4B, 0x12, 0x78, 0x1B, 0x78, 0x00, 0x2C, 0x3C,
+	0x46, 0x09, 0xD1, 0x01, 0x2C, 0x03, 0xD1, 0x38, 0x9E, 0xEC, 0xB2, 0xF6, 0xB2, 0x0F, 0xE0, 0x38,
+	0x9C, 0xEE, 0xB2, 0xE4, 0xB2, 
+	0x00, 0x00, 0x8F, 0x00, 0x80, 0x04, 0xE0, 0x00, 0x2C, 0x06, 0xD1, 0x38, 0x9E, 0xEC, 0xB2, 0xF6,
+	0xB2, 0x03, 0x96, 0x1E, 0x46, 0x02, 0x92, 0x05, 0xE0, 0x38, 0x9C, 0xEE, 0xB2, 0xE4, 0xB2, 0x03,
+	0x96, 0x16, 0x46, 0x02, 0x93, 0x38, 0x9B, 0x9C, 0x42, 0x40, 0xD1, 0x38, 0x9A, 0xEB, 0xB2, 0xAA,
+	0x18, 0x9C, 0x46, 0x15, 0xAF, 0x3D, 0x92, 0x0C, 0xE0, 0x62, 0x46, 0x12, 0x4B, 0x52, 0x00, 0x9A,
+	0x5A, 0x43, 0x00, 0xFA, 0x52, 0x40, 0x1C, 0x62, 0x46, 0x52, 0x1C, 0xD2, 0xB2, 0x94, 0x46, 0x3D,
+	0x9A, 0xC0, 0xB2, 0x62, 0x45, 0xF0, 0xD8, 0x00, 0x22, 0x21, 0xE0, 0x00, 0x00, 0x92, 0x08, 0x00,
+	0x20, 0xD0, 0xE7, 0x00, 0x00, 0x9D, 0x00, 0x00, 0x20, 0x9E, 0x00, 0x00, 0x20, 0xE4, 0x00, 0x00,
+	0x20, 0xF0, 0xE9, 0x00, 0x00, 0xE0, 0xE6, 0x00, 0x00, 0x6C, 0x02, 0x00, 0x20, 0x62, 0x02, 0x00,
+	0x20, 0x61, 0x02, 0x00, 0x20, 
+	0x00, 0x00, 0x90, 0x00, 0x80, 0x32, 0x0B, 0x00, 0x20, 0x62, 0x46, 0xFA, 0x4B, 0x52, 0x00, 0x9A,
+	0x5A, 0x43, 0x00, 0xFA, 0x52, 0x40, 0x1C, 0x62, 0x46, 0x52, 0x1C, 0xC0, 0xB2, 0xD2, 0xB2, 0x94,
+	0x46, 0xAA, 0x42, 0xF1, 0xD3, 0x00, 0x20, 0x01, 0x22, 0x01, 0x92, 0x0F, 0xE0, 0xEA, 0x18, 0x15,
+	0xAF, 0x3C, 0x92, 0x08, 0xE0, 0x62, 0x46, 0x53, 0x00, 0xEE, 0x4A, 0xD2, 0x5A, 0xFA, 0x52, 0x62,
+	0x46, 0x52, 0x1C, 0xD2, 0xB2, 0x94, 0x46, 0x3C, 0x9B, 0x63, 0x45, 0xF3, 0xD8, 0x00, 0x22, 0x94,
+	0x46, 0x09, 0x92, 0x2E, 0xE0, 0x53, 0x00, 0x15, 0xAF, 0xFB, 0x5E, 0x37, 0x9F, 0xBB, 0x42, 0x1E,
+	0xDB, 0x0B, 0x9F, 0x0B, 0x93, 0xBB, 0x42, 0x0C, 0xDB, 0x13, 0xAB, 0x1A, 0x54, 0x01, 0x23, 0x9C,
+	0x46, 0x00, 0x23, 0x09, 0x93, 0x43, 0x1C, 0xDB, 0xB2, 0xDF, 0x4F, 0x02, 0x2B, 0xFB, 0x71, 0x74,
+	0xD8, 0x08, 0xE0, 0x09, 0x9B, 
+	0x00, 0x00, 0x91, 0x00, 0x80, 0x00, 0x2B, 0x05, 0xD1, 0x40, 0x1C, 0x01, 0x23, 0x09, 0x93, 0x00,
+	0x23, 0xC0, 0xB2, 0x9C, 0x46, 0x05, 0x9B, 0x5B, 0x1C, 0xDB, 0xB2, 0x05, 0x93, 0x07, 0xE0, 0x63,
+	0x46, 0x0B, 0x97, 0x00, 0x2B, 0x03, 0xD0, 0x00, 0x23, 0x40, 0x1C, 0x9C, 0x46, 0xC0, 0xB2, 0x52,
+	0x1C, 0xD2, 0xB2, 0xA2, 0x42, 0xCE, 0xD3, 0x3F, 0x98, 0x00, 0x23, 0x00, 0x28, 0xCE, 0x48, 0x9C,
+	0x46, 0xC0, 0x79, 0x04, 0xD0, 0x00, 0x28, 0x76, 0xD0, 0x01, 0x20, 0x41, 0xB0, 0xF0, 0xBD, 0x3B,
+	0x90, 0x00, 0x28, 0xF8, 0xD0, 0x38, 0x9F, 0x20, 0x46, 0xED, 0x19, 0x36, 0x9A, 0x3A, 0x95, 0x29,
+	0xE0, 0x47, 0x00, 0x15, 0xAD, 0xED, 0x5F, 0x36, 0x9F, 0xBD, 0x42, 0x1A, 0xDB, 0x95, 0x42, 0x2A,
+	0x46, 0x0E, 0xDB, 0x4B, 0x00, 0x0E, 0xAD, 0xEA, 0x52, 0x03, 0x1B, 0x11, 0xAD, 0x6B, 0x54, 0x00,
+	0x25, 0xAC, 0x46, 0x4D, 0x1C, 
+	0x00, 0x00, 0x92, 0x00, 0x80, 0xED, 0xB2, 0x01, 0x23, 0x06, 0x95, 0x05, 0x2D, 0x2D, 0xD2, 0x0E,
+	0xE0, 0x65, 0x46, 0x00, 0x2D, 0x0B, 0xD1, 0x49, 0x1C, 0x01, 0x23, 0x9C, 0x46, 0xC9, 0xB2, 0x00,
+	0x23, 0x05, 0xE0, 0x3A, 0x46, 0x00, 0x2B, 0x02, 0xD0, 0x00, 0x23, 0x49, 0x1C, 0xC9, 0xB2, 0x40,
+	0x1C, 0x3A, 0x9D, 0xC0, 0xB2, 0x85, 0x42, 0xD3, 0xD8, 0x00, 0x20, 0x3B, 0x9D, 0x04, 0x90, 0x0A,
+	0x90, 0x6B, 0x46, 0x38, 0x20, 0x18, 0x5E, 0x09, 0x90, 0x00, 0x27, 0x06, 0x98, 0x07, 0x97, 0x00,
+	0x28, 0xBB, 0xD0, 0x00, 0x90, 0x3E, 0x98, 0x00, 0x7C, 0x09, 0x99, 0x48, 0x43, 0x64, 0x21, 0x09,
+	0xF0, 0xB8, 0xF8, 0x00, 0xB2, 0x84, 0x46, 0x20, 0x46, 0x50, 0xE0, 0xA9, 0xE0, 0x41, 0x00, 0x15,
+	0xAA, 0x51, 0x5E, 0x61, 0x45, 0x13, 0xDB, 0x09, 0x9A, 0x91, 0x42, 0x03, 0xDB, 0x09, 0x91, 0x01,
+	0x1B, 0x13, 0xAA, 0x51, 0x55, 
+	0x00, 0x00, 0x93, 0x00, 0x80, 0x3A, 0x99, 0x49, 0x1E, 0x81, 0x42, 0x01, 0xD1, 0x6D, 0x1C, 0xED,
+	0xB2, 0x04, 0x99, 0x49, 0x1C, 0xC9, 0xB2, 0x04, 0x91, 0x01, 0x21, 0x0A, 0x91, 0x34, 0xE0, 0x0A,
+	0x99, 0x00, 0x29, 0x31, 0xD0, 0x00, 0x21, 0x0A, 0x91, 0x07, 0x9B, 0x0C, 0xAA, 0x04, 0x99, 0xD1,
+	0x54, 0x00, 0x21, 0x04, 0x91, 0x09, 0xE0, 0x85, 0xE0, 0x11, 0xAA, 0x52, 0x5C, 0x12, 0x19, 0x82,
+	0x42, 0x01, 0xD9, 0x0F, 0x46, 0x04, 0xE0, 0x49, 0x1C, 0x09, 0xB2, 0x00, 0x9A, 0x91, 0x42, 0xF3,
+	0xDB, 0x00, 0x2F, 0x13, 0xD0, 0x79, 0x00, 0x0E, 0xA8, 0x40, 0x5E, 0x39, 0x90, 0x3E, 0x99, 0x09,
+	0x7C, 0x48, 0x43, 0x64, 0x21, 0x09, 0xF0, 0x75, 0xF8, 0x00, 0xB2, 0x84, 0x46, 0x39, 0x98, 0x09,
+	0x90, 0x11, 0xA8, 0xC1, 0x5D, 0xA0, 0x1E, 0x08, 0x18, 0xC0, 0xB2, 0x00, 0x27, 0x6D, 0x1C, 0x07,
+	0x99, 0xED, 0xB2, 0x49, 0x1C, 
+	0x00, 0x00, 0x94, 0x00, 0x80, 0xC9, 0xB2, 0x07, 0x91, 0x40, 0x1C, 0xC0, 0xB2, 0x3A, 0x99, 0x81,
+	0x42, 0xAC, 0xD8, 0x3B, 0x98, 0x28, 0x1A, 0xC0, 0xB2, 0x02, 0x28, 0x51, 0xD8, 0x3B, 0x99, 0x01,
+	0x29, 0x2A, 0xD1, 0x01, 0x28, 0x0E, 0xD1, 0x74, 0x48, 0x10, 0xAB, 0x19, 0x7B, 0x3C, 0x30, 0x01,
+	0x70, 0x59, 0x7B, 0x41, 0x70, 0x05, 0x99, 0x81, 0x70, 0x08, 0xAB, 0x19, 0x7C, 0xC1, 0x70, 0x01,
+	0x20, 0x08, 0x90, 0x42, 0xE0, 0x02, 0x28, 0x3D, 0xD1, 0x01, 0x98, 0x10, 0xAB, 0x00, 0x28, 0x6B,
+	0x49, 0x18, 0x7B, 0x08, 0x70, 0x05, 0xD0, 0x5A, 0x7B, 0x4A, 0x70, 0x09, 0x1D, 0x08, 0x70, 0x98,
+	0x7B, 0x06, 0xE0, 0x9A, 0x7B, 0x4A, 0x70, 0x65, 0x49, 0x10, 0xAB, 0x09, 0x1D, 0x08, 0x70, 0x58,
+	0x7B, 0x48, 0x70, 0x02, 0x20, 0x08, 0x90, 0x3C, 0xE0, 0x02, 0x29, 0x23, 0xD1, 0x01, 0x28, 0x0C,
+	0xD1, 0x40, 0x99, 0x08, 0xAB, 
+	0x00, 0x00, 0x95, 0x00, 0x80, 0x18, 0x7C, 0xC9, 0x7F, 0x88, 0x42, 0x19, 0xD8, 0x10, 0xAB, 0x5B,
+	0x49, 0x18, 0x7B, 0x08, 0x70, 0x98, 0x7B, 0x48, 0x70, 0x0C, 0xE0, 0x02, 0x28, 0x12, 0xD1, 0x10,
+	0xAB, 0xD8, 0x7B, 0x99, 0x7B, 0x42, 0x1A, 0x52, 0x1D, 0x0A, 0x2A, 0x09, 0xD8, 0x53, 0x4A, 0x1B,
+	0x7B, 0x13, 0x70, 0x51, 0x70, 0x51, 0x49, 0x10, 0xAB, 0x5A, 0x7B, 0x09, 0x1D, 0x0A, 0x70, 0xD7,
+	0xE7, 0x03, 0x20, 0x02, 0xE7, 0x08, 0x98, 0x01, 0x28, 0x11, 0xD1, 0x4C, 0x49, 0x08, 0x78, 0xB0,
+	0x42, 0x2E, 0xD3, 0xA2, 0x1B, 0x52, 0x1E, 0x90, 0x42, 0x2A, 0xDC, 0x48, 0x78, 0x02, 0x99, 0x88,
+	0x42, 0x26, 0xD3, 0x03, 0x9A, 0x51, 0x1A, 0x49, 0x1E, 0x88, 0x42, 0x24, 0xDD, 0x20, 0xE0, 0x02,
+	0x28, 0x21, 0xD1, 0x42, 0x4A, 0x10, 0x78, 0xB0, 0x42, 0x1A, 0xD3, 0xA1, 0x1B, 0x49, 0x1E, 0x88,
+	0x42, 0x16, 0xDC, 0x52, 0x78, 
+	0x00, 0x00, 0x96, 0x00, 0x80, 0x02, 0x98, 0x82, 0x42, 0x12, 0xD3, 0x02, 0x9B, 0x03, 0x98, 0xC0,
+	0x1A, 0x40, 0x1E, 0x82, 0x42, 0x0C, 0xDC, 0x39, 0x4B, 0x1B, 0x1D, 0x1A, 0x78, 0xB2, 0x42, 0x07,
+	0xD3, 0x8A, 0x42, 0x05, 0xDC, 0x59, 0x78, 0x02, 0x9A, 0x91, 0x42, 0x01, 0xD3, 0x81, 0x42, 0x02,
+	0xDD, 0x31, 0x49, 0x01, 0x20, 0x08, 0x72, 0x30, 0x49, 0x08, 0x98, 0x88, 0x71, 0x08, 0x98, 0xC4,
+	0xE6, 0xFF, 0xB5, 0x2D, 0x48, 0x00, 0x25, 0x40, 0x8A, 0x00, 0x90, 0x2D, 0x48, 0x2A, 0x46, 0x03,
+	0x78, 0x28, 0x46, 0xAC, 0x46, 0x29, 0x46, 0x27, 0x4F, 0x03, 0x95, 0x14, 0xE0, 0x4C, 0x00, 0x3C,
+	0x5F, 0x00, 0x9E, 0xB4, 0x42, 0x0D, 0xDB, 0x00, 0x2A, 0x03, 0xD1, 0x40, 0x1C, 0x02, 0x28, 0x0E,
+	0xD0, 0x01, 0x22, 0xAC, 0x42, 0x01, 0xDD, 0x25, 0x46, 0x03, 0x91, 0x64, 0x46, 0x64, 0x1C, 0xA4,
+	0x46, 0x00, 0xE0, 0x00, 0x22, 
+	0x00, 0x00, 0x97, 0x00, 0x80, 0x49, 0x1C, 0x99, 0x42, 0xE8, 0xD3, 0x00, 0x28, 0x2F, 0xD0, 0x1D,
+	0x49, 0x09, 0x78, 0xC9, 0x18, 0x01, 0x91, 0x00, 0x21, 0x8E, 0x46, 0x0C, 0x46, 0x0A, 0x46, 0x0D,
+	0x46, 0x02, 0x91, 0x19, 0x46, 0x14, 0xE0, 0x13, 0x4F, 0x4E, 0x00, 0xBE, 0x5F, 0x00, 0x9F, 0xBE,
+	0x42, 0x0C, 0xDB, 0x00, 0x2C, 0x03, 0xD1, 0x52, 0x1C, 0x02, 0x2A, 0x0C, 0xD0, 0x01, 0x24, 0x76,
+	0x45, 0x02, 0xDD, 0xB6, 0x46, 0xCE, 0x1A, 0x02, 0x96, 0x6D, 0x1C, 0x00, 0xE0, 0x00, 0x24, 0x49,
+	0x1C, 0x01, 0x9E, 0xB1, 0x42, 0xE7, 0xD3, 0x50, 0x43, 0x01, 0x28, 0x08, 0xD1, 0x06, 0x49, 0x03,
+	0x9A, 0x1C, 0x31, 0x0A, 0x70, 0x02, 0x9A, 0x4A, 0x70, 0x62, 0x46, 0x8A, 0x70, 0xCD, 0x70, 0x04,
+	0xB0, 0xF0, 0xBD, 0x00, 0x00, 0x32, 0x0B, 0x00, 0x20, 0xE4, 0x00, 0x00, 0x20, 0x20, 0x01, 0x00,
+	0x20, 0x9E, 0x00, 0x00, 0x20, 
+	0x00, 0x00, 0x98, 0x00, 0x80, 0x9D, 0x00, 0x00, 0x20, 0x10, 0xB5, 0x0C, 0x46, 0xC9, 0x00, 0x62,
+	0x18, 0x00, 0x28, 0x07, 0xD1, 0x46, 0x49, 0x08, 0x46, 0x63, 0x30, 0x08, 0xF0, 0xDF, 0xFE, 0x45,
+	0x48, 0x04, 0x73, 0x10, 0xBD, 0x42, 0x49, 0x42, 0x48, 0x63, 0x31, 0x08, 0xF0, 0xD7, 0xFE, 0x10,
+	0xBD, 0x40, 0x49, 0x00, 0x28, 0x03, 0xD0, 0x03, 0x28, 0x02, 0xD1, 0x3F, 0x48, 0x00, 0x7F, 0x48,
+	0x73, 0x70, 0x47, 0x4A, 0x78, 0x0B, 0x78, 0x12, 0x02, 0x1A, 0x43, 0x02, 0x70, 0x12, 0x0A, 0x42,
+	0x70, 0xCA, 0x79, 0xC2, 0x71, 0x0A, 0x7A, 0x02, 0x72, 0xCA, 0x78, 0x8B, 0x78, 0x12, 0x02, 0x1A,
+	0x43, 0x82, 0x70, 0x12, 0x0A, 0xC2, 0x70, 0x4A, 0x79, 0x0B, 0x79, 0x12, 0x02, 0x1A, 0x43, 0x02,
+	0x71, 0x12, 0x0A, 0x42, 0x71, 0x82, 0x79, 0x89, 0x79, 0x12, 0x07, 0x12, 0x0F, 0x09, 0x09, 0x09,
+	0x01, 0x0A, 0x43, 0x82, 0x71, 
+	0x00, 0x00, 0x99, 0x00, 0x80, 0x70, 0x47, 0xF1, 0xB5, 0x2A, 0x48, 0x40, 0x79, 0x01, 0x28, 0x4D,
+	0xD1, 0x00, 0x98, 0x0B, 0x24, 0x00, 0x78, 0x0B, 0x28, 0x00, 0xD8, 0x04, 0x46, 0x00, 0x25, 0x27,
+	0x4E, 0x42, 0xE0, 0x00, 0x98, 0x69, 0x00, 0x0A, 0x18, 0x50, 0x78, 0x91, 0x78, 0x57, 0x8C, 0x24,
+	0x4A, 0x03, 0x46, 0x12, 0x78, 0xBC, 0x46, 0x53, 0x43, 0x5B, 0x18, 0x22, 0x4F, 0x5B, 0x00, 0xFB,
+	0x5E, 0x63, 0x45, 0x05, 0xD9, 0x29, 0x46, 0x00, 0x98, 0xFE, 0xF7, 0x5A, 0xFF, 0x64, 0x1E, 0x2B,
+	0xE0, 0x1D, 0x4B, 0x1B, 0x78, 0x5B, 0x1E, 0x98, 0x42, 0x06, 0xD1, 0x80, 0x18, 0x40, 0x00, 0x83,
+	0x19, 0x20, 0x3B, 0x1E, 0x27, 0xDF, 0x5F, 0x05, 0xE0, 0x00, 0x28, 0x07, 0xD1, 0x50, 0x00, 0x83,
+	0x19, 0x02, 0x27, 0xDF, 0x5F, 0x30, 0x5E, 0x80, 0x10, 0x87, 0x42, 0xE3, 0xDB, 0x52, 0x1E, 0x91,
+	0x42, 0x09, 0xD1, 0x48, 0x00, 
+	0x00, 0x00, 0x9A, 0x00, 0x80, 0x81, 0x19, 0x20, 0x39, 0x1E, 0x22, 0x30, 0x5E, 0x8A, 0x5E, 0x80,
+	0x10, 0x82, 0x42, 0xD7, 0xDB, 0x07, 0xE0, 0x00, 0x29, 0x05, 0xD1, 0x02, 0x20, 0x71, 0x5E, 0x30,
+	0x5E, 0x89, 0x10, 0x88, 0x42, 0xCE, 0xDB, 0x6D, 0x1C, 0xA5, 0x42, 0xBA, 0xD3, 0xF8, 0xBD, 0x00,
+	0x00, 0x88, 0x03, 0x00, 0x20, 0xE4, 0x00, 0x00, 0x20, 0xD0, 0xE7, 0x00, 0x00, 0x32, 0x0B, 0x00,
+	0x20, 0x9E, 0x00, 0x00, 0x20, 0x92, 0x08, 0x00, 0x20, 0x9D, 0x00, 0x00, 0x20, 0xFC, 0x48, 0x82,
+	0x8D, 0xFC, 0x49, 0x0A, 0x81, 0xC0, 0x8D, 0x48, 0x81, 0xF9, 0x48, 0x20, 0x30, 0x02, 0x7A, 0x8A,
+	0x64, 0x40, 0x7A, 0xC8, 0x64, 0x70, 0x47, 0x00, 0xB5, 0xF6, 0x4B, 0x58, 0x78, 0x00, 0x28, 0x03,
+	0xD1, 0xFF, 0xF7, 0xEC, 0xFF, 0x01, 0x20, 0x58, 0x70, 0x00, 0xBD, 0xF2, 0x49, 0x00, 0x28, 0x01,
+	0xD0, 0x03, 0x28, 0x02, 0xD1, 
+	0x00, 0x00, 0x9B, 0x00, 0x80, 0xEE, 0x48, 0x00, 0x1D, 0x03, 0xE0, 0x02, 0x28, 0x03, 0xD1, 0xEC,
+	0x48, 0x10, 0x30, 0x08, 0x64, 0x70, 0x47, 0x01, 0x28, 0xFC, 0xD1, 0xE9, 0x48, 0x1C, 0x30, 0xF8,
+	0xE7, 0x10, 0xB5, 0x1F, 0x21, 0xE8, 0x48, 0x08, 0xF0, 0x76, 0xFE, 0xE7, 0x48, 0x1F, 0x21, 0x1F,
+	0x30, 0x08, 0xF0, 0x71, 0xFE, 0xE4, 0x48, 0x1F, 0x21, 0x3E, 0x30, 0x08, 0xF0, 0x6C, 0xFE, 0xE2,
+	0x48, 0x1F, 0x21, 0x5D, 0x30, 0x08, 0xF0, 0x67, 0xFE, 0x10, 0xBD, 0xF8, 0xB5, 0xDC, 0x49, 0xDF,
+	0x4A, 0x0C, 0x46, 0xDC, 0x4E, 0x20, 0x34, 0x00, 0x28, 0x01, 0xD1, 0x88, 0x8D, 0x02, 0xE0, 0x02,
+	0x28, 0x0A, 0xD1, 0xE0, 0x7E, 0x30, 0x81, 0xC8, 0x8D, 0x70, 0x81, 0x20, 0x7A, 0xB0, 0x64, 0x60,
+	0x7A, 0xF0, 0x64, 0x10, 0x89, 0x30, 0x65, 0xF8, 0xBD, 0x03, 0x28, 0xFC, 0xD1, 0xD3, 0x48, 0x40,
+	0x30, 0x80, 0x8A, 0x30, 0x65, 
+	0x00, 0x00, 0x9C, 0x00, 0x80, 0x88, 0x8E, 0x00, 0x28, 0x3E, 0xD0, 0xF0, 0x78, 0x00, 0x28, 0x02,
+	0xD0, 0xF0, 0x6B, 0x40, 0x1C, 0xF0, 0x63, 0x0D, 0x46, 0x89, 0x8E, 0xF0, 0x6B, 0x81, 0x42, 0x26,
+	0xD8, 0xAA, 0x8E, 0xCB, 0x49, 0x00, 0x27, 0x09, 0x78, 0xCA, 0x4B, 0x82, 0x42, 0x12, 0xD1, 0x00,
+	0x29, 0x0E, 0xD1, 0xA8, 0x8D, 0x30, 0x81, 0xE8, 0x8D, 0x70, 0x81, 0xA0, 0x7D, 0xB0, 0x64, 0xA0,
+	0x7D, 0xF0, 0x64, 0xA0, 0x7D, 0x40, 0x00, 0x18, 0x1A, 0xF0, 0x63, 0xFF, 0xF7, 0xA9, 0xFF, 0x0E,
+	0xE0, 0xF7, 0x63, 0x0C, 0xE0, 0x98, 0x42, 0x05, 0xD2, 0xAA, 0x8E, 0x82, 0x42, 0x02, 0xD2, 0x00,
+	0x29, 0x05, 0xD0, 0x01, 0xE0, 0x98, 0x42, 0x02, 0xD1, 0xFF, 0xF7, 0x9A, 0xFF, 0xF0, 0xE7, 0xA8,
+	0x8E, 0xF1, 0x6B, 0x88, 0x42, 0xBF, 0xD9, 0x28, 0x8E, 0x30, 0x81, 0x68, 0x8E, 0x70, 0x81, 0x20,
+	0x7A, 0xB0, 0x64, 0x60, 0x7A, 
+	0x00, 0x00, 0x9D, 0x00, 0x80, 0xF0, 0x64, 0xF8, 0xBD, 0x08, 0x8E, 0x30, 0x81, 0x48, 0x8E, 0xF5,
+	0xE7, 0xFF, 0xB5, 0x91, 0xB0, 0x00, 0x20, 0x07, 0x90, 0x06, 0x90, 0x01, 0x20, 0xA9, 0x4C, 0x04,
+	0x90, 0x20, 0x6C, 0x16, 0x46, 0x01, 0x88, 0x08, 0x91, 0x1E, 0x99, 0x01, 0x29, 0x10, 0xD1, 0x02,
+	0xF0, 0xDF, 0xF8, 0x00, 0x28, 0x01, 0xD0, 0x02, 0x20, 0x04, 0x90, 0x20, 0x6C, 0x01, 0x79, 0x07,
+	0x91, 0x05, 0x21, 0x41, 0x56, 0x06, 0x91, 0x08, 0x98, 0x70, 0x21, 0x08, 0x40, 0x00, 0x09, 0x0B,
+	0xE0, 0x03, 0x29, 0x0A, 0xD1, 0x01, 0x7A, 0x07, 0x91, 0x09, 0x21, 0x41, 0x56, 0x06, 0x91, 0x07,
+	0x21, 0x08, 0x98, 0x09, 0x03, 0x08, 0x40, 0x00, 0x0B, 0x08, 0x90, 0x00, 0x20, 0x05, 0x90, 0x94,
+	0x48, 0x40, 0x30, 0x10, 0x90, 0x05, 0x98, 0x5E, 0xE1, 0x00, 0x20, 0x03, 0x90, 0x14, 0x98, 0x51,
+	0xE1, 0xFE, 0xF7, 0x12, 0xFA, 
+	0x00, 0x00, 0x9E, 0x00, 0x80, 0x02, 0x90, 0x0B, 0x98, 0xFE, 0xF7, 0xDA, 0xF9, 0x16, 0x21, 0x01,
+	0x90, 0x48, 0x43, 0x91, 0x49, 0x40, 0x18, 0x0C, 0x90, 0x00, 0x20, 0x0A, 0x90, 0x04, 0x46, 0x05,
+	0x46, 0x09, 0x90, 0x0C, 0x98, 0x07, 0x88, 0x02, 0xF0, 0xA3, 0xF8, 0x00, 0x28, 0x0A, 0xD0, 0x1E,
+	0x98, 0x01, 0x28, 0x07, 0xD1, 0x05, 0x98, 0x00, 0x28, 0x02, 0xD1, 0x3F, 0x07, 0x3F, 0x0F, 0x01,
+	0xE0, 0xF0, 0x20, 0x07, 0x40, 0xF8, 0xB2, 0x86, 0x46, 0x1B, 0x98, 0x00, 0x28, 0x67, 0xD0, 0x08,
+	0x98, 0xC0, 0x07, 0x64, 0xD0, 0x00, 0x21, 0xF8, 0x07, 0x21, 0xD0, 0x0C, 0x98, 0x40, 0x18, 0x00,
+	0x79, 0x02, 0x9A, 0x11, 0x9B, 0x80, 0x18, 0x12, 0x9A, 0x40, 0x00, 0x12, 0x5E, 0x30, 0x5E, 0x12,
+	0x1A, 0x03, 0x98, 0x08, 0x18, 0x40, 0x00, 0x18, 0x5E, 0x80, 0x1A, 0x02, 0x1E, 0x00, 0xDA, 0x42,
+	0x42, 0x1B, 0x9B, 0x9A, 0x42, 
+	0x00, 0x00, 0x9F, 0x00, 0x80, 0x01, 0xDB, 0xFF, 0x2B, 0x09, 0xD1, 0x0A, 0x9A, 0x24, 0x18, 0x52,
+	0x1C, 0x0A, 0x92, 0x00, 0x28, 0x03, 0xDA, 0x09, 0x9A, 0x52, 0x1C, 0x2D, 0x18, 0x09, 0x92, 0x7F,
+	0x08, 0x49, 0x1C, 0x00, 0x2F, 0xD7, 0xD1, 0x0A, 0x98, 0x01, 0x28, 0x0F, 0xDD, 0x6B, 0x49, 0x80,
+	0x00, 0x08, 0x58, 0x60, 0x43, 0x04, 0x12, 0x09, 0x98, 0x80, 0x00, 0x08, 0x58, 0x68, 0x43, 0x05,
+	0x12, 0x00, 0x2C, 0x00, 0xDA, 0x64, 0x1C, 0x00, 0x2D, 0x00, 0xDA, 0x6D, 0x1C, 0x1E, 0x98, 0x01,
+	0x28, 0x25, 0xD1, 0x5C, 0x4A, 0x01, 0x98, 0x60, 0x32, 0x10, 0x56, 0x01, 0x1E, 0x00, 0xDA, 0x41,
+	0x42, 0x10, 0x9B, 0x5B, 0x7A, 0x99, 0x42, 0x00, 0xD1, 0x00, 0x20, 0x00, 0x2C, 0x08, 0xDD, 0x00,
+	0x28, 0x12, 0xDB, 0x10, 0x99, 0x09, 0x23, 0xCB, 0x56, 0x83, 0x42, 0x0E, 0xDD, 0x40, 0x1C, 0x0C,
+	0xE0, 0x00, 0x2C, 0x09, 0xDA, 
+	0x00, 0x00, 0xA0, 0x00, 0x80, 0x00, 0x28, 0x07, 0xDC, 0x10, 0x99, 0x09, 0x23, 0xCB, 0x56, 0x59,
+	0x42, 0x81, 0x42, 0x02, 0xDA, 0x40, 0x1E, 0x00, 0xE0, 0x00, 0x20, 0x01, 0x99, 0x50, 0x54, 0x00,
+	0x20, 0x84, 0x46, 0x70, 0x46, 0xC0, 0x07, 0x79, 0xD0, 0x0C, 0x99, 0x60, 0x46, 0x08, 0x18, 0x00,
+	0x79, 0x02, 0x99, 0x41, 0x18, 0x1E, 0x98, 0x03, 0x28, 0x04, 0xD1, 0x49, 0x48, 0x02, 0x6A, 0xC0,
+	0x69, 0x10, 0x18, 0x09, 0x1A, 0x03, 0x9A, 0x60, 0x46, 0x80, 0x18, 0x11, 0x9A, 0x40, 0x00, 0x10,
+	0x5E, 0x4A, 0x00, 0x0F, 0x90, 0x12, 0x99, 0x08, 0x9F, 0x89, 0x5E, 0xB3, 0x5E, 0x0E, 0x93, 0xFF,
+	0x07, 0x15, 0xD0, 0xCB, 0x1A, 0x98, 0x42, 0x02, 0xDB, 0x07, 0x1B, 0x9F, 0x42, 0x04, 0xDB, 0x98,
+	0x42, 0x04, 0xDC, 0x07, 0x1B, 0x9F, 0x42, 0x01, 0xDD, 0x18, 0x46, 0x08, 0xE0, 0x67, 0x1B, 0xFF,
+	0x1C, 0x06, 0x2F, 0x03, 0xD9, 
+	0x00, 0x00, 0xA1, 0x00, 0x80, 0x98, 0x42, 0x01, 0xDC, 0x40, 0x1B, 0x00, 0xE0, 0x00, 0x1B, 0x08,
+	0x9B, 0x5B, 0x07, 0x10, 0xD5, 0x43, 0x1A, 0x88, 0x42, 0x00, 0xDC, 0x0B, 0x1A, 0x06, 0x9F, 0xBB,
+	0x42, 0x09, 0xDA, 0x07, 0x9B, 0x00, 0x2B, 0x02, 0xD1, 0x40, 0x18, 0x40, 0x10, 0x03, 0xE0, 0x4B,
+	0x00, 0xCB, 0x18, 0x18, 0x18, 0x80, 0x10, 0x08, 0x9B, 0x9B, 0x07, 0x06, 0xD5, 0x88, 0x42, 0x01,
+	0xDD, 0x40, 0x1E, 0x02, 0xE0, 0x88, 0x42, 0x00, 0xDA, 0x40, 0x1C, 0x1E, 0x9B, 0x01, 0x2B, 0x20,
+	0xD1, 0x08, 0x9B, 0xDB, 0x07, 0x1D, 0xD0, 0x10, 0x9B, 0x5B, 0x7A, 0x00, 0x2B, 0x19, 0xD0, 0x19,
+	0x4B, 0x01, 0x9F, 0x60, 0x33, 0xDB, 0x57, 0x10, 0x9F, 0x7F, 0x7A, 0xBB, 0x42, 0x06, 0xD1, 0x0F,
+	0x9B, 0x83, 0x42, 0x0E, 0xDD, 0x0E, 0x9B, 0x40, 0x1C, 0x5B, 0x1E, 0x09, 0xE0, 0x10, 0x9F, 0x7F,
+	0x7A, 0xFB, 0x42, 0x06, 0xD1, 
+	0x00, 0x00, 0xA2, 0x00, 0x80, 0x0F, 0x9B, 0x83, 0x42, 0x03, 0xDA, 0x0E, 0x9B, 0x40, 0x1E, 0x5B,
+	0x1C, 0xB3, 0x52, 0x14, 0x4F, 0xB8, 0x42, 0x02, 0xDD, 0x38, 0x46, 0x05, 0xE0, 0x32, 0xE0, 0x11,
+	0x4B, 0xDB, 0x43, 0x98, 0x42, 0x00, 0xDA, 0x18, 0x46, 0xB3, 0x5E, 0x0D, 0x93, 0x1B, 0x18, 0x5B,
+	0x1A, 0xBB, 0x42, 0x19, 0xDD, 0x0D, 0x98, 0x3B, 0x46, 0x08, 0x1A, 0xC0, 0x19, 0x1F, 0xE0, 0x00,
+	0x00, 0x60, 0xE8, 0x00, 0x00, 0x28, 0x01, 0x00, 0x20, 0x16, 0x08, 0x00, 0x20, 0xD0, 0xE7, 0x00,
+	0x00, 0xC4, 0x01, 0x00, 0x20, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0xEC, 0x00, 0x00, 0xD8, 0xDC, 0x00,
+	0x00, 0xF0, 0xE9, 0x00, 0x00, 0xFF, 0x1F, 0x00, 0x00, 0xFF, 0x4F, 0xBB, 0x42, 0x07, 0xDA, 0x0D,
+	0x98, 0x08, 0x1A, 0x79, 0x42, 0x40, 0x1A, 0x12, 0x99, 0x88, 0x52, 0xB7, 0x52, 0x02, 0xE0, 0x12,
+	0x99, 0x88, 0x52, 0xB3, 0x52, 
+	0x00, 0x00, 0xA3, 0x00, 0x80, 0x70, 0x46, 0x40, 0x08, 0x86, 0x46, 0x60, 0x46, 0x40, 0x1C, 0x84,
+	0x46, 0x70, 0x46, 0x00, 0x28, 0x00, 0xD0, 0x44, 0xE7, 0x03, 0x98, 0x08, 0x30, 0xC0, 0xB2, 0x03,
+	0x90, 0x0B, 0x98, 0x40, 0x1C, 0x0B, 0x90, 0x1A, 0x99, 0x88, 0x42, 0x00, 0xD2, 0xA8, 0xE6, 0x05,
+	0x98, 0x40, 0x1C, 0xC0, 0xB2, 0x05, 0x90, 0x04, 0x99, 0x88, 0x42, 0x00, 0xD2, 0x9C, 0xE6, 0x15,
+	0xB0, 0xF0, 0xBD, 0x70, 0xB5, 0x0E, 0x46, 0xE9, 0x49, 0x86, 0xB0, 0x0C, 0x6B, 0x03, 0x28, 0x02,
+	0xD1, 0x23, 0x46, 0xC8, 0x6B, 0x07, 0xE0, 0x01, 0x28, 0x02, 0xD1, 0x23, 0x46, 0x48, 0x6B, 0x02,
+	0xE0, 0x48, 0x6B, 0x03, 0x19, 0x88, 0x6B, 0xE2, 0x49, 0xC5, 0x18, 0x01, 0x22, 0x08, 0x46, 0x4A,
+	0x30, 0x02, 0x90, 0xE0, 0x48, 0x04, 0x92, 0x03, 0x91, 0x82, 0x78, 0x18, 0x1B, 0x00, 0x01, 0x01,
+	0x92, 0x80, 0x19, 0x00, 0x95, 
+	0x00, 0x00, 0xA4, 0x00, 0x80, 0xDC, 0x4A, 0xDD, 0x49, 0xFF, 0xF7, 0x42, 0xFE, 0x06, 0xB0, 0x70,
+	0xBD, 0xFF, 0xB5, 0x99, 0xB0, 0x00, 0x20, 0x04, 0x90, 0x01, 0x20, 0x03, 0x90, 0xD8, 0x4C, 0x00,
+	0x20, 0x60, 0x65, 0xA0, 0x65, 0xE0, 0x65, 0xD7, 0x48, 0x01, 0x8C, 0xD7, 0x48, 0x02, 0x91, 0x00,
+	0x88, 0x81, 0x42, 0x00, 0xD9, 0x02, 0x90, 0x01, 0xF0, 0x1B, 0xFF, 0x00, 0x28, 0x01, 0xD0, 0x02,
+	0x20, 0x00, 0xE0, 0x01, 0x20, 0x06, 0x90, 0xCE, 0x48, 0x00, 0x6C, 0x01, 0x88, 0x49, 0x07, 0x49,
+	0x0F, 0x0A, 0x91, 0x81, 0x78, 0x09, 0x91, 0x03, 0x21, 0x41, 0x56, 0xC6, 0x48, 0x08, 0x91, 0x18,
+	0x90, 0x40, 0x78, 0x0C, 0x90, 0x00, 0x20, 0x07, 0x90, 0xC0, 0x48, 0x40, 0x30, 0x17, 0x90, 0x07,
+	0x98, 0xE0, 0xE1, 0x1B, 0x98, 0xD5, 0xE1, 0xFE, 0xF7, 0x23, 0xF8, 0x01, 0x90, 0xC3, 0x49, 0x19,
+	0x98, 0x09, 0x78, 0x48, 0x43, 
+	0x00, 0x00, 0xA5, 0x00, 0x80, 0x0D, 0x90, 0x0E, 0x90, 0x01, 0x98, 0x16, 0x21, 0x48, 0x43, 0xC0,
+	0x49, 0x40, 0x18, 0x13, 0x90, 0x19, 0x98, 0xBD, 0xE1, 0x00, 0x26, 0x13, 0x98, 0x0B, 0x96, 0x34,
+	0x46, 0x37, 0x46, 0x05, 0x88, 0x01, 0xF0, 0xE4, 0xFE, 0x00, 0x28, 0x07, 0xD0, 0x07, 0x98, 0x00,
+	0x28, 0x02, 0xD1, 0x2D, 0x07, 0x2D, 0x0F, 0x01, 0xE0, 0xF0, 0x20, 0x05, 0x40, 0xE8, 0xB2, 0x05,
+	0x90, 0x0C, 0x98, 0x00, 0x28, 0x66, 0xD0, 0x0A, 0x98, 0xC0, 0x07, 0x63, 0xD0, 0x00, 0x20, 0xE9,
+	0x07, 0x20, 0xD0, 0x13, 0x99, 0x09, 0x18, 0x0B, 0x79, 0x0D, 0x99, 0x9C, 0x46, 0xC9, 0x18, 0x4A,
+	0x00, 0xAC, 0x49, 0xA6, 0x4B, 0x89, 0x5E, 0xC6, 0x33, 0x9A, 0x5E, 0x22, 0x9B, 0x89, 0x1A, 0x0E,
+	0x9A, 0x62, 0x44, 0x52, 0x00, 0x9A, 0x5E, 0x51, 0x1A, 0x0A, 0x1E, 0x00, 0xDA, 0x4A, 0x42, 0x0C,
+	0x9B, 0x9A, 0x42, 0x07, 0xDA, 
+	0x00, 0x00, 0xA6, 0x00, 0x80, 0x76, 0x1C, 0x64, 0x18, 0x00, 0x29, 0x03, 0xDA, 0x0B, 0x9A, 0x52,
+	0x1C, 0x7F, 0x18, 0x0B, 0x92, 0x6D, 0x08, 0x40, 0x1C, 0x00, 0x2D, 0xD8, 0xD1, 0x01, 0x2E, 0x0F,
+	0xDD, 0x9D, 0x49, 0xB0, 0x00, 0x08, 0x58, 0x60, 0x43, 0x04, 0x12, 0x0B, 0x98, 0x80, 0x00, 0x08,
+	0x58, 0x78, 0x43, 0x07, 0x12, 0x00, 0x2C, 0x00, 0xDA, 0x64, 0x1C, 0x00, 0x2F, 0x00, 0xDA, 0x7F,
+	0x1C, 0x96, 0x48, 0x01, 0x9A, 0x00, 0x78, 0x10, 0x99, 0x42, 0x43, 0x92, 0x48, 0x3C, 0x38, 0x43,
+	0x18, 0xD0, 0x56, 0x01, 0x1E, 0x00, 0xDA, 0x41, 0x42, 0x18, 0x9D, 0x6D, 0x7A, 0xA9, 0x42, 0x00,
+	0xD1, 0x00, 0x20, 0x00, 0x2C, 0x08, 0xDD, 0x00, 0x28, 0x12, 0xDB, 0x18, 0x9D, 0x09, 0x21, 0x69,
+	0x56, 0x81, 0x42, 0x0E, 0xDD, 0x40, 0x1C, 0x0C, 0xE0, 0x00, 0x2C, 0x09, 0xDA, 0x00, 0x28, 0x07,
+	0xDC, 0x18, 0x99, 0x09, 0x25, 
+	0x00, 0x00, 0xA7, 0x00, 0x80, 0x4D, 0x57, 0x69, 0x42, 0x81, 0x42, 0x02, 0xDA, 0x40, 0x1E, 0x00,
+	0xE0, 0x00, 0x20, 0xD0, 0x54, 0x00, 0x20, 0x11, 0x90, 0x05, 0x98, 0x0F, 0x90, 0xC0, 0x07, 0x79,
+	0xD0, 0x11, 0x99, 0x13, 0x98, 0x40, 0x18, 0x05, 0x79, 0x0D, 0x98, 0x78, 0x49, 0x40, 0x19, 0x16,
+	0x90, 0x0E, 0x78, 0x17, 0x21, 0x71, 0x43, 0x88, 0x42, 0x16, 0xD1, 0x17, 0x98, 0x40, 0x68, 0x64,
+	0x21, 0x08, 0xF0, 0x87, 0xFB, 0x76, 0x49, 0x49, 0x6A, 0x48, 0x43, 0x2E, 0x21, 0x4E, 0x43, 0x71,
+	0x49, 0x88, 0x53, 0x0E, 0x99, 0x22, 0x9A, 0x49, 0x19, 0x49, 0x00, 0x50, 0x52, 0x16, 0x99, 0x67,
+	0x4A, 0x00, 0x20, 0x49, 0x00, 0xC6, 0x32, 0x50, 0x52, 0x68, 0x48, 0x16, 0x99, 0x06, 0x78, 0x17,
+	0x20, 0x70, 0x43, 0x08, 0x1A, 0x0C, 0x28, 0x17, 0xD1, 0x17, 0x98, 0x40, 0x68, 0x64, 0x21, 0x08,
+	0xF0, 0x68, 0xFB, 0x67, 0x49, 
+	0x00, 0x00, 0xA8, 0x00, 0x80, 0x49, 0x6A, 0x48, 0x43, 0x2E, 0x21, 0x4E, 0x43, 0x61, 0x49, 0x71,
+	0x18, 0x08, 0x83, 0x0E, 0x99, 0x22, 0x9A, 0x49, 0x19, 0x49, 0x00, 0x50, 0x52, 0x16, 0x99, 0x57,
+	0x4A, 0x00, 0x20, 0x49, 0x00, 0xC6, 0x32, 0x50, 0x52, 0x0E, 0x98, 0x22, 0x99, 0x40, 0x19, 0x40,
+	0x00, 0x08, 0x5E, 0x16, 0x99, 0x0A, 0x9A, 0x4D, 0x00, 0x56, 0x49, 0x84, 0x46, 0x49, 0x5F, 0xD2,
+	0x07, 0x18, 0xD0, 0x4E, 0x4A, 0xC6, 0x32, 0x52, 0x5F, 0x8A, 0x1A, 0x90, 0x42, 0x02, 0xDB, 0x03,
+	0x1B, 0x93, 0x42, 0x04, 0xDB, 0x90, 0x42, 0x04, 0xDC, 0x03, 0x1B, 0x93, 0x42, 0x01, 0xDD, 0x10,
+	0x46, 0x08, 0xE0, 0xE3, 0x1B, 0xDB, 0x1C, 0x06, 0x2B, 0x03, 0xD9, 0x90, 0x42, 0x01, 0xDC, 0xC0,
+	0x1B, 0x00, 0xE0, 0x00, 0x1B, 0x0A, 0x9A, 0x52, 0x07, 0x11, 0xD5, 0x42, 0x1A, 0x88, 0x42, 0x00,
+	0xDC, 0x0A, 0x1A, 0x08, 0x9B, 
+	0x00, 0x00, 0xA9, 0x00, 0x80, 0x9A, 0x42, 0x0A, 0xD2, 0x09, 0x9A, 0x00, 0x2A, 0x03, 0xD1, 0x40,
+	0x18, 0x40, 0x10, 0x04, 0xE0, 0xAC, 0xE0, 0x4A, 0x00, 0x8A, 0x18, 0x10, 0x18, 0x80, 0x10, 0x0A,
+	0x9A, 0x92, 0x07, 0x06, 0xD5, 0x88, 0x42, 0x01, 0xDD, 0x40, 0x1E, 0x02, 0xE0, 0x88, 0x42, 0x00,
+	0xDA, 0x40, 0x1C, 0x0A, 0x9A, 0xD2, 0x07, 0x24, 0xD0, 0x18, 0x9A, 0x52, 0x7A, 0x00, 0x2A, 0x20,
+	0xD0, 0x36, 0x4B, 0x01, 0x9A, 0x1B, 0x78, 0x10, 0x9E, 0x5A, 0x43, 0x32, 0x4B, 0x3C, 0x3B, 0x9B,
+	0x19, 0xD2, 0x56, 0x18, 0x9B, 0x5B, 0x7A, 0x9A, 0x42, 0x07, 0xD1, 0x84, 0x45, 0x11, 0xDD, 0x27,
+	0x4B, 0x40, 0x1C, 0xC6, 0x33, 0x5A, 0x5B, 0x52, 0x1E, 0x0A, 0xE0, 0x18, 0x9B, 0x5B, 0x7A, 0xDA,
+	0x42, 0x07, 0xD1, 0x84, 0x45, 0x05, 0xDA, 0x21, 0x4B, 0x40, 0x1E, 0xC6, 0x33, 0x5A, 0x5B, 0x52,
+	0x1C, 0x5A, 0x53, 0x1E, 0x4B, 
+	0x00, 0x00, 0xAA, 0x00, 0x80, 0xC6, 0x33, 0x5A, 0x5F, 0x12, 0x18, 0x56, 0x1A, 0x21, 0x49, 0x17,
+	0x22, 0x48, 0x53, 0x5E, 0x53, 0x1D, 0x48, 0x16, 0x99, 0x00, 0x78, 0x15, 0x90, 0x50, 0x43, 0x14,
+	0x90, 0x81, 0x42, 0x10, 0xD1, 0x17, 0x98, 0x40, 0x68, 0x64, 0x21, 0x08, 0xF0, 0xD2, 0xFA, 0x1C,
+	0x49, 0x49, 0x6A, 0x2E, 0x22, 0x48, 0x43, 0x15, 0x99, 0x51, 0x43, 0x16, 0x4A, 0x50, 0x52, 0x0F,
+	0x49, 0x00, 0x20, 0xC6, 0x31, 0x48, 0x53, 0x14, 0x99, 0x16, 0x98, 0x40, 0x1A, 0x0C, 0x28, 0x2F,
+	0xD1, 0x17, 0x98, 0x40, 0x68, 0x64, 0x21, 0x08, 0xF0, 0xBC, 0xFA, 0x11, 0x49, 0x49, 0x6A, 0x2E,
+	0x22, 0x48, 0x43, 0x15, 0x99, 0x51, 0x43, 0x1D, 0xE0, 0x00, 0xE0, 0xFF, 0xFF, 0xF0, 0xE9, 0x00,
+	0x00, 0x1C, 0x0E, 0x00, 0x20, 0xA0, 0xE8, 0x00, 0x00, 0x32, 0x0B, 0x00, 0x20, 0xCC, 0x07, 0x00,
+	0x20, 0x28, 0x01, 0x00, 0x20, 
+	0x00, 0x00, 0xAB, 0x00, 0x80, 0xD0, 0xE7, 0x00, 0x00, 0x76, 0x02, 0x00, 0x20, 0x9E, 0x00, 0x00,
+	0x20, 0x00, 0xEC, 0x00, 0x00, 0x2C, 0x05, 0x00, 0x20, 0xD8, 0xDC, 0x00, 0x00, 0x9D, 0x00, 0x00,
+	0x20, 0x80, 0xEA, 0x00, 0x00, 0xFD, 0x4A, 0x89, 0x18, 0x08, 0x83, 0xFD, 0x49, 0x00, 0x20, 0x48,
+	0x53, 0xFC, 0x48, 0x02, 0x99, 0x00, 0x88, 0x41, 0x18, 0xB1, 0x42, 0x01, 0xDC, 0x01, 0x21, 0x04,
+	0x91, 0x02, 0x99, 0x40, 0x1A, 0xB0, 0x42, 0x01, 0xDC, 0x00, 0x20, 0x03, 0x90, 0xF6, 0x48, 0x41,
+	0x6D, 0x8E, 0x42, 0x00, 0xDD, 0x46, 0x65, 0x81, 0x6D, 0x8E, 0x42, 0x00, 0xDA, 0x86, 0x65, 0xF3,
+	0x49, 0x06, 0x22, 0x8A, 0x5E, 0x51, 0x42, 0xB1, 0x42, 0x02, 0xDD, 0xC1, 0x6D, 0x49, 0x1C, 0xC1,
+	0x65, 0x0F, 0x98, 0x40, 0x08, 0x0F, 0x90, 0x11, 0x98, 0x40, 0x1C, 0x11, 0x90, 0x0F, 0x98, 0x00,
+	0x28, 0x00, 0xD0, 0xCB, 0xE6, 
+	0x00, 0x00, 0xAC, 0x00, 0x80, 0xEA, 0x49, 0x0D, 0x98, 0x09, 0x78, 0x40, 0x18, 0x0D, 0x90, 0x0E,
+	0x90, 0x10, 0x98, 0x40, 0x1C, 0x10, 0x90, 0x1A, 0x99, 0x88, 0x42, 0x00, 0xD8, 0x3C, 0xE6, 0x12,
+	0x98, 0x40, 0x1C, 0x12, 0x90, 0x1C, 0x99, 0x88, 0x42, 0x00, 0xD8, 0x24, 0xE6, 0x07, 0x98, 0x40,
+	0x1C, 0xC0, 0xB2, 0x07, 0x90, 0x06, 0x99, 0x88, 0x42, 0x00, 0xD2, 0x1A, 0xE6, 0x04, 0x98, 0x00,
+	0x28, 0x06, 0xD0, 0xD9, 0x48, 0x01, 0x78, 0x49, 0x08, 0x49, 0x00, 0x01, 0x70, 0x1D, 0xB0, 0xF0,
+	0xBD, 0x03, 0x98, 0x00, 0x28, 0xFA, 0xD0, 0xD4, 0x49, 0x01, 0x22, 0x08, 0x78, 0x10, 0x43, 0x08,
+	0x70, 0xF4, 0xE7, 0x08, 0xB5, 0x00, 0x90, 0xD3, 0x48, 0x03, 0x6B, 0xD3, 0x48, 0x00, 0x22, 0x01,
+	0x78, 0x5B, 0x1E, 0x49, 0x1E, 0x10, 0x46, 0xFF, 0xF7, 0xCB, 0xFD, 0x08, 0xBD, 0xF8, 0xB5, 0x04,
+	0x46, 0x0D, 0x46, 0x10, 0x46, 
+	0x00, 0x00, 0xAD, 0x00, 0x80, 0x19, 0x46, 0x06, 0x9E, 0xFD, 0xF7, 0x52, 0xFC, 0xCB, 0x48, 0x00,
+	0x96, 0x03, 0x78, 0xCB, 0x48, 0x29, 0x46, 0x02, 0x78, 0x20, 0x46, 0xFF, 0xF7, 0xB9, 0xFD, 0xF8,
+	0xBD, 0xC4, 0x48, 0x40, 0x6A, 0xC7, 0x4A, 0x00, 0x21, 0x40, 0x1E, 0x43, 0x00, 0xD1, 0x52, 0x00,
+	0x28, 0xFA, 0xD1, 0xBF, 0x48, 0xBA, 0x4A, 0x00, 0x78, 0x3E, 0x3A, 0x11, 0x54, 0x40, 0x1E, 0xFC,
+	0xD1, 0xBD, 0x48, 0xB7, 0x4A, 0x00, 0x78, 0x1F, 0x3A, 0x11, 0x54, 0x40, 0x1E, 0xFC, 0xD1, 0xB6,
+	0x48, 0x01, 0x71, 0x41, 0x71, 0x70, 0x47, 0x70, 0xB5, 0xB3, 0x4D, 0xBB, 0x48, 0x2C, 0x6C, 0x28,
+	0x64, 0xFD, 0xF7, 0x32, 0xF9, 0x03, 0x20, 0xFD, 0xF7, 0xBA, 0xFB, 0xFD, 0xF7, 0x05, 0xFC, 0x00,
+	0x28, 0xFB, 0xD0, 0xB6, 0x48, 0x01, 0x68, 0x03, 0x20, 0xFF, 0xF7, 0x63, 0xFD, 0x2C, 0x64, 0xFF,
+	0xF7, 0xCF, 0xFF, 0x70, 0xBD, 
+	0x00, 0x00, 0xAE, 0x00, 0x80, 0xAB, 0x48, 0x80, 0x6A, 0xA5, 0x4A, 0x00, 0x21, 0x40, 0x1E, 0x43,
+	0x00, 0xD1, 0x52, 0x00, 0x28, 0xFA, 0xD1, 0xA6, 0x48, 0xA1, 0x4A, 0x00, 0x78, 0x7C, 0x3A, 0x11,
+	0x54, 0x40, 0x1E, 0xFC, 0xD1, 0xA4, 0x48, 0x9E, 0x4A, 0x00, 0x78, 0x5D, 0x3A, 0x11, 0x54, 0x40,
+	0x1E, 0xFC, 0xD1, 0x70, 0x47, 0x70, 0xB5, 0x9C, 0x4D, 0xA3, 0x48, 0x2C, 0x6C, 0x28, 0x64, 0xFD,
+	0xF7, 0x45, 0xF8, 0xFD, 0xF7, 0x89, 0xFA, 0xFD, 0xF7, 0xD7, 0xFB, 0x00, 0x28, 0xFB, 0xD0, 0xA0,
+	0x48, 0x00, 0x68, 0xFF, 0xF7, 0x86, 0xFF, 0x2C, 0x64, 0xFF, 0xF7, 0xD4, 0xFF, 0x70, 0xBD, 0xF0,
+	0xB5, 0x93, 0x48, 0x87, 0xB0, 0x00, 0x78, 0x06, 0x90, 0x93, 0x48, 0x00, 0x78, 0x05, 0x90, 0x96,
+	0x48, 0x00, 0x1D, 0x41, 0x7F, 0x40, 0x7F, 0x4F, 0x07, 0x7F, 0x0F, 0xC0, 0x08, 0x8A, 0x4B, 0x03,
+	0x90, 0xD8, 0x6C, 0x00, 0x2F, 
+	0x00, 0x00, 0xAF, 0x00, 0x80, 0x04, 0xD1, 0x40, 0x00, 0x04, 0x90, 0x00, 0x20, 0x02, 0x90, 0x0B,
+	0xE0, 0xC0, 0x19, 0x40, 0x1C, 0x04, 0x90, 0x8F, 0x48, 0x8E, 0x49, 0xC0, 0x5D, 0x02, 0x90, 0xB8,
+	0x00, 0x08, 0x31, 0x40, 0x18, 0x40, 0x68, 0xC0, 0xB2, 0x01, 0x90, 0x00, 0x20, 0x58, 0x64, 0x58,
+	0x71, 0x18, 0x71, 0x9A, 0x78, 0xD0, 0x07, 0x07, 0xD0, 0x79, 0x4C, 0x06, 0x98, 0x3E, 0x3C, 0x21,
+	0x5C, 0x49, 0x1C, 0x21, 0x54, 0x40, 0x1E, 0xFA, 0xD1, 0x90, 0x07, 0x07, 0xD5, 0x74, 0x4C, 0x05,
+	0x98, 0x1F, 0x3C, 0x21, 0x5C, 0x49, 0x1C, 0x21, 0x54, 0x40, 0x1E, 0xFA, 0xD1, 0xD0, 0x07, 0x5E,
+	0xD0, 0x06, 0x9C, 0x78, 0x48, 0x64, 0x1E, 0x66, 0x00, 0x6F, 0x49, 0x85, 0x5F, 0x08, 0x6D, 0x42,
+	0x42, 0x95, 0x42, 0x01, 0xDA, 0x01, 0x22, 0x0A, 0x71, 0x85, 0x42, 0x01, 0xDD, 0x01, 0x20, 0x48,
+	0x71, 0x69, 0x48, 0x40, 0x89, 
+	0x00, 0x00, 0xB0, 0x00, 0x80, 0x85, 0x42, 0x17, 0xDD, 0x67, 0x49, 0x28, 0x1A, 0x4A, 0x6C, 0x80,
+	0x18, 0x48, 0x64, 0xFB, 0xF7, 0xC0, 0xFE, 0x00, 0x28, 0x06, 0xD1, 0x63, 0x49, 0x4A, 0x6A, 0x10,
+	0x55, 0x8A, 0x6A, 0x10, 0x55, 0xC9, 0x6A, 0x06, 0xE0, 0x5F, 0x49, 0x00, 0x20, 0xCA, 0x68, 0x10,
+	0x55, 0x0A, 0x69, 0x10, 0x55, 0x49, 0x69, 0x08, 0x55, 0x5B, 0x4A, 0x51, 0x6A, 0xD2, 0x6C, 0x08,
+	0x5D, 0x94, 0x46, 0x90, 0x42, 0x29, 0xD3, 0x60, 0x45, 0x02, 0xD1, 0x63, 0x48, 0x85, 0x53, 0x24,
+	0xE0, 0x04, 0x9A, 0x90, 0x42, 0x19, 0xD2, 0x00, 0x2F, 0x1F, 0xD0, 0x5F, 0x48, 0x80, 0x5F, 0x86,
+	0x46, 0x28, 0x1A, 0x02, 0x1E, 0x00, 0xDA, 0x52, 0x42, 0x03, 0x9B, 0x9A, 0x42, 0x01, 0xDD, 0x1F,
+	0x2B, 0x08, 0xD1, 0x02, 0x9B, 0x58, 0x4A, 0xC0, 0x18, 0x01, 0x9B, 0x58, 0x43, 0x00, 0x12, 0x70,
+	0x44, 0x90, 0x53, 0x0A, 0xE0, 
+	0x00, 0x00, 0xB1, 0x00, 0x80, 0x60, 0x46, 0x08, 0x55, 0xDF, 0xE7, 0x53, 0x4A, 0x4D, 0x4B, 0x90,
+	0x5B, 0x28, 0x1A, 0x98, 0x53, 0x00, 0x20, 0x08, 0x55, 0xF2, 0xE7, 0x00, 0x2C, 0xA1, 0xD1, 0x42,
+	0x48, 0x81, 0x78, 0x89, 0x07, 0x60, 0xD5, 0x05, 0x9C, 0x06, 0x98, 0x64, 0x1E, 0x20, 0x18, 0x46,
+	0x00, 0x44, 0x48, 0x3D, 0x49, 0x85, 0x5F, 0x08, 0x6D, 0x42, 0x42, 0x95, 0x42, 0x01, 0xDA, 0x01,
+	0x22, 0x0A, 0x71, 0x85, 0x42, 0x01, 0xDD, 0x01, 0x20, 0x48, 0x71, 0x37, 0x48, 0x40, 0x89, 0x85,
+	0x42, 0x17, 0xDD, 0x35, 0x49, 0x28, 0x1A, 0x4A, 0x6C, 0x80, 0x18, 0x48, 0x64, 0xFB, 0xF7, 0x5B,
+	0xFE, 0x00, 0x28, 0x06, 0xD1, 0x30, 0x49, 0x0A, 0x6B, 0x10, 0x55, 0x4A, 0x6B, 0x10, 0x55, 0x89,
+	0x6B, 0x06, 0xE0, 0x2D, 0x49, 0x00, 0x20, 0x8A, 0x69, 0x10, 0x55, 0xCA, 0x69, 0x10, 0x55, 0x09,
+	0x6A, 0x08, 0x55, 0x29, 0x4A, 
+	0x00, 0x00, 0xB2, 0x00, 0x80, 0x11, 0x6B, 0xD2, 0x6C, 0x08, 0x5D, 0x94, 0x46, 0x90, 0x42, 0x29,
+	0xD3, 0x60, 0x45, 0x02, 0xD1, 0x30, 0x48, 0x85, 0x53, 0x24, 0xE0, 0x04, 0x9A, 0x90, 0x42, 0x19,
+	0xD2, 0x00, 0x2F, 0x1F, 0xD0, 0x2C, 0x48, 0x80, 0x5F, 0x86, 0x46, 0x28, 0x1A, 0x02, 0x1E, 0x00,
+	0xDA, 0x52, 0x42, 0x03, 0x9B, 0x9A, 0x42, 0x01, 0xDD, 0x1F, 0x2B, 0x08, 0xD1, 0x02, 0x9B, 0x26,
+	0x4A, 0xC0, 0x18, 0x01, 0x9B, 0x58, 0x43, 0x00, 0x12, 0x70, 0x44, 0x90, 0x53, 0x0A, 0xE0, 0x60,
+	0x46, 0x08, 0x55, 0xDF, 0xE7, 0x20, 0x4A, 0x1B, 0x4B, 0x90, 0x5B, 0x28, 0x1A, 0x98, 0x53, 0x00,
+	0x20, 0x08, 0x55, 0xF2, 0xE7, 0x00, 0x2C, 0x9F, 0xD1, 0x07, 0xB0, 0xF0, 0xBD, 0xF0, 0xB5, 0x10,
+	0x48, 0x89, 0xB0, 0x05, 0x78, 0x10, 0x48, 0x07, 0x78, 0x13, 0x48, 0x00, 0x1D, 0x01, 0x7F, 0x49,
+	0x07, 0x49, 0x0F, 0x03, 0x91, 
+	0x00, 0x00, 0xB3, 0x00, 0x80, 0x00, 0x7F, 0x08, 0x4A, 0xC0, 0x08, 0x02, 0x90, 0x90, 0x6C, 0x00,
+	0x29, 0x24, 0xD1, 0x40, 0x00, 0x04, 0x90, 0x00, 0x20, 0x01, 0x90, 0x2C, 0xE0, 0x2C, 0x05, 0x00,
+	0x20, 0x92, 0x08, 0x00, 0x20, 0x76, 0x02, 0x00, 0x20, 0x28, 0x01, 0x00, 0x20, 0x30, 0xE8, 0x00,
+	0x00, 0x9E, 0x00, 0x00, 0x20, 0xF0, 0xE9, 0x00, 0x00, 0x9D, 0x00, 0x00, 0x20, 0xAB, 0x00, 0x00,
+	0x20, 0xAA, 0x00, 0x00, 0x20, 0x32, 0x0B, 0x00, 0x20, 0x7C, 0xE8, 0x00, 0x00, 0xD8, 0x00, 0x00,
+	0x20, 0xD4, 0x00, 0x00, 0x20, 0xD0, 0xDC, 0x00, 0x00, 0x1C, 0x0E, 0x00, 0x20, 0x40, 0x18, 0x40,
+	0x1C, 0x04, 0x90, 0x9B, 0x49, 0x03, 0x98, 0x08, 0x5C, 0x01, 0x90, 0x03, 0x98, 0x08, 0x31, 0x80,
+	0x00, 0x40, 0x18, 0x40, 0x68, 0xC0, 0xB2, 0x00, 0x90, 0x96, 0x48, 0x00, 0x21, 0xC1, 0x80, 0x80,
+	0x78, 0x80, 0x07, 0x07, 0xD4, 
+	0x00, 0x00, 0xB4, 0x00, 0x80, 0x94, 0x48, 0x2C, 0x46, 0x01, 0x5D, 0x49, 0x1C, 0x01, 0x55, 0x64,
+	0x1E, 0xFA, 0xD1, 0x07, 0xE0, 0x90, 0x48, 0x3C, 0x46, 0x1F, 0x30, 0x01, 0x5D, 0x49, 0x1C, 0x01,
+	0x55, 0x64, 0x1E, 0xFA, 0xD1, 0x00, 0x26, 0xFB, 0xF7, 0xB6, 0xFD, 0x00, 0x28, 0x41, 0xD1, 0x1E,
+	0xE0, 0x00, 0x20, 0x19, 0xE0, 0x88, 0x4A, 0x61, 0x00, 0x7C, 0x32, 0x52, 0x5E, 0x85, 0x49, 0x64,
+	0x1C, 0x0B, 0x89, 0x9A, 0x42, 0x0F, 0xDD, 0xCA, 0x88, 0x52, 0x1C, 0xCA, 0x80, 0xCB, 0x68, 0x00,
+	0x22, 0x1A, 0x54, 0x0B, 0x69, 0x1A, 0x54, 0x4B, 0x69, 0x1A, 0x54, 0x8B, 0x69, 0x9A, 0x55, 0xCB,
+	0x69, 0x9A, 0x55, 0x09, 0x6A, 0x8A, 0x55, 0x40, 0x1C, 0xA8, 0x42, 0xE3, 0xD3, 0x76, 0x1C, 0xBE,
+	0x42, 0xDE, 0xD3, 0x20, 0xE0, 0x00, 0x20, 0x19, 0xE0, 0x77, 0x4A, 0x61, 0x00, 0x7C, 0x32, 0x52,
+	0x5E, 0x74, 0x49, 0x64, 0x1C, 
+	0x00, 0x00, 0xB5, 0x00, 0x80, 0x0B, 0x89, 0x9A, 0x42, 0x0F, 0xDD, 0xCA, 0x88, 0x52, 0x1C, 0xCA,
+	0x80, 0x4B, 0x6A, 0x00, 0x22, 0x1A, 0x54, 0x8B, 0x6A, 0x1A, 0x54, 0xCB, 0x6A, 0x1A, 0x54, 0x0B,
+	0x6B, 0x9A, 0x55, 0x4B, 0x6B, 0x9A, 0x55, 0x89, 0x6B, 0x8A, 0x55, 0x40, 0x1C, 0xA8, 0x42, 0xE3,
+	0xD3, 0x76, 0x1C, 0xBE, 0x42, 0xDE, 0xD3, 0x67, 0x48, 0x80, 0x78, 0x80, 0x07, 0x65, 0xD5, 0x00,
+	0x20, 0x5F, 0xE0, 0x64, 0x4A, 0x91, 0x69, 0x08, 0x91, 0x92, 0x6C, 0x09, 0x5C, 0x94, 0x46, 0x91,
+	0x42, 0x56, 0xD3, 0x61, 0x45, 0x0E, 0xD1, 0x01, 0x46, 0x69, 0x43, 0x00, 0x22, 0x5F, 0x4E, 0x06,
+	0xE0, 0x5D, 0x4C, 0x4B, 0x00, 0x7C, 0x34, 0xE4, 0x5A, 0x49, 0x1C, 0xF4, 0x52, 0x52, 0x1C, 0xAA,
+	0x42, 0xF6, 0xD3, 0x45, 0xE0, 0x04, 0x9A, 0x91, 0x42, 0x2A, 0xD2, 0x03, 0x99, 0x00, 0x29, 0x3F,
+	0xD0, 0x01, 0x46, 0x69, 0x43, 
+	0x00, 0x00, 0xB6, 0x00, 0x80, 0x00, 0x22, 0x1B, 0xE0, 0x53, 0x4B, 0x4C, 0x00, 0x7C, 0x33, 0x07,
+	0x94, 0x52, 0x4E, 0x1B, 0x5F, 0x34, 0x5F, 0xA6, 0x46, 0x1B, 0x1B, 0x1C, 0x1E, 0x00, 0xDA, 0x64,
+	0x42, 0x02, 0x9E, 0xB4, 0x42, 0x01, 0xDD, 0x1F, 0x2E, 0x0D, 0xD1, 0x01, 0x9C, 0x4B, 0x4E, 0x1B,
+	0x19, 0x00, 0x9C, 0x49, 0x1C, 0x63, 0x43, 0x1B, 0x12, 0x07, 0x9C, 0x73, 0x44, 0x33, 0x53, 0x52,
+	0x1C, 0xAA, 0x42, 0xE1, 0xD3, 0x1C, 0xE0, 0x08, 0x9A, 0x61, 0x46, 0x11, 0x54, 0x40, 0x1E, 0x17,
+	0xE0, 0x02, 0x46, 0x6A, 0x43, 0x00, 0x23, 0x0E, 0xE0, 0x3F, 0x4C, 0x51, 0x00, 0x7C, 0x34, 0x66,
+	0x5A, 0x3E, 0x4C, 0x52, 0x1C, 0x64, 0x5A, 0x34, 0x1B, 0x3B, 0x4E, 0x7C, 0x36, 0x74, 0x52, 0x00,
+	0x24, 0x3A, 0x4E, 0x5B, 0x1C, 0x74, 0x52, 0xAB, 0x42, 0xEE, 0xD3, 0x08, 0x9A, 0x00, 0x21, 0x11,
+	0x54, 0x40, 0x1C, 0xB8, 0x42, 
+	0x00, 0x00, 0xB7, 0x00, 0x80, 0x9D, 0xD3, 0x09, 0xB0, 0xF0, 0xBD, 0x00, 0x20, 0x5C, 0xE0, 0x31,
+	0x4A, 0xD1, 0x68, 0x06, 0x91, 0x09, 0x5C, 0x92, 0x6C, 0x05, 0x92, 0x91, 0x42, 0x53, 0xD3, 0x91,
+	0x42, 0x0D, 0xD1, 0x01, 0x46, 0x00, 0x22, 0x2D, 0x4E, 0x06, 0xE0, 0x2B, 0x4C, 0x4B, 0x00, 0x7C,
+	0x34, 0xE4, 0x5A, 0x49, 0x19, 0xF4, 0x52, 0x52, 0x1C, 0xBA, 0x42, 0xF6, 0xD3, 0x43, 0xE0, 0x04,
+	0x9A, 0x91, 0x42, 0x29, 0xD2, 0x03, 0x99, 0x00, 0x29, 0x3D, 0xD0, 0x01, 0x46, 0x00, 0x22, 0x1B,
+	0xE0, 0x21, 0x4B, 0x4C, 0x00, 0x7C, 0x33, 0x21, 0x4E, 0xA6, 0x46, 0x1B, 0x5F, 0x34, 0x5F, 0xA4,
+	0x46, 0x1B, 0x1B, 0x1C, 0x1E, 0x00, 0xDA, 0x64, 0x42, 0x02, 0x9E, 0xB4, 0x42, 0x01, 0xDD, 0x1F,
+	0x2E, 0x0D, 0xD1, 0x01, 0x9E, 0x74, 0x46, 0x9B, 0x19, 0x00, 0x9E, 0x49, 0x19, 0x73, 0x43, 0x1B,
+	0x12, 0x16, 0x4E, 0x63, 0x44, 
+	0x00, 0x00, 0xB8, 0x00, 0x80, 0x33, 0x53, 0x52, 0x1C, 0xBA, 0x42, 0xE1, 0xD3, 0x1B, 0xE0, 0x06,
+	0x9A, 0x05, 0x99, 0x11, 0x54, 0x40, 0x1E, 0x16, 0xE0, 0x02, 0x46, 0x00, 0x23, 0x0E, 0xE0, 0x0E,
+	0x4C, 0x51, 0x00, 0x0E, 0x4E, 0x7C, 0x34, 0x64, 0x5A, 0x76, 0x5A, 0x52, 0x19, 0xA6, 0x1B, 0x0A,
+	0x4C, 0x7C, 0x34, 0x66, 0x52, 0x00, 0x24, 0x09, 0x4E, 0x5B, 0x1C, 0x74, 0x52, 0xBB, 0x42, 0xEE,
+	0xD3, 0x06, 0x9A, 0x00, 0x21, 0x11, 0x54, 0x40, 0x1C, 0xA8, 0x42, 0xA0, 0xD3, 0x9B, 0xE7, 0x00,
+	0x00, 0xD0, 0xDC, 0x00, 0x00, 0x28, 0x01, 0x00, 0x20, 0x16, 0x08, 0x00, 0x20, 0x7C, 0x0B, 0x00,
+	0x20, 0x10, 0xB5, 0x06, 0xF0, 0xB5, 0xFE, 0x06, 0xF0, 0xE1, 0xFE, 0xAA, 0x48, 0x06, 0xF0, 0x0E,
+	0xFE, 0x01, 0x20, 0x06, 0xF0, 0xFE, 0xFD, 0x06, 0xF0, 0x65, 0xFE, 0xC0, 0x24, 0xA6, 0x48, 0x21,
+	0x79, 0x01, 0x70, 0x61, 0x79, 
+	0x00, 0x00, 0xB9, 0x00, 0x80, 0x41, 0x70, 0xA5, 0x48, 0x80, 0x7A, 0x00, 0x28, 0x04, 0xD0, 0x07,
+	0xF0, 0xFC, 0xF8, 0xA1, 0x49, 0x89, 0x1E, 0x08, 0x70, 0x9F, 0x48, 0x04, 0xF0, 0xF1, 0xFA, 0x04,
+	0xF0, 0xD3, 0xFA, 0xA0, 0x79, 0xC1, 0x07, 0x05, 0xD1, 0x80, 0x07, 0x01, 0xD4, 0x04, 0x20, 0x07,
+	0xE0, 0x02, 0x20, 0x05, 0xE0, 0x01, 0x21, 0x80, 0x07, 0x01, 0xD4, 0x05, 0x20, 0x00, 0xE0, 0x03,
+	0x20, 0x04, 0xF0, 0xF6, 0xFA, 0x04, 0xF0, 0x5E, 0xFA, 0x95, 0x49, 0x08, 0x68, 0xA0, 0x43, 0x08,
+	0x60, 0x92, 0x48, 0x20, 0x30, 0x00, 0x7D, 0x07, 0x22, 0x52, 0x02, 0x01, 0x28, 0x0D, 0xD0, 0x02,
+	0x28, 0x0A, 0xD1, 0x08, 0x68, 0x80, 0x23, 0x18, 0x43, 0x08, 0x60, 0x8E, 0x48, 0x81, 0x68, 0x91,
+	0x43, 0xFF, 0x31, 0xFF, 0x31, 0x02, 0x31, 0x81, 0x60, 0x10, 0xBD, 0x08, 0x68, 0x20, 0x43, 0x08,
+	0x60, 0x89, 0x49, 0x88, 0x68, 
+	0x00, 0x00, 0xBA, 0x00, 0x80, 0x90, 0x43, 0xFF, 0x30, 0xFF, 0x30, 0x02, 0x30, 0x88, 0x60, 0x10,
+	0xBD, 0x10, 0xB5, 0x06, 0xF0, 0x3D, 0xFF, 0x85, 0x4C, 0x20, 0x70, 0xC0, 0xB2, 0x06, 0xF0, 0x45,
+	0xFF, 0x20, 0x78, 0x06, 0xF0, 0x6A, 0xFF, 0x10, 0xBD, 0xF8, 0xB5, 0x06, 0xF0, 0x0B, 0xFE, 0x80,
+	0x48, 0x00, 0x25, 0x05, 0x80, 0x06, 0xF0, 0x72, 0xFC, 0x7E, 0x49, 0x01, 0x26, 0x08, 0x80, 0xB6,
+	0x07, 0xB5, 0x60, 0x01, 0x27, 0xB7, 0x61, 0xFF, 0xF7, 0xE3, 0xFF, 0x74, 0x4C, 0xA0, 0x7E, 0xC1,
+	0x07, 0x79, 0x48, 0x31, 0x68, 0x02, 0xD1, 0x01, 0x43, 0x31, 0x60, 0x06, 0xE0, 0x81, 0x43, 0x31,
+	0x60, 0xA0, 0x7E, 0x00, 0x09, 0x40, 0x00, 0x38, 0x43, 0xB0, 0x61, 0x74, 0x48, 0x00, 0x68, 0x00,
+	0x28, 0x14, 0xD0, 0x01, 0x20, 0x06, 0xF0, 0x9C, 0xFE, 0x02, 0x20, 0x70, 0x60, 0x04, 0x20, 0x00,
+	0xF0, 0x04, 0xFA, 0x02, 0x20, 
+	0x00, 0x00, 0xBB, 0x00, 0x80, 0xB0, 0x60, 0x6E, 0x49, 0x04, 0x20, 0x00, 0xF0, 0xDE, 0xF9, 0x00,
+	0x21, 0x04, 0x20, 0x00, 0xF0, 0xE1, 0xF9, 0x04, 0x20, 0x00, 0xF0, 0xE8, 0xF9, 0x69, 0x4E, 0x65,
+	0x49, 0x37, 0x70, 0x08, 0x88, 0x08, 0x22, 0x10, 0x43, 0x08, 0x80, 0x5B, 0x48, 0x80, 0x1E, 0x45,
+	0x70, 0x65, 0x48, 0x05, 0x70, 0xA0, 0x7C, 0x65, 0x4F, 0xC0, 0x08, 0xC0, 0x00, 0x38, 0x70, 0xE0,
+	0x7C, 0x63, 0x49, 0x08, 0x70, 0x20, 0x7D, 0x63, 0x49, 0x08, 0x70, 0x60, 0x7E, 0x21, 0x7E, 0x00,
+	0x02, 0x08, 0x43, 0x61, 0x49, 0x08, 0x80, 0xE0, 0x7D, 0xA1, 0x7D, 0x00, 0x02, 0x08, 0x43, 0x5F,
+	0x49, 0x08, 0x80, 0x60, 0x7C, 0x5E, 0x49, 0x08, 0x70, 0x4C, 0x48, 0x20, 0x30, 0xC0, 0x7C, 0x5D,
+	0x49, 0x08, 0x70, 0x5D, 0x48, 0x41, 0x78, 0x5D, 0x4A, 0x11, 0x70, 0x80, 0x78, 0x5C, 0x49, 0x08,
+	0x70, 0x5C, 0x48, 0xC0, 0x88, 
+	0x00, 0x00, 0xBC, 0x00, 0x80, 0x5C, 0x49, 0x08, 0x80, 0x05, 0xF0, 0xE0, 0xFE, 0x30, 0x78, 0x00,
+	0x28, 0x04, 0xD0, 0x02, 0xF0, 0x81, 0xFF, 0x01, 0x20, 0x04, 0xF0, 0xD3, 0xF8, 0x57, 0x49, 0x38,
+	0x78, 0x08, 0x70, 0x01, 0x20, 0x06, 0xF0, 0x3A, 0xFD, 0x20, 0x7C, 0x04, 0x21, 0x08, 0x40, 0x54,
+	0x4E, 0xC0, 0xB2, 0x10, 0x24, 0x20, 0x43, 0x38, 0x4F, 0x30, 0x70, 0xBF, 0x1E, 0x79, 0x78, 0x01,
+	0x20, 0x04, 0xF0, 0x64, 0xFA, 0x31, 0x78, 0x00, 0x20, 0x04, 0xF0, 0x60, 0xFA, 0x04, 0xF0, 0x1C,
+	0xFA, 0x4C, 0x48, 0x04, 0x70, 0x05, 0xF0, 0x10, 0xFA, 0x4B, 0x48, 0x05, 0x70, 0x06, 0xF0, 0x60,
+	0xF9, 0x06, 0xF0, 0x96, 0xF9, 0x47, 0x4D, 0x06, 0xF0, 0x6D, 0xFD, 0x28, 0x78, 0x00, 0x28, 0x3E,
+	0xD0, 0x10, 0x28, 0x3F, 0xD0, 0x20, 0x28, 0x01, 0xD1, 0x05, 0xF0, 0x27, 0xF8, 0x00, 0x20, 0x04,
+	0xF0, 0x49, 0xFA, 0x30, 0x70, 
+	0x00, 0x00, 0xBD, 0x00, 0x80, 0xC0, 0xB2, 0xC0, 0x07, 0x01, 0xD0, 0x00, 0xF0, 0x87, 0xF9, 0x30,
+	0x78, 0x01, 0x07, 0xE8, 0xD5, 0x30, 0x21, 0x08, 0x40, 0x28, 0x70, 0x00, 0x2C, 0x2D, 0xD0, 0x10,
+	0x2C, 0x2E, 0xD0, 0x20, 0x2C, 0x01, 0xD1, 0x05, 0xF0, 0x07, 0xF9, 0x01, 0x20, 0x06, 0xF0, 0xF6,
+	0xFC, 0x28, 0x78, 0x00, 0x28, 0x27, 0xD0, 0x10, 0x28, 0x28, 0xD0, 0x20, 0x28, 0x01, 0xD1, 0x04,
+	0xF0, 0x27, 0xFB, 0x79, 0x78, 0xEF, 0x20, 0x01, 0x40, 0x01, 0x20, 0x04, 0xF0, 0x1F, 0xFA, 0x30,
+	0x78, 0xC7, 0x21, 0x2C, 0x78, 0x08, 0x40, 0xC0, 0xB2, 0x20, 0x43, 0x30, 0x70, 0xC1, 0xB2, 0x00,
+	0x20, 0x04, 0xF0, 0x14, 0xFA, 0x06, 0xF0, 0x1C, 0xF9, 0x06, 0xF0, 0x52, 0xF9, 0xBB, 0xE7, 0x05,
+	0xF0, 0xCC, 0xFF, 0xC3, 0xE7, 0x05, 0xF0, 0x8E, 0xFA, 0xC0, 0xE7, 0x06, 0xF0, 0x61, 0xF8, 0xD4,
+	0xE7, 0x05, 0xF0, 0x8C, 0xFA, 
+	0x00, 0x00, 0xBE, 0x00, 0x80, 0xD1, 0xE7, 0x05, 0xF0, 0x17, 0xFB, 0xDA, 0xE7, 0x05, 0xF0, 0xB4,
+	0xF9, 0xD7, 0xE7, 0x00, 0x00, 0x10, 0x27, 0x00, 0x00, 0x90, 0x01, 0x00, 0x20, 0x00, 0xE6, 0x00,
+	0x00, 0x00, 0x20, 0x14, 0x40, 0x00, 0x10, 0x14, 0x40, 0x00, 0x00, 0x14, 0x40, 0xEC, 0x02, 0x00,
+	0x20, 0xB8, 0x02, 0x00, 0x20, 0xC8, 0x02, 0x00, 0x20, 0x00, 0x00, 0x80, 0x00, 0x94, 0x01, 0x00,
+	0x20, 0xB1, 0xA4, 0x00, 0x00, 0xB6, 0x02, 0x00, 0x20, 0x65, 0x02, 0x00, 0x20, 0x66, 0x02, 0x00,
+	0x20, 0x5D, 0x02, 0x00, 0x20, 0x5E, 0x02, 0x00, 0x20, 0x6E, 0x02, 0x00, 0x20, 0x70, 0x02, 0x00,
+	0x20, 0x5F, 0x02, 0x00, 0x20, 0x60, 0x02, 0x00, 0x20, 0x00, 0xE7, 0x00, 0x00, 0x61, 0x02, 0x00,
+	0x20, 0x62, 0x02, 0x00, 0x20, 0xD0, 0xE7, 0x00, 0x00, 0x76, 0x02, 0x00, 0x20, 0xDF, 0x01, 0x00,
+	0x20, 0xCC, 0x02, 0x00, 0x20, 
+	0x00, 0x00, 0xBF, 0x00, 0x80, 0xB7, 0x02, 0x00, 0x20, 0xCB, 0x02, 0x00, 0x20, 0x02, 0x48, 0x40,
+	0x68, 0x02, 0x49, 0x08, 0x61, 0x70, 0x47, 0x00, 0x00, 0xE0, 0xEA, 0x00, 0x00, 0x00, 0x00, 0x01,
+	0x40, 0xF8, 0xB5, 0x4F, 0x49, 0x0A, 0x78, 0x4F, 0x48, 0x20, 0x25, 0x24, 0x2A, 0x03, 0xD3, 0x4A,
+	0x78, 0xC2, 0x61, 0x89, 0x78, 0x1C, 0xE0, 0xCA, 0x78, 0x24, 0x2A, 0x03, 0xD3, 0x0A, 0x79, 0xC2,
+	0x61, 0x49, 0x79, 0x15, 0xE0, 0x8A, 0x79, 0x24, 0x2A, 0x03, 0xD3, 0xCA, 0x79, 0xC2, 0x61, 0x09,
+	0x7A, 0x0E, 0xE0, 0x4A, 0x7A, 0x24, 0x2A, 0x03, 0xD3, 0x8A, 0x7A, 0xC2, 0x61, 0xC9, 0x7A, 0x07,
+	0xE0, 0x0A, 0x7B, 0x00, 0x2A, 0x02, 0xD0, 0x0A, 0x7B, 0xC2, 0x61, 0x00, 0xE0, 0xC5, 0x61, 0x49,
+	0x7B, 0x01, 0x62, 0x01, 0x26, 0x3C, 0x4C, 0xB6, 0x04, 0x26, 0x60, 0x39, 0x48, 0x20, 0x30, 0x40,
+	0x7C, 0x3A, 0x4F, 0x78, 0x60, 
+	0x00, 0x00, 0xC0, 0x00, 0x80, 0x05, 0x20, 0x00, 0xF0, 0x99, 0xF8, 0x27, 0x20, 0xB8, 0x60, 0x38,
+	0x48, 0x05, 0x60, 0x37, 0x48, 0x30, 0x21, 0x80, 0x30, 0x01, 0x60, 0x10, 0x21, 0x81, 0x60, 0xC1,
+	0x60, 0x00, 0x06, 0xE0, 0x60, 0x60, 0x60, 0x26, 0x60, 0x32, 0x49, 0x40, 0x1C, 0x08, 0x60, 0x31,
+	0x49, 0x31, 0x48, 0x40, 0x31, 0x08, 0x60, 0x30, 0x48, 0x2D, 0x49, 0x0C, 0x30, 0x80, 0x39, 0x08,
+	0x60, 0xF8, 0xBD, 0xF8, 0xB5, 0x72, 0xB6, 0x00, 0x24, 0x2C, 0x4E, 0x06, 0x20, 0x60, 0x43, 0x85,
+	0x19, 0x28, 0x46, 0x07, 0xF0, 0x24, 0xFD, 0x69, 0x79, 0x2A, 0x79, 0x09, 0x02, 0x11, 0x43, 0x07,
+	0xF0, 0x1A, 0xFD, 0x64, 0x1C, 0xE4, 0xB2, 0x02, 0x2C, 0xEF, 0xD3, 0x24, 0x4F, 0x00, 0x21, 0x0C,
+	0x37, 0x3D, 0x46, 0x0A, 0x46, 0x10, 0x35, 0x90, 0x00, 0x3B, 0x58, 0x1E, 0x0A, 0xD8, 0xB2, 0x36,
+	0x02, 0x05, 0xE0, 0x4B, 0x00, 
+	0x00, 0x00, 0xC1, 0x00, 0x80, 0x5C, 0x19, 0xEB, 0x5C, 0x64, 0x78, 0xF4, 0x54, 0x49, 0x1C, 0x03,
+	0x46, 0x40, 0x1E, 0xC0, 0xB2, 0x00, 0x2B, 0xF4, 0xD1, 0x52, 0x1C, 0x04, 0x2A, 0xEB, 0xD3, 0xFF,
+	0x21, 0x17, 0x48, 0x01, 0x31, 0x01, 0x80, 0x01, 0x22, 0x82, 0x70, 0x16, 0x48, 0x02, 0x60, 0x16,
+	0x48, 0x1F, 0x22, 0x02, 0x60, 0x15, 0x4A, 0x82, 0x60, 0xC1, 0x60, 0x16, 0x48, 0x14, 0x49, 0x01,
+	0x60, 0x45, 0x21, 0x49, 0x04, 0x41, 0x60, 0x14, 0x48, 0x01, 0x78, 0x02, 0x22, 0x11, 0x43, 0x01,
+	0x70, 0x01, 0x78, 0x06, 0x22, 0x11, 0x43, 0x01, 0x70, 0xFF, 0xF7, 0x62, 0xFF, 0xF8, 0xBD, 0x00,
+	0x00, 0xC0, 0xF1, 0xFF, 0x0F, 0x00, 0xFF, 0x00, 0x40, 0x00, 0x00, 0x01, 0x40, 0x00, 0xFF, 0x01,
+	0x40, 0x00, 0x02, 0x01, 0x40, 0x00, 0x01, 0x01, 0x40, 0x26, 0x00, 0x00, 0x80, 0xFC, 0xDC, 0x00,
+	0x00, 0x00, 0x60, 0x13, 0x40, 
+	0x00, 0x00, 0xC2, 0x00, 0x80, 0x00, 0x20, 0x14, 0x40, 0x00, 0x00, 0x14, 0x40, 0x24, 0x42, 0x00,
+	0x00, 0x04, 0x00, 0x09, 0x00, 0x00, 0x50, 0x13, 0x40, 0x00, 0x70, 0x13, 0x40, 0x80, 0x1C, 0x80,
+	0x08, 0x03, 0xD0, 0x00, 0xBF, 0x40, 0x1E, 0x00, 0x46, 0xFC, 0xD1, 0x70, 0x47, 0xEF, 0xF3, 0x10,
+	0x80, 0x72, 0xB6, 0x70, 0x47, 0x80, 0xF3, 0x10, 0x88, 0x70, 0x47, 0x00, 0x00, 0x10, 0xB5, 0x25,
+	0x49, 0x09, 0x78, 0x48, 0x43, 0xFF, 0xF7, 0xEA, 0xFF, 0x10, 0xBD, 0x01, 0x22, 0x52, 0x07, 0x80,
+	0x00, 0x82, 0x18, 0x10, 0x6C, 0x11, 0x64, 0x70, 0x47, 0x82, 0x07, 0xD2, 0x0E, 0x92, 0x1D, 0x91,
+	0x40, 0x80, 0x08, 0x1D, 0x4A, 0x80, 0x00, 0x80, 0x18, 0x01, 0x60, 0x70, 0x47, 0x02, 0x07, 0x1B,
+	0x49, 0x12, 0x0F, 0x01, 0x20, 0x90, 0x40, 0x08, 0x60, 0x70, 0x47, 0x18, 0x49, 0x02, 0x07, 0x80,
+	0x31, 0x12, 0x0F, 0x01, 0x20, 
+	0x00, 0x00, 0xC3, 0x00, 0x80, 0x90, 0x40, 0x08, 0x60, 0x70, 0x47, 0x02, 0x07, 0x14, 0x49, 0x12,
+	0x0F, 0x01, 0x20, 0x90, 0x40, 0x08, 0x60, 0x70, 0x47, 0x00, 0xBE, 0x70, 0x47, 0x12, 0x49, 0x11,
+	0x48, 0xC8, 0x60, 0x70, 0x47, 0x70, 0xB5, 0x0B, 0x4D, 0x00, 0x28, 0x00, 0xD1, 0x0F, 0x48, 0x10,
+	0x49, 0x04, 0x46, 0x68, 0x60, 0x48, 0x1E, 0x20, 0x18, 0x07, 0xF0, 0x81, 0xFC, 0x7D, 0x21, 0x28,
+	0x70, 0xC9, 0x00, 0x48, 0x1E, 0x20, 0x18, 0x07, 0xF0, 0x7A, 0xFC, 0xA8, 0x60, 0xC0, 0x03, 0xE8,
+	0x60, 0x70, 0xBD, 0x00, 0x00, 0x98, 0x01, 0x00, 0x20, 0x00, 0xE4, 0x00, 0xE0, 0x00, 0xE1, 0x00,
+	0xE0, 0x80, 0xE2, 0x00, 0xE0, 0x04, 0x00, 0xFA, 0x05, 0x00, 0xED, 0x00, 0xE0, 0x00, 0x51, 0x25,
+	0x02, 0x40, 0x42, 0x0F, 0x00, 0xFE, 0xB5, 0xFF, 0x48, 0x16, 0x21, 0x00, 0x78, 0x48, 0x43, 0xFE,
+	0x49, 0x08, 0x5A, 0x00, 0x90, 
+	0x00, 0x00, 0xC4, 0x00, 0x80, 0xFD, 0x48, 0x01, 0x21, 0x00, 0x78, 0xFE, 0x4A, 0x81, 0x40, 0x8E,
+	0x46, 0xFB, 0x49, 0x12, 0x78, 0x09, 0x78, 0x51, 0x43, 0xFB, 0x4A, 0x49, 0x00, 0x12, 0x68, 0x8C,
+	0x18, 0x66, 0xE0, 0x00, 0x99, 0x72, 0x46, 0x11, 0x42, 0x5E, 0xD0, 0xF8, 0x4A, 0x41, 0x00, 0x57,
+	0x5E, 0x8A, 0x18, 0x10, 0x25, 0x55, 0x5F, 0x20, 0x21, 0x30, 0x23, 0x51, 0x5E, 0xD3, 0x5E, 0xED,
+	0x4A, 0xAC, 0x46, 0x12, 0x78, 0x16, 0x25, 0x6A, 0x43, 0xEB, 0x4D, 0x52, 0x19, 0x12, 0x18, 0x12,
+	0x79, 0x65, 0x46, 0x7D, 0x19, 0x01, 0x95, 0x6D, 0x18, 0xED, 0x1A, 0xED, 0x4E, 0xAD, 0x10, 0xB5,
+	0x42, 0x01, 0xDA, 0x35, 0x46, 0x04, 0xE0, 0xEA, 0x4E, 0xF6, 0x43, 0xB5, 0x42, 0x00, 0xDD, 0x35,
+	0x46, 0x56, 0x00, 0xA5, 0x53, 0x01, 0x9D, 0xE6, 0x4E, 0xED, 0x18, 0x6D, 0x1A, 0xAD, 0x10, 0xB5,
+	0x42, 0x01, 0xDA, 0x35, 0x46, 
+	0x00, 0x00, 0xC5, 0x00, 0x80, 0x04, 0xE0, 0xE2, 0x4E, 0xF6, 0x43, 0xB5, 0x42, 0x00, 0xDD, 0x35,
+	0x46, 0xDC, 0x4E, 0x36, 0x78, 0x96, 0x19, 0x76, 0x00, 0xA5, 0x53, 0x7D, 0x18, 0xED, 0x18, 0x66,
+	0x46, 0xAD, 0x1B, 0xDB, 0x4E, 0xAD, 0x10, 0xB5, 0x42, 0x01, 0xDA, 0x35, 0x46, 0x04, 0xE0, 0xD8,
+	0x4E, 0xF6, 0x43, 0xB5, 0x42, 0x00, 0xDD, 0x35, 0x46, 0xD2, 0x4E, 0x61, 0x44, 0x36, 0x78, 0xC9,
+	0x18, 0x76, 0x00, 0xB6, 0x18, 0x76, 0x00, 0xC9, 0x1B, 0xD1, 0x4B, 0x89, 0x10, 0xA5, 0x53, 0x99,
+	0x42, 0x02, 0xDB, 0x5B, 0x0C, 0x99, 0x42, 0x00, 0xDD, 0x19, 0x46, 0xCA, 0x4B, 0x1B, 0x78, 0x5D,
+	0x00, 0x5B, 0x19, 0x9A, 0x18, 0x52, 0x00, 0xA1, 0x52, 0x71, 0x46, 0x49, 0x00, 0x8E, 0x46, 0x40,
+	0x1C, 0xC8, 0x49, 0x09, 0x78, 0x88, 0x42, 0x94, 0xD3, 0xC7, 0x48, 0xC8, 0x49, 0x00, 0x78, 0x09,
+	0x78, 0x88, 0x42, 0x09, 0xD1, 
+	0x00, 0x00, 0xC6, 0x00, 0x80, 0xC6, 0x49, 0x08, 0x78, 0x00, 0x28, 0x05, 0xD0, 0x02, 0x28, 0x03,
+	0xD2, 0x40, 0x1C, 0x08, 0x70, 0xFC, 0xF7, 0xA0, 0xFC, 0xFE, 0xBD, 0xFE, 0xB5, 0x14, 0x25, 0xC1,
+	0x48, 0x02, 0x21, 0xC1, 0x60, 0xBC, 0x49, 0x08, 0x78, 0x40, 0x1C, 0x08, 0x70, 0xB4, 0x48, 0xB5,
+	0x49, 0x00, 0x78, 0x09, 0x78, 0x48, 0x43, 0xB4, 0x49, 0x40, 0x00, 0x09, 0x68, 0x44, 0x18, 0xBA,
+	0x48, 0x01, 0x90, 0x41, 0x69, 0x20, 0x30, 0x00, 0x90, 0x01, 0x29, 0x16, 0xD1, 0xFC, 0xF7, 0xE2,
+	0xF9, 0x00, 0x09, 0x03, 0xD0, 0x00, 0x98, 0x80, 0x7A, 0x00, 0x28, 0x0E, 0xD1, 0xB3, 0x48, 0x00,
+	0x6A, 0xB3, 0x49, 0x00, 0xB2, 0x0A, 0x68, 0x12, 0x18, 0x0A, 0x60, 0x01, 0x99, 0x89, 0x69, 0xA3,
+	0x22, 0x92, 0x00, 0x50, 0x43, 0x41, 0x43, 0x08, 0x14, 0x00, 0xE0, 0x00, 0x20, 0x84, 0x46, 0x9D,
+	0x48, 0x16, 0x21, 0x00, 0x78, 
+	0x00, 0x00, 0xC7, 0x00, 0x80, 0x48, 0x43, 0x9C, 0x49, 0x08, 0x5A, 0x01, 0x21, 0x86, 0x46, 0x9B,
+	0x48, 0x00, 0x78, 0x81, 0x40, 0x24, 0xE0, 0x72, 0x46, 0x0A, 0x42, 0x1F, 0xD0, 0xA3, 0x4B, 0x82,
+	0x00, 0xD2, 0x18, 0x12, 0x68, 0xA3, 0x4E, 0x13, 0xB2, 0x42, 0x00, 0xB2, 0x5E, 0x91, 0x4E, 0x16,
+	0x27, 0x36, 0x78, 0x7E, 0x43, 0x90, 0x4F, 0xF6, 0x19, 0x36, 0x18, 0x36, 0x79, 0x67, 0x46, 0xDB,
+	0x1B, 0x53, 0x43, 0x9A, 0x12, 0x92, 0x4B, 0x12, 0xB2, 0x9A, 0x42, 0x02, 0xDB, 0x5B, 0x0C, 0x9A,
+	0x42, 0x02, 0xDD, 0x72, 0x00, 0xA3, 0x52, 0x01, 0xE0, 0x73, 0x00, 0xE2, 0x52, 0x49, 0x00, 0x40,
+	0x1C, 0x8C, 0x4A, 0x12, 0x78, 0x90, 0x42, 0xD6, 0xD3, 0x93, 0x4C, 0x85, 0x49, 0x20, 0x78, 0x08,
+	0x70, 0x92, 0x48, 0x80, 0x49, 0x00, 0x78, 0x92, 0x4E, 0x08, 0x70, 0x31, 0x78, 0x01, 0x29, 0x19,
+	0xD1, 0x00, 0x21, 0x31, 0x70, 
+	0x00, 0x00, 0xC8, 0x00, 0x80, 0x87, 0x4F, 0x49, 0x1E, 0xF9, 0x60, 0x00, 0xF0, 0x61, 0xFE, 0x00,
+	0xF0, 0x51, 0xFE, 0x00, 0x98, 0xC0, 0x7C, 0xFC, 0xF7, 0xA3, 0xFB, 0x05, 0x20, 0xFF, 0xF7, 0xB5,
+	0xFE, 0x38, 0x68, 0x03, 0x21, 0x49, 0x07, 0x08, 0x43, 0x38, 0x60, 0x38, 0x68, 0x80, 0x00, 0x01,
+	0xD5, 0x6D, 0x1E, 0xFA, 0xD2, 0x78, 0x48, 0x79, 0x49, 0x00, 0x78, 0x09, 0x78, 0x40, 0x1C, 0x0F,
+	0x25, 0x80, 0x4F, 0x88, 0x42, 0x57, 0xD2, 0x6F, 0x48, 0x7F, 0x4A, 0x01, 0x78, 0x20, 0x78, 0x09,
+	0x18, 0x51, 0x5C, 0x89, 0x00, 0xC9, 0x19, 0x0D, 0x60, 0x40, 0x1C, 0xC0, 0xB2, 0x7B, 0x49, 0x20,
+	0x70, 0x09, 0x78, 0x88, 0x42, 0x0B, 0xD9, 0x7A, 0x48, 0x74, 0x49, 0x00, 0x78, 0x20, 0x70, 0x08,
+	0x78, 0x40, 0x1C, 0xC0, 0xB2, 0x08, 0x70, 0xFC, 0xF7, 0xAD, 0xFB, 0x01, 0x20, 0x30, 0x70, 0x01,
+	0x98, 0x40, 0x69, 0x00, 0x28, 
+	0x00, 0x00, 0xC9, 0x00, 0x80, 0x1C, 0xD0, 0x73, 0x48, 0x6F, 0x49, 0x02, 0x78, 0x89, 0x5C, 0x3A,
+	0x46, 0x89, 0x00, 0xC9, 0x19, 0x0D, 0x60, 0x70, 0x49, 0x23, 0x78, 0x09, 0x78, 0x49, 0x08, 0x99,
+	0x42, 0x04, 0xD9, 0x61, 0x49, 0x40, 0x39, 0x49, 0x6A, 0x49, 0x1E, 0x01, 0xE0, 0x55, 0x49, 0x09,
+	0x78, 0x01, 0x70, 0x65, 0x4B, 0x00, 0x78, 0x0C, 0x21, 0x18, 0x5C, 0x80, 0x00, 0x80, 0x18, 0x01,
+	0x60, 0x50, 0x48, 0x61, 0x4B, 0x02, 0x78, 0x20, 0x78, 0x01, 0x21, 0x12, 0x18, 0x9A, 0x5C, 0x92,
+	0x00, 0xD2, 0x19, 0x11, 0x60, 0x60, 0x49, 0x59, 0x4A, 0x09, 0x78, 0x12, 0x78, 0x51, 0x43, 0x08,
+	0x18, 0xFC, 0xF7, 0x2A, 0xFB, 0x30, 0x78, 0x01, 0x28, 0x2D, 0xD0, 0x4E, 0x49, 0x08, 0x68, 0x03,
+	0x22, 0x52, 0x07, 0x10, 0x43, 0x08, 0x60, 0x48, 0x48, 0x48, 0x49, 0x00, 0x78, 0x09, 0x78, 0x88,
+	0x42, 0x26, 0xD1, 0x40, 0x48, 
+	0x00, 0x00, 0xCA, 0x00, 0x80, 0x3E, 0x46, 0x01, 0x78, 0x20, 0x78, 0x4F, 0x4C, 0x08, 0x18, 0x20,
+	0x5C, 0x80, 0x00, 0xC0, 0x19, 0x05, 0x60, 0x43, 0x48, 0x01, 0x69, 0x02, 0x22, 0x91, 0x43, 0x01,
+	0x61, 0x05, 0x20, 0xFF, 0xF7, 0x32, 0xFE, 0x4B, 0x48, 0x00, 0x78, 0x20, 0x5C, 0x80, 0x00, 0x80,
+	0x19, 0x05, 0x60, 0x3B, 0x49, 0x08, 0x78, 0x00, 0x28, 0x06, 0xD0, 0x02, 0x28, 0x04, 0xD2, 0x40,
+	0x1C, 0x08, 0x70, 0xFC, 0xF7, 0x89, 0xFB, 0xFE, 0xBD, 0x44, 0x49, 0x01, 0x20, 0x08, 0x70, 0xFE,
+	0xBD, 0x34, 0x49, 0x08, 0x68, 0x8A, 0x03, 0x10, 0x43, 0x08, 0x60, 0xFE, 0xBD, 0x10, 0xB5, 0x3A,
+	0x4B, 0x0F, 0x21, 0x1A, 0x5C, 0x94, 0x00, 0x37, 0x4A, 0xA4, 0x18, 0x21, 0x60, 0x18, 0x18, 0x43,
+	0x78, 0x9B, 0x00, 0x9B, 0x18, 0x19, 0x60, 0x83, 0x78, 0x9B, 0x00, 0x9B, 0x18, 0x19, 0x60, 0xC0,
+	0x78, 0x80, 0x00, 0x80, 0x18, 
+	0x00, 0x00, 0xCB, 0x00, 0x80, 0x01, 0x60, 0x10, 0xBD, 0x70, 0xB5, 0x2F, 0x4B, 0x89, 0x00, 0x1A,
+	0x5C, 0x33, 0x4C, 0x96, 0x00, 0x2B, 0x4A, 0x65, 0x5C, 0xB6, 0x18, 0x35, 0x60, 0x18, 0x18, 0x43,
+	0x78, 0x09, 0x19, 0x9B, 0x00, 0x4C, 0x78, 0x9B, 0x18, 0x1C, 0x60, 0x84, 0x78, 0x8B, 0x78, 0xA4,
+	0x00, 0xA4, 0x18, 0x23, 0x60, 0xC0, 0x78, 0xC9, 0x78, 0x80, 0x00, 0x80, 0x18, 0x01, 0x60, 0x70,
+	0xBD, 0xFE, 0xB5, 0x14, 0x24, 0x17, 0x48, 0x02, 0x21, 0xC1, 0x60, 0x13, 0x49, 0x08, 0x78, 0x40,
+	0x1C, 0x08, 0x70, 0x24, 0x48, 0x0D, 0x49, 0x00, 0x78, 0x00, 0x01, 0x45, 0x18, 0x12, 0x48, 0x02,
+	0x90, 0x41, 0x69, 0x20, 0x30, 0x11, 0x4E, 0x01, 0x90, 0x01, 0x29, 0x50, 0xD1, 0xFC, 0xF7, 0x92,
+	0xF8, 0x00, 0x09, 0x39, 0xE0, 0xA1, 0x00, 0x00, 0x20, 0x00, 0xEC, 0x00, 0x00, 0xB5, 0x01, 0x00,
+	0x20, 0xA3, 0x00, 0x00, 0x20, 
+	0x00, 0x00, 0xCC, 0x00, 0x80, 0x9E, 0x00, 0x00, 0x20, 0xD4, 0x00, 0x00, 0x20, 0x36, 0x03, 0x00,
+	0x20, 0x00, 0x80, 0xFF, 0xFF, 0xB6, 0x01, 0x00, 0x20, 0xA6, 0x00, 0x00, 0x20, 0xA9, 0x00, 0x00,
+	0x20, 0xB4, 0x01, 0x00, 0x20, 0x00, 0x00, 0x11, 0x40, 0x30, 0xEA, 0x00, 0x00, 0x00, 0x02, 0x11,
+	0x40, 0xD0, 0x00, 0x00, 0x20, 0x76, 0x03, 0x00, 0x20, 0xA4, 0x00, 0x00, 0x20, 0xA2, 0x00, 0x00,
+	0x20, 0xA8, 0x01, 0x00, 0x20, 0x00, 0x04, 0x11, 0x40, 0x00, 0xEB, 0x00, 0x00, 0xAD, 0x00, 0x00,
+	0x20, 0xAC, 0x00, 0x00, 0x20, 0xA5, 0x00, 0x00, 0x20, 0x9D, 0x00, 0x00, 0x20, 0xAE, 0x00, 0x00,
+	0x20, 0xA8, 0xDC, 0x00, 0x00, 0xA8, 0x00, 0x00, 0x20, 0x03, 0xD0, 0x01, 0x98, 0x80, 0x7A, 0x00,
+	0x28, 0x0D, 0xD1, 0x30, 0x6A, 0xFA, 0x49, 0x00, 0xB2, 0x0A, 0x68, 0x12, 0x18, 0x0A, 0x60, 0x02,
+	0x99, 0x89, 0x69, 0xA3, 0x22, 
+	0x00, 0x00, 0xCD, 0x00, 0x80, 0x92, 0x00, 0x50, 0x43, 0x41, 0x43, 0x09, 0x14, 0x00, 0xE0, 0x00,
+	0x21, 0xF4, 0x48, 0xF5, 0x4F, 0x00, 0x78, 0x0B, 0xE0, 0xF4, 0x4B, 0x82, 0x00, 0xD2, 0x18, 0x12,
+	0x68, 0x46, 0x00, 0x13, 0xB2, 0xBA, 0x5F, 0x5B, 0x1A, 0x53, 0x43, 0x9A, 0x12, 0xAA, 0x53, 0x40,
+	0x1C, 0xEF, 0x4A, 0x12, 0x78, 0x90, 0x42, 0xEF, 0xD3, 0xEE, 0x48, 0xEF, 0x4D, 0x00, 0x78, 0x01,
+	0x28, 0x1B, 0xD1, 0xEC, 0x49, 0x00, 0x20, 0x08, 0x70, 0xEC, 0x4E, 0x40, 0x1E, 0xF0, 0x60, 0x28,
+	0x78, 0x00, 0xF0, 0xFE, 0xFC, 0x00, 0xF0, 0xEE, 0xFC, 0x01, 0x98, 0xC0, 0x7C, 0xFC, 0xF7, 0x40,
+	0xFA, 0x05, 0x20, 0xFF, 0xF7, 0x52, 0xFD, 0x30, 0x68, 0x03, 0x21, 0x49, 0x07, 0x08, 0x43, 0x30,
+	0x60, 0x30, 0x68, 0x80, 0x00, 0x01, 0xD5, 0x64, 0x1E, 0xFA, 0xD2, 0xE1, 0x48, 0xE1, 0x4C, 0x00,
+	0x78, 0x21, 0x78, 0xE1, 0x4E, 
+	0x00, 0x00, 0xCE, 0x00, 0x80, 0x40, 0x18, 0x00, 0x90, 0x30, 0x78, 0xE0, 0x4F, 0x00, 0x28, 0x20,
+	0xD0, 0x01, 0x28, 0x2E, 0xD0, 0x02, 0x28, 0xDE, 0x48, 0x00, 0x78, 0x7B, 0xD1, 0xDD, 0x49, 0x40,
+	0x1C, 0x09, 0x78, 0x88, 0x42, 0x37, 0xD2, 0xDC, 0x48, 0xDC, 0x49, 0x00, 0x78, 0x00, 0x1D, 0xC0,
+	0xB2, 0x20, 0x70, 0x09, 0x78, 0x88, 0x42, 0x31, 0xD9, 0xD9, 0x48, 0x00, 0x78, 0x20, 0x70, 0x28,
+	0x78, 0x40, 0x1C, 0xC0, 0xB2, 0x28, 0x70, 0xFC, 0xF7, 0x45, 0xFA, 0xCA, 0x48, 0x01, 0x21, 0x01,
+	0x70, 0x29, 0xE0, 0x02, 0x21, 0x00, 0x98, 0xFF, 0xF7, 0x17, 0xFF, 0x38, 0x78, 0x29, 0x78, 0xC0,
+	0x1C, 0x80, 0x08, 0x80, 0x00, 0x48, 0x43, 0x21, 0x78, 0xC9, 0x1C, 0x89, 0x08, 0x89, 0x00, 0x89,
+	0x1C, 0x0E, 0xE0, 0x03, 0x21, 0x00, 0x98, 0xFF, 0xF7, 0x07, 0xFF, 0x38, 0x78, 0x29, 0x78, 0xC0,
+	0x1C, 0x80, 0x08, 0x80, 0x00, 
+	0x00, 0x00, 0xCF, 0x00, 0x80, 0x48, 0x43, 0x21, 0x78, 0xC9, 0x1C, 0x89, 0x08, 0x89, 0x00, 0xC9,
+	0x1C, 0x40, 0x18, 0xFC, 0xF7, 0xD1, 0xF9, 0x30, 0x78, 0x40, 0x1C, 0x5B, 0xE0, 0xC0, 0x1C, 0x88,
+	0x42, 0x01, 0xD9, 0xC9, 0x1E, 0x21, 0x70, 0x00, 0x98, 0xFF, 0xF7, 0xD8, 0xFE, 0x02, 0x98, 0x40,
+	0x69, 0x00, 0x28, 0x1B, 0xD0, 0xBC, 0x48, 0xBB, 0x4A, 0x03, 0x78, 0x0F, 0x21, 0xD2, 0x5C, 0xBB,
+	0x4B, 0x92, 0x00, 0xD2, 0x18, 0x11, 0x60, 0x39, 0x78, 0x22, 0x78, 0x49, 0x08, 0x91, 0x42, 0x03,
+	0xD9, 0xB7, 0x49, 0x49, 0x6A, 0x49, 0x1E, 0x01, 0xE0, 0xA9, 0x49, 0x09, 0x78, 0x01, 0x70, 0xB1,
+	0x4A, 0x00, 0x78, 0x0C, 0x21, 0x10, 0x5C, 0x82, 0x00, 0xD0, 0x18, 0x01, 0x60, 0xA4, 0x48, 0x21,
+	0x78, 0x00, 0x78, 0x40, 0x18, 0x00, 0x21, 0x00, 0x90, 0xFF, 0xF7, 0xC6, 0xFE, 0x38, 0x78, 0x29,
+	0x78, 0xC0, 0x1C, 0x80, 0x08, 
+	0x00, 0x00, 0xD0, 0x00, 0x80, 0x80, 0x00, 0x48, 0x43, 0x21, 0x78, 0xC9, 0x1C, 0x89, 0x08, 0x89,
+	0x00, 0xBE, 0xE7, 0xFF, 0xE7, 0x9F, 0x49, 0x40, 0x1C, 0x09, 0x78, 0x88, 0x42, 0x11, 0xD2, 0x01,
+	0x21, 0x00, 0x98, 0xFF, 0xF7, 0xB1, 0xFE, 0x38, 0x78, 0xC0, 0x1C, 0x81, 0x08, 0x28, 0x78, 0x89,
+	0x00, 0x41, 0x43, 0x20, 0x78, 0xC0, 0x1C, 0x80, 0x08, 0x80, 0x00, 0x40, 0x1C, 0x08, 0x18, 0xFC,
+	0xF7, 0x7B, 0xF9, 0xFF, 0xF7, 0xD7, 0xFC, 0x9B, 0x49, 0x28, 0x78, 0x08, 0x70, 0x92, 0x48, 0x21,
+	0x78, 0x01, 0x70, 0x00, 0x20, 0x30, 0x70, 0x8E, 0x48, 0x8E, 0x49, 0x00, 0x78, 0x09, 0x78, 0x42,
+	0x1C, 0x8A, 0x42, 0x09, 0xD2, 0x83, 0x4A, 0x12, 0x78, 0x01, 0x2A, 0x24, 0xD0, 0x83, 0x4A, 0x13,
+	0x68, 0x03, 0x24, 0x64, 0x07, 0x23, 0x43, 0x13, 0x60, 0x88, 0x42, 0x1D, 0xD1, 0x00, 0x98, 0xFF,
+	0xF7, 0x6D, 0xFE, 0x89, 0x4A, 
+	0x00, 0x00, 0xD1, 0x00, 0x80, 0x87, 0x49, 0x12, 0x78, 0x0F, 0x20, 0x89, 0x5C, 0x87, 0x4A, 0x89,
+	0x00, 0x89, 0x18, 0x08, 0x60, 0x79, 0x49, 0x08, 0x69, 0x02, 0x22, 0x90, 0x43, 0x08, 0x61, 0x05,
+	0x20, 0xFF, 0xF7, 0x73, 0xFC, 0x84, 0x48, 0x00, 0x78, 0x00, 0x28, 0x01, 0xD0, 0x02, 0x28, 0x02,
+	0xD3, 0x82, 0x49, 0x01, 0x20, 0x08, 0x70, 0xFE, 0xBD, 0x70, 0x49, 0x08, 0x68, 0x8A, 0x03, 0x10,
+	0x43, 0x08, 0x60, 0xFE, 0xBD, 0xF8, 0xB5, 0x72, 0x49, 0x7A, 0x4D, 0x08, 0x78, 0x78, 0x4F, 0x40,
+	0x1C, 0x08, 0x70, 0x7B, 0x49, 0x28, 0x78, 0x09, 0x68, 0x00, 0x01, 0x44, 0x18, 0x40, 0x37, 0x78,
+	0x69, 0x62, 0x4E, 0x01, 0x28, 0x15, 0xD1, 0xFB, 0xF7, 0x15, 0xFF, 0x00, 0x09, 0x04, 0xD0, 0x38,
+	0x46, 0x20, 0x30, 0x80, 0x7A, 0x00, 0x28, 0x0C, 0xD1, 0x30, 0x6A, 0x59, 0x49, 0x00, 0xB2, 0x0A,
+	0x68, 0x12, 0x18, 0x0A, 0x60, 
+	0x00, 0x00, 0xD2, 0x00, 0x80, 0xB9, 0x69, 0xA3, 0x22, 0x92, 0x00, 0x50, 0x43, 0x41, 0x43, 0x09,
+	0x14, 0x00, 0xE0, 0x00, 0x21, 0x53, 0x48, 0x6B, 0x4B, 0x00, 0x78, 0x0B, 0xE0, 0x82, 0x00, 0x92,
+	0x19, 0x12, 0x68, 0x00, 0x27, 0x12, 0xB2, 0xDF, 0x5F, 0x52, 0x1A, 0x7A, 0x43, 0x12, 0x13, 0x47,
+	0x00, 0xE2, 0x53, 0x40, 0x1C, 0x4E, 0x4A, 0x12, 0x78, 0x90, 0x42, 0xEF, 0xD3, 0x28, 0x78, 0x00,
+	0x21, 0x40, 0x1C, 0xC0, 0xB2, 0x4D, 0x4C, 0x28, 0x70, 0xC9, 0x43, 0xE1, 0x60, 0x51, 0x49, 0x09,
+	0x78, 0x88, 0x42, 0x0F, 0xD2, 0x00, 0xF0, 0xBC, 0xFB, 0x00, 0xF0, 0xAC, 0xFB, 0x28, 0x78, 0xFC,
+	0xF7, 0x39, 0xF9, 0x28, 0x78, 0xFC, 0xF7, 0xE8, 0xF8, 0x20, 0x68, 0x03, 0x21, 0x49, 0x07, 0x08,
+	0x43, 0x20, 0x60, 0xF8, 0xBD, 0x20, 0x69, 0x02, 0x21, 0x88, 0x43, 0x20, 0x61, 0x05, 0x20, 0xFF,
+	0xF7, 0x04, 0xFC, 0x4D, 0x49, 
+	0x00, 0x00, 0xD3, 0x00, 0x80, 0x50, 0x4B, 0x08, 0x78, 0x00, 0x28, 0x0C, 0xD0, 0x02, 0x28, 0x0A,
+	0xD2, 0x40, 0x1C, 0x08, 0x70, 0x18, 0x78, 0x01, 0x28, 0x02, 0xD1, 0xFC, 0xF7, 0x53, 0xFA, 0xF8,
+	0xBD, 0xFC, 0xF7, 0x3F, 0xFA, 0xF8, 0xBD, 0x49, 0x4A, 0x14, 0x78, 0x01, 0x22, 0x03, 0x2C, 0x06,
+	0xD1, 0x1B, 0x78, 0x01, 0x2B, 0x03, 0xD1, 0x00, 0x28, 0xF2, 0xD0, 0x0A, 0x70, 0xF0, 0xE7, 0x3F,
+	0x48, 0x02, 0x70, 0x43, 0x48, 0x00, 0x68, 0x80, 0x47, 0xF8, 0xBD, 0xF0, 0xB5, 0x2B, 0x4A, 0x97,
+	0xB0, 0x02, 0x20, 0xD0, 0x60, 0x2E, 0x49, 0x08, 0x78, 0x40, 0x1C, 0xC0, 0xB2, 0x08, 0x70, 0x16,
+	0x90, 0x26, 0x48, 0x40, 0x30, 0x80, 0x69, 0x00, 0x01, 0x01, 0xD5, 0x3A, 0x48, 0x00, 0xE0, 0x3A,
+	0x48, 0x0E, 0x90, 0x22, 0x48, 0x80, 0x68, 0x1B, 0x4A, 0x00, 0x0A, 0x0D, 0x90, 0x37, 0x48, 0x01,
+	0x88, 0x00, 0x20, 0x02, 0x90, 
+	0x00, 0x00, 0xD4, 0x00, 0x80, 0x2C, 0x48, 0x00, 0x78, 0x15, 0x90, 0x15, 0x78, 0x01, 0x22, 0xAA,
+	0x40, 0x94, 0x46, 0x17, 0x4A, 0x00, 0x28, 0x14, 0x78, 0x0C, 0xD0, 0x63, 0x46, 0x00, 0x22, 0x28,
+	0x46, 0x05, 0xE0, 0x0E, 0x46, 0x1E, 0x42, 0x01, 0xD0, 0x52, 0x1C, 0x5B, 0x00, 0x40, 0x1C, 0xA0,
+	0x42, 0xF7, 0xD3, 0x01, 0xE0, 0x2A, 0x48, 0x02, 0x78, 0x16, 0x48, 0x16, 0x9B, 0x00, 0x78, 0x14,
+	0x90, 0x1B, 0x48, 0x60, 0x30, 0x13, 0x90, 0x01, 0x2B, 0x7E, 0xD1, 0x00, 0x20, 0x08, 0x90, 0x0A,
+	0x90, 0x60, 0x46, 0x0B, 0x90, 0x00, 0x20, 0x10, 0x90, 0x03, 0x95, 0x28, 0x46, 0x6D, 0xE0, 0x00,
+	0x00, 0xD0, 0x00, 0x00, 0x20, 0xB5, 0x01, 0x00, 0x20, 0x76, 0x03, 0x00, 0x20, 0x00, 0x02, 0x11,
+	0x40, 0xB6, 0x01, 0x00, 0x20, 0xA8, 0x01, 0x00, 0x20, 0xA2, 0x00, 0x00, 0x20, 0x00, 0x00, 0x11,
+	0x40, 0x9E, 0x00, 0x00, 0x20, 
+	0x00, 0x00, 0xD5, 0x00, 0x80, 0xA4, 0x00, 0x00, 0x20, 0xA8, 0x00, 0x00, 0x20, 0x9D, 0x00, 0x00,
+	0x20, 0xA6, 0x00, 0x00, 0x20, 0xA9, 0x00, 0x00, 0x20, 0xA3, 0x00, 0x00, 0x20, 0xAD, 0x00, 0x00,
+	0x20, 0xAC, 0x00, 0x00, 0x20, 0x00, 0xEB, 0x00, 0x00, 0xA5, 0x00, 0x00, 0x20, 0x00, 0x04, 0x11,
+	0x40, 0xF0, 0xE9, 0x00, 0x00, 0xA1, 0x00, 0x00, 0x20, 0xB4, 0x01, 0x00, 0x20, 0xAE, 0x00, 0x00,
+	0x20, 0xD8, 0x00, 0x00, 0x20, 0xC0, 0x00, 0x00, 0x20, 0xB8, 0x01, 0x00, 0x20, 0xB7, 0x01, 0x00,
+	0x20, 0xCC, 0x00, 0x00, 0x20, 0x00, 0x12, 0x11, 0x40, 0x00, 0x10, 0x11, 0x40, 0xC6, 0x00, 0x00,
+	0x20, 0xAF, 0x00, 0x00, 0x20, 0x0B, 0x98, 0x01, 0x42, 0x21, 0xD0, 0x00, 0x26, 0x33, 0x46, 0x11,
+	0xE0, 0x18, 0x46, 0x10, 0x9F, 0x50, 0x43, 0xC0, 0x19, 0x0E, 0x9F, 0x80, 0x00, 0x38, 0x58, 0x00,
+	0x04, 0x80, 0x14, 0x01, 0xD5, 
+	0x00, 0x00, 0xD6, 0x00, 0x80, 0x40, 0x42, 0x00, 0xB2, 0x0A, 0x9F, 0x36, 0x18, 0x87, 0x42, 0x00,
+	0xDA, 0x0A, 0x90, 0x5B, 0x1C, 0x0D, 0x98, 0x83, 0x42, 0xEA, 0xD3, 0x08, 0x98, 0x86, 0x42, 0x03,
+	0xDD, 0x08, 0x96, 0xFA, 0x4B, 0x03, 0x98, 0x18, 0x70, 0x10, 0x98, 0x40, 0x1C, 0x10, 0x90, 0x0B,
+	0x98, 0x40, 0x00, 0x0B, 0x90, 0x03, 0x98, 0x40, 0x1C, 0x03, 0x90, 0xA0, 0x42, 0xD2, 0xD3, 0xF4,
+	0x48, 0x0A, 0x9B, 0x00, 0x78, 0x98, 0x42, 0x00, 0xE0, 0x07, 0xE1, 0x02, 0xDA, 0x18, 0x46, 0xF0,
+	0x4B, 0x18, 0x70, 0xF0, 0x48, 0x08, 0x9B, 0x06, 0x68, 0xEF, 0x48, 0xB3, 0x42, 0x07, 0x78, 0xEF,
+	0x48, 0x07, 0xDD, 0x43, 0x6B, 0xBB, 0x42, 0x04, 0xD9, 0xEA, 0x4E, 0x08, 0x9B, 0x33, 0x60, 0xEC,
+	0x4B, 0x1F, 0x70, 0xE9, 0x4E, 0x7F, 0x1C, 0xFB, 0xB2, 0x33, 0x70, 0x46, 0x6B, 0x9E, 0x42, 0x05,
+	0xD9, 0xE8, 0x49, 0x08, 0x69, 
+	0x00, 0x00, 0xD7, 0x00, 0x80, 0x02, 0x22, 0x90, 0x43, 0x08, 0x61, 0x0D, 0xE0, 0x46, 0x6B, 0x9E,
+	0x42, 0x10, 0xD1, 0x40, 0x6B, 0xE2, 0x4B, 0x40, 0x1E, 0x1B, 0x78, 0x98, 0x42, 0x0A, 0xD0, 0xE1,
+	0x48, 0x01, 0x69, 0x02, 0x22, 0x91, 0x43, 0x01, 0x61, 0x05, 0x20, 0xFF, 0xF7, 0xEE, 0xFA, 0xDE,
+	0x48, 0x00, 0x78, 0xBA, 0xE0, 0x13, 0x98, 0x06, 0x89, 0xD5, 0x48, 0xDC, 0x4F, 0x03, 0x78, 0x38,
+	0x68, 0x9E, 0x42, 0x7E, 0xD2, 0x83, 0x42, 0x7C, 0xDD, 0x3B, 0x60, 0xD9, 0x4B, 0x01, 0x20, 0x18,
+	0x70, 0x00, 0x20, 0x08, 0x90, 0x01, 0x90, 0x80, 0xE0, 0x60, 0x46, 0x0B, 0x90, 0x00, 0x20, 0x09,
+	0x90, 0x2B, 0x46, 0x10, 0x90, 0x29, 0xE0, 0x0B, 0x98, 0x01, 0x42, 0x22, 0xD0, 0x0F, 0x98, 0x10,
+	0x9E, 0x50, 0x43, 0x80, 0x19, 0x0E, 0x9E, 0x80, 0x00, 0x30, 0x58, 0xC4, 0x4E, 0x00, 0xB2, 0x36,
+	0x78, 0xB3, 0x42, 0x09, 0xD1, 
+	0x00, 0x00, 0xD8, 0x00, 0x80, 0x06, 0x46, 0xFF, 0x36, 0xCA, 0x4F, 0x91, 0x36, 0xBE, 0x42, 0x03,
+	0xD3, 0xC9, 0x4F, 0x3E, 0x88, 0x76, 0x1C, 0x3E, 0x80, 0x5E, 0x00, 0x04, 0xAF, 0xB8, 0x53, 0x46,
+	0x42, 0x00, 0x28, 0x00, 0xDB, 0x06, 0x46, 0x09, 0x98, 0x30, 0x18, 0x09, 0x90, 0x10, 0x98, 0x40,
+	0x1C, 0x10, 0x90, 0x0B, 0x98, 0x40, 0x00, 0x5B, 0x1C, 0x0B, 0x90, 0xA3, 0x42, 0xD3, 0xD3, 0xBF,
+	0x4B, 0x50, 0x00, 0x18, 0x5E, 0x09, 0x9B, 0x58, 0x43, 0x00, 0x12, 0x09, 0x90, 0x00, 0x20, 0x0A,
+	0x90, 0x0C, 0x90, 0x60, 0x46, 0x09, 0x9B, 0x0B, 0x90, 0x28, 0x46, 0x5F, 0x42, 0x15, 0xE0, 0x0B,
+	0x9B, 0x19, 0x42, 0x0E, 0xD0, 0x43, 0x00, 0x04, 0xAE, 0xF3, 0x5E, 0xBB, 0x42, 0x09, 0xDB, 0x09,
+	0x9E, 0xB3, 0x42, 0x06, 0xDC, 0x0C, 0x9E, 0x9B, 0x19, 0x1B, 0xB2, 0x0C, 0x93, 0x0A, 0x9B, 0x5B,
+	0x1C, 0x0A, 0x93, 0x0B, 0x9B, 
+	0x00, 0x00, 0xD9, 0x00, 0x80, 0x5B, 0x00, 0x40, 0x1C, 0x0B, 0x93, 0xA0, 0x42, 0xE7, 0xD3, 0x0A,
+	0x98, 0xAA, 0x4B, 0x40, 0x00, 0x18, 0x5E, 0x0C, 0x9B, 0x04, 0xAE, 0x58, 0x43, 0x9B, 0x4B, 0x00,
+	0x12, 0x1B, 0x78, 0x5B, 0x00, 0xF3, 0x5A, 0x18, 0x1A, 0x03, 0xB2, 0x58, 0x42, 0x00, 0x2B, 0x00,
+	0xDB, 0x18, 0x46, 0xFF, 0x26, 0x00, 0xB2, 0xFD, 0x36, 0xB0, 0x42, 0x00, 0xDD, 0x30, 0x46, 0x02,
+	0x9E, 0x00, 0xE0, 0x1F, 0xE0, 0x86, 0x42, 0x00, 0xDA, 0x02, 0x90, 0x01, 0x9E, 0x30, 0x18, 0x01,
+	0x90, 0x08, 0x98, 0xC0, 0x18, 0x08, 0x90, 0x0F, 0x98, 0x40, 0x1C, 0x0D, 0x9B, 0x0F, 0x90, 0x98,
+	0x42, 0x00, 0xD2, 0x79, 0xE7, 0x96, 0x49, 0x02, 0x98, 0x48, 0x60, 0x01, 0x98, 0x88, 0x60, 0x08,
+	0x98, 0x00, 0x28, 0x00, 0xDA, 0x40, 0x42, 0x93, 0x49, 0x08, 0x60, 0x8A, 0x49, 0x08, 0x68, 0x03,
+	0x22, 0x52, 0x07, 0x76, 0xE1, 
+	0x00, 0x00, 0xDA, 0x00, 0x80, 0x87, 0x4B, 0x19, 0x69, 0x02, 0x24, 0xA1, 0x43, 0x19, 0x61, 0x15,
+	0x99, 0x8D, 0x4B, 0x00, 0x29, 0x0C, 0xD0, 0x02, 0x29, 0x0A, 0xD2, 0x48, 0x1C, 0x18, 0x70, 0x7E,
+	0x48, 0x00, 0x21, 0x01, 0x70, 0x7B, 0x48, 0x01, 0x60, 0x14, 0x98, 0xFC, 0xF7, 0xA1, 0xF8, 0x62,
+	0xE1, 0x00, 0x28, 0x0E, 0xD1, 0x85, 0x49, 0x80, 0x4C, 0x08, 0x70, 0x85, 0x49, 0x08, 0x70, 0x85,
+	0x49, 0x08, 0x70, 0x0D, 0x99, 0x20, 0x88, 0x51, 0x43, 0x64, 0x22, 0x50, 0x43, 0x06, 0xF0, 0xB7,
+	0xFE, 0x20, 0x80, 0x81, 0x49, 0x01, 0x20, 0x08, 0x70, 0x4D, 0xE1, 0x00, 0x20, 0x08, 0x90, 0x01,
+	0x90, 0x0F, 0x90, 0x6A, 0x48, 0x00, 0x78, 0x12, 0x90, 0x0F, 0x98, 0x7D, 0xE0, 0x60, 0x46, 0x0B,
+	0x90, 0x00, 0x20, 0x09, 0x90, 0x2B, 0x46, 0x10, 0x90, 0x28, 0xE0, 0x0B, 0x98, 0x01, 0x42, 0x21,
+	0xD0, 0x0F, 0x98, 0x10, 0x9E, 
+	0x00, 0x00, 0xDB, 0x00, 0x80, 0x50, 0x43, 0x80, 0x19, 0x0E, 0x9E, 0x80, 0x00, 0x30, 0x58, 0x12,
+	0x9E, 0x00, 0xB2, 0xB3, 0x42, 0x09, 0xD1, 0x06, 0x46, 0xFF, 0x36, 0x66, 0x4F, 0x91, 0x36, 0xBE,
+	0x42, 0x03, 0xD3, 0x65, 0x4F, 0x3E, 0x88, 0x76, 0x1C, 0x3E, 0x80, 0x5E, 0x00, 0x04, 0xAF, 0xB8,
+	0x53, 0x46, 0x42, 0x00, 0x28, 0x00, 0xDB, 0x06, 0x46, 0x09, 0x98, 0x30, 0x18, 0x09, 0x90, 0x10,
+	0x98, 0x40, 0x1C, 0x10, 0x90, 0x0B, 0x98, 0x40, 0x00, 0x5B, 0x1C, 0x0B, 0x90, 0xA3, 0x42, 0xD4,
+	0xD3, 0x5A, 0x4B, 0x50, 0x00, 0x18, 0x5E, 0x09, 0x9B, 0x58, 0x43, 0x00, 0x12, 0x09, 0x90, 0x00,
+	0x20, 0x0A, 0x90, 0x0C, 0x90, 0x60, 0x46, 0x09, 0x9B, 0x0B, 0x90, 0x28, 0x46, 0x5F, 0x42, 0x15,
+	0xE0, 0x0B, 0x9B, 0x19, 0x42, 0x0E, 0xD0, 0x43, 0x00, 0x04, 0xAE, 0xF3, 0x5E, 0xBB, 0x42, 0x09,
+	0xDB, 0x09, 0x9E, 0xB3, 0x42, 
+	0x00, 0x00, 0xDC, 0x00, 0x80, 0x06, 0xDC, 0x0C, 0x9E, 0x9B, 0x19, 0x1B, 0xB2, 0x0C, 0x93, 0x0A,
+	0x9B, 0x5B, 0x1C, 0x0A, 0x93, 0x0B, 0x9B, 0x5B, 0x00, 0x40, 0x1C, 0x0B, 0x93, 0xA0, 0x42, 0xE7,
+	0xD3, 0x0A, 0x98, 0x46, 0x4B, 0x40, 0x00, 0x18, 0x5E, 0x0C, 0x9B, 0x04, 0xAE, 0x58, 0x43, 0x12,
+	0x9B, 0x00, 0x12, 0x5B, 0x00, 0xF3, 0x5A, 0x18, 0x1A, 0x03, 0xB2, 0x58, 0x42, 0x00, 0x2B, 0x00,
+	0xDB, 0x18, 0x46, 0xFF, 0x26, 0x00, 0xB2, 0xFD, 0x36, 0xB0, 0x42, 0x00, 0xDD, 0x30, 0x46, 0x02,
+	0x9E, 0x86, 0x42, 0x00, 0xDA, 0x02, 0x90, 0x08, 0x9E, 0xF3, 0x18, 0x08, 0x93, 0x01, 0x9B, 0x18,
+	0x18, 0x01, 0x90, 0x0F, 0x98, 0x40, 0x1C, 0x0F, 0x90, 0x0D, 0x9B, 0x98, 0x42, 0x00, 0xD2, 0x7D,
+	0xE7, 0x33, 0x48, 0x02, 0x99, 0x42, 0x68, 0x56, 0x18, 0x46, 0x60, 0x81, 0x68, 0x01, 0x9A, 0x8D,
+	0x18, 0x85, 0x60, 0x08, 0x98, 
+	0x00, 0x00, 0xDD, 0x00, 0x80, 0x00, 0x28, 0x00, 0xDA, 0x40, 0x42, 0x2E, 0x49, 0x0A, 0x68, 0x87,
+	0x18, 0x0F, 0x60, 0x16, 0x98, 0x14, 0x99, 0x40, 0x1C, 0x88, 0x42, 0x06, 0xD2, 0x21, 0x48, 0x01,
+	0x68, 0x03, 0x22, 0x52, 0x07, 0x11, 0x43, 0x01, 0x60, 0xA5, 0xE0, 0x16, 0x98, 0x88, 0x42, 0x7D,
+	0xD1, 0x81, 0x00, 0x30, 0x46, 0x06, 0xF0, 0x0D, 0xFE, 0xC4, 0xB2, 0x24, 0x48, 0x04, 0x70, 0x64,
+	0x20, 0x78, 0x43, 0x11, 0x94, 0x0D, 0x99, 0x06, 0xF0, 0xFA, 0xFD, 0x31, 0x46, 0x06, 0xF0, 0xF7,
+	0xFD, 0xC0, 0xB2, 0x1F, 0x49, 0x07, 0x46, 0x08, 0x70, 0x28, 0x46, 0x64, 0x21, 0x48, 0x43, 0x0D,
+	0x99, 0x06, 0xF0, 0xED, 0xFD, 0x31, 0x46, 0x06, 0xF0, 0xEA, 0xFD, 0x1A, 0x49, 0x23, 0x02, 0x08,
+	0x70, 0x12, 0x4C, 0x05, 0x22, 0x00, 0x20, 0x12, 0x34, 0x13, 0x99, 0x09, 0x7B, 0x45, 0x00, 0x65,
+	0x5B, 0x69, 0x43, 0x99, 0x42, 
+	0x00, 0x00, 0xDE, 0x00, 0x80, 0x2A, 0xDA, 0x02, 0xB2, 0x2B, 0xE0, 0x00, 0x00, 0xE0, 0x00, 0x00,
+	0x20, 0xB6, 0x00, 0x00, 0x20, 0xDC, 0x00, 0x00, 0x20, 0xBD, 0x00, 0x00, 0x20, 0xF0, 0xE9, 0x00,
+	0x00, 0xBE, 0x00, 0x00, 0x20, 0x00, 0x00, 0x11, 0x40, 0xA9, 0x00, 0x00, 0x20, 0xBC, 0x01, 0x00,
+	0x20, 0xB7, 0x00, 0x00, 0x20, 0x21, 0x03, 0x00, 0x00, 0xCA, 0x00, 0x00, 0x20, 0x30, 0xDE, 0x00,
+	0x00, 0xA8, 0x01, 0x00, 0x20, 0xD0, 0x00, 0x00, 0x20, 0xB4, 0x01, 0x00, 0x20, 0xBA, 0x00, 0x00,
+	0x20, 0xBB, 0x00, 0x00, 0x20, 0xBC, 0x00, 0x00, 0x20, 0xAE, 0x00, 0x00, 0x20, 0x40, 0x1C, 0x05,
+	0x28, 0xCA, 0xD3, 0x13, 0x98, 0x40, 0x7B, 0x51, 0x00, 0x33, 0x4A, 0x34, 0x4C, 0x51, 0x5A, 0x48,
+	0x43, 0x00, 0x0A, 0x01, 0x25, 0x25, 0x70, 0x13, 0x99, 0xC9, 0x7B, 0xCA, 0x07, 0x03, 0x21, 0x00,
+	0x2A, 0x02, 0xD0, 0x87, 0x42, 
+	0x00, 0x00, 0xDF, 0x00, 0x80, 0x0A, 0xD9, 0x08, 0xE0, 0x13, 0x98, 0x40, 0x7B, 0xB8, 0x42, 0x05,
+	0xD2, 0x13, 0x98, 0x00, 0x7B, 0x11, 0x9A, 0x90, 0x42, 0x00, 0xD2, 0x21, 0x70, 0x16, 0x99, 0x0D,
+	0x98, 0x27, 0x4E, 0x41, 0x43, 0x30, 0x88, 0x64, 0x22, 0x50, 0x43, 0x00, 0xE0, 0x1E, 0xE0, 0x06,
+	0xF0, 0x86, 0xFD, 0x24, 0x4A, 0x30, 0x80, 0x11, 0x69, 0x02, 0x20, 0x81, 0x43, 0x11, 0x61, 0x05,
+	0x20, 0xFF, 0xF7, 0xE3, 0xF8, 0x20, 0x78, 0x80, 0x07, 0x0D, 0xD4, 0x1F, 0x49, 0x08, 0x78, 0x00,
+	0x28, 0x09, 0xD0, 0x02, 0x28, 0x07, 0xD2, 0x40, 0x1C, 0x08, 0x70, 0x1C, 0x49, 0x00, 0x20, 0x08,
+	0x70, 0x1B, 0x49, 0x08, 0x60, 0xE3, 0xE5, 0x1B, 0x48, 0x05, 0x70, 0x04, 0xE0, 0x15, 0x49, 0x08,
+	0x68, 0x8A, 0x03, 0x10, 0x43, 0x08, 0x60, 0x17, 0x48, 0x00, 0x78, 0x01, 0x28, 0x19, 0xD1, 0x13,
+	0x98, 0x00, 0x7D, 0x00, 0x28, 
+	0x00, 0x00, 0xE0, 0x00, 0x80, 0x15, 0xD0, 0x13, 0x98, 0x00, 0x7C, 0x40, 0x07, 0x40, 0x0F, 0x05,
+	0x28, 0x00, 0xD9, 0x00, 0x20, 0x0B, 0x49, 0xC0, 0x31, 0x0A, 0x69, 0x0F, 0x4B, 0x1A, 0x40, 0x0A,
+	0x61, 0x0A, 0x69, 0x0E, 0x4B, 0x80, 0x00, 0x18, 0x58, 0x0B, 0x4B, 0xDB, 0x43, 0x18, 0x40, 0x02,
+	0x43, 0x0A, 0x61, 0x17, 0xB0, 0xF0, 0xBD, 0x00, 0x00, 0x4C, 0xDE, 0x00, 0x00, 0xB7, 0x00, 0x00,
+	0x20, 0xCA, 0x00, 0x00, 0x20, 0x00, 0x00, 0x11, 0x40, 0xB4, 0x01, 0x00, 0x20, 0xBD, 0x00, 0x00,
+	0x20, 0xDC, 0x00, 0x00, 0x20, 0xAE, 0x00, 0x00, 0x20, 0xFF, 0xE0, 0xE3, 0xF1, 0xB8, 0xDC, 0x00,
+	0x00, 0x27, 0x49, 0x01, 0x20, 0x08, 0x70, 0x70, 0x47, 0x25, 0x49, 0x00, 0x20, 0x08, 0x70, 0x70,
+	0x47, 0x23, 0x48, 0x00, 0x78, 0x00, 0x28, 0x00, 0xD0, 0x01, 0x20, 0x70, 0x47, 0x10, 0xB5, 0x20,
+	0x49, 0x00, 0x23, 0x08, 0x78, 
+	0x00, 0x00, 0xE1, 0x00, 0x80, 0x08, 0x22, 0x00, 0x28, 0x07, 0xD0, 0x04, 0x24, 0x01, 0x28, 0x02,
+	0xD1, 0x4B, 0x70, 0x8C, 0x70, 0x03, 0xE0, 0x4C, 0x70, 0x00, 0xE0, 0x4B, 0x70, 0x8A, 0x70, 0x00,
+	0xF0, 0x23, 0xF8, 0x02, 0x04, 0x17, 0x48, 0x01, 0x68, 0xFF, 0x23, 0x1B, 0x04, 0x99, 0x43, 0x0A,
+	0x43, 0x02, 0x60, 0x10, 0xBD, 0x10, 0xB5, 0x04, 0x46, 0x00, 0xF0, 0x16, 0xF8, 0x20, 0x40, 0x02,
+	0x04, 0x10, 0x48, 0x01, 0x68, 0xFF, 0x23, 0x1B, 0x04, 0x99, 0x43, 0x0A, 0x43, 0x02, 0x60, 0x10,
+	0xBD, 0x10, 0xB5, 0x0D, 0x49, 0x09, 0x78, 0x08, 0x18, 0x16, 0x21, 0x48, 0x43, 0x0B, 0x49, 0x0C,
+	0x5A, 0x00, 0xF0, 0x02, 0xF8, 0x20, 0x40, 0x10, 0xBD, 0x05, 0x48, 0x00, 0x78, 0x00, 0x28, 0x05,
+	0xD0, 0x01, 0x28, 0x01, 0xD1, 0x0F, 0x20, 0x70, 0x47, 0xF0, 0x20, 0x70, 0x47, 0xFF, 0x20, 0x70,
+	0x47, 0xB4, 0x01, 0x00, 0x20, 
+	0x00, 0x00, 0xE2, 0x00, 0x80, 0x00, 0x00, 0x11, 0x40, 0x9F, 0x00, 0x00, 0x20, 0x00, 0xEC, 0x00,
+	0x00, 0xFC, 0x49, 0x00, 0x20, 0xC8, 0x70, 0x70, 0x47, 0xF3, 0xB5, 0xFA, 0x48, 0x84, 0xB0, 0xC0,
+	0x78, 0x03, 0x90, 0xFA, 0x48, 0xF8, 0x4C, 0x00, 0x78, 0x00, 0x23, 0x02, 0x90, 0x62, 0xE0, 0xF9,
+	0x48, 0xF7, 0x4A, 0x00, 0x21, 0x00, 0x90, 0x57, 0xE0, 0x05, 0x98, 0x00, 0x28, 0x05, 0xD0, 0x2C,
+	0x20, 0x04, 0x9D, 0x48, 0x43, 0x40, 0x19, 0x9D, 0x00, 0x04, 0xE0, 0x2C, 0x20, 0x04, 0x9D, 0x58,
+	0x43, 0x40, 0x19, 0x8D, 0x00, 0x40, 0x19, 0x55, 0x79, 0x16, 0x79, 0x2D, 0x02, 0x35, 0x43, 0x66,
+	0x79, 0x27, 0x79, 0x36, 0x02, 0x3E, 0x43, 0xAD, 0x1B, 0xAE, 0x46, 0xD5, 0x78, 0x96, 0x78, 0x2D,
+	0x02, 0x35, 0x43, 0xE6, 0x78, 0xA7, 0x78, 0x36, 0x02, 0x3E, 0x43, 0xAD, 0x1B, 0x01, 0x95, 0x75,
+	0x46, 0x76, 0x46, 0x6E, 0x43, 
+	0x00, 0x00, 0xE3, 0x00, 0x80, 0x01, 0x9D, 0x6D, 0x43, 0x77, 0x19, 0x07, 0x60, 0x00, 0x9D, 0xEE,
+	0x78, 0xAD, 0x78, 0x36, 0x06, 0x36, 0x14, 0x2E, 0x43, 0xB4, 0x46, 0x00, 0x9E, 0x75, 0x78, 0x36,
+	0x78, 0x2D, 0x06, 0x2D, 0x14, 0x35, 0x43, 0x64, 0x2F, 0x0D, 0xDA, 0x57, 0x78, 0x16, 0x78, 0x3F,
+	0x02, 0x37, 0x43, 0x08, 0xD0, 0x66, 0x46, 0x2F, 0x46, 0x76, 0x43, 0x6F, 0x43, 0xF6, 0x19, 0x64,
+	0x2E, 0x01, 0xDA, 0xD5, 0x4E, 0x06, 0x60, 0x02, 0x9F, 0x03, 0x9E, 0xB7, 0x42, 0x0A, 0xD2, 0x76,
+	0x46, 0x67, 0x46, 0xF6, 0x1B, 0x01, 0x9F, 0x76, 0x43, 0x7D, 0x1B, 0x6D, 0x43, 0x75, 0x19, 0x06,
+	0x68, 0x75, 0x19, 0x05, 0x60, 0x49, 0x1C, 0x09, 0x32, 0x03, 0x98, 0x81, 0x42, 0xA4, 0xD3, 0x5B,
+	0x1C, 0x02, 0x98, 0x09, 0x34, 0x83, 0x42, 0x9A, 0xD3, 0x06, 0xB0, 0xF0, 0xBD, 0x70, 0xB5, 0x8B,
+	0x79, 0xC2, 0x79, 0x1B, 0x07, 
+	0x00, 0x00, 0xE4, 0x00, 0x80, 0xC5, 0x4D, 0x1B, 0x0F, 0x0E, 0x2A, 0x04, 0xD8, 0x2C, 0x7B, 0x24,
+	0x01, 0x23, 0x43, 0x8B, 0x71, 0x12, 0xE0, 0x84, 0x79, 0x26, 0x09, 0x07, 0xD0, 0xC0, 0x4E, 0x36,
+	0x78, 0x00, 0x2E, 0x06, 0xD1, 0xB7, 0x4E, 0x36, 0x79, 0x01, 0x2E, 0x02, 0xD1, 0x52, 0x06, 0x52,
+	0x0E, 0xEC, 0xE7, 0x24, 0x09, 0x24, 0x01, 0x10, 0x3C, 0x1C, 0x43, 0x8C, 0x71, 0xCA, 0x71, 0x43,
+	0x78, 0x04, 0x78, 0x18, 0x02, 0x20, 0x43, 0x40, 0x1C, 0x08, 0x70, 0x00, 0x0A, 0x48, 0x70, 0x10,
+	0x06, 0xC0, 0x17, 0x40, 0x1C, 0x70, 0xBD, 0x41, 0x79, 0x02, 0x79, 0x09, 0x02, 0x11, 0x43, 0x0F,
+	0x29, 0x0E, 0xD3, 0xC2, 0x78, 0x83, 0x78, 0x10, 0x02, 0x18, 0x43, 0x0F, 0x28, 0x08, 0xD3, 0xAD,
+	0x4A, 0xD3, 0x68, 0x10, 0x3B, 0x99, 0x42, 0x03, 0xD8, 0x11, 0x69, 0x10, 0x39, 0x88, 0x42, 0x01,
+	0xD9, 0x01, 0x20, 0x70, 0x47, 
+	0x00, 0x00, 0xE5, 0x00, 0x80, 0x00, 0x20, 0x70, 0x47, 0x70, 0xB5, 0x04, 0x46, 0x00, 0xF0, 0x9F,
+	0xFC, 0x05, 0x46, 0xA0, 0x79, 0xA1, 0x4E, 0x01, 0x09, 0x17, 0xD0, 0xA1, 0x48, 0x00, 0x78, 0x01,
+	0x28, 0x10, 0xD1, 0x20, 0x46, 0xFF, 0xF7, 0xD7, 0xFF, 0x00, 0x28, 0x0B, 0xD0, 0x9E, 0x48, 0x00,
+	0x68, 0x00, 0x28, 0x07, 0xD1, 0x30, 0x7B, 0xA1, 0x79, 0x00, 0x01, 0x09, 0x07, 0x09, 0x0F, 0x01,
+	0x43, 0xA1, 0x71, 0x08, 0xE0, 0x80, 0x20, 0x05, 0x43, 0x05, 0xE0, 0x31, 0x7B, 0x00, 0x07, 0x09,
+	0x01, 0x00, 0x0F, 0x08, 0x43, 0xA0, 0x71, 0x00, 0x20, 0x20, 0x70, 0x60, 0x70, 0x28, 0x06, 0xC0,
+	0x17, 0xE5, 0x71, 0x40, 0x1C, 0x70, 0xBD, 0xF0, 0xB5, 0xC2, 0x79, 0x87, 0xB0, 0x0E, 0x2A, 0x72,
+	0xD8, 0x43, 0x79, 0x04, 0x79, 0x1B, 0x02, 0x23, 0x43, 0x04, 0x93, 0xC3, 0x78, 0x84, 0x78, 0x18,
+	0x02, 0x20, 0x43, 0x03, 0x90, 
+	0x00, 0x00, 0xE6, 0x00, 0x80, 0x48, 0x79, 0x0B, 0x79, 0x04, 0x02, 0xC8, 0x78, 0x89, 0x78, 0x05,
+	0x02, 0x06, 0x20, 0x42, 0x43, 0x85, 0x48, 0x0D, 0x43, 0x10, 0x18, 0x00, 0x21, 0x1C, 0x43, 0x06,
+	0x92, 0x05, 0x90, 0x01, 0x71, 0x00, 0x2C, 0x56, 0xD0, 0x7E, 0x49, 0xC8, 0x68, 0x40, 0x1E, 0xA0,
+	0x42, 0x51, 0xD0, 0x00, 0x2D, 0x4F, 0xD0, 0x08, 0x46, 0x00, 0x69, 0x40, 0x1E, 0xA8, 0x42, 0x4A,
+	0xD0, 0x04, 0x98, 0x00, 0x27, 0x21, 0x1A, 0xCA, 0x0F, 0x03, 0x98, 0x52, 0x18, 0x52, 0x10, 0x28,
+	0x1A, 0x16, 0x19, 0xC2, 0x0F, 0x12, 0x18, 0x52, 0x10, 0x52, 0x19, 0x02, 0x92, 0x00, 0x29, 0x0D,
+	0xD1, 0x00, 0x2A, 0x02, 0xDA, 0x00, 0x25, 0x34, 0x46, 0x01, 0x27, 0x6E, 0x48, 0x02, 0x69, 0x02,
+	0x99, 0x8A, 0x42, 0x63, 0xDC, 0x05, 0x69, 0x34, 0x46, 0x6D, 0x1E, 0x5E, 0xE0, 0x00, 0x02, 0x06,
+	0xF0, 0xA8, 0xFB, 0x01, 0x90, 
+	0x00, 0x00, 0xE7, 0x00, 0x80, 0x03, 0x98, 0x04, 0x9A, 0x01, 0x02, 0x01, 0x98, 0x50, 0x43, 0x08,
+	0x1A, 0x00, 0x90, 0x00, 0x2E, 0x0B, 0xDA, 0x00, 0x24, 0x25, 0x46, 0x00, 0x28, 0x00, 0xDB, 0x05,
+	0x12, 0x60, 0x48, 0x01, 0x69, 0xA9, 0x42, 0x01, 0xD8, 0x05, 0x69, 0x6D, 0x1E, 0x01, 0x27, 0x02,
+	0x98, 0x00, 0x28, 0x13, 0xDA, 0x00, 0x98, 0x01, 0x99, 0x40, 0x42, 0x06, 0xF0, 0x8A, 0xFB, 0x00,
+	0x26, 0x00, 0x28, 0x00, 0xDB, 0x06, 0x46, 0x57, 0x48, 0x00, 0x25, 0xC1, 0x68, 0xB1, 0x42, 0x03,
+	0xDC, 0xC4, 0x68, 0x64, 0x1E, 0x01, 0xE0, 0x38, 0xE0, 0x34, 0x46, 0x01, 0x27, 0x51, 0x4A, 0xD0,
+	0x68, 0xB0, 0x42, 0x13, 0xDC, 0xD4, 0x68, 0x01, 0x98, 0x64, 0x1E, 0x00, 0x99, 0x60, 0x43, 0x40,
+	0x18, 0x00, 0x12, 0x00, 0x21, 0x00, 0x28, 0x00, 0xDB, 0x01, 0x46, 0x02, 0x91, 0x10, 0x69, 0x88,
+	0x42, 0x02, 0xDC, 0x15, 0x69, 
+	0x00, 0x00, 0xE8, 0x00, 0x80, 0x6D, 0x1E, 0x00, 0xE0, 0x0D, 0x46, 0x01, 0x27, 0x10, 0x69, 0x02,
+	0x99, 0x88, 0x42, 0x13, 0xDC, 0x15, 0x69, 0x14, 0x46, 0x6D, 0x1E, 0x00, 0x98, 0x29, 0x02, 0x08,
+	0x1A, 0x01, 0x99, 0x06, 0xF0, 0x56, 0xFB, 0x00, 0x21, 0x00, 0x28, 0x00, 0xDB, 0x01, 0x46, 0xE0,
+	0x68, 0x88, 0x42, 0x01, 0xDC, 0xE1, 0x68, 0x49, 0x1E, 0x0C, 0x46, 0x01, 0x27, 0x3B, 0x48, 0x06,
+	0x99, 0x44, 0x52, 0x05, 0x98, 0x45, 0x80, 0x05, 0x98, 0x07, 0x71, 0x07, 0xB0, 0xF0, 0xBD, 0xF3,
+	0xB5, 0x87, 0xB0, 0x08, 0x98, 0x00, 0x24, 0x40, 0x1E, 0x05, 0x90, 0x4E, 0xE0, 0xE0, 0x00, 0x2A,
+	0x49, 0x20, 0x18, 0x40, 0x18, 0x06, 0x90, 0x42, 0x78, 0x03, 0x78, 0x12, 0x02, 0x1A, 0x43, 0xC6,
+	0x79, 0x25, 0x46, 0x60, 0x1C, 0x12, 0xE0, 0xC1, 0x00, 0x43, 0x18, 0x23, 0x49, 0x59, 0x18, 0x4B,
+	0x78, 0x0F, 0x78, 0x1B, 0x02, 
+	0x00, 0x00, 0xE9, 0x00, 0x80, 0x3B, 0x43, 0x93, 0x42, 0x04, 0xD8, 0x93, 0x42, 0x05, 0xD1, 0xCF,
+	0x79, 0xB7, 0x42, 0x02, 0xD2, 0xCE, 0x79, 0x05, 0x46, 0x1A, 0x46, 0x40, 0x1C, 0x08, 0x99, 0x88,
+	0x42, 0xE9, 0xD3, 0xAC, 0x42, 0x27, 0xD0, 0x18, 0x4E, 0x09, 0x22, 0x02, 0xA8, 0x06, 0x99, 0x06,
+	0xF0, 0x95, 0xFA, 0xE8, 0x00, 0x28, 0x18, 0x86, 0x19, 0x09, 0x22, 0x31, 0x46, 0x06, 0x98, 0x06,
+	0xF0, 0x8D, 0xFA, 0x09, 0x22, 0x02, 0xA9, 0x30, 0x46, 0x06, 0xF0, 0x88, 0xFA, 0x07, 0x98, 0xA1,
+	0x00, 0x0E, 0x18, 0x04, 0x22, 0x31, 0x46, 0x01, 0xA8, 0x06, 0xF0, 0x80, 0xFA, 0x07, 0x98, 0xA9,
+	0x00, 0x0D, 0x18, 0x04, 0x22, 0x29, 0x46, 0x30, 0x46, 0x06, 0xF0, 0x78, 0xFA, 0x04, 0x22, 0x01,
+	0xA9, 0x28, 0x46, 0x06, 0xF0, 0x73, 0xFA, 0x05, 0x98, 0x64, 0x1C, 0x84, 0x42, 0xAE, 0xD3, 0x09,
+	0xB0, 0xF0, 0xBD, 0x00, 0x00, 
+	0x00, 0x00, 0xEA, 0x00, 0x80, 0xC0, 0x01, 0x00, 0x20, 0x88, 0x03, 0x00, 0x20, 0xEE, 0x00, 0x00,
+	0x20, 0xEB, 0x03, 0x00, 0x20, 0xC4, 0x04, 0x00, 0x20, 0x00, 0x00, 0xC0, 0xFF, 0xA0, 0xE7, 0x00,
+	0x00, 0xE9, 0x00, 0x00, 0x20, 0xD0, 0xE7, 0x00, 0x00, 0x1C, 0x01, 0x00, 0x20, 0x72, 0x0E, 0x00,
+	0x20, 0xFF, 0xB5, 0xA1, 0xB0, 0x05, 0x46, 0x0C, 0x46, 0x0B, 0x21, 0x2A, 0x98, 0xF9, 0xF7, 0x58,
+	0xFF, 0x20, 0x90, 0x0B, 0x21, 0x2A, 0x98, 0xF9, 0xF7, 0x53, 0xFF, 0x00, 0x21, 0x22, 0xE0, 0x00,
+	0x21, 0x62, 0x46, 0xF8, 0x4B, 0x92, 0x00, 0x0A, 0xE0, 0x2C, 0x27, 0x0E, 0x46, 0x7E, 0x43, 0x24,
+	0x9F, 0xF6, 0x19, 0xB6, 0x58, 0x9E, 0x42, 0x00, 0xDA, 0x33, 0x46, 0x49, 0x1C, 0xC9, 0xB2, 0xA9,
+	0x42, 0xF2, 0xD3, 0x00, 0x21, 0x09, 0xE0, 0x2C, 0x27, 0x0E, 0x46, 0x7E, 0x43, 0x24, 0x9F, 0xF7,
+	0x19, 0xBE, 0x58, 0xF6, 0x1A, 
+	0x00, 0x00, 0xEB, 0x00, 0x80, 0x49, 0x1C, 0xBE, 0x50, 0xC9, 0xB2, 0xA9, 0x42, 0xF3, 0xD3, 0x61,
+	0x46, 0x49, 0x1C, 0xC9, 0xB2, 0x8C, 0x46, 0xA1, 0x42, 0xD9, 0xD3, 0x00, 0x21, 0x35, 0xE0, 0x23,
+	0x9B, 0xFF, 0x22, 0x5A, 0x54, 0x00, 0x22, 0x2C, 0xE0, 0x2C, 0x23, 0x24, 0x9E, 0x53, 0x43, 0x9B,
+	0x19, 0x8E, 0x00, 0x9B, 0x59, 0x00, 0x2B, 0x1C, 0xD1, 0x0B, 0x23, 0x53, 0x43, 0x01, 0xAF, 0xDB,
+	0x19, 0x00, 0x26, 0x9C, 0x46, 0x5E, 0x54, 0x33, 0x46, 0x01, 0x26, 0x06, 0xE0, 0x23, 0x9F, 0xFF,
+	0x56, 0x97, 0x42, 0x00, 0xD1, 0x00, 0x26, 0x5B, 0x1C, 0xDB, 0xB2, 0x8B, 0x42, 0x02, 0xD2, 0x01,
+	0x2E, 0xF4, 0xD0, 0x0C, 0xE0, 0x01, 0x2E, 0x0A, 0xD1, 0x23, 0x9B, 0x5A, 0x54, 0x63, 0x46, 0x5E,
+	0x54, 0x05, 0xE0, 0x0B, 0x23, 0xFF, 0x26, 0x53, 0x43, 0x01, 0xAF, 0xDB, 0x19, 0xF7, 0xE7, 0x52,
+	0x1C, 0xD2, 0xB2, 0xAA, 0x42, 
+	0x00, 0x00, 0xEC, 0x00, 0x80, 0xD0, 0xD3, 0x49, 0x1C, 0xC9, 0xB2, 0xA1, 0x42, 0xC7, 0xD3, 0x21,
+	0xE1, 0x00, 0x21, 0x04, 0xE0, 0x20, 0x9B, 0x00, 0x22, 0x5A, 0x54, 0x49, 0x1C, 0xC9, 0xB2, 0xA9,
+	0x42, 0xF8, 0xD3, 0x00, 0x21, 0x07, 0xE0, 0x23, 0x9A, 0x52, 0x56, 0x52, 0x1C, 0x00, 0xD0, 0x01,
+	0x22, 0x42, 0x54, 0x49, 0x1C, 0xC9, 0xB2, 0xA1, 0x42, 0xF5, 0xD3, 0x00, 0x21, 0xBE, 0x4A, 0xC9,
+	0x43, 0x11, 0x70, 0xBC, 0xE0, 0x00, 0x23, 0x1A, 0x46, 0x1D, 0xE0, 0x20, 0x99, 0x89, 0x5C, 0x01,
+	0x29, 0x17, 0xD0, 0x0B, 0x26, 0x00, 0x21, 0x56, 0x43, 0x01, 0xAF, 0xF6, 0x19, 0xB4, 0x46, 0x56,
+	0xB2, 0x0D, 0xE0, 0x47, 0x5C, 0x01, 0x2F, 0x08, 0xD0, 0x67, 0x46, 0x7F, 0x5C, 0x00, 0x2F, 0x04,
+	0xD1, 0xB1, 0x4F, 0x01, 0x23, 0x3E, 0x70, 0x7F, 0x1C, 0x39, 0x70, 0x49, 0x1C, 0xC9, 0xB2, 0xA1,
+	0x42, 0xEF, 0xD3, 0x52, 0x1C, 
+	0x00, 0x00, 0xED, 0x00, 0x80, 0xD2, 0xB2, 0xAA, 0x42, 0xDF, 0xD3, 0x59, 0xB2, 0x8C, 0x46, 0x00,
+	0x29, 0x5A, 0xD1, 0xA8, 0x49, 0x00, 0x22, 0x8C, 0x46, 0x17, 0xE0, 0x20, 0x99, 0x89, 0x5C, 0x01,
+	0x29, 0x11, 0xD0, 0x2C, 0x23, 0x24, 0x9E, 0x00, 0x21, 0x53, 0x43, 0x9F, 0x19, 0x09, 0xE0, 0x43,
+	0x5C, 0x01, 0x2B, 0x04, 0xD0, 0x8B, 0x00, 0xFB, 0x58, 0x63, 0x45, 0x00, 0xDA, 0x9C, 0x46, 0x49,
+	0x1C, 0xC9, 0xB2, 0xA1, 0x42, 0xF3, 0xD3, 0x52, 0x1C, 0xD2, 0xB2, 0xAA, 0x42, 0xE5, 0xD3, 0x00,
+	0x22, 0x37, 0xE0, 0x00, 0x21, 0x31, 0xE0, 0x43, 0x5C, 0x01, 0x2B, 0x12, 0xD1, 0x20, 0x9B, 0x9B,
+	0x5C, 0x01, 0x2B, 0x0E, 0xD1, 0x2C, 0x23, 0x24, 0x9E, 0x53, 0x43, 0x9E, 0x19, 0x8F, 0x00, 0xF3,
+	0x59, 0x63, 0x44, 0xF3, 0x51, 0x0B, 0x27, 0x13, 0x46, 0x7B, 0x43, 0xFF, 0x26, 0x01, 0xAF, 0xDB,
+	0x19, 0x5E, 0x54, 0x43, 0x5C, 
+	0x00, 0x00, 0xEE, 0x00, 0x80, 0x00, 0x2B, 0x16, 0xD1, 0x20, 0x9B, 0x9B, 0x5C, 0x00, 0x2B, 0x12,
+	0xD1, 0x2C, 0x23, 0x24, 0x9E, 0x53, 0x43, 0x8F, 0x00, 0x9E, 0x19, 0xBE, 0x46, 0xF3, 0x59, 0x67,
+	0x46, 0xDB, 0x1B, 0x77, 0x46, 0xF3, 0x51, 0x06, 0xD1, 0x0B, 0x27, 0x13, 0x46, 0x7B, 0x43, 0x00,
+	0x26, 0x01, 0xAF, 0xDB, 0x19, 0x5E, 0x54, 0x49, 0x1C, 0xC9, 0xB2, 0xA1, 0x42, 0xCB, 0xD3, 0x52,
+	0x1C, 0xD2, 0xB2, 0xAA, 0x42, 0xC5, 0xD3, 0x7D, 0xE7, 0x7B, 0x4E, 0x00, 0x21, 0x73, 0x56, 0x0B,
+	0x26, 0x73, 0x43, 0x01, 0xAE, 0x9F, 0x19, 0x78, 0x4E, 0x4A, 0x1E, 0x76, 0x1C, 0x73, 0x56, 0x0A,
+	0xE0, 0x46, 0x5C, 0x00, 0x2E, 0x05, 0xD0, 0x99, 0x42, 0x03, 0xD0, 0x7E, 0x5C, 0x01, 0x2E, 0x00,
+	0xD1, 0x4A, 0xB2, 0x49, 0x1C, 0xC9, 0xB2, 0xA1, 0x42, 0x02, 0xD2, 0x56, 0x1C, 0xF0, 0xD0, 0x11,
+	0xE0, 0x51, 0x1C, 0x0F, 0xD1, 
+	0x00, 0x00, 0xEF, 0x00, 0x80, 0x61, 0x46, 0x01, 0x29, 0xDD, 0xD1, 0x6B, 0x4E, 0x00, 0x21, 0x71,
+	0x56, 0x0B, 0x22, 0x51, 0x43, 0x01, 0xAA, 0x02, 0x23, 0x89, 0x18, 0x01, 0x27, 0xF7, 0x57, 0xCB,
+	0x55, 0x17, 0x46, 0x0E, 0xE0, 0x02, 0x21, 0xF9, 0x54, 0x00, 0x21, 0x81, 0x54, 0x62, 0x4B, 0x00,
+	0x26, 0x9E, 0x57, 0x20, 0x99, 0x01, 0x22, 0x8A, 0x55, 0x91, 0x1E, 0x1A, 0x46, 0x11, 0x70, 0x51,
+	0x70, 0x40, 0xE7, 0x5D, 0x4E, 0x00, 0x21, 0x71, 0x56, 0x0B, 0x22, 0x8C, 0x46, 0x51, 0x43, 0x01,
+	0x22, 0xB2, 0x56, 0xCB, 0x19, 0x99, 0x56, 0x02, 0x29, 0x21, 0xD1, 0x00, 0x21, 0x0E, 0xE0, 0x0B,
+	0x26, 0x4E, 0x43, 0xF6, 0x19, 0xB6, 0x5C, 0x01, 0x2E, 0x06, 0xD1, 0x9E, 0x54, 0x23, 0x9E, 0x63,
+	0x46, 0xB3, 0x54, 0x51, 0x4A, 0x11, 0x70, 0x03, 0xE0, 0x49, 0x1C, 0xC9, 0xB2, 0xA9, 0x42, 0xEE,
+	0xD3, 0xA9, 0x42, 0xDE, 0xD1, 
+	0x00, 0x00, 0xF0, 0x00, 0x80, 0x4C, 0x4A, 0x00, 0x21, 0x51, 0x56, 0x0B, 0x22, 0x01, 0x23, 0x4A,
+	0x43, 0xD6, 0x19, 0x49, 0x4F, 0xFA, 0x56, 0xB3, 0x54, 0x23, 0x9B, 0x99, 0x54, 0x1A, 0xE0, 0x01,
+	0x29, 0xCF, 0xD1, 0x00, 0x21, 0x08, 0xE0, 0x5E, 0x5C, 0x02, 0x2E, 0x03, 0xD1, 0x9E, 0x54, 0x42,
+	0x4A, 0x51, 0x70, 0x03, 0xE0, 0x49, 0x1C, 0xC9, 0xB2, 0xA1, 0x42, 0xF4, 0xD3, 0xA1, 0x42, 0xC0,
+	0xD1, 0x3D, 0x4A, 0x00, 0x21, 0x51, 0x56, 0x0B, 0x26, 0x71, 0x43, 0x02, 0x23, 0xC9, 0x19, 0x01,
+	0x26, 0x96, 0x57, 0x8B, 0x55, 0x00, 0x22, 0x11, 0x46, 0x06, 0xE0, 0x23, 0x9B, 0x5B, 0x56, 0x5B,
+	0x1C, 0x00, 0xD0, 0x52, 0x1C, 0x49, 0x1C, 0xC9, 0xB2, 0xA1, 0x42, 0xF6, 0xD3, 0xA2, 0x42, 0x00,
+	0xD2, 0xCE, 0xE6, 0x2A, 0x98, 0xF9, 0xF7, 0xC9, 0xFD, 0x2A, 0x98, 0xF9, 0xF7, 0xC6, 0xFD, 0x25,
+	0xB0, 0x3E, 0xE6, 0xF1, 0xB5, 
+	0x00, 0x00, 0xF1, 0x00, 0x80, 0x2D, 0x48, 0x88, 0xB0, 0x81, 0x68, 0x05, 0x91, 0x40, 0x68, 0x04,
+	0x90, 0x00, 0x24, 0x0C, 0x21, 0x08, 0x98, 0xF9, 0xF7, 0xAB, 0xFD, 0x05, 0x46, 0xFF, 0x21, 0xE5,
+	0x31, 0x08, 0x98, 0xF9, 0xF7, 0xA5, 0xFD, 0x03, 0x90, 0x2C, 0x21, 0x08, 0x98, 0xF9, 0xF7, 0xA0,
+	0xFD, 0x02, 0x90, 0x0B, 0x21, 0x08, 0x98, 0xF9, 0xF7, 0x9B, 0xFD, 0x01, 0x90, 0x20, 0x48, 0x1E,
+	0x4B, 0x00, 0x78, 0x18, 0x71, 0x00, 0x20, 0x1E, 0x27, 0x41, 0x1E, 0xC2, 0x00, 0x1D, 0x4E, 0x82,
+	0x18, 0x92, 0x19, 0xD7, 0x71, 0x01, 0x9A, 0x11, 0x54, 0x40, 0x1C, 0xC0, 0xB2, 0x0B, 0x28, 0xF4,
+	0xD3, 0x17, 0x4E, 0xD9, 0x78, 0x30, 0x78, 0x01, 0x22, 0x88, 0x42, 0x00, 0xD1, 0x00, 0x22, 0x12,
+	0x4B, 0x88, 0x42, 0x9A, 0x70, 0x0A, 0x46, 0x00, 0xD3, 0x02, 0x46, 0x06, 0x92, 0x01, 0x28, 0x05,
+	0xD1, 0x01, 0x29, 0x03, 0xD1, 
+	0x00, 0x00, 0xF2, 0x00, 0x80, 0x01, 0x99, 0x00, 0x20, 0x08, 0x70, 0x3B, 0xE0, 0x0C, 0x4F, 0x0A,
+	0x4E, 0x88, 0x42, 0x21, 0xD3, 0x00, 0x21, 0x03, 0x98, 0xFF, 0xF7, 0xFE, 0xFB, 0x08, 0x9A, 0x00,
+	0x92, 0x2A, 0x46, 0xF1, 0x78, 0x38, 0x78, 0x03, 0x9B, 0xFF, 0xF7, 0x02, 0xFE, 0x00, 0x20, 0xF1,
+	0x78, 0x0F, 0xE0, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x7F, 0xC0, 0x01, 0x00, 0x20, 0xA0, 0xE7, 0x00,
+	0x00, 0xEE, 0x00, 0x00, 0x20, 0x88, 0x03, 0x00, 0x20, 0x01, 0x9B, 0x2A, 0x5C, 0x1A, 0x54, 0x40,
+	0x1C, 0xC0, 0xB2, 0x88, 0x42, 0xF8, 0xD3, 0x15, 0xE0, 0x01, 0x21, 0x03, 0x98, 0xFF, 0xF7, 0xDC,
+	0xFB, 0x08, 0x9A, 0x00, 0x92, 0x2A, 0x46, 0x39, 0x78, 0xF0, 0x78, 0x03, 0x9B, 0xFF, 0xF7, 0xE0,
+	0xFD, 0x00, 0x20, 0x04, 0xE0, 0x29, 0x56, 0x01, 0x9A, 0x50, 0x54, 0x40, 0x1C, 0xC0, 0xB2, 0x39,
+	0x78, 0x88, 0x42, 0xF7, 0xD3, 
+	0x00, 0x00, 0xF3, 0x00, 0x80, 0x00, 0x25, 0xDB, 0xE0, 0x01, 0x98, 0x40, 0x57, 0x00, 0x90, 0x40,
+	0x1C, 0x71, 0xD0, 0xE8, 0x00, 0x29, 0x18, 0xA5, 0x48, 0x08, 0x18, 0x41, 0x79, 0x03, 0x79, 0x0A,
+	0x02, 0x00, 0x99, 0x1A, 0x43, 0xCB, 0x00, 0xCB, 0x18, 0xA1, 0x49, 0x84, 0x46, 0x59, 0x18, 0x07,
+	0x91, 0x4B, 0x79, 0x0E, 0x79, 0x1B, 0x02, 0x33, 0x43, 0xD6, 0x1A, 0xC2, 0x78, 0x83, 0x78, 0x12,
+	0x02, 0x1A, 0x43, 0xCB, 0x78, 0x8F, 0x78, 0x1B, 0x02, 0x3B, 0x43, 0xD7, 0x1A, 0x42, 0x78, 0x00,
+	0x78, 0x12, 0x02, 0x02, 0x43, 0x06, 0xD1, 0x30, 0x46, 0x3A, 0x46, 0x70, 0x43, 0x7A, 0x43, 0x80,
+	0x18, 0x80, 0x10, 0x11, 0xE0, 0x93, 0x48, 0xAA, 0x00, 0x12, 0x18, 0xD0, 0x78, 0x93, 0x78, 0x00,
+	0x06, 0x00, 0x14, 0x18, 0x43, 0x33, 0x1A, 0x50, 0x78, 0x12, 0x78, 0x00, 0x06, 0x00, 0x14, 0x10,
+	0x43, 0x38, 0x1A, 0x5B, 0x43, 
+	0x00, 0x00, 0xF4, 0x00, 0x80, 0x40, 0x43, 0x18, 0x18, 0x05, 0x9A, 0x90, 0x42, 0x0B, 0xD8, 0xFF,
+	0x22, 0x91, 0x32, 0x90, 0x42, 0x0F, 0xDD, 0x88, 0x48, 0x00, 0x68, 0x00, 0x28, 0x0B, 0xD0, 0x60,
+	0x46, 0xC0, 0x79, 0x0E, 0x28, 0x07, 0xD9, 0x08, 0x46, 0xFF, 0xF7, 0x2E, 0xFC, 0x00, 0x19, 0x00,
+	0x26, 0xC4, 0xB2, 0x37, 0x46, 0x10, 0xE0, 0x60, 0x46, 0xFF, 0xF7, 0xE0, 0xFB, 0x00, 0x19, 0xC4,
+	0xB2, 0x60, 0x46, 0x07, 0x99, 0xFF, 0xF7, 0x4F, 0xFC, 0x30, 0x46, 0x39, 0x46, 0x70, 0x43, 0x79,
+	0x43, 0x40, 0x18, 0x04, 0x99, 0x88, 0x42, 0x02, 0xD9, 0x78, 0x49, 0x01, 0x20, 0x88, 0x70, 0x00,
+	0x98, 0x02, 0x99, 0x80, 0x00, 0x40, 0x18, 0x86, 0x70, 0x31, 0x0A, 0xC1, 0x70, 0x07, 0x70, 0x39,
+	0x0A, 0x41, 0x70, 0x63, 0xE0, 0xFF, 0xE7, 0x72, 0x48, 0x70, 0x4E, 0x00, 0x78, 0xF1, 0x78, 0x88,
+	0x42, 0x5C, 0xD2, 0xE8, 0x00, 
+	0x00, 0x00, 0xF5, 0x00, 0x80, 0x29, 0x18, 0x69, 0x48, 0x09, 0x18, 0xC8, 0x79, 0x0E, 0x28, 0x55,
+	0xDC, 0x06, 0x22, 0x50, 0x43, 0x6B, 0x4A, 0x82, 0x18, 0x13, 0x79, 0x00, 0x2B, 0x22, 0xD0, 0x4B,
+	0x78, 0x0F, 0x78, 0x1B, 0x02, 0x3B, 0x43, 0x5B, 0x1C, 0x0B, 0x70, 0x1B, 0x0A, 0x4B, 0x70, 0x65,
+	0x4B, 0x00, 0x27, 0x18, 0x5A, 0x08, 0x71, 0x00, 0x0A, 0x48, 0x71, 0x50, 0x88, 0x88, 0x70, 0x00,
+	0x0A, 0xC8, 0x70, 0x17, 0x71, 0x30, 0x79, 0xC2, 0x00, 0x80, 0x18, 0x59, 0x4A, 0x80, 0x18, 0xFD,
+	0xF7, 0xB8, 0xF8, 0x31, 0x79, 0x02, 0x9A, 0x89, 0x00, 0x89, 0x18, 0x8F, 0x70, 0x38, 0x0A, 0xC8,
+	0x70, 0x38, 0x46, 0x1F, 0xE0, 0x88, 0x79, 0x02, 0x09, 0x28, 0xD0, 0x4A, 0x78, 0x0B, 0x78, 0x12,
+	0x02, 0x1A, 0x43, 0x52, 0x1C, 0x0A, 0x70, 0x12, 0x0A, 0x4A, 0x70, 0x02, 0x09, 0x12, 0x01, 0x00,
+	0x07, 0x10, 0x3A, 0x00, 0x0F, 
+	0x00, 0x00, 0xF6, 0x00, 0x80, 0x02, 0x43, 0x8A, 0x71, 0x30, 0x79, 0xC2, 0x00, 0x82, 0x18, 0x48,
+	0x48, 0x10, 0x18, 0xFD, 0xF7, 0x96, 0xF8, 0x31, 0x79, 0x00, 0x20, 0x8A, 0x00, 0x02, 0x99, 0x51,
+	0x18, 0x88, 0x70, 0xC8, 0x70, 0x31, 0x79, 0x02, 0x9A, 0x89, 0x00, 0x89, 0x18, 0x08, 0x70, 0x00,
+	0x0A, 0x48, 0x70, 0x64, 0x1C, 0x30, 0x79, 0xE4, 0xB2, 0x40, 0x1C, 0x30, 0x71, 0x6D, 0x1C, 0xED,
+	0xB2, 0x06, 0x98, 0x85, 0x42, 0x00, 0xD2, 0x1F, 0xE7, 0x3D, 0x4E, 0x3C, 0x48, 0x31, 0x78, 0xC0,
+	0x78, 0x81, 0x42, 0x1B, 0xD9, 0x00, 0x25, 0x2F, 0x46, 0x15, 0xE0, 0xE8, 0x00, 0x29, 0x18, 0x34,
+	0x48, 0x08, 0x18, 0xC1, 0x79, 0x1E, 0x29, 0x0C, 0xD1, 0xFF, 0xF7, 0x8E, 0xFB, 0x00, 0x19, 0xC4,
+	0xB2, 0x02, 0x99, 0xA8, 0x00, 0x40, 0x18, 0x87, 0x70, 0x39, 0x0A, 0xC1, 0x70, 0x07, 0x70, 0x39,
+	0x0A, 0x41, 0x70, 0x6D, 0x1C, 
+	0x00, 0x00, 0xF7, 0x00, 0x80, 0xED, 0xB2, 0x30, 0x78, 0x85, 0x42, 0xE6, 0xD3, 0x2B, 0x4D, 0x29,
+	0x79, 0x01, 0x29, 0x02, 0xD9, 0x02, 0x98, 0xFF, 0xF7, 0x5A, 0xFC, 0x29, 0x79, 0x00, 0x20, 0xFD,
+	0xF7, 0x33, 0xF8, 0x28, 0x79, 0x02, 0x99, 0x82, 0x00, 0x22, 0x48, 0x05, 0xF0, 0x17, 0xFF, 0x28,
+	0x79, 0xE8, 0x70, 0x34, 0x70, 0x08, 0x98, 0xF9, 0xF7, 0x28, 0xFC, 0x08, 0x98, 0xF9, 0xF7, 0x25,
+	0xFC, 0x08, 0x98, 0xF9, 0xF7, 0x22, 0xFC, 0x08, 0x98, 0xF9, 0xF7, 0x1F, 0xFC, 0x97, 0xE4, 0xF0,
+	0xB5, 0x1A, 0x48, 0x16, 0x4F, 0xC4, 0x78, 0x1A, 0x48, 0x15, 0x4E, 0x05, 0x78, 0x00, 0x21, 0x00,
+	0x22, 0x10, 0x46, 0x0A, 0xE0, 0xC3, 0x00, 0xC3, 0x18, 0xDB, 0x19, 0xDB, 0x79, 0x5B, 0x06, 0x5B,
+	0x0E, 0x8B, 0x42, 0x01, 0xD1, 0x01, 0x22, 0x02, 0xE0, 0x40, 0x1C, 0xA0, 0x42, 0xF2, 0xDB, 0x00,
+	0x20, 0x08, 0xE0, 0xC3, 0x00, 
+	0x00, 0x00, 0xF8, 0x00, 0x80, 0xC3, 0x18, 0x9B, 0x19, 0xDB, 0x79, 0x5B, 0x06, 0x5B, 0x0E, 0x8B,
+	0x42, 0x06, 0xD0, 0x40, 0x1C, 0xA8, 0x42, 0xF4, 0xDB, 0x00, 0x2A, 0x01, 0xD1, 0xC8, 0xB2, 0x6F,
+	0xE4, 0x49, 0x1C, 0x0E, 0x29, 0xDB, 0xDD, 0x1E, 0x20, 0x6A, 0xE4, 0x00, 0x00, 0xEB, 0x03, 0x00,
+	0x20, 0x88, 0x03, 0x00, 0x20, 0xC4, 0x04, 0x00, 0x20, 0x1C, 0x01, 0x00, 0x20, 0xC0, 0x01, 0x00,
+	0x20, 0xEE, 0x00, 0x00, 0x20, 0x72, 0x0E, 0x00, 0x20, 0xFF, 0x49, 0xC8, 0x60, 0xFF, 0x48, 0x02,
+	0x78, 0x0A, 0x70, 0x42, 0x78, 0x4A, 0x70, 0x82, 0x78, 0x8A, 0x70, 0xC2, 0x78, 0xCA, 0x70, 0x00,
+	0x79, 0x08, 0x71, 0x70, 0x47, 0xF0, 0xE7, 0x70, 0xB5, 0x15, 0x46, 0x06, 0x22, 0x51, 0x43, 0x0C,
+	0x18, 0xA4, 0x1D, 0x03, 0x21, 0x28, 0x46, 0x05, 0xF0, 0x22, 0xFF, 0x41, 0x00, 0x41, 0x18, 0x69,
+	0x1A, 0x8A, 0x00, 0x89, 0x18, 
+	0x00, 0x00, 0xF9, 0x00, 0x80, 0x40, 0x00, 0x20, 0x5A, 0xC8, 0x40, 0xC0, 0x06, 0xC0, 0x0E, 0x70,
+	0xBD, 0x0A, 0x46, 0x01, 0x46, 0xEC, 0x48, 0x80, 0x68, 0xE5, 0xE7, 0xF7, 0xB5, 0x82, 0xB0, 0x07,
+	0x46, 0x0E, 0x00, 0x0A, 0xD0, 0x00, 0x25, 0x0F, 0xE0, 0x00, 0x24, 0x78, 0x19, 0x01, 0x90, 0x21,
+	0x46, 0x01, 0x98, 0xFF, 0xF7, 0xED, 0xFF, 0x00, 0x28, 0x02, 0xD0, 0x04, 0x98, 0x05, 0xB0, 0xF0,
+	0xBD, 0x64, 0x1C, 0x09, 0x2C, 0xF3, 0xD3, 0x6D, 0x1C, 0xB5, 0x42, 0xED, 0xD3, 0x00, 0x20, 0xF5,
+	0xE7, 0xF8, 0xB5, 0xDF, 0x49, 0x00, 0x91, 0x0A, 0x6A, 0x00, 0x20, 0xDE, 0x49, 0x02, 0x2A, 0x09,
+	0x78, 0x02, 0xD1, 0xC9, 0x1C, 0x89, 0x08, 0x89, 0x00, 0xD9, 0x4C, 0x40, 0x3C, 0x26, 0x6B, 0x01,
+	0x22, 0x4E, 0x43, 0x31, 0x46, 0xFF, 0xF7, 0xD1, 0xFF, 0xE7, 0x6B, 0x05, 0x46, 0x02, 0x22, 0x39,
+	0x46, 0x30, 0x46, 0xFF, 0xF7, 
+	0x00, 0x00, 0xFA, 0x00, 0x80, 0xCA, 0xFF, 0x05, 0x43, 0x00, 0x98, 0xF6, 0x19, 0x07, 0x68, 0x04,
+	0x22, 0x39, 0x46, 0x30, 0x46, 0xFF, 0xF7, 0xC1, 0xFF, 0x05, 0x43, 0xE1, 0x6A, 0xF0, 0x19, 0x00,
+	0x29, 0x00, 0xD0, 0x01, 0x21, 0x08, 0x22, 0xFF, 0xF7, 0xB8, 0xFF, 0x28, 0x43, 0xF8, 0xBD, 0x70,
+	0xB5, 0x16, 0x46, 0x06, 0x22, 0x51, 0x43, 0x0C, 0x18, 0x1D, 0x46, 0xA4, 0x1D, 0x03, 0x21, 0x30,
+	0x46, 0x05, 0xF0, 0xBD, 0xFE, 0x41, 0x00, 0x41, 0x18, 0x71, 0x1A, 0x8A, 0x00, 0x89, 0x18, 0x1F,
+	0x22, 0x8A, 0x40, 0x40, 0x00, 0x23, 0x5A, 0x93, 0x43, 0xEA, 0x06, 0xD2, 0x0E, 0x8A, 0x40, 0x1A,
+	0x43, 0x22, 0x52, 0x70, 0xBD, 0x70, 0xB5, 0xBD, 0x4B, 0xBB, 0x48, 0x1A, 0x69, 0x07, 0x24, 0x64,
+	0x06, 0x11, 0x46, 0xA1, 0x43, 0x01, 0x24, 0x64, 0x06, 0x09, 0x19, 0x19, 0x61, 0xB7, 0x4C, 0x07,
+	0x25, 0xC0, 0x3C, 0xE5, 0x60, 
+	0x00, 0x00, 0xFB, 0x00, 0x80, 0x21, 0x68, 0xC6, 0x06, 0x31, 0x43, 0x21, 0x60, 0xE1, 0x68, 0xC9,
+	0x07, 0x01, 0xD1, 0x40, 0x1E, 0xFA, 0xD2, 0xE5, 0x60, 0xB1, 0x4C, 0xB2, 0x4D, 0x00, 0x20, 0x81,
+	0x00, 0x09, 0x19, 0x09, 0x68, 0x46, 0x00, 0x09, 0xB2, 0xC9, 0x10, 0x40, 0x1C, 0xA9, 0x53, 0x09,
+	0x28, 0xF5, 0xD3, 0x1A, 0x61, 0x70, 0xBD, 0x70, 0xB5, 0x01, 0x24, 0xAA, 0x4D, 0x00, 0x23, 0x06,
+	0x46, 0x26, 0x42, 0x0C, 0xD0, 0x00, 0x29, 0x04, 0xD0, 0x5E, 0x00, 0xAE, 0x5F, 0x96, 0x42, 0x06,
+	0xDD, 0x03, 0xE0, 0x5E, 0x00, 0xAE, 0x5F, 0x96, 0x42, 0x01, 0xDA, 0x01, 0x20, 0x70, 0xBD, 0x64,
+	0x00, 0x5B, 0x1C, 0x08, 0x2B, 0xEB, 0xD3, 0x00, 0x20, 0x70, 0xBD, 0xFF, 0xB5, 0x97, 0xB0, 0x22,
+	0x9C, 0x20, 0x98, 0x16, 0x46, 0x1F, 0x46, 0x13, 0x90, 0x01, 0x2C, 0x01, 0xD0, 0x02, 0x2C, 0x05,
+	0xD1, 0xFF, 0xF7, 0x36, 0xF9, 
+	0x00, 0x00, 0xFC, 0x00, 0x80, 0x00, 0x28, 0x01, 0xD0, 0x02, 0x20, 0x00, 0xE0, 0x01, 0x20, 0x01,
+	0x90, 0x00, 0x20, 0x10, 0x90, 0x0B, 0x90, 0x05, 0x46, 0x0D, 0x90, 0x07, 0x90, 0x06, 0x90, 0x04,
+	0x90, 0x89, 0x48, 0x01, 0x22, 0x81, 0x68, 0x52, 0x02, 0x13, 0x98, 0x05, 0xF0, 0xD7, 0xFD, 0x02,
+	0x2C, 0x02, 0xD1, 0xFA, 0xF7, 0x89, 0xFD, 0x03, 0xE0, 0x01, 0x2C, 0x01, 0xD1, 0xFA, 0xF7, 0xC6,
+	0xFC, 0x86, 0x48, 0xC0, 0x38, 0x81, 0x68, 0x01, 0x22, 0xC9, 0xB2, 0xD2, 0x02, 0x89, 0x18, 0x81,
+	0x60, 0x7F, 0x48, 0x40, 0x38, 0x16, 0x90, 0x40, 0x6B, 0x11, 0x90, 0x16, 0x98, 0x81, 0x6B, 0x82,
+	0x48, 0x7B, 0x4A, 0x15, 0x92, 0x02, 0x2C, 0x07, 0xD1, 0x01, 0x22, 0x07, 0x92, 0x04, 0x92, 0x11,
+	0x9A, 0x51, 0x18, 0x10, 0x91, 0x80, 0x6A, 0x1E, 0xE0, 0x01, 0x2C, 0x13, 0xD1, 0x16, 0x99, 0x09,
+	0x6B, 0x10, 0x91, 0x74, 0x49, 
+	0x00, 0x00, 0xFD, 0x00, 0x80, 0x09, 0x78, 0x07, 0x91, 0x78, 0x49, 0x09, 0x78, 0x06, 0x91, 0x40,
+	0x6A, 0x0B, 0x90, 0x77, 0x4D, 0x10, 0x6A, 0x02, 0x28, 0x01, 0xD1, 0x04, 0x20, 0x00, 0xE0, 0x01,
+	0x20, 0x04, 0x90, 0x0A, 0xE0, 0x05, 0x2C, 0x01, 0xD0, 0x04, 0x2C, 0x06, 0xD1, 0x01, 0x21, 0x07,
+	0x91, 0x04, 0x91, 0x10, 0x91, 0x00, 0x6B, 0x6E, 0x4D, 0x0B, 0x90, 0x29, 0x46, 0x08, 0x20, 0xFB,
+	0xF7, 0x35, 0xFA, 0x66, 0x49, 0x00, 0x20, 0x40, 0x39, 0x48, 0x63, 0x00, 0x2E, 0x08, 0xD0, 0x63,
+	0x48, 0x80, 0x38, 0x41, 0x6A, 0x03, 0x22, 0x12, 0x07, 0x91, 0x43, 0x3A, 0x07, 0x11, 0x43, 0x41,
+	0x62, 0x5B, 0x48, 0x17, 0x99, 0x20, 0x30, 0x14, 0x90, 0x00, 0x29, 0x13, 0xD0, 0x5B, 0x49, 0x08,
+	0x68, 0x18, 0x9A, 0x00, 0x0A, 0x00, 0x02, 0x10, 0x43, 0x08, 0x60, 0x01, 0x2C, 0x01, 0xD0, 0x02,
+	0x2C, 0x06, 0xD1, 0xFF, 0xF7, 
+	0x00, 0x00, 0xFE, 0x00, 0x80, 0xB5, 0xF8, 0x00, 0x28, 0x02, 0xD0, 0x5A, 0x49, 0x01, 0x20, 0x08,
+	0x70, 0x00, 0x20, 0x3B, 0xE3, 0xFF, 0x20, 0x0A, 0x90, 0x00, 0x20, 0x09, 0x90, 0x40, 0xE1, 0x01,
+	0x2C, 0x01, 0xD0, 0x02, 0x2C, 0x06, 0xD1, 0xFF, 0xF7, 0xA3, 0xF8, 0x00, 0x28, 0x02, 0xD0, 0x51,
+	0x49, 0x01, 0x20, 0x08, 0x70, 0x00, 0x20, 0x1B, 0xE1, 0x01, 0x2C, 0x01, 0xD0, 0x02, 0x2C, 0x01,
+	0xD1, 0xFF, 0xF7, 0x9C, 0xF8, 0x04, 0xF0, 0xFE, 0xFC, 0x12, 0x98, 0xFA, 0xF7, 0x43, 0xFE, 0x01,
+	0x2C, 0x01, 0xD0, 0x02, 0x2C, 0x03, 0xD1, 0x14, 0x98, 0xC0, 0x7C, 0xFA, 0xF7, 0x01, 0xFE, 0x05,
+	0x2C, 0x01, 0xD0, 0x04, 0x2C, 0x09, 0xD1, 0x44, 0x48, 0x12, 0x99, 0x00, 0x78, 0xFA, 0xF7, 0x10,
+	0xFC, 0x16, 0x21, 0x48, 0x43, 0x41, 0x49, 0x08, 0x5A, 0x06, 0xE0, 0x01, 0x2C, 0x01, 0xD0, 0x02,
+	0x2C, 0x03, 0xD1, 0x12, 0x98, 
+	0x00, 0x00, 0xFF, 0x00, 0x80, 0xFF, 0xF7, 0xA4, 0xF8, 0x0D, 0x90, 0x00, 0x25, 0xDE, 0xE0, 0x01,
+	0x2C, 0x19, 0xD1, 0x30, 0x48, 0x00, 0x78, 0x40, 0x08, 0xA8, 0x42, 0x03, 0xD9, 0x16, 0x98, 0x40,
+	0x6A, 0x40, 0x1E, 0x01, 0xE0, 0x31, 0x48, 0x00, 0x78, 0x35, 0x49, 0x08, 0x70, 0x15, 0x98, 0x40,
+	0x69, 0x00, 0x28, 0x08, 0xD0, 0x32, 0x4A, 0x33, 0x49, 0x12, 0x78, 0x0C, 0x20, 0x89, 0x5C, 0x32,
+	0x4A, 0x89, 0x00, 0x89, 0x18, 0x08, 0x60, 0x00, 0x20, 0x92, 0xE0, 0x01, 0x2C, 0x12, 0xD1, 0x15,
+	0x98, 0x00, 0x6A, 0x02, 0x28, 0x05, 0xD1, 0x06, 0x98, 0x03, 0x99, 0x40, 0x19, 0xFE, 0xF7, 0xD4,
+	0xFA, 0x08, 0xE0, 0x06, 0x99, 0x27, 0x4A, 0x49, 0x19, 0x51, 0x5C, 0x27, 0x4A, 0x01, 0x20, 0x89,
+	0x00, 0x89, 0x18, 0x08, 0x60, 0x80, 0x27, 0x3E, 0x46, 0x08, 0x97, 0x18, 0x49, 0x08, 0x68, 0x08,
+	0x9A, 0x00, 0x0A, 0x00, 0x02, 
+	0x00, 0x01, 0x00, 0x00, 0x80, 0x10, 0x43, 0x08, 0x60, 0x02, 0x2C, 0x01, 0xD0, 0x01, 0x2C, 0x02,
+	0xD1, 0x0D, 0x98, 0xFF, 0xF7, 0x4F, 0xF8, 0xFF, 0xF7, 0xA5, 0xFE, 0x02, 0x2C, 0x01, 0xD0, 0x04,
+	0x2C, 0x02, 0xD1, 0x01, 0x21, 0x0B, 0x9A, 0x05, 0xE0, 0x01, 0x2C, 0x01, 0xD0, 0x05, 0x2C, 0x06,
+	0xD1, 0x0B, 0x9A, 0x00, 0x21, 0x0D, 0x98, 0xFF, 0xF7, 0xBE, 0xFE, 0x00, 0x28, 0x02, 0xD1, 0x08,
+	0x98, 0xB0, 0x43, 0x08, 0x90, 0x05, 0x49, 0x21, 0xE0, 0xC8, 0x01, 0x00, 0x20, 0xC6, 0x0E, 0x00,
+	0x20, 0x30, 0xEA, 0x00, 0x00, 0x9D, 0x00, 0x00, 0x20, 0x88, 0x90, 0x00, 0x00, 0xC0, 0x00, 0x11,
+	0x40, 0x00, 0x02, 0x11, 0x40, 0x36, 0x03, 0x00, 0x20, 0x80, 0xEA, 0x00, 0x00, 0x9E, 0x00, 0x00,
+	0x20, 0x10, 0x10, 0x00, 0x00, 0xB4, 0x01, 0x00, 0x20, 0xA7, 0x00, 0x00, 0x20, 0x00, 0xEC, 0x00,
+	0x00, 0xA5, 0x00, 0x00, 0x20, 
+	0x00, 0x01, 0x01, 0x00, 0x80, 0x00, 0xEB, 0x00, 0x00, 0x00, 0x04, 0x11, 0x40, 0x08, 0x68, 0x00,
+	0x0A, 0x00, 0x02, 0x38, 0x43, 0x08, 0x60, 0x02, 0x2C, 0x01, 0xD0, 0x01, 0x2C, 0x02, 0xD1, 0x0D,
+	0x98, 0xFF, 0xF7, 0x08, 0xF8, 0xFF, 0xF7, 0x5E, 0xFE, 0x02, 0x2C, 0x01, 0xD0, 0x04, 0x2C, 0x02,
+	0xD1, 0x00, 0x21, 0x0B, 0x9A, 0x05, 0xE0, 0x01, 0x2C, 0x01, 0xD0, 0x05, 0x2C, 0x07, 0xD1, 0x0B,
+	0x9A, 0x01, 0x21, 0x0D, 0x98, 0xFF, 0xF7, 0x77, 0xFE, 0x00, 0x28, 0x00, 0xD0, 0xB7, 0x43, 0x76,
+	0x08, 0x08, 0x98, 0x37, 0x43, 0x30, 0x43, 0x08, 0x90, 0x00, 0x2E, 0x8E, 0xD1, 0x09, 0x99, 0x88,
+	0x42, 0x00, 0xD9, 0x09, 0x90, 0x0A, 0x98, 0x87, 0x42, 0x00, 0xD2, 0x0A, 0x97, 0x03, 0x98, 0x40,
+	0x1C, 0x04, 0x99, 0x03, 0x90, 0x88, 0x42, 0x00, 0xD2, 0x67, 0xE7, 0x01, 0x2C, 0x25, 0xD1, 0x15,
+	0x98, 0x00, 0x6A, 0x02, 0x28, 
+	0x00, 0x01, 0x02, 0x00, 0x80, 0x0D, 0xD1, 0x06, 0x98, 0x40, 0x19, 0xFE, 0xF7, 0x27, 0xFA, 0x07,
+	0x98, 0x2D, 0x1D, 0x85, 0x42, 0x0F, 0xD2, 0x07, 0x99, 0x28, 0x1D, 0x88, 0x42, 0x0B, 0xD9, 0x0D,
+	0x1F, 0x09, 0xE0, 0x06, 0x98, 0x0F, 0x21, 0x40, 0x19, 0xFF, 0x4A, 0x10, 0x5C, 0xFF, 0x4A, 0x80,
+	0x00, 0x80, 0x18, 0x01, 0x60, 0x6D, 0x1C, 0xFE, 0x4A, 0xFB, 0x48, 0x12, 0x78, 0x0F, 0x21, 0x80,
+	0x5C, 0xFA, 0x4A, 0x80, 0x00, 0x80, 0x18, 0x01, 0x60, 0x00, 0xE0, 0x6D, 0x1C, 0x07, 0x98, 0x85,
+	0x42, 0x00, 0xD2, 0x1C, 0xE7, 0x01, 0x2C, 0x01, 0xD0, 0x02, 0x2C, 0x07, 0xD1, 0xFE, 0xF7, 0x88,
+	0xFF, 0x00, 0x28, 0x03, 0xD0, 0xF3, 0x49, 0x08, 0x78, 0x40, 0x1C, 0x08, 0x70, 0x02, 0x98, 0x40,
+	0x1C, 0x01, 0x99, 0x02, 0x90, 0x88, 0x42, 0x00, 0xD2, 0xDE, 0xE6, 0x02, 0x2C, 0x0E, 0xD1, 0x11,
+	0x98, 0x12, 0x99, 0x40, 0x1E, 
+	0x00, 0x01, 0x03, 0x00, 0x80, 0x81, 0x42, 0x09, 0xD1, 0x09, 0x99, 0x0A, 0x98, 0x40, 0x18, 0x13,
+	0x99, 0x40, 0x08, 0x48, 0x70, 0xFF, 0x20, 0x0A, 0x90, 0x00, 0x20, 0x09, 0x90, 0x12, 0x98, 0x40,
+	0x1C, 0x10, 0x99, 0x12, 0x90, 0x88, 0x42, 0x00, 0xD2, 0xB9, 0xE6, 0x02, 0x2C, 0x06, 0xD1, 0x09,
+	0x99, 0x0A, 0x98, 0x40, 0x18, 0x13, 0x99, 0x40, 0x08, 0x88, 0x70, 0xA2, 0xE6, 0x01, 0x2C, 0x06,
+	0xD1, 0x09, 0x99, 0x0A, 0x98, 0x40, 0x18, 0x13, 0x99, 0x40, 0x08, 0x08, 0x70, 0x99, 0xE6, 0x04,
+	0x2C, 0x06, 0xD1, 0x09, 0x99, 0x0A, 0x98, 0x40, 0x18, 0x13, 0x99, 0x40, 0x08, 0x08, 0x71, 0x97,
+	0xE6, 0x05, 0x2C, 0xFC, 0xD1, 0x09, 0x99, 0x0A, 0x98, 0x40, 0x18, 0x13, 0x99, 0x40, 0x08, 0xC8,
+	0x70, 0x8E, 0xE6, 0x01, 0x2C, 0x01, 0xD0, 0x02, 0x2C, 0x01, 0xD1, 0xFE, 0xF7, 0x3F, 0xFF, 0x00,
+	0x20, 0x05, 0x90, 0xB0, 0xE1, 
+	0x00, 0x01, 0x04, 0x00, 0x80, 0x04, 0xF0, 0x9E, 0xFB, 0x17, 0x98, 0x00, 0x28, 0x2D, 0xD1, 0x02,
+	0x2C, 0x0F, 0xD1, 0x12, 0x99, 0x11, 0x98, 0x81, 0x42, 0xC7, 0x49, 0x08, 0x68, 0x04, 0xD2, 0x13,
+	0x9A, 0x00, 0x0A, 0x00, 0x02, 0x52, 0x78, 0x1E, 0xE0, 0x13, 0x9A, 0x00, 0x0A, 0x00, 0x02, 0x92,
+	0x78, 0x19, 0xE0, 0x01, 0x2C, 0x06, 0xD1, 0xC0, 0x49, 0x08, 0x68, 0x13, 0x9A, 0x00, 0x0A, 0x00,
+	0x02, 0x12, 0x78, 0x10, 0xE0, 0x04, 0x2C, 0x06, 0xD1, 0xBB, 0x49, 0x08, 0x68, 0x13, 0x9A, 0x00,
+	0x0A, 0x00, 0x02, 0x12, 0x79, 0x07, 0xE0, 0x05, 0x2C, 0x07, 0xD1, 0xB7, 0x49, 0x08, 0x68, 0x13,
+	0x9A, 0x00, 0x0A, 0xD2, 0x78, 0x00, 0x02, 0x10, 0x43, 0x08, 0x60, 0x12, 0x98, 0xFA, 0xF7, 0xB2,
+	0xFC, 0x01, 0x2C, 0x01, 0xD0, 0x02, 0x2C, 0x03, 0xD1, 0x14, 0x98, 0xC0, 0x7C, 0xFA, 0xF7, 0x70,
+	0xFC, 0x05, 0x2C, 0x01, 0xD0, 
+	0x00, 0x01, 0x05, 0x00, 0x80, 0x04, 0x2C, 0x09, 0xD1, 0xAC, 0x48, 0x12, 0x99, 0x00, 0x78, 0xFA,
+	0xF7, 0x7F, 0xFA, 0x16, 0x21, 0x48, 0x43, 0xAA, 0x49, 0x08, 0x5A, 0x10, 0xE0, 0x01, 0x2C, 0x01,
+	0xD0, 0x02, 0x2C, 0x0D, 0xD1, 0x12, 0x98, 0xFE, 0xF7, 0x13, 0xFF, 0x0D, 0x90, 0x01, 0x2C, 0x07,
+	0xD1, 0x15, 0x98, 0x40, 0x69, 0x01, 0x28, 0x03, 0xD1, 0x0D, 0x98, 0x21, 0x02, 0x08, 0x43, 0x0D,
+	0x90, 0x00, 0x25, 0x4A, 0xE1, 0x01, 0x2C, 0x19, 0xD1, 0x9E, 0x48, 0x00, 0x78, 0x40, 0x08, 0xA8,
+	0x42, 0x03, 0xD9, 0x16, 0x98, 0x40, 0x6A, 0x40, 0x1E, 0x01, 0xE0, 0x9B, 0x48, 0x00, 0x78, 0x94,
+	0x49, 0x08, 0x70, 0x15, 0x98, 0x40, 0x69, 0x00, 0x28, 0x08, 0xD0, 0x91, 0x4A, 0x8E, 0x48, 0x12,
+	0x78, 0x0C, 0x21, 0x80, 0x5C, 0x8D, 0x4A, 0x80, 0x00, 0x80, 0x18, 0x01, 0x60, 0x00, 0x20, 0xDF,
+	0xE0, 0x01, 0x2C, 0x12, 0xD1, 
+	0x00, 0x01, 0x06, 0x00, 0x80, 0x15, 0x98, 0x00, 0x6A, 0x02, 0x28, 0x05, 0xD1, 0x06, 0x98, 0x03,
+	0x99, 0x40, 0x19, 0xFE, 0xF7, 0x39, 0xF9, 0x08, 0xE0, 0x06, 0x99, 0x83, 0x4A, 0x49, 0x19, 0x51,
+	0x5C, 0x82, 0x4A, 0x01, 0x20, 0x89, 0x00, 0x89, 0x18, 0x08, 0x60, 0x88, 0x4E, 0x08, 0x20, 0x31,
+	0x46, 0xFA, 0xF7, 0xFC, 0xFF, 0x02, 0x2C, 0x01, 0xD0, 0x01, 0x2C, 0x08, 0xD1, 0x7E, 0x48, 0x40,
+	0x38, 0x46, 0x63, 0x15, 0x99, 0x49, 0x69, 0x01, 0x29, 0x01, 0xD0, 0x00, 0x21, 0x41, 0x63, 0x10,
+	0x26, 0x00, 0x20, 0x0E, 0x90, 0x02, 0x2C, 0x01, 0xD0, 0x01, 0x2C, 0x02, 0xD1, 0x0D, 0x98, 0xFE,
+	0xF7, 0xA9, 0xFE, 0xFF, 0xF7, 0xFF, 0xFC, 0x01, 0x22, 0x00, 0x20, 0x0D, 0x99, 0x11, 0x42, 0x23,
+	0xD0, 0x71, 0x4B, 0x81, 0x00, 0x40, 0x3B, 0xC9, 0x18, 0x8C, 0x46, 0x49, 0x69, 0x09, 0x04, 0x09,
+	0x0E, 0x02, 0x2C, 0x01, 0xD0, 
+	0x00, 0x01, 0x07, 0x00, 0x80, 0x04, 0x2C, 0x06, 0xD1, 0x71, 0x4F, 0x43, 0x00, 0xFB, 0x5E, 0x0B,
+	0x9F, 0xBB, 0x42, 0x0B, 0xDA, 0x09, 0xE0, 0x01, 0x2C, 0x01, 0xD0, 0x05, 0x2C, 0x06, 0xD1, 0x6C,
+	0x4F, 0x43, 0x00, 0xFB, 0x5E, 0x0B, 0x9F, 0xBB, 0x42, 0x00, 0xDD, 0xB1, 0x43, 0x73, 0x08, 0x0B,
+	0x43, 0x19, 0x02, 0x19, 0x43, 0x63, 0x46, 0x59, 0x61, 0x52, 0x00, 0x40, 0x1C, 0x08, 0x28, 0xD4,
+	0xD3, 0x02, 0x2C, 0x01, 0xD0, 0x01, 0x2C, 0x14, 0xD1, 0x15, 0x98, 0x40, 0x69, 0x01, 0x28, 0x10,
+	0xD1, 0x59, 0x4A, 0x40, 0x3A, 0x50, 0x6B, 0x5E, 0x49, 0x10, 0x23, 0xCB, 0x5E, 0x00, 0x04, 0x0B,
+	0x99, 0x00, 0x0E, 0x8B, 0x42, 0x00, 0xDD, 0xB0, 0x43, 0x71, 0x08, 0x01, 0x43, 0x08, 0x02, 0x08,
+	0x43, 0x50, 0x63, 0x0E, 0x98, 0x76, 0x08, 0x40, 0x1C, 0x0E, 0x90, 0x05, 0x28, 0xAA, 0xD3, 0x02,
+	0x2C, 0x1F, 0xD1, 0x01, 0x20, 
+	0x00, 0x01, 0x08, 0x00, 0x80, 0x0C, 0x90, 0x00, 0x20, 0x4B, 0x4E, 0x52, 0x4F, 0x40, 0x3E, 0x0F,
+	0x90, 0x0C, 0x99, 0x0D, 0x98, 0x08, 0x42, 0x0B, 0xD0, 0x0F, 0x98, 0x80, 0x00, 0x80, 0x19, 0x40,
+	0x69, 0x39, 0x78, 0xC3, 0xB2, 0x12, 0x98, 0x0F, 0x9A, 0x41, 0x18, 0x13, 0x98, 0xFF, 0xF7, 0x7F,
+	0xFC, 0x0C, 0x98, 0x40, 0x00, 0x0C, 0x90, 0x0F, 0x98, 0x40, 0x1C, 0x0F, 0x90, 0x09, 0x28, 0xE7,
+	0xD3, 0x3C, 0xE0, 0x01, 0x2C, 0x21, 0xD1, 0x01, 0x20, 0x0C, 0x90, 0x00, 0x20, 0x3A, 0x4E, 0x41,
+	0x4F, 0x40, 0x3E, 0x0F, 0x90, 0x0C, 0x99, 0x0D, 0x98, 0x08, 0x42, 0x0D, 0xD0, 0x0F, 0x98, 0x80,
+	0x00, 0x80, 0x19, 0x40, 0x69, 0x39, 0x78, 0xC3, 0xB2, 0x05, 0x98, 0x0F, 0x9A, 0x40, 0x18, 0x03,
+	0x99, 0x41, 0x18, 0x13, 0x98, 0xFF, 0xF7, 0x5B, 0xFC, 0x0C, 0x98, 0x40, 0x00, 0x0C, 0x90, 0x0F,
+	0x98, 0x40, 0x1C, 0x0F, 0x90, 
+	0x00, 0x01, 0x09, 0x00, 0x80, 0x09, 0x28, 0xE5, 0xD3, 0x18, 0xE0, 0x05, 0x2C, 0x01, 0xD0, 0x04,
+	0x2C, 0x14, 0xD1, 0x00, 0x20, 0x28, 0x4E, 0x2F, 0x4F, 0x40, 0x3E, 0x0F, 0x90, 0x80, 0x00, 0x80,
+	0x19, 0x40, 0x69, 0x39, 0x78, 0xC3, 0xB2, 0x12, 0x98, 0x0F, 0x9A, 0x41, 0x18, 0x13, 0x98, 0xFF,
+	0xF7, 0x3E, 0xFC, 0x0F, 0x98, 0x40, 0x1C, 0x0F, 0x90, 0x08, 0x28, 0xEF, 0xD3, 0x03, 0x98, 0x40,
+	0x1C, 0x04, 0x99, 0x03, 0x90, 0x88, 0x42, 0x00, 0xD2, 0x1A, 0xE7, 0x01, 0x2C, 0x44, 0xD1, 0x15,
+	0x98, 0x00, 0x6A, 0x02, 0x28, 0x10, 0xD1, 0x06, 0x98, 0x40, 0x19, 0xFE, 0xF7, 0x3F, 0xF8, 0x05,
+	0x98, 0x2D, 0x1D, 0x00, 0x1D, 0x05, 0x90, 0x07, 0x98, 0x85, 0x42, 0x12, 0xD2, 0x07, 0x99, 0x28,
+	0x1D, 0x88, 0x42, 0x0E, 0xD9, 0x0D, 0x1F, 0x0C, 0xE0, 0x06, 0x99, 0x0B, 0x4A, 0x49, 0x19, 0x51,
+	0x5C, 0x0A, 0x4A, 0x0F, 0x20, 
+	0x00, 0x01, 0x0A, 0x00, 0x80, 0x89, 0x00, 0x89, 0x18, 0x08, 0x60, 0x05, 0x98, 0x6D, 0x1C, 0x40,
+	0x1C, 0x05, 0x90, 0x07, 0x4A, 0x04, 0x48, 0x12, 0x78, 0x0F, 0x21, 0x80, 0x5C, 0x03, 0x4A, 0x80,
+	0x00, 0x80, 0x18, 0x01, 0x60, 0x19, 0xE0, 0x00, 0x00, 0x00, 0xEB, 0x00, 0x00, 0x00, 0x04, 0x11,
+	0x40, 0xA5, 0x00, 0x00, 0x20, 0xB4, 0x01, 0x00, 0x20, 0xC0, 0x00, 0x11, 0x40, 0xA7, 0x00, 0x00,
+	0x20, 0x00, 0xEC, 0x00, 0x00, 0x9D, 0x00, 0x00, 0x20, 0x9E, 0x00, 0x00, 0x20, 0x10, 0x10, 0x00,
+	0x00, 0x36, 0x03, 0x00, 0x20, 0xA0, 0x00, 0x00, 0x20, 0x6D, 0x1C, 0x07, 0x98, 0x85, 0x42, 0x00,
+	0xD2, 0xB0, 0xE6, 0x12, 0x98, 0x40, 0x1C, 0x10, 0x99, 0x12, 0x90, 0x88, 0x42, 0x00, 0xD2, 0x49,
+	0xE6, 0x01, 0x2C, 0x01, 0xD0, 0x02, 0x2C, 0x07, 0xD1, 0xFE, 0xF7, 0x7A, 0xFD, 0x00, 0x28, 0x03,
+	0xD0, 0xC3, 0x49, 0x08, 0x78, 
+	0x00, 0x01, 0x0B, 0x00, 0x80, 0x40, 0x1C, 0x08, 0x70, 0x02, 0x98, 0x40, 0x1C, 0x01, 0x99, 0x02,
+	0x90, 0x88, 0x42, 0x00, 0xD2, 0x2D, 0xE6, 0x02, 0x2C, 0x07, 0xD1, 0x13, 0x98, 0x41, 0x78, 0xBD,
+	0x48, 0x41, 0x70, 0x13, 0x99, 0x89, 0x78, 0x81, 0x70, 0x13, 0xE0, 0x01, 0x2C, 0x04, 0xD1, 0x13,
+	0x98, 0x01, 0x78, 0xB8, 0x48, 0x01, 0x70, 0x0C, 0xE0, 0x04, 0x2C, 0x04, 0xD1, 0x13, 0x98, 0x01,
+	0x79, 0xB4, 0x48, 0x01, 0x71, 0x05, 0xE0, 0x05, 0x2C, 0x03, 0xD1, 0x13, 0x98, 0xC1, 0x78, 0xB1,
+	0x48, 0xC1, 0x70, 0x21, 0x99, 0x13, 0x98, 0x00, 0xF0, 0x23, 0xF9, 0x1B, 0xB0, 0xF0, 0xBD, 0x0E,
+	0xB5, 0x01, 0x22, 0x6B, 0x46, 0x07, 0xC3, 0x00, 0x22, 0x11, 0x46, 0x10, 0x46, 0x13, 0x46, 0xFF,
+	0xF7, 0xFC, 0xFB, 0x0E, 0xBD, 0x3E, 0xB5, 0x05, 0x46, 0x10, 0x46, 0x01, 0x22, 0x01, 0x93, 0x00,
+	0x90, 0x0B, 0x46, 0x02, 0x92, 
+	0x00, 0x01, 0x0C, 0x00, 0x80, 0x29, 0x46, 0x10, 0x46, 0xFF, 0xF7, 0xEF, 0xFB, 0x3E, 0xBD, 0x0E,
+	0xB5, 0x02, 0x22, 0x6B, 0x46, 0x07, 0xC3, 0x00, 0x22, 0x11, 0x46, 0x10, 0x46, 0x13, 0x46, 0xFF,
+	0xF7, 0xE4, 0xFB, 0x0E, 0xBD, 0xF7, 0xB5, 0x84, 0xB0, 0x07, 0x46, 0x0E, 0x46, 0xFE, 0xF7, 0x20,
+	0xFD, 0x00, 0x28, 0x01, 0xD0, 0x02, 0x20, 0x00, 0xE0, 0x01, 0x20, 0x01, 0x90, 0x96, 0x48, 0x81,
+	0x68, 0x01, 0x22, 0xC9, 0xB2, 0xD2, 0x02, 0x89, 0x18, 0x81, 0x60, 0x94, 0x4C, 0x39, 0x46, 0x20,
+	0x78, 0xFA, 0xF7, 0x9E, 0xF8, 0x16, 0x21, 0x92, 0x4D, 0x48, 0x43, 0x28, 0x5A, 0x03, 0x90, 0x39,
+	0x46, 0x20, 0x78, 0xFA, 0xF7, 0x95, 0xF8, 0x16, 0x21, 0x48, 0x43, 0x40, 0x19, 0x80, 0x78, 0x80,
+	0x24, 0x25, 0x46, 0x02, 0x90, 0x88, 0x49, 0xC0, 0x31, 0x08, 0x68, 0x00, 0x0A, 0x00, 0x02, 0x20,
+	0x43, 0x08, 0x60, 0xFE, 0xF7, 
+	0x00, 0x01, 0x0D, 0x00, 0x80, 0xF5, 0xFC, 0x00, 0x28, 0x02, 0xD0, 0x81, 0x49, 0x01, 0x20, 0x08,
+	0x70, 0x00, 0x27, 0x13, 0xE0, 0xFE, 0xF7, 0xF2, 0xFC, 0x02, 0x2E, 0x01, 0xD0, 0x01, 0x2E, 0x02,
+	0xD1, 0x03, 0x98, 0xFE, 0xF7, 0x07, 0xFD, 0xFF, 0xF7, 0x5D, 0xFB, 0xFE, 0xF7, 0xE1, 0xFC, 0x00,
+	0x28, 0x03, 0xD0, 0x77, 0x49, 0x08, 0x78, 0x40, 0x1C, 0x08, 0x70, 0x7F, 0x1C, 0x01, 0x98, 0x87,
+	0x42, 0xE8, 0xD3, 0x00, 0x22, 0x77, 0x4B, 0x01, 0x21, 0x10, 0x46, 0x03, 0x9F, 0x0F, 0x42, 0x02,
+	0xD0, 0x47, 0x00, 0xDF, 0x5F, 0xBA, 0x18, 0x49, 0x00, 0x40, 0x1C, 0x08, 0x28, 0xF5, 0xD3, 0x02,
+	0x98, 0x71, 0x49, 0x40, 0x00, 0x08, 0x5E, 0x06, 0x99, 0x50, 0x43, 0xC0, 0x12, 0x88, 0x42, 0x01,
+	0xDA, 0x02, 0x2E, 0x03, 0xD0, 0x88, 0x42, 0x02, 0xDD, 0x01, 0x2E, 0x00, 0xD1, 0xAC, 0x43, 0x6D,
+	0x08, 0x2C, 0x43, 0x00, 0x2D, 
+	0x00, 0x01, 0x0E, 0x00, 0x80, 0xB6, 0xD1, 0xE0, 0xB2, 0x07, 0xB0, 0xF0, 0xBD, 0x70, 0xB5, 0xFA,
+	0xF7, 0x5D, 0xF8, 0x66, 0x48, 0x00, 0x25, 0x00, 0x78, 0x40, 0x08, 0x84, 0x08, 0xA4, 0x00, 0x28,
+	0x46, 0xFA, 0xF7, 0x58, 0xFA, 0x20, 0x46, 0xFA, 0xF7, 0x07, 0xFA, 0x61, 0x48, 0xC0, 0x7C, 0xFA,
+	0xF7, 0x17, 0xFA, 0x5F, 0x48, 0x20, 0x38, 0x01, 0x6A, 0x5E, 0x48, 0x02, 0x29, 0x05, 0xD1, 0x00,
+	0x78, 0x00, 0x21, 0x00, 0x19, 0xFD, 0xF7, 0x20, 0xFF, 0x08, 0xE0, 0x00, 0x78, 0x5A, 0x4A, 0x00,
+	0x19, 0x10, 0x5C, 0x5A, 0x4A, 0x01, 0x21, 0x80, 0x00, 0x80, 0x18, 0x01, 0x60, 0x58, 0x48, 0x42,
+	0x6A, 0x01, 0x21, 0x28, 0x46, 0xFF, 0xF7, 0x5E, 0xFF, 0x70, 0xBD, 0x10, 0xB5, 0xFA, 0xF7, 0xEC,
+	0xF8, 0x4F, 0x48, 0x60, 0x38, 0x40, 0x6B, 0x44, 0x08, 0x20, 0x46, 0xFA, 0xF7, 0xDD, 0xF9, 0x20,
+	0x46, 0xFA, 0xF7, 0x28, 0xFA, 
+	0x00, 0x01, 0x0F, 0x00, 0x80, 0x44, 0x48, 0x00, 0x68, 0x00, 0x06, 0x80, 0x0F, 0x03, 0xD0, 0x48,
+	0x48, 0xC0, 0x7C, 0xFA, 0xF7, 0xE5, 0xF9, 0x4A, 0x48, 0x82, 0x6A, 0x02, 0x21, 0x20, 0x46, 0xFF,
+	0xF7, 0x41, 0xFF, 0x10, 0xBD, 0x10, 0xB5, 0xFA, 0xF7, 0xCF, 0xF8, 0x41, 0x48, 0x60, 0x38, 0x41,
+	0x6B, 0x80, 0x6B, 0x40, 0x08, 0x0C, 0x18, 0x20, 0x46, 0xFA, 0xF7, 0xBE, 0xF9, 0x20, 0x46, 0xFA,
+	0xF7, 0x09, 0xFA, 0x35, 0x48, 0x00, 0x68, 0x00, 0x06, 0x80, 0x0F, 0x03, 0xD0, 0x38, 0x48, 0xC0,
+	0x7C, 0xFA, 0xF7, 0xC6, 0xF9, 0x3A, 0x48, 0x82, 0x6A, 0x02, 0x21, 0x20, 0x46, 0xFF, 0xF7, 0x22,
+	0xFF, 0x10, 0xBD, 0x00, 0x28, 0x07, 0xD0, 0x01, 0x28, 0x03, 0xD0, 0x02, 0x28, 0x03, 0xD1, 0x35,
+	0x48, 0x70, 0x47, 0x35, 0x48, 0x70, 0x47, 0x35, 0x48, 0x70, 0x47, 0x10, 0xB5, 0x01, 0x24, 0x64,
+	0x02, 0x22, 0x46, 0x33, 0x49, 
+	0x00, 0x01, 0x10, 0x00, 0x80, 0x31, 0x48, 0x05, 0xF0, 0xE9, 0xF8, 0x22, 0x46, 0x31, 0x49, 0x2E,
+	0x48, 0x05, 0xF0, 0xE4, 0xF8, 0x22, 0x46, 0x30, 0x49, 0x2A, 0x48, 0x05, 0xF0, 0xDF, 0xF8, 0x10,
+	0xBD, 0xF3, 0xB5, 0x1C, 0x4F, 0x81, 0xB0, 0x29, 0x4A, 0xB8, 0x68, 0x01, 0x9D, 0x90, 0x42, 0x01,
+	0xD1, 0x27, 0x48, 0x08, 0xE0, 0x24, 0x4A, 0x90, 0x42, 0x01, 0xD1, 0x26, 0x48, 0x03, 0xE0, 0x21,
+	0x4A, 0x90, 0x42, 0x01, 0xD1, 0x24, 0x48, 0xC4, 0x09, 0x26, 0x1D, 0x00, 0x29, 0x09, 0xD0, 0x06,
+	0xE0, 0xA0, 0xB2, 0x29, 0x46, 0xFA, 0x68, 0xF8, 0xF7, 0xE3, 0xFD, 0x80, 0x35, 0x64, 0x1C, 0xB4,
+	0x42, 0xF6, 0xD3, 0x1A, 0x49, 0x01, 0x22, 0xB8, 0x68, 0x52, 0x02, 0x88, 0x42, 0x02, 0xD1, 0x17,
+	0x48, 0x01, 0x99, 0x04, 0xE0, 0x14, 0x49, 0x88, 0x42, 0x04, 0xD1, 0x13, 0x48, 0x01, 0x99, 0x05,
+	0xF0, 0xAD, 0xF8, 0xFE, 0xBD, 
+	0x00, 0x01, 0x11, 0x00, 0x80, 0x0F, 0x49, 0x88, 0x42, 0xFB, 0xD1, 0x0E, 0x48, 0x01, 0x99, 0xF6,
+	0xE7, 0xB4, 0x01, 0x00, 0x20, 0xC8, 0x01, 0x00, 0x20, 0x00, 0x00, 0x11, 0x40, 0xA7, 0x00, 0x00,
+	0x20, 0x00, 0xEC, 0x00, 0x00, 0x36, 0x03, 0x00, 0x20, 0x30, 0xDE, 0x00, 0x00, 0x9D, 0x00, 0x00,
+	0x20, 0x50, 0xEA, 0x00, 0x00, 0x9E, 0x00, 0x00, 0x20, 0x00, 0xEB, 0x00, 0x00, 0x00, 0x04, 0x11,
+	0x40, 0x80, 0xEA, 0x00, 0x00, 0x02, 0x12, 0x00, 0x20, 0x64, 0x10, 0x00, 0x20, 0xC6, 0x0E, 0x00,
+	0x20, 0x80, 0xEE, 0x00, 0x00, 0x00, 0xF1, 0x00, 0x00, 0x80, 0xF3, 0x00, 0x00, 0xF7, 0x48, 0x40,
+	0x69, 0xF7, 0x49, 0x08, 0x70, 0xF7, 0x49, 0x80, 0x20, 0xC8, 0x71, 0xF4, 0x48, 0x40, 0x30, 0x40,
+	0x8B, 0x80, 0x07, 0xC0, 0x0F, 0x08, 0x72, 0x70, 0x47, 0xFE, 0xB5, 0x00, 0x20, 0xF1, 0x49, 0x05,
+	0x46, 0x48, 0x70, 0x01, 0x90, 
+	0x00, 0x01, 0x12, 0x00, 0x80, 0xF0, 0x48, 0xF1, 0x4E, 0x00, 0x90, 0x38, 0xE0, 0x00, 0x24, 0x2E,
+	0xE0, 0x00, 0x20, 0x21, 0x46, 0x16, 0x22, 0x51, 0x43, 0xED, 0x4A, 0x53, 0x5A, 0x8F, 0x18, 0xB9,
+	0x78, 0x9C, 0x46, 0x8E, 0x46, 0x02, 0x46, 0x63, 0x46, 0xD3, 0x40, 0xDB, 0x07, 0x08, 0xD0, 0x33,
+	0x6A, 0x6B, 0x43, 0xB9, 0x18, 0x09, 0x79, 0x5B, 0x18, 0xE6, 0x49, 0x5B, 0x00, 0xCB, 0x5E, 0x18,
+	0x18, 0x52, 0x1C, 0xD2, 0xB2, 0x08, 0x2A, 0xEE, 0xD3, 0x71, 0x46, 0x05, 0xF0, 0xC2, 0xF8, 0x00,
+	0x99, 0x08, 0x22, 0x8A, 0x5E, 0x00, 0xB2, 0x82, 0x42, 0x03, 0xDB, 0x0A, 0x22, 0x8A, 0x5E, 0x82,
+	0x42, 0x03, 0xDD, 0xD8, 0x48, 0x01, 0x21, 0x41, 0x70, 0xFE, 0xBD, 0x64, 0x1C, 0xE4, 0xB2, 0x30,
+	0x6B, 0xA0, 0x42, 0xCD, 0xD8, 0x01, 0x98, 0x01, 0x28, 0xF6, 0xD0, 0x6D, 0x1C, 0xED, 0xB2, 0xF0,
+	0x69, 0xA8, 0x42, 0xC3, 0xD8, 
+	0x00, 0x01, 0x13, 0x00, 0x80, 0xFE, 0xBD, 0xF8, 0xB5, 0x00, 0x20, 0xCE, 0x49, 0x05, 0x46, 0x88,
+	0x70, 0xCE, 0x4E, 0x00, 0x90, 0x37, 0xE0, 0x00, 0x23, 0x2D, 0xE0, 0x19, 0x46, 0x16, 0x20, 0xCC,
+	0x4F, 0x41, 0x43, 0x78, 0x5A, 0xCC, 0x4C, 0x86, 0x46, 0x62, 0x0C, 0x00, 0x20, 0xC9, 0x19, 0x8C,
+	0x46, 0x71, 0x46, 0xC1, 0x40, 0xC9, 0x07, 0x0E, 0xD0, 0x31, 0x6A, 0x67, 0x46, 0x69, 0x43, 0x3F,
+	0x18, 0x3F, 0x79, 0xC9, 0x19, 0xC3, 0x4F, 0x49, 0x00, 0x79, 0x5E, 0xA1, 0x42, 0x00, 0xDD, 0x0C,
+	0x46, 0x91, 0x42, 0x00, 0xDA, 0x0A, 0x46, 0x40, 0x1C, 0xC0, 0xB2, 0x08, 0x28, 0xE8, 0xD3, 0xBA,
+	0x49, 0xA0, 0x1A, 0x89, 0x89, 0x80, 0xB2, 0x81, 0x42, 0x03, 0xD2, 0xB6, 0x48, 0x01, 0x21, 0x81,
+	0x70, 0xF8, 0xBD, 0x5B, 0x1C, 0xDB, 0xB2, 0x30, 0x6B, 0x98, 0x42, 0xCE, 0xD8, 0x00, 0x98, 0x01,
+	0x28, 0xF6, 0xD0, 0x6D, 0x1C, 
+	0x00, 0x01, 0x14, 0x00, 0x80, 0xED, 0xB2, 0xF0, 0x69, 0xA8, 0x42, 0xC4, 0xD8, 0xF8, 0xBD, 0xF0,
+	0xB5, 0x00, 0x21, 0xAC, 0x48, 0x85, 0xB0, 0xC1, 0x70, 0xAC, 0x48, 0x0E, 0x46, 0x40, 0x30, 0x02,
+	0x91, 0x01, 0x6A, 0xAE, 0x48, 0x02, 0x29, 0x00, 0x78, 0x02, 0xD1, 0xC0, 0x1C, 0x80, 0x08, 0x80,
+	0x00, 0x00, 0x90, 0xA6, 0x48, 0x04, 0x90, 0x00, 0x6B, 0x00, 0x99, 0x48, 0x43, 0x01, 0x90, 0xA9,
+	0x49, 0xA7, 0x48, 0x00, 0x25, 0x08, 0x60, 0x1A, 0xE0, 0x28, 0x46, 0x00, 0x99, 0x05, 0xF0, 0x37,
+	0xF8, 0x16, 0x21, 0x48, 0x43, 0x9E, 0x49, 0x0F, 0x5A, 0x02, 0x98, 0x00, 0x24, 0x40, 0x19, 0x03,
+	0x90, 0x38, 0x46, 0xE0, 0x40, 0xC0, 0x07, 0x06, 0xD0, 0x21, 0x46, 0x03, 0x98, 0xFF, 0xF7, 0x10,
+	0xF9, 0x00, 0x28, 0x00, 0xD1, 0x76, 0x1C, 0x64, 0x1C, 0x09, 0x2C, 0xF1, 0xD3, 0x6D, 0x1C, 0x01,
+	0x98, 0x85, 0x42, 0xE1, 0xD3, 
+	0x00, 0x01, 0x15, 0x00, 0x80, 0x04, 0x98, 0x80, 0x6A, 0x40, 0x08, 0xB0, 0x42, 0x02, 0xD2, 0x8D,
+	0x48, 0x01, 0x21, 0xC1, 0x70, 0x05, 0xB0, 0xF0, 0xBD, 0x8A, 0x49, 0x01, 0x20, 0x88, 0x75, 0x70,
+	0x47, 0x88, 0x49, 0x10, 0xB5, 0x24, 0x31, 0x90, 0x4A, 0x09, 0x5C, 0x11, 0x70, 0x85, 0x49, 0x8F,
+	0x4A, 0x27, 0x31, 0x09, 0x5C, 0x11, 0x70, 0x83, 0x49, 0x8D, 0x4A, 0x2A, 0x31, 0x09, 0x5C, 0x11,
+	0x70, 0xFF, 0xF7, 0x8F, 0xFE, 0x87, 0x49, 0x08, 0x60, 0x10, 0xBD, 0xF7, 0xB5, 0x0F, 0x46, 0x15,
+	0x46, 0x88, 0x4C, 0x03, 0x20, 0xF8, 0xF7, 0x3F, 0xFD, 0xFA, 0xF7, 0xA9, 0xFB, 0x00, 0x20, 0xFA,
+	0xF7, 0xCD, 0xFB, 0x80, 0x4E, 0x7E, 0x48, 0x30, 0x60, 0x01, 0x78, 0x7F, 0x4A, 0x11, 0x70, 0x41,
+	0x78, 0x7E, 0x4A, 0x11, 0x70, 0x80, 0x78, 0x7E, 0x49, 0x08, 0x70, 0xFC, 0xF7, 0x1B, 0xFE, 0xFC,
+	0xF7, 0xEA, 0xFD, 0x03, 0x20, 
+	0x00, 0x01, 0x16, 0x00, 0x80, 0x00, 0x99, 0xF8, 0xF7, 0x16, 0xFD, 0xFA, 0xF7, 0xB7, 0xFB, 0x37,
+	0x60, 0x6C, 0x4E, 0x30, 0x78, 0x00, 0x28, 0x01, 0xD1, 0x01, 0x21, 0x00, 0xE0, 0x00, 0x21, 0x20,
+	0x46, 0xFF, 0xF7, 0x5D, 0xFD, 0xF9, 0xF7, 0x52, 0xFE, 0xFA, 0xF7, 0x96, 0xF8, 0xFA, 0xF7, 0xE4,
+	0xF9, 0x00, 0x28, 0xFB, 0xD0, 0x70, 0x48, 0x00, 0x68, 0xFC, 0xF7, 0x93, 0xFD, 0x30, 0x78, 0x00,
+	0x28, 0x01, 0xD1, 0x01, 0x21, 0x00, 0xE0, 0x00, 0x21, 0x20, 0x46, 0xFF, 0xF7, 0x60, 0xFD, 0xF9,
+	0xF7, 0xFB, 0xFE, 0x03, 0x20, 0xFA, 0xF7, 0x83, 0xF9, 0xFA, 0xF7, 0xCE, 0xF9, 0x00, 0x28, 0xFB,
+	0xD0, 0x66, 0x48, 0x01, 0x68, 0x03, 0x20, 0xFC, 0xF7, 0x2C, 0xFB, 0xE9, 0x09, 0x06, 0x22, 0x23,
+	0x46, 0x63, 0x48, 0x01, 0xF0, 0xBE, 0xFA, 0x05, 0x23, 0xDB, 0x01, 0x15, 0x27, 0x7F, 0x01, 0x20,
+	0x22, 0x5F, 0x4E, 0x00, 0x20, 
+	0x00, 0x01, 0x17, 0x00, 0x80, 0x19, 0x18, 0x71, 0x5C, 0x21, 0x54, 0x40, 0x1C, 0x90, 0x42, 0xF9,
+	0xD3, 0x5C, 0x49, 0x00, 0x20, 0x0B, 0x5C, 0x16, 0x18, 0x40, 0x1C, 0xA3, 0x55, 0x4A, 0x28, 0xF9,
+	0xD3, 0xE8, 0x19, 0xC1, 0x09, 0xC9, 0x32, 0xE3, 0x1D, 0xD2, 0x09, 0xF9, 0x33, 0x20, 0x46, 0x01,
+	0xF0, 0xA0, 0xFA, 0xFE, 0xBD, 0xF8, 0xB5, 0x05, 0x46, 0x00, 0x06, 0x01, 0xD5, 0x00, 0x20, 0x04,
+	0xE0, 0xFF, 0xF7, 0x86, 0xF8, 0x0B, 0x21, 0x08, 0x40, 0x48, 0x40, 0x28, 0x43, 0x04, 0x46, 0x45,
+	0x48, 0x43, 0x4E, 0x06, 0x60, 0x39, 0x48, 0xC1, 0x6B, 0x01, 0x29, 0x04, 0xD1, 0x00, 0x6C, 0x00,
+	0x28, 0x01, 0xD0, 0x01, 0x25, 0x00, 0xE0, 0x00, 0x25, 0x00, 0x2D, 0x07, 0xD0, 0x03, 0x20, 0xF8,
+	0xF7, 0xB2, 0xFC, 0xFA, 0xF7, 0x1C, 0xFB, 0x00, 0x20, 0xFA, 0xF7, 0x40, 0xFB, 0x31, 0x4F, 0xA0,
+	0x07, 0x08, 0xD5, 0x38, 0x78, 
+	0x00, 0x01, 0x18, 0x00, 0x80, 0x00, 0x28, 0x01, 0xD1, 0x01, 0x21, 0x00, 0xE0, 0x00, 0x21, 0x39,
+	0x48, 0xFF, 0xF7, 0xFD, 0xFC, 0xE0, 0x07, 0x08, 0xD0, 0x38, 0x78, 0x00, 0x28, 0x01, 0xD1, 0x01,
+	0x21, 0x00, 0xE0, 0x00, 0x21, 0x33, 0x48, 0xFF, 0xF7, 0xDA, 0xFC, 0x00, 0x2D, 0x1D, 0xD0, 0xA0,
+	0x07, 0x1B, 0xD0, 0x38, 0x8C, 0x40, 0x24, 0x20, 0x43, 0x38, 0x84, 0x01, 0x20, 0xFC, 0xF7, 0x9D,
+	0xF8, 0x00, 0x20, 0xFC, 0xF7, 0xC2, 0xF8, 0x30, 0x4A, 0x30, 0x49, 0x00, 0x20, 0xFF, 0xF7, 0x3D,
+	0xFF, 0x2F, 0x4A, 0x30, 0x49, 0x01, 0x20, 0xFF, 0xF7, 0x38, 0xFF, 0x00, 0x20, 0xFC, 0xF7, 0x8D,
+	0xF8, 0x38, 0x8C, 0xA0, 0x43, 0x38, 0x84, 0xF9, 0xF7, 0x2C, 0xFD, 0x30, 0x78, 0x15, 0x4A, 0x24,
+	0x32, 0x10, 0x70, 0x26, 0x48, 0x01, 0x78, 0x51, 0x70, 0x26, 0x49, 0x0B, 0x78, 0x93, 0x70, 0x73,
+	0x78, 0xD2, 0x1C, 0x13, 0x70, 
+	0x00, 0x01, 0x19, 0x00, 0x80, 0x43, 0x78, 0x53, 0x70, 0x4B, 0x78, 0x93, 0x70, 0xB3, 0x78, 0xD2,
+	0x1C, 0x13, 0x70, 0x80, 0x78, 0x50, 0x70, 0x88, 0x78, 0x90, 0x70, 0x00, 0x20, 0xFF, 0xF7, 0x00,
+	0xFF, 0x00, 0x2D, 0x05, 0xD0, 0x00, 0x20, 0xFA, 0xF7, 0xE9, 0xFA, 0x00, 0x20, 0xFA, 0xF7, 0xBF,
+	0xFA, 0xFC, 0xF7, 0x40, 0xFD, 0xFC, 0xF7, 0x0F, 0xFD, 0xF8, 0xBD, 0x70, 0x47, 0x80, 0xE6, 0x00,
+	0x00, 0x2A, 0x01, 0x00, 0x20, 0xD8, 0x01, 0x00, 0x20, 0xC0, 0xEA, 0x00, 0x00, 0xF0, 0xE9, 0x00,
+	0x00, 0x00, 0xEC, 0x00, 0x00, 0x2C, 0x05, 0x00, 0x20, 0x00, 0x80, 0xFF, 0xFF, 0x9D, 0x00, 0x00,
+	0x20, 0xC6, 0x0E, 0x00, 0x20, 0xD0, 0x01, 0x00, 0x20, 0xC8, 0x01, 0x00, 0x20, 0xC9, 0x01, 0x00,
+	0x20, 0xCA, 0x01, 0x00, 0x20, 0x60, 0x14, 0x00, 0x20, 0xD4, 0x00, 0x00, 0x20, 0xD8, 0x00, 0x00,
+	0x20, 0x92, 0x08, 0x00, 0x20, 
+	0x00, 0x01, 0x1A, 0x00, 0x80, 0x32, 0x0B, 0x00, 0x20, 0x00, 0xF6, 0x00, 0x00, 0x64, 0x10, 0x00,
+	0x20, 0x80, 0xFA, 0x00, 0x00, 0x02, 0x12, 0x00, 0x20, 0x70, 0xB5, 0xFE, 0x4C, 0x01, 0x26, 0x20,
+	0x79, 0x00, 0x28, 0x02, 0xD1, 0x26, 0x71, 0xFF, 0xF7, 0xD9, 0xFD, 0xFB, 0x48, 0xFA, 0xF7, 0xEF,
+	0xF9, 0x00, 0x25, 0xA5, 0x63, 0xF9, 0x48, 0xE5, 0x63, 0xFE, 0xF7, 0x94, 0xFF, 0xF9, 0xF7, 0xB5,
+	0xFC, 0xFC, 0xF7, 0x11, 0xF8, 0xFA, 0xF7, 0xDB, 0xFB, 0xFE, 0xF7, 0xE2, 0xF9, 0x04, 0xF0, 0xB8,
+	0xF8, 0xF8, 0xF7, 0x16, 0xFC, 0xF2, 0x48, 0x01, 0x46, 0xC0, 0x31, 0xA1, 0x64, 0x60, 0x64, 0x60,
+	0x39, 0xE1, 0x64, 0xF0, 0x49, 0x21, 0x65, 0xFA, 0xF7, 0xDD, 0xF9, 0xA0, 0x6C, 0xFA, 0xF7, 0xD5,
+	0xF9, 0xFF, 0xF7, 0x43, 0xFD, 0xFF, 0xF7, 0x4B, 0xFE, 0xE0, 0x78, 0x00, 0x28, 0x03, 0xD0, 0x25,
+	0x70, 0x83, 0x20, 0xFF, 0xF7, 
+	0x00, 0x01, 0x1B, 0x00, 0x80, 0x17, 0xFF, 0x25, 0x70, 0x00, 0x20, 0xFF, 0xF7, 0x13, 0xFF, 0xFF,
+	0xF7, 0xB3, 0xFD, 0xFF, 0xF7, 0xF8, 0xFD, 0xA0, 0x78, 0x61, 0x78, 0x08, 0x43, 0x04, 0xD0, 0x26,
+	0x70, 0x83, 0x20, 0xFF, 0xF7, 0x07, 0xFF, 0x25, 0x70, 0xDF, 0x48, 0xE5, 0x74, 0xC0, 0x6B, 0x01,
+	0x28, 0x11, 0xD1, 0xDD, 0x48, 0x40, 0x30, 0x40, 0x8B, 0x21, 0x7A, 0x88, 0x43, 0xC0, 0x07, 0x0A,
+	0xD1, 0x01, 0xF0, 0x88, 0xF9, 0xFA, 0xF7, 0x25, 0xFA, 0x00, 0x28, 0x03, 0xD1, 0xFA, 0xF7, 0x26,
+	0xFA, 0x00, 0x28, 0x00, 0xD0, 0xE6, 0x74, 0x25, 0x64, 0xE5, 0x72, 0x25, 0x73, 0xE5, 0x75, 0x25,
+	0x76, 0x25, 0x77, 0x25, 0x84, 0x65, 0x84, 0x65, 0x72, 0xA6, 0x75, 0x70, 0xBD, 0x10, 0xB5, 0xF9,
+	0xF7, 0x84, 0xFC, 0xC8, 0x49, 0x00, 0x20, 0x48, 0x72, 0x10, 0xBD, 0xF8, 0xB5, 0xC5, 0x4D, 0x00,
+	0x24, 0x06, 0x46, 0xAC, 0x71, 
+	0x00, 0x01, 0x1C, 0x00, 0x80, 0xFD, 0xF7, 0x92, 0xF9, 0x07, 0x46, 0x62, 0xB6, 0x68, 0x7A, 0x2A,
+	0x28, 0x06, 0xD2, 0xC6, 0x49, 0x80, 0x00, 0x09, 0x58, 0x30, 0x46, 0x88, 0x47, 0x04, 0x46, 0x04,
+	0xE0, 0xF9, 0xF7, 0x6B, 0xFC, 0x00, 0x20, 0x68, 0x72, 0x08, 0x24, 0x72, 0xB6, 0xE0, 0x07, 0x05,
+	0xD0, 0xFA, 0xF7, 0x62, 0xF8, 0x01, 0x28, 0x01, 0xD1, 0xC0, 0x07, 0x04, 0x43, 0x00, 0x2C, 0xE4,
+	0xDB, 0xF8, 0xB2, 0xFD, 0xF7, 0x77, 0xF9, 0xB8, 0x48, 0x40, 0x30, 0x00, 0x8B, 0x00, 0x28, 0x02,
+	0xD1, 0xF8, 0xF7, 0x96, 0xFB, 0x10, 0xE0, 0xFA, 0xF7, 0xDC, 0xF9, 0x00, 0x28, 0x03, 0xD0, 0x6E,
+	0x63, 0xF8, 0xF7, 0x95, 0xFB, 0x08, 0xE0, 0xB0, 0x4A, 0x69, 0x6B, 0x52, 0x6D, 0x28, 0x46, 0x71,
+	0x1A, 0x91, 0x42, 0x01, 0xD9, 0x46, 0x63, 0xEB, 0xE7, 0x69, 0x8C, 0x20, 0x46, 0x08, 0x43, 0xF8,
+	0xBD, 0xF0, 0xB5, 0x00, 0x22, 
+	0x00, 0x01, 0x1D, 0x00, 0x80, 0xAA, 0x4C, 0xAB, 0x4F, 0x0B, 0xE0, 0x53, 0x00, 0xAA, 0x4D, 0xAB,
+	0x4E, 0xED, 0x5A, 0xF6, 0x5A, 0x45, 0x43, 0x4E, 0x43, 0xAD, 0x19, 0xFE, 0x5A, 0xAD, 0x19, 0xFD,
+	0x52, 0x52, 0x1C, 0xA3, 0x6A, 0x93, 0x42, 0xF0, 0xD8, 0x00, 0x22, 0x12, 0xE0, 0x53, 0x00, 0x15,
+	0x27, 0xA1, 0x4D, 0x7F, 0x01, 0xA1, 0x4E, 0x5D, 0x19, 0x9E, 0x19, 0xED, 0x19, 0xF6, 0x19, 0x2D,
+	0x88, 0x36, 0x88, 0x45, 0x43, 0x4E, 0x43, 0xAE, 0x19, 0x9D, 0x4D, 0xEF, 0x5A, 0xF6, 0x19, 0xEE,
+	0x52, 0x52, 0x1C, 0x63, 0x6A, 0x93, 0x42, 0xE9, 0xD8, 0xF0, 0xBD, 0x02, 0x46, 0x00, 0x20, 0x10,
+	0xB5, 0xC0, 0x43, 0x00, 0x29, 0x0C, 0xD0, 0x01, 0x29, 0x03, 0xD0, 0x02, 0x29, 0x11, 0xD1, 0x01,
+	0x21, 0x0C, 0xE0, 0x00, 0x2A, 0x01, 0xD1, 0x00, 0x21, 0x00, 0xE0, 0x01, 0x46, 0x01, 0x20, 0x05,
+	0xE0, 0x01, 0x2A, 0x01, 0xD1, 
+	0x00, 0x01, 0x1E, 0x00, 0x80, 0x00, 0x21, 0x01, 0xE0, 0x01, 0x46, 0x00, 0x20, 0xFF, 0xF7, 0xB8,
+	0xFF, 0x10, 0xBD, 0x80, 0x4C, 0x00, 0x20, 0x20, 0x76, 0xFA, 0xF7, 0xB0, 0xF9, 0x20, 0x7E, 0xFF,
+	0xF7, 0xBF, 0xFD, 0xFC, 0xF7, 0x07, 0xFC, 0xFC, 0xF7, 0xD6, 0xFB, 0x10, 0xBD, 0x70, 0xB5, 0x79,
+	0x4C, 0x7D, 0x4D, 0x21, 0x8C, 0x8A, 0x06, 0x03, 0xD4, 0xCA, 0x06, 0x01, 0xD4, 0xC9, 0x05, 0x3A,
+	0xD5, 0x80, 0x49, 0x09, 0x78, 0x00, 0x29, 0x36, 0xD1, 0x21, 0x6B, 0x88, 0x42, 0x32, 0xD9, 0x69,
+	0x6D, 0x08, 0x18, 0x20, 0x63, 0x00, 0x20, 0xFA, 0xF7, 0x6A, 0xF9, 0x68, 0x6E, 0xC0, 0xB2, 0xFA,
+	0xF7, 0x36, 0xF9, 0x00, 0x25, 0x25, 0x77, 0x20, 0x7E, 0x00, 0x28, 0x0C, 0xD0, 0x00, 0x20, 0xFA,
+	0xF7, 0x85, 0xF9, 0x20, 0x7E, 0x60, 0x76, 0x25, 0x76, 0x00, 0x20, 0xFF, 0xF7, 0x91, 0xFD, 0x21,
+	0x7E, 0x60, 0x7E, 0xFF, 0xF7, 
+	0x00, 0x01, 0x1F, 0x00, 0x80, 0xAA, 0xFF, 0x00, 0x20, 0xFB, 0xF7, 0xF7, 0xFE, 0x00, 0x20, 0xFB,
+	0xF7, 0x1C, 0xFF, 0x00, 0x20, 0x03, 0xF0, 0x98, 0xFF, 0x00, 0x20, 0xFA, 0xF7, 0xE3, 0xF9, 0x00,
+	0x20, 0xFB, 0xF7, 0x46, 0xFE, 0x00, 0x20, 0xFA, 0xF7, 0xB6, 0xFA, 0x20, 0x8C, 0xFF, 0x21, 0xF1,
+	0x31, 0x88, 0x43, 0x20, 0x84, 0x70, 0xBD, 0x69, 0x6D, 0x08, 0x18, 0x20, 0x63, 0x70, 0xBD, 0x70,
+	0xB5, 0xFF, 0xF7, 0xB4, 0xFF, 0x53, 0x4C, 0x58, 0x4D, 0x20, 0x8C, 0x60, 0x84, 0xE8, 0x6E, 0x00,
+	0x28, 0x05, 0xD0, 0x02, 0xF0, 0xB5, 0xFA, 0x03, 0x28, 0x01, 0xD1, 0x24, 0x20, 0x08, 0xE0, 0x02,
+	0xF0, 0xAF, 0xFA, 0x04, 0x28, 0x01, 0xD1, 0x26, 0x20, 0x02, 0xE0, 0xA8, 0x69, 0x01, 0x28, 0x01,
+	0xD1, 0x60, 0x72, 0x13, 0xE0, 0x54, 0x48, 0x40, 0x7E, 0x01, 0x28, 0x07, 0xD1, 0x02, 0xF0, 0xA0,
+	0xFA, 0x03, 0x28, 0x01, 0xD1, 
+	0x00, 0x01, 0x20, 0x00, 0x80, 0x21, 0x20, 0x06, 0xE0, 0x0E, 0x20, 0x04, 0xE0, 0x02, 0xF0, 0x98,
+	0xFA, 0x03, 0x28, 0x00, 0xD0, 0x09, 0x20, 0x60, 0x72, 0x00, 0x20, 0x60, 0x74, 0x01, 0x20, 0xC0,
+	0x07, 0x70, 0xBD, 0xF8, 0xB5, 0x05, 0x46, 0x0E, 0x46, 0xF9, 0xF7, 0x8E, 0xFC, 0x39, 0x4C, 0x3C,
+	0x48, 0x60, 0x64, 0xE0, 0x64, 0xFA, 0xF7, 0x76, 0xF8, 0x44, 0x48, 0x01, 0x27, 0x00, 0x78, 0x00,
+	0x28, 0x10, 0xD1, 0x03, 0x2E, 0x05, 0xD0, 0x38, 0x49, 0xA0, 0x6B, 0x49, 0x68, 0x28, 0x1A, 0x88,
+	0x42, 0x06, 0xD9, 0x03, 0x20, 0xF9, 0xF7, 0x03, 0xFF, 0x04, 0x20, 0x20, 0x75, 0xA5, 0x63, 0x0B,
+	0xE0, 0x01, 0x2E, 0x04, 0xD1, 0x01, 0x20, 0xF9, 0xF7, 0xFA, 0xFE, 0x27, 0x75, 0x04, 0xE0, 0x02,
+	0x20, 0xF9, 0xF7, 0xF5, 0xFE, 0x02, 0x20, 0x20, 0x75, 0x01, 0x20, 0xF8, 0xBD, 0x10, 0xB5, 0x2A,
+	0x49, 0x49, 0x69, 0xFF, 0xF7, 
+	0x00, 0x01, 0x21, 0x00, 0x80, 0xCE, 0xFF, 0x23, 0x4A, 0x05, 0x21, 0x51, 0x72, 0x10, 0xBD, 0xF0,
+	0xB5, 0x2F, 0x48, 0x01, 0x27, 0x00, 0x78, 0x85, 0xB0, 0x01, 0x28, 0x5D, 0xD1, 0x29, 0x48, 0x01,
+	0x78, 0x01, 0x29, 0x59, 0xD9, 0x00, 0x25, 0x25, 0xE0, 0x3C, 0x46, 0x1B, 0xE0, 0xE0, 0x00, 0x21,
+	0x18, 0x1A, 0x48, 0xEA, 0x00, 0x0E, 0x18, 0xAA, 0x18, 0x31, 0x7A, 0x10, 0x18, 0x03, 0x90, 0x00,
+	0x7A, 0x81, 0x42, 0x0E, 0xD9, 0x09, 0x22, 0x68, 0x46, 0x03, 0x99, 0x04, 0xF0, 0x87, 0xFC, 0x09,
+	0x22, 0x31, 0x46, 0x03, 0x98, 0x04, 0xF0, 0x82, 0xFC, 0x09, 0x22, 0x69, 0x46, 0x30, 0x46, 0x04,
+	0xF0, 0x7D, 0xFC, 0x64, 0x1C, 0x17, 0x48, 0x00, 0x78, 0x84, 0x42, 0xDF, 0xDB, 0x7F, 0x1C, 0x6D,
+	0x1C, 0xFF, 0xB2, 0xED, 0xB2, 0x13, 0x48, 0x01, 0x78, 0x8D, 0x42, 0xD5, 0xD3, 0x01, 0x78, 0x02,
+	0x29, 0x2A, 0xD9, 0x06, 0x4A, 
+	0x00, 0x01, 0x22, 0x00, 0x80, 0x11, 0x7A, 0x92, 0x7E, 0x89, 0x08, 0x8A, 0x42, 0x22, 0xD3, 0x00,
+	0x21, 0x21, 0xE0, 0x00, 0x00, 0xD8, 0x01, 0x00, 0x20, 0xB7, 0x8C, 0x00, 0x00, 0x88, 0x03, 0x00,
+	0x20, 0xA0, 0x13, 0x00, 0x20, 0x00, 0x17, 0x00, 0x20, 0x80, 0xE6, 0x00, 0x00, 0x58, 0xDE, 0x00,
+	0x00, 0xF0, 0xE9, 0x00, 0x00, 0x2C, 0x05, 0x00, 0x20, 0x00, 0xF6, 0x00, 0x00, 0x80, 0xFA, 0x00,
+	0x00, 0xCC, 0x07, 0x00, 0x20, 0xEE, 0x00, 0x00, 0x20, 0x80, 0xE8, 0x00, 0x00, 0x6C, 0x02, 0x00,
+	0x20, 0x28, 0x01, 0x00, 0x20, 0x02, 0x21, 0x01, 0x70, 0x9C, 0xE4, 0xFC, 0x48, 0xFC, 0x49, 0x00,
+	0x78, 0x00, 0x28, 0x06, 0xD0, 0xFB, 0x48, 0x00, 0x78, 0x00, 0x28, 0x02, 0xD1, 0xFA, 0x48, 0x40,
+	0x7E, 0x03, 0xE0, 0xC8, 0x7D, 0x00, 0x28, 0x01, 0xD0, 0x40, 0x1E, 0xC8, 0x75, 0x70, 0x47, 0x10,
+	0xB5, 0xFF, 0xF7, 0xEB, 0xFF, 
+	0x00, 0x01, 0x23, 0x00, 0x80, 0xFF, 0xF7, 0x83, 0xFF, 0x10, 0xBD, 0xF8, 0xB5, 0x07, 0x46, 0x01,
+	0x24, 0xF9, 0xF7, 0xB2, 0xFE, 0x01, 0x28, 0x48, 0xD1, 0xF9, 0xF7, 0x93, 0xFA, 0xEC, 0x4D, 0x00,
+	0x26, 0xE8, 0x79, 0x00, 0x07, 0x00, 0x28, 0x08, 0xDA, 0xEA, 0x48, 0x00, 0x78, 0x01, 0x28, 0x04,
+	0xD1, 0xEA, 0x48, 0x06, 0x70, 0x03, 0x20, 0xFB, 0xF7, 0x08, 0xFE, 0x28, 0x7D, 0x04, 0x28, 0x02,
+	0xD1, 0x03, 0x20, 0xE9, 0x6C, 0x05, 0xE0, 0xE9, 0x6C, 0xC0, 0x07, 0x01, 0xD0, 0x01, 0x20, 0x00,
+	0xE0, 0x02, 0x20, 0xFB, 0xF7, 0xF6, 0xFF, 0xFC, 0xF7, 0xC2, 0xFA, 0xE1, 0x49, 0x8A, 0x69, 0x03,
+	0x20, 0xC4, 0x07, 0x01, 0x2A, 0x20, 0xD1, 0xDF, 0x4A, 0x12, 0x78, 0x01, 0x2A, 0x1C, 0xD0, 0xEA,
+	0x7A, 0x00, 0x2A, 0x19, 0xD1, 0xAA, 0x7A, 0x01, 0x2A, 0x16, 0xD0, 0xDB, 0x4A, 0x12, 0x78, 0x01,
+	0x2A, 0x12, 0xD0, 0xEA, 0x6B, 
+	0x00, 0x01, 0x24, 0x00, 0x80, 0x89, 0x68, 0xBA, 0x1A, 0x8A, 0x42, 0x0D, 0xD8, 0x6E, 0x72, 0x29,
+	0x7B, 0xA8, 0x79, 0x08, 0x24, 0x81, 0x42, 0x01, 0xD0, 0x28, 0x73, 0x0C, 0x24, 0xFF, 0xF7, 0xAF,
+	0xFF, 0xCA, 0x48, 0x06, 0x70, 0xEE, 0x72, 0x00, 0xE0, 0x68, 0x72, 0x20, 0x46, 0xF8, 0xBD, 0x10,
+	0xB5, 0xCE, 0x48, 0x42, 0x78, 0x01, 0x78, 0x07, 0x20, 0x00, 0xF0, 0x6F, 0xFF, 0xF9, 0xF7, 0xC6,
+	0xFA, 0xC3, 0x4C, 0xCB, 0x48, 0xA0, 0x64, 0x20, 0x65, 0xF9, 0xF7, 0x67, 0xFF, 0x23, 0x7C, 0xE2,
+	0x7B, 0xA1, 0x7B, 0x60, 0x7B, 0xF9, 0xF7, 0x9B, 0xFE, 0x06, 0x20, 0x60, 0x72, 0x01, 0x20, 0x10,
+	0xBD, 0x70, 0xB5, 0x05, 0x46, 0xF9, 0xF7, 0xB2, 0xFA, 0xB9, 0x4C, 0xC1, 0x48, 0xA0, 0x64, 0x20,
+	0x65, 0xF9, 0xF7, 0x53, 0xFF, 0xF9, 0xF7, 0xF0, 0xFC, 0x07, 0x20, 0xE5, 0x63, 0x60, 0x72, 0x01,
+	0x20, 0x70, 0xBD, 0x08, 0x20, 
+	0x00, 0x01, 0x25, 0x00, 0x80, 0x70, 0x47, 0xF8, 0xB5, 0x00, 0x26, 0x00, 0xF0, 0x23, 0xFF, 0xF9,
+	0xF7, 0xC5, 0xFF, 0xAF, 0x4D, 0x04, 0x46, 0xE8, 0x7C, 0x01, 0x28, 0x0A, 0xD1, 0xF9, 0xF7, 0xC2,
+	0xFF, 0x00, 0x28, 0x06, 0xD1, 0x00, 0x2C, 0x04, 0xD1, 0xE8, 0x74, 0xFC, 0xF7, 0x14, 0xFA, 0xFC,
+	0xF7, 0x41, 0xFA, 0x28, 0x8C, 0xAF, 0x49, 0xAA, 0x4F, 0xC2, 0x05, 0x06, 0xD5, 0xFA, 0x6C, 0x3B,
+	0x6D, 0xD2, 0x1A, 0xA2, 0x42, 0x0E, 0xD9, 0x88, 0x43, 0x28, 0x84, 0x28, 0x7F, 0x01, 0x28, 0x16,
+	0xD1, 0x38, 0x6C, 0x00, 0x28, 0x13, 0xD1, 0xF8, 0x6C, 0xA0, 0x42, 0x05, 0xD2, 0x28, 0x8C, 0x08,
+	0x43, 0x28, 0x84, 0x1F, 0xE0, 0x01, 0x20, 0xF8, 0xBD, 0xF9, 0xF7, 0x9C, 0xFF, 0x80, 0x21, 0x00,
+	0x28, 0x28, 0x8C, 0x01, 0xD0, 0x08, 0x43, 0x00, 0xE0, 0x88, 0x43, 0x28, 0x84, 0x13, 0xE0, 0xF9,
+	0xF7, 0x91, 0xFF, 0x00, 0x28, 
+	0x00, 0x01, 0x26, 0x00, 0x80, 0x09, 0xD1, 0xF8, 0x6C, 0xA0, 0x42, 0x06, 0xD3, 0xF9, 0xF7, 0x81,
+	0xFF, 0x00, 0x28, 0x08, 0xD0, 0x28, 0x8C, 0xC0, 0x06, 0x05, 0xD4, 0x00, 0x20, 0xA8, 0x76, 0xE8,
+	0x76, 0x01, 0x20, 0x68, 0x77, 0x01, 0x26, 0x30, 0x46, 0xF8, 0xBD, 0xF0, 0xB5, 0x85, 0xB0, 0x01,
+	0x26, 0xF9, 0xF7, 0xE2, 0xFD, 0x01, 0x28, 0x78, 0xD1, 0xF9, 0xF7, 0xC3, 0xF9, 0x88, 0x48, 0xC0,
+	0x6B, 0xF6, 0x07, 0x83, 0x4C, 0x01, 0x28, 0x0C, 0xD1, 0x85, 0x48, 0x40, 0x30, 0x40, 0x8B, 0x21,
+	0x7A, 0x88, 0x43, 0xC0, 0x07, 0x05, 0xD1, 0xFF, 0xF7, 0x96, 0xFF, 0x01, 0x28, 0x01, 0xD1, 0x15,
+	0x20, 0x62, 0xE0, 0x20, 0x8C, 0x60, 0x84, 0x22, 0x6D, 0x00, 0x92, 0x23, 0x7C, 0xE2, 0x7B, 0xA1,
+	0x7B, 0x60, 0x7B, 0xFC, 0xF7, 0x83, 0xF9, 0xE0, 0x79, 0xC1, 0x08, 0x04, 0xD1, 0x00, 0x20, 0xFB,
+	0xF7, 0x24, 0xFD, 0x00, 0x20, 
+	0x00, 0x01, 0x27, 0x00, 0x80, 0x15, 0xE0, 0x01, 0x07, 0x0E, 0xD5, 0x72, 0x49, 0x09, 0x78, 0x01,
+	0x29, 0x0A, 0xD1, 0xE1, 0x7D, 0x00, 0x29, 0x07, 0xD1, 0x70, 0x49, 0x01, 0x20, 0x08, 0x70, 0x03,
+	0x20, 0xFB, 0xF7, 0x13, 0xFD, 0x04, 0x20, 0x04, 0xE0, 0xC0, 0x09, 0xE7, 0xD1, 0xFB, 0xF7, 0x0D,
+	0xFD, 0x0F, 0x20, 0xF9, 0xF7, 0xD7, 0xFF, 0xFC, 0xF7, 0xD9, 0xFA, 0x15, 0x22, 0x6C, 0x48, 0x52,
+	0x01, 0x81, 0x18, 0x02, 0xA8, 0xF8, 0xF7, 0x0C, 0xF8, 0x60, 0x7B, 0x6B, 0x46, 0x18, 0x71, 0xA0,
+	0x7B, 0x58, 0x71, 0xE0, 0x7B, 0x98, 0x71, 0x20, 0x7C, 0xD8, 0x71, 0x60, 0x21, 0x02, 0xA8, 0xF8,
+	0xF7, 0x07, 0xF8, 0x05, 0x46, 0x02, 0x46, 0x01, 0xA9, 0x02, 0xA8, 0xFA, 0xF7, 0xDF, 0xF9, 0x28,
+	0x46, 0xFB, 0xF7, 0x49, 0xFC, 0x29, 0x46, 0x02, 0xA8, 0xFA, 0xF7, 0xEC, 0xFB, 0x02, 0x46, 0x29,
+	0x46, 0x02, 0xA8, 0xFB, 0xF7, 
+	0x00, 0x01, 0x28, 0x00, 0x80, 0x69, 0xF9, 0x02, 0xA8, 0xF7, 0xF7, 0xFF, 0xFF, 0xFF, 0xF7, 0xB7,
+	0xFE, 0x4E, 0x4F, 0x38, 0x78, 0x01, 0x28, 0x06, 0xD8, 0x00, 0x25, 0x01, 0x28, 0x06, 0xD1, 0x56,
+	0x48, 0xC0, 0x79, 0xC0, 0x06, 0x04, 0xD5, 0x03, 0x20, 0x60, 0x72, 0x1A, 0xE0, 0x00, 0x28, 0x00,
+	0xD0, 0xA5, 0x71, 0x02, 0xA8, 0xFE, 0xF7, 0x25, 0xFA, 0x03, 0xF0, 0x51, 0xFD, 0x60, 0x79, 0x00,
+	0x28, 0x07, 0xD1, 0x4E, 0x48, 0x00, 0x78, 0x01, 0x28, 0x03, 0xD0, 0x20, 0x7B, 0xA1, 0x79, 0x88,
+	0x42, 0x03, 0xD0, 0xA0, 0x79, 0x20, 0x73, 0x0C, 0x26, 0x00, 0xE0, 0x08, 0x26, 0x38, 0x78, 0xE0,
+	0x72, 0x65, 0x72, 0x30, 0x46, 0x78, 0xE6, 0xF8, 0xB5, 0x39, 0x4D, 0x00, 0x21, 0xAA, 0x7D, 0x3C,
+	0x4E, 0x0C, 0x46, 0x01, 0x2A, 0x08, 0xD0, 0x2A, 0x6C, 0x33, 0x6A, 0x82, 0x1A, 0x9A, 0x42, 0x63,
+	0xD9, 0x3F, 0x4A, 0x12, 0x78, 
+	0x00, 0x01, 0x29, 0x00, 0x80, 0x00, 0x2A, 0x5F, 0xD1, 0x28, 0x64, 0x00, 0x20, 0xA8, 0x75, 0x3D,
+	0x4B, 0x0A, 0xE0, 0x3D, 0x4A, 0x47, 0x00, 0xD2, 0x5F, 0xB7, 0x6A, 0xBA, 0x42, 0x02, 0xDC, 0xF7,
+	0x6A, 0xBA, 0x42, 0x00, 0xDA, 0x49, 0x1C, 0x40, 0x1C, 0x9A, 0x6A, 0x82, 0x42, 0xF1, 0xD8, 0x00,
+	0x20, 0x0A, 0xE0, 0x36, 0x4A, 0x47, 0x00, 0xD2, 0x5F, 0x77, 0x6B, 0xBA, 0x42, 0x02, 0xDC, 0xB7,
+	0x6B, 0xBA, 0x42, 0x00, 0xDA, 0x64, 0x1C, 0x40, 0x1C, 0x5A, 0x6A, 0x82, 0x42, 0xF1, 0xD8, 0x24,
+	0x48, 0x40, 0x6A, 0x1F, 0x4E, 0x27, 0x36, 0x88, 0x42, 0x7D, 0xD2, 0xF9, 0xF7, 0x77, 0xF9, 0x20,
+	0x49, 0xC8, 0x6B, 0x01, 0x28, 0x62, 0xD1, 0x08, 0x46, 0x40, 0x30, 0x40, 0x8B, 0x2A, 0x7A, 0x90,
+	0x43, 0xC0, 0x07, 0x5B, 0xD1, 0x08, 0x6C, 0x00, 0x28, 0x58, 0xD0, 0x03, 0x20, 0xF8, 0xF7, 0x2B,
+	0xF8, 0xF9, 0xF7, 0x95, 0xFE, 
+	0x00, 0x01, 0x2A, 0x00, 0x80, 0x00, 0x27, 0x79, 0x1E, 0x03, 0x20, 0xF8, 0xF7, 0x14, 0xF8, 0xF9,
+	0xF7, 0xB5, 0xFE, 0xFF, 0xF7, 0xFB, 0xF8, 0x0E, 0x49, 0x24, 0x31, 0xC8, 0x55, 0xFF, 0xF7, 0x25,
+	0xF9, 0xF0, 0x55, 0xFF, 0xF7, 0x3F, 0xF9, 0x0A, 0x49, 0x2A, 0x31, 0xC8, 0x55, 0x7F, 0x1C, 0x03,
+	0x2F, 0xE9, 0xD3, 0x28, 0x8C, 0x40, 0x06, 0x2B, 0xD5, 0x29, 0x7E, 0x03, 0x20, 0x49, 0x1E, 0xF7,
+	0xF7, 0xFA, 0xFF, 0xF9, 0xF7, 0x9B, 0xFE, 0x40, 0xE0, 0x97, 0xE0, 0x00, 0x00, 0xEE, 0x00, 0x00,
+	0x20, 0xD8, 0x01, 0x00, 0x20, 0x28, 0x01, 0x00, 0x20, 0x10, 0xE8, 0x00, 0x00, 0x2B, 0x01, 0x00,
+	0x20, 0x80, 0xE6, 0x00, 0x00, 0x2D, 0x01, 0x00, 0x20, 0x2C, 0x01, 0x00, 0x20, 0x00, 0x01, 0x00,
+	0x20, 0x60, 0x14, 0x00, 0x20, 0x00, 0x01, 0x00, 0x00, 0x88, 0x03, 0x00, 0x20, 0xC2, 0x01, 0x00,
+	0x20, 0xEF, 0x00, 0x00, 0x20, 
+	0x00, 0x01, 0x2B, 0x00, 0x80, 0xF0, 0xE9, 0x00, 0x00, 0x2C, 0x05, 0x00, 0x20, 0xCC, 0x07, 0x00,
+	0x20, 0x00, 0x20, 0xF9, 0xF7, 0x73, 0xFE, 0x28, 0x8C, 0x80, 0x06, 0x03, 0xD5, 0x02, 0x20, 0xF7,
+	0xF7, 0xDA, 0xFF, 0x00, 0xE0, 0x00, 0x20, 0xF9, 0xF7, 0x42, 0xFE, 0x0E, 0xE0, 0xFF, 0xF7, 0xAE,
+	0xF8, 0xFF, 0x49, 0x2A, 0x7E, 0x88, 0x54, 0xFF, 0xF7, 0xD8, 0xF8, 0x29, 0x7E, 0x70, 0x54, 0xFF,
+	0xF7, 0xF1, 0xF8, 0xFB, 0x49, 0x2A, 0x7E, 0x89, 0x1D, 0x88, 0x54, 0xF9, 0x48, 0x29, 0x7E, 0x40,
+	0x5C, 0xF8, 0x49, 0x08, 0x70, 0x00, 0xE0, 0x01, 0xE0, 0xFC, 0xF7, 0xAC, 0xF8, 0xF6, 0x48, 0x01,
+	0x6B, 0xA1, 0x42, 0x4A, 0xD2, 0xC1, 0x6B, 0x00, 0x29, 0x32, 0xD0, 0x00, 0x6C, 0x00, 0x28, 0x2F,
+	0xD0, 0x03, 0x20, 0xF7, 0xF7, 0xB0, 0xFF, 0xF9, 0xF7, 0x1A, 0xFE, 0xED, 0x4F, 0x00, 0x24, 0xBF,
+	0x1D, 0x61, 0x1E, 0x03, 0x20, 
+	0x00, 0x01, 0x2C, 0x00, 0x80, 0xF7, 0xF7, 0x97, 0xFF, 0xF9, 0xF7, 0x38, 0xFE, 0xFF, 0xF7, 0xAD,
+	0xF8, 0x30, 0x55, 0xFF, 0xF7, 0xC7, 0xF8, 0x38, 0x55, 0x64, 0x1C, 0x03, 0x2C, 0xF0, 0xD3, 0x28,
+	0x8C, 0x40, 0x06, 0x07, 0xD5, 0x29, 0x7E, 0x03, 0x20, 0x49, 0x1E, 0xF7, 0xF7, 0x84, 0xFF, 0xF9,
+	0xF7, 0x25, 0xFE, 0x17, 0xE0, 0x00, 0x20, 0xF9, 0xF7, 0x21, 0xFE, 0x28, 0x8C, 0x80, 0x06, 0x03,
+	0xD5, 0x02, 0x20, 0xF7, 0xF7, 0x88, 0xFF, 0x00, 0xE0, 0x00, 0x20, 0xF9, 0xF7, 0xF0, 0xFD, 0x09,
+	0xE0, 0xFF, 0xF7, 0x8B, 0xF8, 0x29, 0x7E, 0x70, 0x54, 0xFF, 0xF7, 0xA4, 0xF8, 0xD4, 0x49, 0x2A,
+	0x7E, 0x89, 0x1D, 0x88, 0x54, 0x28, 0x7E, 0xD5, 0x4A, 0x31, 0x5C, 0x11, 0x70, 0xD0, 0x49, 0x89,
+	0x1D, 0x08, 0x5C, 0xD3, 0x49, 0x08, 0x70, 0xFC, 0xF7, 0x2E, 0xF8, 0xF8, 0xBD, 0xF3, 0xB5, 0x83,
+	0xB0, 0x0D, 0x46, 0x01, 0x24, 
+	0x00, 0x01, 0x2D, 0x00, 0x80, 0xF9, 0xF7, 0x38, 0xFC, 0x01, 0x28, 0x7D, 0xD1, 0xF9, 0xF7, 0x19,
+	0xF8, 0xC9, 0x48, 0xC0, 0x6B, 0xC6, 0x4C, 0x24, 0x3C, 0x01, 0x28, 0x13, 0xD1, 0xC6, 0x48, 0x40,
+	0x30, 0x40, 0x8B, 0x21, 0x7A, 0x88, 0x43, 0xC0, 0x07, 0x0C, 0xD1, 0xFF, 0xF7, 0xEC, 0xFD, 0x01,
+	0x28, 0x08, 0xD1, 0x00, 0x2D, 0x02, 0xD0, 0xC3, 0x48, 0xF9, 0xF7, 0x29, 0xFD, 0x15, 0x20, 0x60,
+	0x72, 0xC0, 0x07, 0x49, 0xE5, 0x20, 0x8C, 0x60, 0x84, 0x00, 0x2D, 0x03, 0xD0, 0x03, 0x20, 0xE1,
+	0x6C, 0xFB, 0xF7, 0x77, 0xFD, 0x20, 0x6D, 0xFB, 0xF7, 0xC4, 0xFF, 0xE0, 0x79, 0x01, 0x27, 0xC1,
+	0x08, 0x00, 0x29, 0x04, 0xD1, 0x00, 0x20, 0xFB, 0xF7, 0x70, 0xFB, 0x00, 0x20, 0x14, 0xE0, 0x01,
+	0x07, 0x0D, 0xD5, 0xB5, 0x49, 0x09, 0x78, 0x01, 0x29, 0x09, 0xD1, 0xE1, 0x7D, 0x00, 0x29, 0x06,
+	0xD1, 0xB2, 0x48, 0x07, 0x70, 
+	0x00, 0x01, 0x2E, 0x00, 0x80, 0x03, 0x20, 0xFB, 0xF7, 0x60, 0xFB, 0x04, 0x20, 0x04, 0xE0, 0xC0,
+	0x09, 0xE8, 0xD1, 0xFB, 0xF7, 0x5A, 0xFB, 0x0F, 0x20, 0xF9, 0xF7, 0x24, 0xFE, 0x00, 0x2D, 0x01,
+	0xD0, 0xFC, 0xF7, 0x1D, 0xF8, 0xFC, 0xF7, 0x22, 0xF9, 0x15, 0x22, 0x52, 0x01, 0x01, 0xA8, 0x21,
+	0x6D, 0xF7, 0xF7, 0x56, 0xFE, 0x60, 0x21, 0x01, 0xA8, 0xF7, 0xF7, 0x5A, 0xFE, 0x05, 0x46, 0x01,
+	0x46, 0x01, 0xA8, 0xFA, 0xF7, 0xC2, 0xF9, 0x28, 0x46, 0xFB, 0xF7, 0x9D, 0xFA, 0x29, 0x46, 0x01,
+	0xA8, 0xFA, 0xF7, 0x40, 0xFA, 0x02, 0x46, 0x29, 0x46, 0x01, 0xA8, 0xFA, 0xF7, 0xBD, 0xFF, 0x01,
+	0xA8, 0xF7, 0xF7, 0x53, 0xFE, 0xFF, 0xF7, 0x0B, 0xFD, 0x99, 0x4D, 0x00, 0x26, 0x28, 0x78, 0x00,
+	0x28, 0x00, 0xD0, 0xA6, 0x71, 0x97, 0x48, 0x00, 0x78, 0x00, 0x28, 0x03, 0xD0, 0xA0, 0x79, 0x80,
+	0x21, 0x08, 0x43, 0xA0, 0x71, 
+	0x00, 0x01, 0x2F, 0x00, 0x80, 0x01, 0xA8, 0x00, 0xE0, 0x2F, 0xE0, 0xFE, 0xF7, 0x7A, 0xF8, 0x03,
+	0xF0, 0xA6, 0xFB, 0x61, 0x79, 0x20, 0x46, 0x00, 0x29, 0x07, 0xD1, 0x8F, 0x49, 0x09, 0x78, 0x01,
+	0x29, 0x03, 0xD0, 0x01, 0x7B, 0x82, 0x79, 0x91, 0x42, 0x12, 0xD0, 0x81, 0x79, 0x01, 0x73, 0x29,
+	0x78, 0x00, 0x29, 0x02, 0xD1, 0x46, 0x72, 0x0C, 0x24, 0x0C, 0xE0, 0x88, 0x49, 0x49, 0x7E, 0x01,
+	0x29, 0x01, 0xD1, 0x0E, 0x21, 0x00, 0xE0, 0x09, 0x21, 0x41, 0x72, 0x00, 0x24, 0x47, 0x74, 0x01,
+	0xE0, 0x08, 0x24, 0x46, 0x72, 0x29, 0x78, 0xC1, 0x72, 0x77, 0x49, 0xC9, 0x69, 0x01, 0x29, 0x04,
+	0xD1, 0x7F, 0x49, 0x01, 0x65, 0x03, 0x98, 0xFF, 0xF7, 0x3E, 0xFE, 0x20, 0x46, 0xB4, 0xE4, 0x00,
+	0x21, 0x44, 0xE7, 0x10, 0xB5, 0x6E, 0x4C, 0x01, 0x20, 0x24, 0x3C, 0x60, 0x75, 0xF8, 0xF7, 0xE6,
+	0xFF, 0xA0, 0x6C, 0xF9, 0xF7, 
+	0x00, 0x01, 0x30, 0x00, 0x80, 0x8A, 0xFC, 0xF9, 0xF7, 0x27, 0xFA, 0x10, 0xBD, 0x70, 0xB5, 0x05,
+	0x46, 0x73, 0x48, 0x67, 0x4C, 0xC0, 0x38, 0x24, 0x3C, 0x60, 0x64, 0xE0, 0x64, 0xC0, 0x30, 0xA0,
+	0x64, 0x20, 0x65, 0x70, 0x48, 0xF9, 0xF7, 0x73, 0xFC, 0xF9, 0xF7, 0x8E, 0xF8, 0x60, 0x6C, 0xF9,
+	0xF7, 0x79, 0xFC, 0x03, 0x20, 0xF9, 0xF7, 0x13, 0xFB, 0x22, 0x20, 0xA5, 0x63, 0x60, 0x72, 0x01,
+	0x20, 0x70, 0xBD, 0x01, 0x21, 0x1A, 0xE7, 0x00, 0x20, 0x70, 0x47, 0x70, 0xB5, 0x05, 0x46, 0x5A,
+	0x48, 0x80, 0x69, 0x57, 0x4C, 0x24, 0x3C, 0x01, 0x28, 0x05, 0xD1, 0x61, 0x48, 0xC0, 0x38, 0x60,
+	0x64, 0xE0, 0x64, 0xF9, 0xF7, 0x5F, 0xFC, 0x5E, 0x48, 0xA0, 0x64, 0x5F, 0x48, 0x20, 0x65, 0xF8,
+	0xF7, 0xAD, 0xFF, 0xA0, 0x6C, 0xF9, 0xF7, 0x51, 0xFC, 0xF9, 0xF7, 0xEE, 0xF9, 0x0A, 0x20, 0xE5,
+	0x63, 0x60, 0x72, 0x61, 0x7C, 
+	0x00, 0x01, 0x31, 0x00, 0x80, 0x05, 0x20, 0x00, 0x29, 0x00, 0xD1, 0x01, 0x20, 0x70, 0xBD, 0x10,
+	0xB5, 0xF9, 0xF7, 0x32, 0xFB, 0x01, 0x28, 0x1A, 0xD1, 0xF8, 0xF7, 0x13, 0xFF, 0x46, 0x48, 0xC0,
+	0x6B, 0x43, 0x4C, 0x24, 0x3C, 0x01, 0x28, 0x0E, 0xD1, 0x43, 0x48, 0x40, 0x30, 0x40, 0x8B, 0x21,
+	0x7A, 0x88, 0x43, 0xC0, 0x07, 0x07, 0xD1, 0xFF, 0xF7, 0xE6, 0xFC, 0x01, 0x28, 0x03, 0xD1, 0x15,
+	0x20, 0x60, 0x72, 0xC0, 0x07, 0x10, 0xBD, 0x0B, 0x20, 0x60, 0x72, 0x00, 0x20, 0x10, 0xBD, 0x01,
+	0x20, 0x10, 0xBD, 0x70, 0xB5, 0x36, 0x4D, 0x04, 0x46, 0x24, 0x3D, 0xA9, 0x6C, 0x28, 0x6D, 0x29,
+	0x65, 0xA8, 0x64, 0xF9, 0xF7, 0x1A, 0xFC, 0x34, 0x4E, 0xB0, 0x69, 0x01, 0x28, 0x11, 0xD1, 0xA8,
+	0x6B, 0x71, 0x68, 0x20, 0x1A, 0x88, 0x42, 0x0C, 0xD9, 0x3A, 0x48, 0xF9, 0xF7, 0x08, 0xFC, 0x00,
+	0x20, 0x68, 0x75, 0xF9, 0xF7, 
+	0x00, 0x01, 0x32, 0x00, 0x80, 0x21, 0xF8, 0x70, 0x69, 0xF9, 0xF7, 0xA9, 0xFA, 0x23, 0x20, 0xAC,
+	0x63, 0x05, 0xE0, 0xF8, 0xF7, 0x5B, 0xFF, 0xF9, 0xF7, 0x9F, 0xF9, 0x0C, 0x20, 0xEC, 0x63, 0x68,
+	0x72, 0x01, 0x20, 0xC0, 0x07, 0x70, 0xBD, 0xF1, 0xB5, 0x21, 0x4D, 0x82, 0xB0, 0x24, 0x3D, 0x00,
+	0x24, 0x28, 0x6D, 0xFB, 0xF7, 0x96, 0xFE, 0xE8, 0x79, 0x01, 0x26, 0xC1, 0x08, 0x00, 0x29, 0x04,
+	0xD1, 0x00, 0x20, 0xFB, 0xF7, 0x42, 0xFA, 0x00, 0x20, 0x14, 0xE0, 0x01, 0x07, 0x0D, 0xD5, 0x1E,
+	0x49, 0x09, 0x78, 0x01, 0x29, 0x09, 0xD1, 0xE9, 0x7D, 0x00, 0x29, 0x06, 0xD1, 0x1B, 0x48, 0x06,
+	0x70, 0x03, 0x20, 0xFB, 0xF7, 0x32, 0xFA, 0x04, 0x20, 0x04, 0xE0, 0xC0, 0x09, 0xE8, 0xD1, 0xFB,
+	0xF7, 0x2C, 0xFA, 0x0F, 0x20, 0xF9, 0xF7, 0xF6, 0xFC, 0xFB, 0xF7, 0xF8, 0xFF, 0x15, 0x22, 0x52,
+	0x01, 0x68, 0x46, 0x29, 0x6D, 
+	0x00, 0x01, 0x33, 0x00, 0x80, 0xF7, 0xF7, 0x2C, 0xFD, 0x60, 0x21, 0x68, 0x46, 0xF7, 0xF7, 0x30,
+	0xFD, 0x07, 0x46, 0x01, 0x46, 0x68, 0x46, 0xFA, 0xF7, 0x98, 0xF8, 0x38, 0x46, 0xFB, 0xF7, 0x73,
+	0xF9, 0x39, 0x46, 0x68, 0x46, 0xFA, 0xF7, 0x16, 0xF9, 0x02, 0x46, 0x39, 0x46, 0x68, 0x46, 0x1D,
+	0xE0, 0xFC, 0x01, 0x00, 0x20, 0xC8, 0x01, 0x00, 0x20, 0x80, 0xE6, 0x00, 0x00, 0xC9, 0x01, 0x00,
+	0x20, 0xCA, 0x01, 0x00, 0x20, 0xB7, 0x8C, 0x00, 0x00, 0x28, 0x01, 0x00, 0x20, 0x2B, 0x01, 0x00,
+	0x20, 0xEE, 0x00, 0x00, 0x20, 0xEF, 0x00, 0x00, 0x20, 0xC2, 0x01, 0x00, 0x20, 0x80, 0xE8, 0x00,
+	0x00, 0x60, 0x14, 0x00, 0x20, 0xEF, 0x97, 0x00, 0x00, 0x00, 0x17, 0x00, 0x20, 0xFA, 0xF7, 0x74,
+	0xFE, 0x68, 0x46, 0xF7, 0xF7, 0x0A, 0xFD, 0xFF, 0xF7, 0xC2, 0xFB, 0xFC, 0x4F, 0x38, 0x78, 0x00,
+	0x28, 0x01, 0xD0, 0x00, 0x20, 
+	0x00, 0x01, 0x34, 0x00, 0x80, 0xA8, 0x71, 0xFA, 0x48, 0x00, 0x78, 0x00, 0x28, 0x03, 0xD0, 0xA8,
+	0x79, 0x80, 0x21, 0x08, 0x43, 0xA8, 0x71, 0x68, 0x46, 0xFD, 0xF7, 0x33, 0xFF, 0x03, 0xF0, 0x5F,
+	0xFA, 0x68, 0x79, 0x00, 0x28, 0x07, 0xD1, 0xF3, 0x48, 0x00, 0x78, 0x01, 0x28, 0x03, 0xD0, 0x28,
+	0x7B, 0xA9, 0x79, 0x88, 0x42, 0x02, 0xD0, 0xA8, 0x79, 0x28, 0x73, 0x04, 0x24, 0xEE, 0x48, 0x80,
+	0x69, 0x01, 0x28, 0x26, 0xD1, 0x38, 0x78, 0x00, 0x28, 0x01, 0xD1, 0x00, 0x20, 0x00, 0xE0, 0x0B,
+	0x20, 0x68, 0x72, 0x38, 0x78, 0xE8, 0x72, 0x28, 0x8C, 0x68, 0x84, 0xF9, 0xF7, 0x4D, 0xFA, 0x01,
+	0x28, 0x2A, 0xD1, 0xF8, 0xF7, 0x2E, 0xFE, 0xE4, 0x4F, 0xF8, 0x6B, 0x01, 0x28, 0x1A, 0xD1, 0x38,
+	0x46, 0x40, 0x30, 0x40, 0x8B, 0x29, 0x7A, 0x88, 0x43, 0xC0, 0x07, 0x13, 0xD1, 0xFF, 0xF7, 0x03,
+	0xFC, 0x01, 0x28, 0x0F, 0xD1, 
+	0x00, 0x01, 0x35, 0x00, 0x80, 0x04, 0x2C, 0x00, 0xD1, 0x6E, 0x74, 0x15, 0x20, 0x68, 0x72, 0xC4,
+	0x07, 0x1A, 0xE0, 0x01, 0xF0, 0x55, 0xFD, 0x03, 0x28, 0xD7, 0xD0, 0x01, 0xF0, 0x51, 0xFD, 0x04,
+	0x28, 0xD5, 0xD1, 0xD2, 0xE7, 0x02, 0x98, 0xFF, 0xF7, 0x41, 0xFA, 0xF8, 0x69, 0x01, 0x28, 0x0B,
+	0xD1, 0x02, 0x98, 0xFF, 0xF7, 0xD8, 0xFC, 0x07, 0xE0, 0x68, 0x7A, 0x34, 0x43, 0x00, 0x28, 0x00,
+	0xD0, 0x00, 0x26, 0xAE, 0x74, 0x0D, 0x20, 0x68, 0x72, 0x20, 0x46, 0xFE, 0xBD, 0x70, 0xB5, 0x06,
+	0x46, 0xF9, 0xF7, 0x12, 0xFA, 0x01, 0x28, 0x29, 0xD1, 0xF8, 0xF7, 0xF3, 0xFD, 0xC6, 0x4D, 0xE8,
+	0x6B, 0xC6, 0x4C, 0x01, 0x28, 0x0E, 0xD1, 0x28, 0x46, 0x40, 0x30, 0x40, 0x8B, 0x21, 0x7A, 0x88,
+	0x43, 0xC0, 0x07, 0x07, 0xD1, 0xFF, 0xF7, 0xC7, 0xFB, 0x01, 0x28, 0x03, 0xD1, 0x15, 0x20, 0x60,
+	0x72, 0xC0, 0x07, 0x70, 0xBD, 
+	0x00, 0x01, 0x36, 0x00, 0x80, 0x30, 0x46, 0xFF, 0xF7, 0x11, 0xFA, 0xE8, 0x69, 0x01, 0x28, 0x02,
+	0xD1, 0x30, 0x46, 0xFF, 0xF7, 0xA8, 0xFC, 0xA0, 0x7C, 0x01, 0x28, 0x03, 0xD1, 0x00, 0x20, 0x60,
+	0x72, 0x08, 0x20, 0x70, 0xBD, 0x0B, 0x20, 0x60, 0x72, 0x00, 0x20, 0x70, 0xBD, 0x01, 0x20, 0x70,
+	0xBD, 0x70, 0xB5, 0x05, 0x46, 0xB1, 0x4C, 0xB2, 0x48, 0x60, 0x64, 0x60, 0x30, 0xE0, 0x64, 0x60,
+	0x30, 0xA0, 0x64, 0xB0, 0x48, 0x20, 0x65, 0xB0, 0x48, 0xF9, 0xF7, 0xE1, 0xFA, 0xF8, 0xF7, 0xFC,
+	0xFE, 0x60, 0x6C, 0xF9, 0xF7, 0xE7, 0xFA, 0x03, 0x20, 0xF9, 0xF7, 0x81, 0xF9, 0x04, 0x20, 0x20,
+	0x75, 0x0F, 0x20, 0xA5, 0x63, 0x60, 0x72, 0x61, 0x7C, 0x05, 0x20, 0x00, 0x29, 0x00, 0xD1, 0x01,
+	0x20, 0x70, 0xBD, 0x10, 0xB5, 0xF9, 0xF7, 0xC0, 0xF9, 0x01, 0x28, 0x1C, 0xD1, 0xF8, 0xF7, 0xA1,
+	0xFD, 0x9D, 0x48, 0xC0, 0x6B, 
+	0x00, 0x01, 0x37, 0x00, 0x80, 0x9D, 0x4C, 0x01, 0x28, 0x11, 0xD1, 0x9B, 0x48, 0x40, 0x30, 0x40,
+	0x8B, 0x21, 0x7A, 0x88, 0x43, 0xC0, 0x07, 0x0A, 0xD1, 0xFF, 0xF7, 0x75, 0xFB, 0x01, 0x28, 0x06,
+	0xD1, 0x9A, 0x48, 0xF9, 0xF7, 0xB4, 0xFA, 0x15, 0x20, 0x60, 0x72, 0xC0, 0x07, 0x10, 0xBD, 0x10,
+	0x20, 0x60, 0x72, 0x00, 0x20, 0x10, 0xBD, 0x01, 0x20, 0x10, 0xBD, 0x70, 0xB5, 0x8F, 0x4C, 0x05,
+	0x46, 0x61, 0x6C, 0xE0, 0x6C, 0xE1, 0x64, 0x60, 0x64, 0xA1, 0x6C, 0x20, 0x6D, 0x21, 0x65, 0xA0,
+	0x64, 0xF8, 0xF7, 0xBA, 0xFE, 0x60, 0x6C, 0xF9, 0xF7, 0xA5, 0xFA, 0x03, 0x20, 0xF9, 0xF7, 0x3F,
+	0xF9, 0x04, 0x20, 0x20, 0x75, 0x11, 0x20, 0xA5, 0x63, 0x60, 0x72, 0xC0, 0x07, 0x70, 0xBD, 0xF1,
+	0xB5, 0x82, 0x4D, 0x00, 0x24, 0x28, 0x7D, 0x29, 0x46, 0xC9, 0x6C, 0x82, 0xB0, 0x04, 0x28, 0x01,
+	0xD1, 0x03, 0x20, 0x04, 0xE0, 
+	0x00, 0x01, 0x38, 0x00, 0x80, 0xC0, 0x07, 0x01, 0xD0, 0x01, 0x20, 0x00, 0xE0, 0x02, 0x20, 0xFB,
+	0xF7, 0xD8, 0xFA, 0x28, 0x6D, 0xFB, 0xF7, 0x25, 0xFD, 0xE8, 0x79, 0xC1, 0x08, 0x04, 0xD1, 0x00,
+	0x20, 0xFB, 0xF7, 0xD3, 0xF8, 0x00, 0x20, 0x15, 0xE0, 0x01, 0x07, 0x0E, 0xD5, 0x78, 0x49, 0x09,
+	0x78, 0x01, 0x29, 0x0A, 0xD1, 0xE9, 0x7D, 0x00, 0x29, 0x07, 0xD1, 0x76, 0x48, 0x01, 0x21, 0x01,
+	0x70, 0x03, 0x20, 0xFB, 0xF7, 0xC2, 0xF8, 0x04, 0x20, 0x04, 0xE0, 0xC0, 0x09, 0xE7, 0xD1, 0xFB,
+	0xF7, 0xBC, 0xF8, 0x0F, 0x20, 0xF9, 0xF7, 0x86, 0xFB, 0xFB, 0xF7, 0x81, 0xFD, 0xFB, 0xF7, 0x86,
+	0xFE, 0x15, 0x22, 0x52, 0x01, 0x68, 0x46, 0x29, 0x6D, 0xF7, 0xF7, 0xBA, 0xFB, 0x60, 0x21, 0x68,
+	0x46, 0xF7, 0xF7, 0xBE, 0xFB, 0x06, 0x46, 0x01, 0x46, 0x68, 0x46, 0xF9, 0xF7, 0x26, 0xFF, 0x30,
+	0x46, 0xFB, 0xF7, 0x01, 0xF8, 
+	0x00, 0x01, 0x39, 0x00, 0x80, 0x31, 0x46, 0x68, 0x46, 0xF9, 0xF7, 0xA4, 0xFF, 0x02, 0x46, 0x31,
+	0x46, 0x68, 0x46, 0xFA, 0xF7, 0x21, 0xFD, 0x68, 0x46, 0xF7, 0xF7, 0xB7, 0xFB, 0xFF, 0xF7, 0x6F,
+	0xFA, 0x52, 0x4E, 0x00, 0x27, 0x30, 0x78, 0x00, 0x28, 0x00, 0xD0, 0xAF, 0x71, 0x50, 0x48, 0x00,
+	0x78, 0x00, 0x28, 0x03, 0xD0, 0xA8, 0x79, 0x80, 0x21, 0x08, 0x43, 0xA8, 0x71, 0x68, 0x46, 0xFD,
+	0xF7, 0xE0, 0xFD, 0x03, 0xF0, 0x0C, 0xF9, 0x68, 0x79, 0x00, 0x28, 0x07, 0xD1, 0x49, 0x48, 0x00,
+	0x78, 0x01, 0x28, 0x03, 0xD0, 0x28, 0x7B, 0xA9, 0x79, 0x88, 0x42, 0x02, 0xD0, 0xA8, 0x79, 0x28,
+	0x73, 0x04, 0x24, 0x45, 0x48, 0x80, 0x69, 0x01, 0x28, 0x03, 0xD1, 0x30, 0x78, 0x00, 0x28, 0x0A,
+	0xD1, 0x07, 0xE0, 0x01, 0xF0, 0x25, 0xFC, 0x03, 0x28, 0x03, 0xD0, 0x01, 0xF0, 0x21, 0xFC, 0x04,
+	0x28, 0x01, 0xD1, 0x6F, 0x72, 
+	0x00, 0x01, 0x3A, 0x00, 0x80, 0x01, 0xE0, 0x10, 0x20, 0x68, 0x72, 0x30, 0x78, 0xE8, 0x72, 0x28,
+	0x8C, 0x68, 0x84, 0xF9, 0xF7, 0xF1, 0xF8, 0x01, 0x28, 0x2B, 0xD1, 0xF8, 0xF7, 0xD2, 0xFC, 0x36,
+	0x4E, 0xF0, 0x6B, 0x01, 0x28, 0x15, 0xD1, 0x30, 0x46, 0x40, 0x30, 0x40, 0x8B, 0x29, 0x7A, 0x88,
+	0x43, 0xC0, 0x07, 0x0E, 0xD1, 0xFF, 0xF7, 0xA7, 0xFA, 0x01, 0x28, 0x0A, 0xD1, 0x33, 0x48, 0xF9,
+	0xF7, 0xE6, 0xF9, 0x04, 0x2C, 0x01, 0xD1, 0x01, 0x20, 0x68, 0x74, 0x15, 0x20, 0x68, 0x72, 0xC4,
+	0x07, 0x18, 0xE0, 0x02, 0x98, 0xFF, 0xF7, 0xEA, 0xF8, 0x68, 0x7A, 0x00, 0x28, 0x02, 0xD1, 0x2B,
+	0x48, 0xF9, 0xF7, 0xD5, 0xF9, 0xF0, 0x69, 0x01, 0x28, 0x0C, 0xD1, 0x02, 0x98, 0xFF, 0xF7, 0x7B,
+	0xFB, 0x08, 0xE0, 0x01, 0x20, 0x69, 0x7A, 0x04, 0x43, 0x00, 0x29, 0x00, 0xD0, 0x00, 0x20, 0xA8,
+	0x74, 0x12, 0x20, 0x68, 0x72, 
+	0x00, 0x01, 0x3B, 0x00, 0x80, 0x20, 0x46, 0xFE, 0xBD, 0x70, 0xB5, 0x06, 0x46, 0xF9, 0xF7, 0xB4,
+	0xF8, 0x01, 0x28, 0x45, 0xD1, 0xF8, 0xF7, 0x95, 0xFC, 0x17, 0x4D, 0xE8, 0x6B, 0x17, 0x4C, 0x01,
+	0x28, 0x11, 0xD1, 0x28, 0x46, 0x40, 0x30, 0x40, 0x8B, 0x21, 0x7A, 0x88, 0x43, 0xC0, 0x07, 0x0A,
+	0xD1, 0xFF, 0xF7, 0x69, 0xFA, 0x01, 0x28, 0x06, 0xD1, 0x14, 0x48, 0xF9, 0xF7, 0xA8, 0xF9, 0x15,
+	0x20, 0x60, 0x72, 0xC0, 0x07, 0x70, 0xBD, 0x30, 0x46, 0xFF, 0xF7, 0xB0, 0xF8, 0xE8, 0x69, 0x01,
+	0x28, 0x02, 0xD1, 0x30, 0x46, 0xFF, 0xF7, 0x47, 0xFB, 0xA0, 0x7C, 0x01, 0x28, 0x1C, 0xD1, 0x00,
+	0x20, 0x60, 0x72, 0x08, 0x24, 0x09, 0x48, 0xF9, 0xF7, 0x92, 0xF9, 0x1A, 0xE0, 0xEE, 0x00, 0x00,
+	0x20, 0xEF, 0x00, 0x00, 0x20, 0xC2, 0x01, 0x00, 0x20, 0x80, 0xE6, 0x00, 0x00, 0xD8, 0x01, 0x00,
+	0x20, 0xA0, 0x13, 0x00, 0x20, 
+	0x00, 0x01, 0x3C, 0x00, 0x80, 0x00, 0x17, 0x00, 0x20, 0xEF, 0x97, 0x00, 0x00, 0xB7, 0x8C, 0x00,
+	0x00, 0x28, 0x01, 0x00, 0x20, 0x2B, 0x01, 0x00, 0x20, 0x10, 0x20, 0x60, 0x72, 0x00, 0x24, 0x00,
+	0xE0, 0x01, 0x24, 0x20, 0x46, 0x70, 0xBD, 0x10, 0xB5, 0xF8, 0xF7, 0x10, 0xFE, 0xCE, 0x48, 0x40,
+	0x6C, 0xC0, 0xB2, 0xF9, 0xF7, 0x1D, 0xF8, 0xCD, 0x48, 0x14, 0x21, 0x41, 0x72, 0x41, 0x7C, 0x01,
+	0x29, 0x03, 0xD1, 0x00, 0x21, 0x41, 0x74, 0x05, 0x20, 0x10, 0xBD, 0x01, 0x20, 0x10, 0xBD, 0xF8,
+	0xB5, 0xF9, 0xF7, 0x52, 0xF8, 0x01, 0x28, 0x3E, 0xD1, 0xF8, 0xF7, 0x33, 0xFC, 0xF9, 0xF7, 0xDE,
+	0xF9, 0xC2, 0x4C, 0x00, 0x90, 0x20, 0x8C, 0x15, 0x27, 0x80, 0x06, 0xFE, 0x07, 0x00, 0x28, 0x0F,
+	0xDA, 0xF9, 0xF7, 0xD8, 0xF9, 0xBC, 0x49, 0x00, 0x25, 0x00, 0x28, 0x03, 0xD1, 0xCA, 0x6C, 0x00,
+	0x98, 0x82, 0x42, 0x19, 0xD2, 
+	0x00, 0x01, 0x3D, 0x00, 0x80, 0x08, 0x6C, 0x01, 0x28, 0x13, 0xD1, 0xA0, 0x7E, 0x02, 0x28, 0x02,
+	0xD2, 0x67, 0x72, 0x30, 0x46, 0xF8, 0xBD, 0x89, 0x6C, 0xE0, 0x7E, 0x81, 0x42, 0x03, 0xD9, 0xA5,
+	0x76, 0x40, 0x1C, 0xE0, 0x76, 0xF4, 0xE7, 0x20, 0x8C, 0xFF, 0x21, 0x01, 0x31, 0x08, 0x43, 0x20,
+	0x84, 0x0E, 0xE0, 0x20, 0x8C, 0x80, 0x21, 0xF9, 0xE7, 0xF9, 0xF7, 0xB0, 0xF9, 0xE1, 0x7C, 0x01,
+	0x29, 0x06, 0xD1, 0x00, 0x28, 0x04, 0xD1, 0xE5, 0x74, 0xFB, 0xF7, 0x05, 0xFC, 0xFB, 0xF7, 0x32,
+	0xFC, 0x65, 0x72, 0x08, 0x20, 0xF8, 0xBD, 0x01, 0x20, 0xF8, 0xBD, 0x70, 0xB5, 0xA3, 0x4C, 0x00,
+	0x25, 0x20, 0x8C, 0xC1, 0x05, 0x00, 0x29, 0x02, 0xDA, 0x65, 0x72, 0x08, 0x20, 0x70, 0xBD, 0xC0,
+	0x06, 0x0E, 0xD4, 0x02, 0x20, 0xFA, 0xF7, 0x41, 0xFF, 0x02, 0x20, 0xFA, 0xF7, 0x66, 0xFF, 0x02,
+	0x20, 0xF9, 0xF7, 0x30, 0xFA, 
+	0x00, 0x01, 0x3E, 0x00, 0x80, 0x01, 0x20, 0x02, 0xF0, 0xDF, 0xFF, 0x20, 0x8C, 0x10, 0x21, 0x3E,
+	0xE0, 0x20, 0x7F, 0x00, 0x28, 0x12, 0xD1, 0x02, 0x20, 0xF7, 0xF7, 0x1D, 0xFB, 0xF9, 0xF7, 0x87,
+	0xF9, 0x91, 0x48, 0x80, 0x6E, 0xC0, 0xB2, 0xF9, 0xF7, 0x52, 0xF9, 0x01, 0x20, 0x20, 0x77, 0x03,
+	0x20, 0xFA, 0xF7, 0x7E, 0xFE, 0x03, 0x20, 0xF9, 0xF7, 0xEE, 0xFA, 0x26, 0xE0, 0x03, 0x20, 0xF7,
+	0xF7, 0x0A, 0xFB, 0xF9, 0xF7, 0x74, 0xF9, 0x20, 0x7E, 0x60, 0x76, 0x40, 0x1C, 0xC0, 0xB2, 0x20,
+	0x76, 0x03, 0x28, 0x04, 0xD3, 0x60, 0x7F, 0x00, 0x28, 0x00, 0xD0, 0x01, 0x20, 0x20, 0x76, 0x21,
+	0x7E, 0x03, 0x20, 0x49, 0x1E, 0xF7, 0xF7, 0xE7, 0xFA, 0xF9, 0xF7, 0x88, 0xF9, 0x20, 0x7E, 0xFE,
+	0xF7, 0x97, 0xFD, 0x21, 0x7E, 0x60, 0x7E, 0xFE, 0xF7, 0xB0, 0xFF, 0x65, 0x77, 0xA0, 0x7E, 0x40,
+	0x21, 0x40, 0x1C, 0xA0, 0x76, 
+	0x00, 0x01, 0x3F, 0x00, 0x80, 0x20, 0x8C, 0x08, 0x43, 0x20, 0x84, 0x20, 0x8C, 0x20, 0x21, 0x08,
+	0x43, 0x20, 0x84, 0x13, 0x20, 0x60, 0x72, 0xC0, 0x07, 0x70, 0xBD, 0x10, 0xB5, 0xFF, 0xF7, 0xC3,
+	0xFC, 0x72, 0x49, 0x04, 0x46, 0x4A, 0x7D, 0x00, 0x2A, 0xFC, 0xD0, 0x6F, 0x48, 0x40, 0x69, 0xC9,
+	0x6C, 0xFB, 0xF7, 0x07, 0xF9, 0xFB, 0xF7, 0xD3, 0xFB, 0x6D, 0x48, 0xF9, 0xF7, 0xA8, 0xF8, 0x20,
+	0x46, 0x10, 0xBD, 0x6A, 0x49, 0x88, 0x72, 0x70, 0x47, 0x10, 0xB5, 0xF8, 0xF7, 0x96, 0xFB, 0x10,
+	0xBD, 0x10, 0xB5, 0xF8, 0xF7, 0x6A, 0xFB, 0x10, 0xBD, 0x66, 0x48, 0x70, 0x47, 0x10, 0xB5, 0x66,
+	0x49, 0x00, 0x20, 0xC8, 0x76, 0x03, 0xF0, 0x24, 0xF9, 0x10, 0xBD, 0x10, 0xB5, 0x03, 0x21, 0xFF,
+	0xF7, 0x18, 0xF8, 0x5E, 0x4A, 0x25, 0x21, 0x51, 0x72, 0x10, 0xBD, 0x70, 0xB5, 0x05, 0x46, 0x01,
+	0x24, 0xF8, 0xF7, 0x7A, 0xFF, 
+	0x00, 0x01, 0x40, 0x00, 0x80, 0x01, 0x28, 0x1B, 0xD1, 0xF8, 0xF7, 0x5B, 0xFB, 0x57, 0x4C, 0x03,
+	0x20, 0xE1, 0x6C, 0xFB, 0xF7, 0xD6, 0xF8, 0xFB, 0xF7, 0xA2, 0xFB, 0x28, 0x46, 0x03, 0xF0, 0x10,
+	0xF9, 0x01, 0x28, 0x0A, 0xD1, 0x54, 0x49, 0xC8, 0x76, 0x52, 0x48, 0xA0, 0x64, 0x20, 0x65, 0xF9,
+	0xF7, 0x74, 0xF8, 0xFB, 0xF7, 0x7F, 0xFB, 0x00, 0x20, 0x00, 0xE0, 0x24, 0x20, 0x60, 0x72, 0x08,
+	0x24, 0x20, 0x46, 0x70, 0xBD, 0x10, 0xB5, 0x49, 0x49, 0x00, 0x20, 0x88, 0x77, 0x03, 0xF0, 0x6A,
+	0xF9, 0x10, 0xBD, 0x10, 0xB5, 0xFB, 0xF7, 0x56, 0xFB, 0xFB, 0xF7, 0x22, 0xFB, 0x10, 0xBD, 0x10,
+	0xB5, 0x03, 0x21, 0xFE, 0xF7, 0xDE, 0xFF, 0x41, 0x4A, 0x27, 0x21, 0x51, 0x72, 0x10, 0xBD, 0xF8,
+	0xB5, 0x07, 0x46, 0x00, 0x24, 0x01, 0x25, 0xF8, 0xF7, 0x3F, 0xFF, 0x01, 0x28, 0x28, 0xD1, 0xF8,
+	0xF7, 0x20, 0xFB, 0x3E, 0x4E, 
+	0x00, 0x01, 0x41, 0x00, 0x80, 0x39, 0x4D, 0x30, 0x78, 0xE9, 0x6C, 0x00, 0x28, 0x01, 0xD0, 0x01,
+	0x20, 0x00, 0xE0, 0x03, 0x20, 0xFB, 0xF7, 0x95, 0xF8, 0xF7, 0xF7, 0x7D, 0xFA, 0x00, 0x28, 0x02,
+	0xD0, 0xF7, 0xF7, 0x75, 0xFA, 0x01, 0x24, 0xFB, 0xF7, 0x5A, 0xFB, 0x00, 0x2C, 0x01, 0xD0, 0xF7,
+	0xF7, 0x67, 0xFA, 0x38, 0x46, 0x03, 0xF0, 0x20, 0xFA, 0x00, 0x24, 0x00, 0x28, 0x06, 0xD0, 0x34,
+	0x70, 0xA8, 0x77, 0x29, 0x48, 0x80, 0x30, 0x00, 0x78, 0x02, 0xF0, 0xE8, 0xFB, 0x6C, 0x72, 0x08,
+	0x25, 0x28, 0x46, 0xF8, 0xBD, 0x10, 0xB5, 0xF8, 0xF7, 0xB9, 0xFC, 0x23, 0x48, 0x40, 0x6C, 0xC0,
+	0xB2, 0xF8, 0xF7, 0xC6, 0xFE, 0xF8, 0xF7, 0x08, 0xFF, 0x01, 0x28, 0xFB, 0xD1, 0xF8, 0xF7, 0xE9,
+	0xFA, 0x10, 0xBD, 0xF8, 0xB5, 0x1F, 0x46, 0x05, 0x46, 0x0C, 0x46, 0x56, 0x18, 0x0A, 0xE0, 0xA0,
+	0xB2, 0x3A, 0x46, 0x29, 0x46, 
+	0x00, 0x01, 0x42, 0x00, 0x80, 0xF7, 0xF7, 0x8C, 0xF9, 0x00, 0x28, 0x01, 0xD0, 0x72, 0xB6, 0xFE,
+	0xE7, 0x80, 0x35, 0x64, 0x1C, 0xA6, 0x42, 0xF2, 0xD8, 0xF8, 0xBD, 0x70, 0xB5, 0x40, 0x08, 0x00,
+	0x25, 0x12, 0x4B, 0x90, 0x42, 0x01, 0xD3, 0x5D, 0x73, 0x01, 0xE0, 0x14, 0x1A, 0x5C, 0x73, 0x14,
+	0x4C, 0xE6, 0x69, 0x36, 0x1A, 0x76, 0x1E, 0x96, 0x42, 0x02, 0xD8, 0xE2, 0x69, 0x52, 0x1E, 0x00,
+	0xE0, 0x82, 0x18, 0x9A, 0x73, 0x88, 0x42, 0x01, 0xD3, 0xDD, 0x73, 0x01, 0xE0, 0x0A, 0x1A, 0xDA,
+	0x73, 0x22, 0x6A, 0x12, 0x1A, 0x52, 0x1E, 0x8A, 0x42, 0x02, 0xD8, 0x20, 0x6A, 0x40, 0x1E, 0x00,
+	0xE0, 0x40, 0x18, 0x18, 0x74, 0x70, 0xBD, 0x00, 0x00, 0x80, 0xE6, 0x00, 0x00, 0xD8, 0x01, 0x00,
+	0x20, 0xB7, 0x8C, 0x00, 0x00, 0x60, 0x14, 0x00, 0x20, 0x88, 0x03, 0x00, 0x20, 0x6C, 0x02, 0x00,
+	0x20, 0xF0, 0xE9, 0x00, 0x00, 
+	0x00, 0x01, 0x43, 0x00, 0x80, 0x10, 0xB5, 0xC3, 0x48, 0x40, 0x7A, 0x00, 0x28, 0x01, 0xD1, 0x01,
+	0x20, 0x00, 0xE0, 0x00, 0x20, 0x03, 0xF0, 0x64, 0xFB, 0x10, 0xBD, 0x10, 0xB5, 0x00, 0x20, 0x03,
+	0xF0, 0x0D, 0xFB, 0x03, 0xF0, 0x74, 0xFB, 0x00, 0x20, 0x03, 0xF0, 0x11, 0xFB, 0x00, 0x20, 0x03,
+	0xF0, 0x17, 0xFB, 0xB9, 0x48, 0x00, 0x78, 0x01, 0x07, 0xB6, 0x48, 0x0E, 0xD4, 0x40, 0x7A, 0x00,
+	0x28, 0x04, 0xD1, 0x01, 0x20, 0x03, 0xF0, 0x55, 0xFB, 0x01, 0x20, 0x03, 0xE0, 0x01, 0x20, 0x03,
+	0xF0, 0x50, 0xFB, 0x00, 0x20, 0x03, 0xF0, 0x44, 0xFB, 0x10, 0xBD, 0x00, 0x7A, 0x03, 0xF0, 0x49,
+	0xFB, 0xFF, 0xF7, 0xD0, 0xFF, 0x10, 0xBD, 0xD8, 0xE7, 0x30, 0xB5, 0x02, 0x24, 0xA9, 0x49, 0x24,
+	0x20, 0x8C, 0x71, 0xC8, 0x71, 0xA8, 0x48, 0x02, 0x78, 0x52, 0x08, 0x52, 0x00, 0x02, 0x70, 0x02,
+	0x78, 0xFD, 0x23, 0x1A, 0x40, 
+	0x00, 0x01, 0x44, 0x00, 0x80, 0x02, 0x70, 0x22, 0x02, 0x0A, 0x80, 0x00, 0x22, 0x4A, 0x80, 0x8A,
+	0x80, 0x03, 0x78, 0xF7, 0x25, 0x2B, 0x40, 0x03, 0x70, 0x0C, 0x72, 0x4A, 0x72, 0x01, 0x78, 0xFB,
+	0x22, 0x11, 0x40, 0x01, 0x70, 0x01, 0x21, 0x41, 0x70, 0x30, 0xBD, 0x9A, 0x49, 0x9B, 0x48, 0x4A,
+	0x88, 0x82, 0x62, 0x89, 0x88, 0xC1, 0x62, 0x98, 0x49, 0x09, 0x78, 0xC9, 0x07, 0x03, 0xD0, 0x41,
+	0x69, 0x08, 0x22, 0x11, 0x43, 0x41, 0x61, 0x70, 0x47, 0x10, 0xB5, 0x93, 0x48, 0x40, 0x78, 0x00,
+	0x28, 0x0B, 0xD1, 0x03, 0xF0, 0xDD, 0xFA, 0xFF, 0xF7, 0xC7, 0xFF, 0x03, 0x21, 0x00, 0x20, 0xFB,
+	0xF7, 0x7B, 0xFF, 0x8F, 0x49, 0x00, 0x20, 0xFB, 0xF7, 0x70, 0xFF, 0x8C, 0x48, 0x40, 0x69, 0xC0,
+	0x07, 0x01, 0xD0, 0x00, 0xF0, 0x05, 0xF9, 0xFF, 0xF7, 0xD8, 0xFF, 0xFF, 0xF7, 0x8E, 0xFF, 0x10,
+	0xBD, 0x10, 0xB5, 0x03, 0xF0, 
+	0x00, 0x01, 0x45, 0x00, 0x80, 0xB7, 0xFA, 0x10, 0xBD, 0x84, 0x48, 0x41, 0x69, 0x01, 0x22, 0x11,
+	0x43, 0x41, 0x61, 0x81, 0x48, 0x01, 0x78, 0x04, 0x22, 0x11, 0x43, 0x01, 0x70, 0x70, 0x47, 0x10,
+	0xB5, 0x00, 0xF0, 0xEE, 0xF8, 0x7C, 0x48, 0x01, 0x78, 0xFB, 0x22, 0x11, 0x40, 0x01, 0x70, 0x10,
+	0xBD, 0x30, 0xB4, 0x79, 0x4A, 0x01, 0x28, 0x13, 0x78, 0x02, 0xD1, 0xF7, 0x24, 0x23, 0x40, 0x01,
+	0xE0, 0x08, 0x24, 0x23, 0x43, 0x13, 0x70, 0x73, 0x4A, 0x10, 0x72, 0x51, 0x72, 0x30, 0xBC, 0x64,
+	0xE7, 0x10, 0xB5, 0x70, 0x48, 0x40, 0x7A, 0x00, 0x28, 0x00, 0xD0, 0x01, 0x20, 0x03, 0xF0, 0xC0,
+	0xFA, 0x10, 0xBD, 0x10, 0xB5, 0x03, 0xF0, 0xCE, 0xFA, 0x01, 0x21, 0x48, 0x40, 0x03, 0xF0, 0xB8,
+	0xFA, 0x10, 0xBD, 0x69, 0x49, 0x0A, 0x78, 0x01, 0x23, 0x1A, 0x43, 0x0A, 0x70, 0x69, 0x49, 0x65,
+	0x4A, 0x88, 0x42, 0x01, 0xD9, 
+	0x00, 0x01, 0x46, 0x00, 0x80, 0x91, 0x80, 0x00, 0xE0, 0x90, 0x80, 0x8E, 0xE7, 0x10, 0xB5, 0x03,
+	0xF0, 0x9B, 0xFA, 0x10, 0xBD, 0x64, 0x49, 0x80, 0x00, 0x40, 0x18, 0x00, 0x68, 0xC0, 0xB2, 0x70,
+	0x47, 0x70, 0xB5, 0x0C, 0x46, 0x05, 0x46, 0x09, 0x0A, 0x03, 0xF0, 0x8E, 0xFA, 0xE1, 0xB2, 0x68,
+	0x1C, 0x03, 0xF0, 0x8A, 0xFA, 0x70, 0xBD, 0x81, 0x00, 0x5B, 0x48, 0x08, 0x18, 0x01, 0x68, 0x40,
+	0x68, 0x09, 0x02, 0x01, 0x43, 0x88, 0xB2, 0x70, 0x47, 0x54, 0x48, 0x80, 0x69, 0x08, 0x21, 0x08,
+	0x40, 0x70, 0x47, 0x10, 0xB5, 0x51, 0x4C, 0xFB, 0xF7, 0xE9, 0xFE, 0xA1, 0x69, 0x09, 0x07, 0x07,
+	0xD4, 0xA1, 0x68, 0x01, 0x22, 0x11, 0x43, 0xA1, 0x60, 0xC0, 0xB2, 0xFB, 0xF7, 0xE3, 0xFE, 0x10,
+	0xBD, 0xC0, 0xB2, 0xFB, 0xF7, 0xDF, 0xFE, 0xEE, 0xE7, 0xEB, 0xE7, 0x10, 0xB5, 0x47, 0x4C, 0xFB,
+	0xF7, 0xD5, 0xFE, 0xA1, 0x69, 
+	0x00, 0x01, 0x47, 0x00, 0x80, 0x09, 0x07, 0x07, 0xD4, 0xA1, 0x68, 0x49, 0x08, 0x49, 0x00, 0xA1,
+	0x60, 0xC0, 0xB2, 0xFB, 0xF7, 0xCF, 0xFE, 0x03, 0xE0, 0xC0, 0xB2, 0xFB, 0xF7, 0xCB, 0xFE, 0xEE,
+	0xE7, 0xA0, 0x68, 0x80, 0x07, 0xFC, 0xD4, 0x10, 0xBD, 0xE7, 0xE7, 0x70, 0xB5, 0x04, 0x46, 0x80,
+	0x07, 0x01, 0xD1, 0x01, 0x20, 0x04, 0x43, 0x38, 0x4E, 0x3C, 0x4D, 0xB4, 0x70, 0xE0, 0x07, 0x12,
+	0xD0, 0xFF, 0xF7, 0xC7, 0xFF, 0x35, 0x49, 0x48, 0x69, 0x80, 0x07, 0x01, 0xD5, 0x09, 0x20, 0x00,
+	0xE0, 0x03, 0x20, 0x08, 0x61, 0xFF, 0x20, 0xC8, 0x60, 0x03, 0x20, 0xFB, 0xF7, 0xD6, 0xFE, 0x03,
+	0x20, 0xFB, 0xF7, 0xC4, 0xFE, 0x0E, 0xE0, 0x00, 0xF0, 0x4B, 0xF8, 0xA8, 0x68, 0xFF, 0x21, 0xC8,
+	0x31, 0xB0, 0x60, 0x88, 0x43, 0x40, 0x1C, 0xA8, 0x60, 0x2D, 0x49, 0x08, 0x68, 0x70, 0x60, 0x80,
+	0x08, 0x80, 0x00, 0x08, 0x60, 
+	0x00, 0x01, 0x48, 0x00, 0x80, 0xA0, 0x07, 0x10, 0xD5, 0x03, 0x20, 0x03, 0xF0, 0xD7, 0xF9, 0x00,
+	0x20, 0x03, 0xF0, 0xDD, 0xF9, 0x00, 0x20, 0x03, 0xF0, 0xE3, 0xF9, 0x10, 0x20, 0x28, 0x61, 0x00,
+	0x20, 0xFB, 0xF7, 0xB3, 0xFE, 0x00, 0x20, 0xFB, 0xF7, 0xA1, 0xFE, 0x70, 0xBD, 0x70, 0xB5, 0x1A,
+	0x4C, 0x00, 0x20, 0xA5, 0x78, 0xFB, 0xF7, 0xA1, 0xFE, 0x00, 0x20, 0x03, 0xF0, 0xBF, 0xF9, 0x1B,
+	0x4E, 0x10, 0x20, 0x30, 0x61, 0x00, 0x20, 0xFB, 0xF7, 0xA0, 0xFE, 0xE8, 0x07, 0x0B, 0xD0, 0x13,
+	0x48, 0x00, 0x21, 0x01, 0x61, 0xFF, 0x21, 0xC1, 0x60, 0x03, 0x20, 0xFB, 0xF7, 0x8E, 0xFE, 0x03,
+	0x20, 0xFB, 0xF7, 0x93, 0xFE, 0x09, 0xE0, 0x12, 0x49, 0x60, 0x68, 0x08, 0x60, 0xA0, 0x68, 0xB0,
+	0x60, 0x20, 0x78, 0x40, 0x07, 0x01, 0xD5, 0xFF, 0xF7, 0x07, 0xFF, 0xFF, 0xF7, 0x7E, 0xFF, 0x70,
+	0xBD, 0x06, 0x48, 0x81, 0x69, 
+	0x00, 0x01, 0x49, 0x00, 0x80, 0x09, 0x07, 0xFC, 0xD4, 0x41, 0x69, 0x49, 0x08, 0x49, 0x00, 0x41,
+	0x61, 0x70, 0x47, 0x00, 0x00, 0xA0, 0x19, 0x00, 0x20, 0x2C, 0x02, 0x00, 0x20, 0x00, 0x00, 0x12,
+	0x40, 0xE3, 0xA1, 0x00, 0x00, 0xFF, 0x01, 0x00, 0x00, 0x00, 0x10, 0x12, 0x40, 0x00, 0x00, 0x14,
+	0x40, 0x00, 0x20, 0x14, 0x40, 0x10, 0xB5, 0xFF, 0x20, 0xFB, 0xF7, 0x6E, 0xFE, 0x10, 0xBD, 0x70,
+	0xB5, 0xFB, 0xF7, 0x34, 0xFE, 0x0D, 0x4A, 0x11, 0x68, 0x03, 0x23, 0x9B, 0x03, 0x01, 0x24, 0x99,
+	0x43, 0xA4, 0x03, 0x0C, 0x43, 0x14, 0x60, 0x01, 0x24, 0xE4, 0x03, 0x0C, 0x43, 0x14, 0x60, 0x09,
+	0x4D, 0x07, 0x4C, 0x2C, 0x61, 0x08, 0x4D, 0x04, 0x24, 0x2C, 0x60, 0x19, 0x43, 0x11, 0x60, 0xFB,
+	0xF7, 0x21, 0xFE, 0x06, 0x49, 0x01, 0x20, 0x08, 0x70, 0x70, 0xBD, 0x00, 0x00, 0x00, 0x00, 0x01,
+	0x40, 0x05, 0x01, 0x01, 0x00, 
+	0x00, 0x01, 0x4A, 0x00, 0x80, 0x00, 0x04, 0x01, 0x40, 0x80, 0xE2, 0x00, 0xE0, 0x3A, 0x02, 0x00,
+	0x20, 0x70, 0xB5, 0xFF, 0xF7, 0xC4, 0xFE, 0x01, 0x25, 0x6D, 0x02, 0x28, 0x46, 0xFF, 0xF7, 0xE9,
+	0xFE, 0xFF, 0xF7, 0xB2, 0xFE, 0x03, 0x24, 0xA0, 0xB2, 0x00, 0x21, 0xFF, 0xF7, 0xEF, 0xFE, 0x64,
+	0x1C, 0xAC, 0x42, 0xF8, 0xD3, 0x40, 0x21, 0x02, 0x20, 0xFF, 0xF7, 0xE8, 0xFE, 0xF9, 0x49, 0x00,
+	0x20, 0x08, 0x70, 0x70, 0xBD, 0xF1, 0xB5, 0xF8, 0x48, 0x84, 0xB0, 0x82, 0x78, 0x41, 0x78, 0x12,
+	0x02, 0x89, 0x18, 0xC2, 0x78, 0x00, 0x79, 0x12, 0x04, 0x00, 0x06, 0x10, 0x18, 0x0C, 0x18, 0x08,
+	0x20, 0xFF, 0xF7, 0xD8, 0xFE, 0x05, 0x46, 0x09, 0x20, 0xFF, 0xF7, 0xD4, 0xFE, 0x00, 0x02, 0xFF,
+	0x26, 0x04, 0x99, 0x28, 0x18, 0xEF, 0x36, 0x00, 0x29, 0x01, 0xD1, 0xFF, 0x26, 0xFD, 0x36, 0xB0,
+	0x42, 0x00, 0xD8, 0x06, 0x46, 
+	0x00, 0x01, 0x4B, 0x00, 0x80, 0x01, 0x20, 0x00, 0x25, 0x01, 0x90, 0x28, 0x46, 0x0A, 0x30, 0x07,
+	0x46, 0x80, 0xB2, 0xFF, 0xF7, 0xBF, 0xFE, 0x02, 0xA9, 0x48, 0x55, 0xB8, 0xB2, 0x00, 0x21, 0xFF,
+	0xF7, 0xB5, 0xFE, 0xE2, 0x48, 0x02, 0xA9, 0x40, 0x5D, 0x49, 0x5D, 0x88, 0x42, 0x01, 0xD0, 0x00,
+	0x20, 0x01, 0x90, 0x6D, 0x1C, 0x08, 0x2D, 0xE8, 0xD3, 0x01, 0x98, 0x01, 0x28, 0x06, 0xD1, 0x40,
+	0x07, 0x84, 0x42, 0x03, 0xD3, 0xDA, 0x49, 0xA0, 0x19, 0x88, 0x42, 0x02, 0xD9, 0x01, 0x20, 0x05,
+	0xB0, 0xF0, 0xBD, 0x04, 0x98, 0x00, 0x28, 0x0C, 0xD0, 0x00, 0x25, 0x07, 0xE0, 0x28, 0x46, 0x12,
+	0x30, 0x80, 0xB2, 0xFF, 0xF7, 0x97, 0xFE, 0x20, 0x70, 0x64, 0x1C, 0x6D, 0x1C, 0xB5, 0x42, 0xF5,
+	0xD3, 0x13, 0xE0, 0xCD, 0x48, 0x00, 0x25, 0x40, 0x1D, 0x21, 0x78, 0x42, 0x19, 0x64, 0x1C, 0x6D,
+	0x1C, 0x51, 0x70, 0x04, 0x2D, 
+	0x00, 0x01, 0x4C, 0x00, 0x80, 0xF8, 0xD3, 0x06, 0xE0, 0x21, 0x78, 0x28, 0x1D, 0x64, 0x1C, 0x80,
+	0xB2, 0xFF, 0xF7, 0x7C, 0xFE, 0x6D, 0x1C, 0xB5, 0x42, 0xF6, 0xD3, 0x00, 0x20, 0xD7, 0xE7, 0xFE,
+	0xB5, 0xC1, 0x48, 0x01, 0x88, 0x06, 0x79, 0x4F, 0xBA, 0x41, 0x88, 0xC2, 0x48, 0x4D, 0xBA, 0xBE,
+	0x49, 0x09, 0x79, 0xC9, 0x00, 0x02, 0x91, 0x03, 0x2E, 0x01, 0xD2, 0x84, 0x6A, 0x07, 0xE0, 0x06,
+	0x2E, 0x01, 0xD2, 0x44, 0x6A, 0x03, 0xE0, 0x09, 0x2E, 0x15, 0xD2, 0x40, 0x6A, 0x44, 0x00, 0x08,
+	0x46, 0xB6, 0x49, 0x08, 0x31, 0x40, 0x18, 0x00, 0x79, 0x40, 0x07, 0x40, 0x0F, 0x01, 0x46, 0x01,
+	0x90, 0xFF, 0x20, 0xF9, 0x30, 0x03, 0xF0, 0x2B, 0xFA, 0x85, 0x42, 0x00, 0xD9, 0x05, 0x46, 0xA7,
+	0x42, 0x11, 0xD2, 0xE0, 0x1B, 0x10, 0xE0, 0x09, 0x2E, 0x09, 0xD1, 0xC0, 0x6A, 0x84, 0x00, 0xAD,
+	0x48, 0x40, 0x30, 0x40, 0x6A, 
+	0x00, 0x01, 0x4D, 0x00, 0x80, 0x03, 0x28, 0x00, 0xD1, 0x64, 0x00, 0x02, 0x20, 0xE6, 0xE7, 0xA6,
+	0x48, 0x01, 0x21, 0x40, 0x1D, 0x21, 0xE0, 0x00, 0x20, 0x85, 0x42, 0x00, 0xD9, 0x05, 0x46, 0xA3,
+	0x49, 0x02, 0x98, 0x08, 0x31, 0x08, 0x58, 0x01, 0x99, 0x4F, 0x43, 0x3F, 0x18, 0x08, 0x46, 0x68,
+	0x43, 0x00, 0x24, 0x00, 0x90, 0x07, 0xE0, 0x20, 0x46, 0x08, 0x30, 0x80, 0xB2, 0xFF, 0xF7, 0x2A,
+	0xFE, 0x38, 0x70, 0x7F, 0x1C, 0x64, 0x1C, 0x00, 0x98, 0x84, 0x42, 0xF4, 0xD3, 0x96, 0x48, 0x40,
+	0x1D, 0x46, 0x70, 0x29, 0x0A, 0x81, 0x70, 0xC5, 0x70, 0x00, 0x21, 0x01, 0x70, 0xFE, 0xBD, 0xF0,
+	0xB5, 0x95, 0x48, 0x04, 0x68, 0x95, 0x48, 0x05, 0x78, 0x95, 0x48, 0x00, 0x78, 0x85, 0x42, 0x00,
+	0xD9, 0x05, 0x46, 0x94, 0x48, 0x94, 0x4A, 0x00, 0x88, 0x12, 0x78, 0xDC, 0x23, 0x1A, 0x40, 0xA2,
+	0x72, 0x41, 0x1C, 0xEA, 0x00, 
+	0x00, 0x01, 0x4E, 0x00, 0x80, 0x89, 0xB2, 0x52, 0x1B, 0x52, 0x18, 0x09, 0x3A, 0x62, 0x72, 0x25,
+	0x54, 0x00, 0x20, 0x21, 0xE0, 0xC2, 0x00, 0x83, 0x18, 0x8C, 0x4A, 0x9A, 0x18, 0x53, 0x79, 0x16,
+	0x79, 0x1B, 0x02, 0x33, 0x43, 0x1B, 0x0A, 0x63, 0x54, 0x53, 0x79, 0x17, 0x79, 0x1E, 0x02, 0x63,
+	0x18, 0x3E, 0x43, 0x5E, 0x70, 0xD6, 0x78, 0x97, 0x78, 0x36, 0x02, 0x3E, 0x43, 0x36, 0x0A, 0x9E,
+	0x70, 0xD6, 0x78, 0x97, 0x78, 0x36, 0x02, 0x3E, 0x43, 0xDE, 0x70, 0x12, 0x7A, 0x1A, 0x71, 0xC9,
+	0x1D, 0x58, 0x71, 0x40, 0x1C, 0x89, 0xB2, 0xC0, 0xB2, 0xA8, 0x42, 0xDB, 0xD3, 0x7A, 0x49, 0x08,
+	0x78, 0x40, 0x30, 0x08, 0x70, 0xF0, 0xBD, 0x10, 0xB5, 0x6F, 0x4C, 0x01, 0x46, 0x10, 0x3C, 0x62,
+	0x68, 0xE0, 0x68, 0x90, 0x42, 0x07, 0xD3, 0xA3, 0x68, 0x98, 0x42, 0x04, 0xD2, 0x80, 0x1A, 0x08,
+	0x30, 0x80, 0xB2, 0xFF, 0xF7, 
+	0x00, 0x01, 0x4F, 0x00, 0x80, 0xC3, 0xFD, 0xE0, 0x68, 0x40, 0x1C, 0xE0, 0x60, 0x10, 0xBD, 0xFF,
+	0xB5, 0x83, 0xB0, 0x00, 0x20, 0x0F, 0x9E, 0x04, 0x46, 0x01, 0x90, 0x0E, 0xE0, 0x0E, 0x98, 0x00,
+	0x19, 0xF8, 0xF7, 0x8E, 0xFD, 0x16, 0x21, 0x48, 0x43, 0x69, 0x49, 0x40, 0x18, 0x81, 0x78, 0x01,
+	0x98, 0x08, 0x18, 0xC0, 0xB2, 0x64, 0x1C, 0xA4, 0xB2, 0x01, 0x90, 0x0D, 0x98, 0x84, 0x42, 0xED,
+	0xD3, 0x00, 0x25, 0x49, 0xE0, 0x11, 0x98, 0x04, 0x99, 0x68, 0x43, 0x40, 0x18, 0x80, 0xB2, 0x00,
+	0x90, 0x0E, 0x98, 0x00, 0x24, 0x40, 0x19, 0x02, 0x90, 0xF8, 0xF7, 0x72, 0xFD, 0x16, 0x21, 0x48,
+	0x43, 0x5B, 0x49, 0x09, 0x5A, 0x01, 0x20, 0xA0, 0x40, 0x01, 0x42, 0x2D, 0xD0, 0x03, 0x98, 0x01,
+	0x28, 0x06, 0xD1, 0x21, 0x46, 0x00, 0x98, 0xFD, 0xF7, 0x4B, 0xFA, 0x07, 0x46, 0x28, 0x46, 0x1A,
+	0xE0, 0x02, 0x28, 0x0C, 0x98, 
+	0x00, 0x01, 0x50, 0x00, 0x80, 0x11, 0xD1, 0x28, 0x18, 0x21, 0x46, 0xFD, 0xF7, 0x41, 0xFA, 0x07,
+	0x46, 0x02, 0x98, 0xF8, 0xF7, 0x55, 0xFD, 0x16, 0x21, 0x48, 0x43, 0x4D, 0x49, 0x40, 0x18, 0x00,
+	0x19, 0x01, 0x79, 0x44, 0x48, 0x40, 0x6A, 0x08, 0x1A, 0x0D, 0xE0, 0x28, 0x18, 0x21, 0x46, 0xFD,
+	0xF7, 0x2F, 0xFA, 0x07, 0x46, 0x02, 0x98, 0xF8, 0xF7, 0x43, 0xFD, 0x16, 0x21, 0x48, 0x43, 0x44,
+	0x49, 0x40, 0x18, 0x00, 0x19, 0x00, 0x79, 0x37, 0x54, 0x64, 0x1C, 0xA4, 0xB2, 0x08, 0x2C, 0x01,
+	0xD2, 0x02, 0x98, 0xC1, 0xE7, 0x6D, 0x1C, 0xAD, 0xB2, 0x0D, 0x98, 0x85, 0x42, 0xB2, 0xD3, 0x00,
+	0x24, 0x04, 0xE0, 0x30, 0x5D, 0xFF, 0xF7, 0x7F, 0xFF, 0x64, 0x1C, 0xA4, 0xB2, 0x01, 0x98, 0x84,
+	0x42, 0xF7, 0xD3, 0x07, 0xB0, 0xF0, 0xBD, 0xF0, 0xB5, 0x07, 0x46, 0x9D, 0xB0, 0x00, 0x20, 0x2A,
+	0x49, 0x1A, 0x90, 0x08, 0x88, 
+	0x00, 0x01, 0x51, 0x00, 0x80, 0xFF, 0x25, 0x40, 0xBA, 0x19, 0x90, 0x48, 0x88, 0x31, 0x4E, 0x40,
+	0xBA, 0xF9, 0x35, 0xA8, 0x42, 0x00, 0xD8, 0x05, 0x46, 0x23, 0x48, 0x19, 0x99, 0x10, 0x38, 0x41,
+	0x60, 0x19, 0x99, 0x49, 0x19, 0x81, 0x60, 0x00, 0x21, 0xC1, 0x60, 0x04, 0x2F, 0x01, 0xD1, 0x2A,
+	0x4E, 0x02, 0xE0, 0x05, 0x2F, 0x00, 0xD1, 0x29, 0x4E, 0x1E, 0x4C, 0x40, 0x34, 0x21, 0x6A, 0x28,
+	0x48, 0x02, 0x29, 0x00, 0x78, 0x02, 0xD1, 0xC0, 0x1C, 0x80, 0x08, 0x80, 0x00, 0x1C, 0x90, 0x3B,
+	0x46, 0x18, 0x48, 0x03, 0xF0, 0xDE, 0xF9, 0x06, 0x04, 0x47, 0x68, 0x6E, 0x04, 0x04, 0x7A, 0x00,
+	0x6B, 0x80, 0xB2, 0x18, 0x90, 0x00, 0x20, 0x17, 0x90, 0x1B, 0x90, 0x30, 0x78, 0xFF, 0xF7, 0x3B,
+	0xFF, 0x00, 0x24, 0x12, 0xE0, 0x1C, 0x9A, 0x0F, 0xA8, 0x03, 0x90, 0x05, 0x92, 0x1B, 0x98, 0x04,
+	0x96, 0x17, 0x9A, 0x18, 0x99, 
+	0x00, 0x01, 0x52, 0x00, 0x80, 0x00, 0x90, 0x02, 0x92, 0x01, 0x91, 0x2B, 0x46, 0x21, 0x46, 0x01,
+	0x20, 0x19, 0x9A, 0xFF, 0xF7, 0x3C, 0xFF, 0x64, 0x1C, 0xA4, 0xB2, 0x11, 0x48, 0x00, 0x78, 0x84,
+	0x42, 0xE8, 0xD3, 0x9F, 0xE0, 0xCA, 0x02, 0x00, 0x20, 0x4C, 0x02, 0x00, 0x20, 0x08, 0xDF, 0x00,
+	0x00, 0x00, 0x20, 0x00, 0x20, 0xF0, 0xE9, 0x00, 0x00, 0x28, 0x02, 0x00, 0x20, 0xEE, 0x00, 0x00,
+	0x20, 0x18, 0x03, 0x00, 0x20, 0x74, 0x02, 0x00, 0x20, 0x65, 0x02, 0x00, 0x20, 0x88, 0x03, 0x00,
+	0x20, 0x00, 0xEC, 0x00, 0x00, 0xC6, 0x0E, 0x00, 0x20, 0x64, 0x10, 0x00, 0x20, 0x02, 0x12, 0x00,
+	0x20, 0x9D, 0x00, 0x00, 0x20, 0x41, 0x6B, 0x82, 0x6B, 0x89, 0x18, 0x89, 0xB2, 0x18, 0x91, 0x01,
+	0x6B, 0xC9, 0xB2, 0x17, 0x91, 0x01, 0x6B, 0x1C, 0x98, 0x41, 0x43, 0x8C, 0xB2, 0x70, 0x78, 0xFF,
+	0xF7, 0xF2, 0xFE, 0xB0, 0x78, 
+	0x00, 0x01, 0x53, 0x00, 0x80, 0xFF, 0xF7, 0xEF, 0xFE, 0x1C, 0x9A, 0x06, 0xA8, 0x04, 0x96, 0x05,
+	0x92, 0x03, 0x90, 0x18, 0x99, 0x17, 0x9A, 0x01, 0x91, 0x00, 0x94, 0x02, 0x92, 0x00, 0x21, 0x2B,
+	0x46, 0x08, 0x46, 0x19, 0x9A, 0x5C, 0xE0, 0x21, 0x68, 0x01, 0x6B, 0xC1, 0x6B, 0x01, 0x6B, 0xC0,
+	0x6B, 0x58, 0xE0, 0x01, 0x21, 0x18, 0x91, 0x01, 0x6B, 0xC2, 0x6B, 0x89, 0x18, 0x22, 0x68, 0x89,
+	0x18, 0xC9, 0xB2, 0x17, 0x91, 0xC1, 0x6A, 0x00, 0x29, 0x02, 0xD1, 0x01, 0x20, 0x1A, 0x90, 0x49,
+	0xE0, 0x01, 0x6B, 0x1C, 0x9A, 0xC0, 0x6B, 0x51, 0x43, 0x08, 0x18, 0x21, 0x68, 0x40, 0x18, 0x80,
+	0xB2, 0x1B, 0x90, 0x60, 0x6A, 0x02, 0x28, 0x02, 0xD0, 0x60, 0x6A, 0x03, 0x28, 0x02, 0xD1, 0xF0,
+	0x78, 0xFF, 0xF7, 0xB9, 0xFE, 0x60, 0x6A, 0x01, 0x28, 0x02, 0xD0, 0x60, 0x6A, 0x03, 0x28, 0x02,
+	0xD1, 0x30, 0x79, 0xFF, 0xF7, 
+	0x00, 0x01, 0x54, 0x00, 0x80, 0xB0, 0xFE, 0x60, 0x6A, 0x02, 0x28, 0x02, 0xD0, 0x60, 0x6A, 0x03,
+	0x28, 0x10, 0xD1, 0x1C, 0x9A, 0x06, 0xA8, 0x03, 0x90, 0x05, 0x92, 0x1B, 0x98, 0x04, 0x96, 0x17,
+	0x9A, 0x18, 0x99, 0x00, 0x90, 0x02, 0x92, 0x01, 0x91, 0x2B, 0x46, 0x00, 0x21, 0x02, 0x20, 0x19,
+	0x9A, 0xFF, 0xF7, 0xAD, 0xFE, 0x60, 0x6A, 0x01, 0x28, 0x02, 0xD0, 0x60, 0x6A, 0x03, 0x28, 0x11,
+	0xD1, 0x1C, 0x9A, 0x06, 0xA8, 0x03, 0x90, 0x1B, 0x98, 0x04, 0x96, 0x05, 0x92, 0x40, 0x1C, 0x80,
+	0xB2, 0x17, 0x9A, 0x18, 0x99, 0x6C, 0x46, 0x07, 0xC4, 0x2B, 0x46, 0x00, 0x21, 0x02, 0x20, 0x19,
+	0x9A, 0xFF, 0xF7, 0x95, 0xFE, 0xFF, 0x48, 0x1A, 0x99, 0x01, 0x70, 0x47, 0x70, 0x29, 0x0A, 0x81,
+	0x70, 0xC5, 0x70, 0x09, 0x21, 0x01, 0x71, 0x1D, 0xB0, 0xF0, 0xBD, 0xF0, 0xB5, 0xF9, 0x48, 0x85,
+	0xB0, 0x40, 0x1F, 0x01, 0x88, 
+	0x00, 0x01, 0x55, 0x00, 0x80, 0x06, 0x79, 0x4F, 0xBA, 0x41, 0x88, 0xF7, 0x48, 0x4D, 0xBA, 0xF5,
+	0x49, 0x49, 0x1F, 0x09, 0x79, 0xC9, 0x00, 0x03, 0x91, 0x03, 0x2E, 0x01, 0xD2, 0x84, 0x6A, 0x07,
+	0xE0, 0x06, 0x2E, 0x01, 0xD2, 0x44, 0x6A, 0x03, 0xE0, 0x09, 0x2E, 0x14, 0xD2, 0x40, 0x6A, 0x44,
+	0x00, 0x08, 0x46, 0xEE, 0x49, 0x40, 0x18, 0x00, 0x79, 0x40, 0x07, 0x40, 0x0F, 0x01, 0x46, 0x01,
+	0x90, 0xFF, 0x20, 0xF9, 0x30, 0x02, 0xF0, 0xFB, 0xFF, 0x85, 0x42, 0x00, 0xD9, 0x05, 0x46, 0xA7,
+	0x42, 0x10, 0xD2, 0xE0, 0x1B, 0x0F, 0xE0, 0x09, 0x2E, 0x09, 0xD1, 0xC0, 0x6A, 0x84, 0x00, 0xE2,
+	0x48, 0x40, 0x30, 0x40, 0x6A, 0x03, 0x28, 0x00, 0xD1, 0x64, 0x00, 0x02, 0x20, 0xE6, 0xE7, 0x01,
+	0x21, 0xDC, 0x48, 0x3A, 0xE0, 0x00, 0x20, 0x85, 0x42, 0x00, 0xD9, 0x05, 0x46, 0x03, 0x98, 0xDB,
+	0x49, 0x02, 0x90, 0x08, 0x58, 
+	0x00, 0x01, 0x56, 0x00, 0x80, 0x01, 0x99, 0x4F, 0x43, 0x3F, 0x18, 0x08, 0x46, 0x68, 0x43, 0x00,
+	0x24, 0x00, 0x90, 0x07, 0xE0, 0x20, 0x46, 0x08, 0x30, 0x39, 0x78, 0x80, 0xB2, 0xFF, 0xF7, 0xF6,
+	0xFB, 0x7F, 0x1C, 0x64, 0x1C, 0x00, 0x98, 0x84, 0x42, 0xF4, 0xD3, 0xCE, 0x48, 0x29, 0x0A, 0x46,
+	0x70, 0x81, 0x70, 0xC5, 0x70, 0x09, 0x2E, 0x01, 0xD1, 0x32, 0x21, 0x14, 0xE0, 0x03, 0x2E, 0x03,
+	0xD3, 0xCA, 0x4A, 0x02, 0x99, 0x89, 0x18, 0x0D, 0xE0, 0xC9, 0x49, 0x49, 0x69, 0x01, 0x29, 0x06,
+	0xD1, 0xC6, 0x4A, 0x02, 0x99, 0x89, 0x18, 0x09, 0x79, 0x08, 0x22, 0x11, 0x43, 0x03, 0xE0, 0xC3,
+	0x49, 0x02, 0x9A, 0x51, 0x18, 0x09, 0x79, 0x01, 0x71, 0x00, 0x21, 0x01, 0x70, 0x2F, 0xE5, 0xFE,
+	0xB5, 0xBC, 0x48, 0x40, 0x1F, 0x01, 0x88, 0x4E, 0xBA, 0x41, 0x88, 0x00, 0x79, 0x4C, 0xBA, 0x01,
+	0x90, 0xFF, 0xF7, 0x2A, 0xFA, 
+	0x00, 0x01, 0x57, 0x00, 0x80, 0x00, 0x20, 0x00, 0x90, 0x01, 0x98, 0x02, 0x28, 0x03, 0xD0, 0x03,
+	0x28, 0x07, 0xD0, 0x04, 0x28, 0x33, 0xD1, 0x1B, 0x2C, 0x00, 0xD9, 0x1B, 0x24, 0x00, 0x25, 0xB5,
+	0x4F, 0x24, 0xE0, 0xFF, 0x20, 0xF9, 0x30, 0x84, 0x42, 0x00, 0xD9, 0x04, 0x46, 0x00, 0x25, 0x11,
+	0xE0, 0x77, 0x19, 0x09, 0x21, 0x38, 0x46, 0x02, 0xF0, 0x82, 0xFF, 0xC1, 0x00, 0x41, 0x18, 0x79,
+	0x1A, 0xFD, 0xF7, 0x66, 0xF8, 0xC1, 0xB2, 0x28, 0x46, 0x08, 0x30, 0x80, 0xB2, 0xFF, 0xF7, 0x9E,
+	0xFB, 0x6D, 0x1C, 0xAD, 0xB2, 0xA5, 0x42, 0xEB, 0xD3, 0x13, 0xE0, 0x70, 0x19, 0x39, 0x5C, 0x28,
+	0x46, 0x09, 0x30, 0x80, 0xB2, 0xFF, 0xF7, 0x92, 0xFB, 0x6D, 0x1C, 0xAD, 0xB2, 0xAC, 0x42, 0xF4,
+	0xD8, 0x9C, 0x48, 0x15, 0x38, 0x41, 0x78, 0x08, 0x20, 0xFF, 0xF7, 0x88, 0xFB, 0x01, 0xE0, 0x01,
+	0x20, 0x00, 0x90, 0x98, 0x48, 
+	0x00, 0x01, 0x58, 0x00, 0x80, 0x00, 0x99, 0x01, 0x70, 0x01, 0x99, 0x41, 0x70, 0x21, 0x0A, 0x81,
+	0x70, 0xC4, 0x70, 0xFE, 0xBD, 0xF8, 0xB5, 0x93, 0x49, 0x97, 0x48, 0x49, 0x1F, 0x0E, 0x78, 0x4F,
+	0x78, 0x00, 0x88, 0x00, 0x90, 0x01, 0x24, 0x00, 0x25, 0x94, 0x48, 0x01, 0xF0, 0x2F, 0xFE, 0x30,
+	0x46, 0x8C, 0x4E, 0x15, 0x3E, 0x01, 0x28, 0x08, 0xD0, 0x02, 0x28, 0x1E, 0xD0, 0x03, 0x28, 0x11,
+	0xD0, 0x04, 0x28, 0x33, 0xD1, 0x01, 0xF0, 0x4B, 0xFC, 0x2E, 0xE0, 0x8A, 0x48, 0x09, 0x38, 0x01,
+	0xF0, 0x5E, 0xFD, 0x70, 0x70, 0xC0, 0xB2, 0x00, 0x28, 0x02, 0xD0, 0x01, 0x21, 0x08, 0x43, 0x70,
+	0x70, 0x00, 0x24, 0x23, 0xE0, 0x83, 0x48, 0x39, 0x46, 0x09, 0x38, 0x01, 0xF0, 0x1D, 0xFD, 0x70,
+	0x70, 0xC0, 0xB2, 0x00, 0x28, 0xF4, 0xD1, 0x01, 0x25, 0xF2, 0xE7, 0x30, 0x78, 0x00, 0x28, 0x05,
+	0xD0, 0x01, 0x28, 0x13, 0xD1, 
+	0x00, 0x01, 0x59, 0x00, 0x80, 0x00, 0x20, 0x01, 0x46, 0x7A, 0x4A, 0x04, 0xE0, 0x79, 0x48, 0x09,
+	0x38, 0x01, 0xF0, 0xF0, 0xFB, 0x08, 0xE0, 0x11, 0x54, 0x40, 0x1C, 0xC0, 0xB2, 0x1B, 0x28, 0xFA,
+	0xD3, 0x74, 0x48, 0x09, 0x38, 0x01, 0xF0, 0x91, 0xFB, 0x70, 0x70, 0xE4, 0xE7, 0x00, 0x98, 0x01,
+	0xF0, 0xED, 0xFD, 0x6C, 0x48, 0x04, 0x70, 0x71, 0x78, 0x41, 0x70, 0x85, 0x70, 0xF8, 0xBD, 0xF0,
+	0xB5, 0x6F, 0x48, 0xA5, 0xB0, 0x00, 0x68, 0x01, 0x90, 0x66, 0x48, 0x40, 0x1F, 0x01, 0x88, 0x4E,
+	0xBA, 0x41, 0x88, 0x00, 0x79, 0x4D, 0xBA, 0x24, 0x90, 0x00, 0x28, 0x09, 0xD0, 0x01, 0x28, 0x0F,
+	0xD0, 0x02, 0x28, 0x11, 0xD1, 0x67, 0x49, 0x01, 0x20, 0x02, 0x91, 0x49, 0x02, 0x0F, 0x0C, 0x0E,
+	0xE0, 0x65, 0x48, 0x66, 0x49, 0xC0, 0x09, 0xC9, 0x09, 0x40, 0x1A, 0x64, 0x49, 0x02, 0x91, 0xF4,
+	0xE7, 0x61, 0x49, 0x01, 0x20, 
+	0x00, 0x01, 0x5A, 0x00, 0x80, 0x02, 0x91, 0xF0, 0xE7, 0x00, 0x20, 0x07, 0x46, 0x02, 0x90, 0x86,
+	0x42, 0x17, 0xD2, 0x80, 0x2D, 0x15, 0xD8, 0x00, 0x20, 0x04, 0x46, 0x03, 0x90, 0x28, 0x19, 0x08,
+	0x30, 0x80, 0xB2, 0xFF, 0xF7, 0xF7, 0xFA, 0x51, 0x49, 0x10, 0x39, 0x09, 0x5D, 0x88, 0x42, 0x01,
+	0xD0, 0x01, 0x20, 0x03, 0x90, 0x64, 0x1C, 0xA4, 0xB2, 0x08, 0x2C, 0xEF, 0xD3, 0x03, 0x98, 0x00,
+	0x28, 0x04, 0xD0, 0x48, 0x49, 0x01, 0x20, 0x08, 0x70, 0x25, 0xB0, 0xF0, 0xBD, 0x00, 0x24, 0x08,
+	0xE0, 0x20, 0x46, 0x08, 0x30, 0x80, 0xB2, 0xFF, 0xF7, 0xDD, 0xFA, 0x04, 0xA9, 0x08, 0x55, 0x64,
+	0x1C, 0xA4, 0xB2, 0xA5, 0x42, 0xF4, 0xD8, 0x02, 0x98, 0xF1, 0x01, 0x08, 0x18, 0x41, 0x19, 0x80,
+	0x20, 0x02, 0x1B, 0x04, 0xA8, 0x00, 0x19, 0x02, 0xF0, 0x31, 0xFE, 0x28, 0x46, 0x10, 0x30, 0x80,
+	0xB2, 0xFF, 0xF7, 0xC8, 0xFA, 
+	0x00, 0x01, 0x5B, 0x00, 0x80, 0x04, 0x02, 0x28, 0x46, 0x11, 0x30, 0x80, 0xB2, 0xFF, 0xF7, 0xC2,
+	0xFA, 0x04, 0x43, 0x04, 0xA9, 0x28, 0x46, 0x02, 0xF0, 0x83, 0xFD, 0x84, 0x42, 0x03, 0xD0, 0x31,
+	0x48, 0x01, 0x21, 0x01, 0x70, 0xD0, 0xE7, 0x00, 0x2E, 0x04, 0xD1, 0x04, 0x22, 0x04, 0xA8, 0x02,
+	0x99, 0x02, 0xF0, 0x14, 0xFE, 0xB8, 0x19, 0x80, 0xB2, 0x04, 0xA9, 0x01, 0x9A, 0xF6, 0xF7, 0x30,
+	0xFB, 0x00, 0x28, 0x00, 0xD0, 0x01, 0x20, 0x27, 0x49, 0x08, 0x70, 0x24, 0x98, 0x48, 0x70, 0x28,
+	0x0A, 0x88, 0x70, 0xCD, 0x70, 0x24, 0x98, 0x00, 0x28, 0xB6, 0xD1, 0x2D, 0x49, 0x08, 0x70, 0x2D,
+	0x48, 0x01, 0x88, 0xC9, 0x07, 0xC9, 0x0F, 0x01, 0x80, 0xAE, 0xE7, 0xFE, 0xB5, 0x1D, 0x48, 0x40,
+	0x1F, 0x01, 0x88, 0x42, 0x88, 0x00, 0x79, 0x49, 0xBA, 0x55, 0xBA, 0x00, 0x90, 0x00, 0x28, 0x06,
+	0xD0, 0x01, 0x28, 0x0B, 0xD0, 
+	0x00, 0x01, 0x5C, 0x00, 0x80, 0x02, 0x28, 0x0C, 0xD1, 0x01, 0x20, 0x1E, 0x4E, 0x0B, 0xE0, 0x1E,
+	0x48, 0x1E, 0x4A, 0xC0, 0x09, 0xD2, 0x09, 0x80, 0x1A, 0x1C, 0x4E, 0x04, 0xE0, 0x01, 0x20, 0x1A,
+	0x4E, 0x01, 0xE0, 0x00, 0x20, 0x06, 0x46, 0x81, 0x42, 0x01, 0xD2, 0x80, 0x2D, 0x03, 0xD9, 0x0D,
+	0x48, 0x01, 0x21, 0x01, 0x70, 0xFE, 0xBD, 0xC8, 0x01, 0x87, 0x19, 0x00, 0x24, 0x01, 0x90, 0x07,
+	0xE0, 0x20, 0x46, 0x08, 0x30, 0x39, 0x5D, 0x80, 0xB2, 0xFF, 0xF7, 0x60, 0xFA, 0x64, 0x1C, 0xA4,
+	0xB2, 0xA5, 0x42, 0xF5, 0xD8, 0x39, 0x46, 0x28, 0x46, 0x02, 0xF0, 0x22, 0xFD, 0x04, 0x46, 0x01,
+	0x0A, 0x28, 0x46, 0x19, 0xE0, 0x51, 0x02, 0x00, 0x20, 0xF0, 0xE9, 0x00, 0x00, 0x10, 0xDF, 0x00,
+	0x00, 0xD0, 0xE7, 0x00, 0x00, 0xB3, 0x19, 0x00, 0x20, 0xD0, 0x02, 0x00, 0x20, 0x10, 0x27, 0x00,
+	0x00, 0x28, 0x02, 0x00, 0x20, 
+	0x00, 0x01, 0x5D, 0x00, 0x80, 0x00, 0xEE, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xE6, 0x00,
+	0x00, 0xB6, 0x02, 0x00, 0x20, 0xC8, 0x02, 0x00, 0x20, 0x08, 0x30, 0x80, 0xB2, 0xFF, 0xF7, 0x36,
+	0xFA, 0x28, 0x46, 0x09, 0x30, 0xE1, 0xB2, 0x80, 0xB2, 0xFF, 0xF7, 0x30, 0xFA, 0x00, 0x2D, 0x03,
+	0xD1, 0x71, 0x88, 0x01, 0x98, 0x08, 0x1A, 0x85, 0xB2, 0xE1, 0x48, 0x00, 0x21, 0x01, 0x70, 0x00,
+	0x99, 0x41, 0x70, 0x29, 0x0A, 0x81, 0x70, 0xC5, 0x70, 0xFE, 0xBD, 0xFE, 0xB5, 0x02, 0x20, 0xFF,
+	0xF7, 0x21, 0xFA, 0x04, 0x46, 0x40, 0x06, 0x78, 0xD4, 0x01, 0xE0, 0x01, 0xF0, 0x33, 0xFD, 0xFF,
+	0xF7, 0x33, 0xFA, 0x00, 0x28, 0xF9, 0xD1, 0xD6, 0x4E, 0x00, 0x25, 0x76, 0x1F, 0xE8, 0x1C, 0xFF,
+	0xF7, 0x11, 0xFA, 0x70, 0x55, 0x6D, 0x1C, 0xED, 0xB2, 0x05, 0x2D, 0xF7, 0xD3, 0x05, 0x21, 0xD0,
+	0x48, 0x02, 0xF0, 0xC9, 0xFD, 
+	0x00, 0x01, 0x5E, 0x00, 0x80, 0xA3, 0x06, 0x9B, 0x0E, 0x00, 0x27, 0xCE, 0x48, 0xCC, 0x4D, 0x0B,
+	0x2B, 0x4D, 0xD0, 0x08, 0xDC, 0x02, 0xF0, 0xBD, 0xFE, 0x0B, 0xB4, 0xB2, 0x27, 0x2B, 0x2E, 0xB2,
+	0x31, 0x34, 0x37, 0x3A, 0x3D, 0xB2, 0x00, 0x10, 0x2B, 0x65, 0xD0, 0x0B, 0xDC, 0x0C, 0x2B, 0x4D,
+	0xD0, 0x0D, 0x2B, 0x4E, 0xD0, 0x0E, 0x2B, 0x5B, 0xD0, 0x0F, 0x2B, 0x70, 0xD1, 0xC2, 0x49, 0x30,
+	0x78, 0x08, 0x70, 0x32, 0xE0, 0x11, 0x2B, 0x6E, 0xD0, 0x12, 0x2B, 0x6F, 0xD0, 0x13, 0x2B, 0x70,
+	0xD0, 0x3F, 0x2B, 0xF2, 0xD1, 0x30, 0x78, 0xFE, 0x28, 0x7E, 0xD0, 0xFF, 0x28, 0x7D, 0xD1, 0x01,
+	0x20, 0xFF, 0xF7, 0xF0, 0xFA, 0x88, 0xE0, 0x2F, 0x70, 0x80, 0x20, 0x68, 0x70, 0x88, 0xE0, 0xFF,
+	0xF7, 0x3C, 0xFF, 0x85, 0xE0, 0xFF, 0xF7, 0xA3, 0xFE, 0x82, 0xE0, 0x00, 0xF0, 0x21, 0xF9, 0x7F,
+	0xE0, 0xFF, 0xF7, 0x48, 0xFE, 
+	0x00, 0x01, 0x5F, 0x00, 0x80, 0x7C, 0xE0, 0xFF, 0xF7, 0xF2, 0xFD, 0x79, 0xE0, 0x00, 0xF0, 0xEE,
+	0xF8, 0x76, 0xE0, 0x00, 0x78, 0x00, 0x28, 0x3F, 0xD0, 0x36, 0x78, 0xF0, 0x07, 0x01, 0xD0, 0xFA,
+	0xF7, 0xC9, 0xFB, 0x70, 0x07, 0x01, 0xD5, 0xFA, 0xF7, 0x96, 0xFB, 0x2F, 0x70, 0x68, 0xE0, 0x00,
+	0x78, 0x00, 0x28, 0x31, 0xD0, 0x01, 0x20, 0xFF, 0xF7, 0x04, 0xF8, 0x01, 0xF0, 0xFB, 0xFB, 0xFD,
+	0xF7, 0x1C, 0xFF, 0xC0, 0x07, 0xF9, 0xD1, 0x62, 0xB6, 0x5A, 0xE0, 0x74, 0xE0, 0xFF, 0xF7, 0x55,
+	0xFD, 0x56, 0xE0, 0x00, 0x26, 0x77, 0x00, 0xF8, 0x1C, 0x80, 0xB2, 0xFF, 0xF7, 0xAC, 0xF9, 0x9B,
+	0x49, 0x76, 0x1C, 0xC8, 0x53, 0x19, 0x2E, 0xF5, 0xD3, 0x99, 0x48, 0x01, 0x21, 0x01, 0x70, 0x47,
+	0xE0, 0x97, 0x48, 0x07, 0x70, 0x44, 0xE0, 0x30, 0x79, 0x00, 0x07, 0x00, 0x0F, 0x03, 0x46, 0x02,
+	0xF0, 0x48, 0xFE, 0x07, 0x05, 
+	0x00, 0x01, 0x60, 0x00, 0x80, 0x05, 0x05, 0x05, 0x05, 0x05, 0x08, 0x0B, 0x00, 0xFF, 0xF7, 0x33,
+	0xFC, 0x36, 0xE0, 0x00, 0xF0, 0x78, 0xF8, 0x33, 0xE0, 0x01, 0x20, 0x28, 0x70, 0x30, 0xE0, 0x2D,
+	0xE0, 0x01, 0xE0, 0x03, 0xE0, 0x05, 0xE0, 0x00, 0xF0, 0x48, 0xF8, 0x29, 0xE0, 0xFF, 0xF7, 0xF7,
+	0xFA, 0x26, 0xE0, 0x88, 0x48, 0xA1, 0x22, 0x01, 0x68, 0x92, 0x00, 0x68, 0x46, 0xF6, 0xF7, 0xD0,
+	0xF9, 0x60, 0x21, 0x68, 0x46, 0xF6, 0xF7, 0xD4, 0xF9, 0x06, 0x46, 0x01, 0x46, 0x68, 0x46, 0xF8,
+	0xF7, 0x3C, 0xFD, 0x31, 0x46, 0x68, 0x46, 0x01, 0xE0, 0x0B, 0xE0, 0x0C, 0xE0, 0xF8, 0xF7, 0xBA,
+	0xFD, 0x02, 0x46, 0x31, 0x46, 0x68, 0x46, 0xF9, 0xF7, 0x37, 0xFB, 0x68, 0x46, 0xF6, 0xF7, 0xCD,
+	0xF9, 0x9B, 0xE7, 0x00, 0x20, 0x74, 0xE7, 0x01, 0x20, 0x00, 0x28, 0x01, 0xD0, 0xA4, 0x09, 0xA4,
+	0x01, 0x00, 0x26, 0xA9, 0x5D, 
+	0x00, 0x01, 0x61, 0x00, 0x80, 0xF0, 0x1C, 0xFF, 0xF7, 0x41, 0xF9, 0x76, 0x1C, 0xF6, 0xB2, 0x05,
+	0x2E, 0xF7, 0xD3, 0x71, 0x48, 0x80, 0x22, 0x01, 0x78, 0x51, 0x40, 0x01, 0x70, 0xC8, 0xB2, 0xC1,
+	0x09, 0xC9, 0x01, 0x21, 0x43, 0x40, 0x20, 0x01, 0x43, 0x02, 0x20, 0xFF, 0xF7, 0x2F, 0xF9, 0x01,
+	0xF0, 0x37, 0xF8, 0x01, 0xF0, 0x6D, 0xF8, 0xFE, 0xBD, 0x70, 0x47, 0xF8, 0xB5, 0x60, 0x48, 0x00,
+	0x25, 0x40, 0x1F, 0x00, 0x78, 0x5E, 0x4F, 0x00, 0x28, 0x05, 0xD0, 0x01, 0x28, 0x05, 0xD0, 0x02,
+	0x28, 0x16, 0xD1, 0x62, 0x4C, 0x02, 0xE0, 0x62, 0x4C, 0x00, 0xE0, 0x62, 0x4C, 0x20, 0x88, 0x66,
+	0x88, 0x21, 0x46, 0x02, 0xF0, 0xDD, 0xFB, 0xA1, 0x19, 0x09, 0x88, 0x88, 0x42, 0x00, 0xD0, 0x01,
+	0x25, 0x3D, 0x70, 0x02, 0x0A, 0x7A, 0x70, 0xB8, 0x70, 0x08, 0x0A, 0xF8, 0x70, 0x39, 0x71, 0xF8,
+	0xBD, 0x01, 0x20, 0x38, 0x70, 
+	0x00, 0x01, 0x62, 0x00, 0x80, 0xF8, 0xBD, 0xF8, 0xB5, 0x52, 0x48, 0x07, 0x68, 0x4C, 0x48, 0x40,
+	0x1F, 0x01, 0x88, 0x40, 0x88, 0x4E, 0xBA, 0x45, 0xBA, 0x53, 0x48, 0x00, 0x78, 0xC1, 0x00, 0x08,
+	0x1A, 0x80, 0x1C, 0x80, 0xB2, 0x86, 0x42, 0x01, 0xD2, 0x80, 0x1B, 0x00, 0xE0, 0x00, 0x20, 0x85,
+	0x42, 0x00, 0xD9, 0x05, 0x46, 0x00, 0x2D, 0x01, 0xD0, 0xFF, 0xF7, 0xD1, 0xFA, 0x00, 0x24, 0x08,
+	0xE0, 0xA0, 0x19, 0xC0, 0x19, 0x41, 0x7A, 0x20, 0x46, 0x08, 0x30, 0x80, 0xB2, 0xFF, 0xF7, 0xDE,
+	0xF8, 0x64, 0x1C, 0xAC, 0x42, 0xF4, 0xD3, 0x3A, 0x48, 0x00, 0x21, 0x01, 0x70, 0x06, 0x21, 0x41,
+	0x70, 0x29, 0x0A, 0x81, 0x70, 0xC5, 0x70, 0x01, 0x21, 0x01, 0x71, 0xF8, 0xBD, 0xF8, 0xB5, 0x35,
+	0x48, 0x33, 0x4E, 0x00, 0x78, 0x00, 0x28, 0x02, 0xD1, 0x01, 0x20, 0x30, 0x70, 0xF8, 0xBD, 0x30,
+	0x48, 0x40, 0x1F, 0x04, 0x78, 
+	0x00, 0x01, 0x63, 0x00, 0x80, 0x39, 0x48, 0x07, 0x88, 0x39, 0x48, 0x01, 0xF0, 0x7F, 0xFB, 0x00,
+	0x25, 0x00, 0x2C, 0x09, 0xD0, 0x01, 0x2C, 0x09, 0xD0, 0x02, 0x2C, 0x09, 0xD0, 0x03, 0x2C, 0x09,
+	0xD1, 0x84, 0x20, 0xFD, 0xF7, 0x07, 0xFD, 0x06, 0xE0, 0x81, 0x20, 0xFA, 0xE7, 0x88, 0x20, 0xF8,
+	0xE7, 0x82, 0x20, 0xF6, 0xE7, 0x01, 0x25, 0x38, 0x46, 0x01, 0xF0, 0x68, 0xFB, 0x35, 0x70, 0xF8,
+	0xBD, 0xF8, 0xB5, 0x1F, 0x48, 0x40, 0x1F, 0x01, 0x88, 0x07, 0x79, 0x4E, 0xBA, 0x41, 0x88, 0x00,
+	0x20, 0x4D, 0xBA, 0x00, 0x90, 0x09, 0x2D, 0x00, 0xD9, 0x09, 0x25, 0x01, 0x2F, 0x03, 0xD0, 0x02,
+	0x2F, 0x0F, 0xD0, 0x03, 0x2F, 0x21, 0xD1, 0x00, 0x24, 0x08, 0xE0, 0x20, 0x46, 0x08, 0x30, 0xFF,
+	0xF7, 0x91, 0xF8, 0x31, 0x19, 0x1F, 0x4A, 0x64, 0x1C, 0x50, 0x54, 0xE4, 0xB2, 0xA5, 0x42, 0xF4,
+	0xD8, 0x15, 0xE0, 0x08, 0x20, 
+	0x00, 0x01, 0x64, 0x00, 0x80, 0xFF, 0xF7, 0x86, 0xF8, 0x0D, 0x49, 0x15, 0x39, 0x08, 0x70, 0x00,
+	0x24, 0x08, 0xE0, 0x20, 0x46, 0x09, 0x30, 0xFF, 0xF7, 0x7D, 0xF8, 0x31, 0x19, 0x15, 0x4A, 0x64,
+	0x1C, 0x50, 0x54, 0xE4, 0xB2, 0xA5, 0x42, 0xF4, 0xD8, 0x01, 0xE0, 0x01, 0x20, 0x00, 0x90, 0x04,
+	0x48, 0x00, 0x99, 0x01, 0x70, 0x47, 0x70, 0x29, 0x0A, 0x81, 0x70, 0xC5, 0x70, 0xF8, 0xBD, 0x00,
+	0x00, 0x51, 0x02, 0x00, 0x20, 0xB6, 0x02, 0x00, 0x20, 0xCB, 0x02, 0x00, 0x20, 0x80, 0x02, 0x00,
+	0x20, 0x5A, 0x02, 0x00, 0x20, 0x28, 0x02, 0x00, 0x20, 0xCA, 0x02, 0x00, 0x20, 0x00, 0xEE, 0x00,
+	0x00, 0x00, 0xE6, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x18, 0x03, 0x00, 0x20, 0xD0, 0x02, 0x00,
+	0x20, 0x10, 0x27, 0x00, 0x00, 0xAA, 0x19, 0x00, 0x20, 0x70, 0xB5, 0xFF, 0xF7, 0x10, 0xF8, 0x01,
+	0x20, 0xFF, 0xF7, 0x37, 0xF8, 
+	0x00, 0x01, 0x65, 0x00, 0x80, 0xFF, 0xF7, 0x00, 0xF8, 0x01, 0x24, 0x65, 0x02, 0xA0, 0xB2, 0x00,
+	0x21, 0xFF, 0xF7, 0x3C, 0xF8, 0x64, 0x1C, 0xAC, 0x42, 0xF8, 0xD3, 0x61, 0x4D, 0x00, 0x24, 0x60,
+	0x00, 0x41, 0x19, 0x49, 0x78, 0x28, 0x5C, 0xFF, 0xF7, 0x31, 0xF8, 0x64, 0x1C, 0x2E, 0x2C, 0xF6,
+	0xD3, 0xFF, 0x24, 0x01, 0x34, 0xA1, 0x78, 0x1C, 0x20, 0xFF, 0xF7, 0x28, 0xF8, 0xE1, 0x78, 0x1D,
+	0x20, 0xFF, 0xF7, 0x24, 0xF8, 0x57, 0x48, 0x81, 0x88, 0x1E, 0x20, 0xFF, 0xF7, 0x29, 0xF8, 0x55,
+	0x4C, 0x23, 0x20, 0x20, 0x34, 0x21, 0x8B, 0xFF, 0xF7, 0x23, 0xF8, 0xA1, 0x7E, 0x25, 0x20, 0xFF,
+	0xF7, 0x15, 0xF8, 0xE1, 0x7E, 0x26, 0x20, 0xFF, 0xF7, 0x11, 0xF8, 0x21, 0x7F, 0x27, 0x20, 0xFF,
+	0xF7, 0x0D, 0xF8, 0x61, 0x7F, 0x28, 0x20, 0xFF, 0xF7, 0x09, 0xF8, 0xA1, 0x7F, 0x29, 0x20, 0xFF,
+	0xF7, 0x05, 0xF8, 0xE1, 0x7F, 
+	0x00, 0x01, 0x66, 0x00, 0x80, 0x2A, 0x20, 0xFF, 0xF7, 0x01, 0xF8, 0x47, 0x4C, 0x60, 0x7A, 0x22,
+	0x7A, 0x01, 0x02, 0x11, 0x43, 0x2D, 0x20, 0xFF, 0xF7, 0x03, 0xF8, 0x44, 0x48, 0x01, 0x88, 0x32,
+	0x20, 0xFE, 0xF7, 0xFE, 0xFF, 0x60, 0x7B, 0x22, 0x7B, 0x01, 0x02, 0x11, 0x43, 0x36, 0x20, 0xFE,
+	0xF7, 0xF7, 0xFF, 0xE0, 0x7B, 0xA2, 0x7B, 0x01, 0x02, 0x11, 0x43, 0x38, 0x20, 0xFE, 0xF7, 0xF0,
+	0xFF, 0x3B, 0x4D, 0x68, 0x69, 0x3B, 0x4C, 0x01, 0x28, 0x06, 0xD1, 0xE0, 0x69, 0xC1, 0xB2, 0x34,
+	0x20, 0xFE, 0xF7, 0xDC, 0xFF, 0x20, 0x6A, 0x05, 0xE0, 0x20, 0x6A, 0xC1, 0xB2, 0x34, 0x20, 0xFE,
+	0xF7, 0xD5, 0xFF, 0xE0, 0x69, 0xC1, 0xB2, 0x35, 0x20, 0xFE, 0xF7, 0xD0, 0xFF, 0xE8, 0x68, 0x81,
+	0xB2, 0x3A, 0x20, 0xFE, 0xF7, 0xD5, 0xFF, 0x28, 0x69, 0x81, 0xB2, 0x3C, 0x20, 0xFE, 0xF7, 0xD0,
+	0xFF, 0x2D, 0x48, 0x01, 0x78, 
+	0x00, 0x01, 0x67, 0x00, 0x80, 0x40, 0x20, 0xFE, 0xF7, 0xC1, 0xFF, 0x00, 0xF0, 0x61, 0xF8, 0x2B,
+	0x4D, 0x2B, 0x4E, 0x28, 0x78, 0xC1, 0x00, 0x08, 0x1A, 0x31, 0x88, 0x40, 0x18, 0x08, 0x38, 0x81,
+	0xB2, 0x43, 0x20, 0xFE, 0xF7, 0xBD, 0xFF, 0xE0, 0x6A, 0xC1, 0xB2, 0x45, 0x20, 0xFE, 0xF7, 0xAE,
+	0xFF, 0x30, 0x88, 0xC1, 0xB2, 0x46, 0x20, 0xFE, 0xF7, 0xA9, 0xFF, 0x22, 0x48, 0x00, 0x88, 0x41,
+	0x06, 0x02, 0x06, 0xC9, 0x0F, 0xD2, 0x0F, 0x49, 0x00, 0x92, 0x00, 0x80, 0x06, 0x0A, 0x43, 0xC0,
+	0x0F, 0xC1, 0x00, 0x11, 0x43, 0x47, 0x20, 0xFE, 0xF7, 0x99, 0xFF, 0x29, 0x78, 0x48, 0x20, 0xFE,
+	0xF7, 0x95, 0xFF, 0x19, 0x4D, 0x00, 0x24, 0x28, 0x19, 0x01, 0x79, 0x20, 0x46, 0x5B, 0x30, 0x80,
+	0xB2, 0xFE, 0xF7, 0x8C, 0xFF, 0x64, 0x1C, 0x20, 0x2C, 0xF5, 0xD3, 0x14, 0x4D, 0x00, 0x24, 0x28,
+	0x19, 0x01, 0x79, 0x20, 0x46, 
+	0x00, 0x01, 0x68, 0x00, 0x80, 0x7B, 0x30, 0x80, 0xB2, 0xFE, 0xF7, 0x80, 0xFF, 0x64, 0x1C, 0x40,
+	0x2C, 0xF5, 0xD3, 0x70, 0xBD, 0x10, 0xB5, 0x01, 0xF0, 0x69, 0xFA, 0x10, 0xBD, 0x70, 0x47, 0x00,
+	0x00, 0x40, 0xDF, 0x00, 0x00, 0x40, 0xF1, 0xFF, 0x0F, 0x00, 0xE6, 0x00, 0x00, 0xC8, 0x02, 0x00,
+	0x20, 0xD0, 0xE7, 0x00, 0x00, 0xF0, 0xE9, 0x00, 0x00, 0x8E, 0x01, 0x00, 0x20, 0x18, 0x03, 0x00,
+	0x20, 0x74, 0x02, 0x00, 0x20, 0x1A, 0x03, 0x00, 0x20, 0x00, 0xEE, 0x00, 0x00, 0x00, 0xFF, 0x00,
+	0x00, 0xFE, 0x48, 0xC0, 0x6A, 0x00, 0x28, 0x00, 0xD0, 0x01, 0x20, 0xFD, 0x49, 0x0B, 0x30, 0x88,
+	0x83, 0x70, 0x47, 0xF8, 0xB5, 0xFA, 0x4D, 0x00, 0x26, 0x2E, 0x84, 0xFF, 0xF7, 0xF1, 0xFF, 0xFE,
+	0xF7, 0x16, 0xFF, 0x09, 0x20, 0xFE, 0xF7, 0x3D, 0xFF, 0xFE, 0xF7, 0x06, 0xFF, 0x20, 0x21, 0x0A,
+	0x20, 0xFE, 0xF7, 0x44, 0xFF, 
+	0x00, 0x01, 0x69, 0x00, 0x80, 0x40, 0x21, 0x02, 0x20, 0xFE, 0xF7, 0x40, 0xFF, 0x00, 0x21, 0x03,
+	0x20, 0xFE, 0xF7, 0x3C, 0xFF, 0x00, 0x21, 0x04, 0x20, 0xFE, 0xF7, 0x38, 0xFF, 0x00, 0x21, 0x05,
+	0x20, 0xFE, 0xF7, 0x34, 0xFF, 0x00, 0x21, 0x06, 0x20, 0xFE, 0xF7, 0x30, 0xFF, 0x00, 0x21, 0x07,
+	0x20, 0xFE, 0xF7, 0x2C, 0xFF, 0x00, 0x21, 0x08, 0x20, 0xFE, 0xF7, 0x28, 0xFF, 0x00, 0x21, 0x09,
+	0x20, 0xFE, 0xF7, 0x24, 0xFF, 0x0B, 0x24, 0x01, 0x27, 0x7F, 0x02, 0xA0, 0xB2, 0x00, 0x21, 0xFE,
+	0xF7, 0x1D, 0xFF, 0x64, 0x1C, 0xBC, 0x42, 0xF8, 0xD3, 0x01, 0xF0, 0xA8, 0xFA, 0xAE, 0x74, 0x00,
+	0x20, 0xDC, 0x49, 0x2E, 0x74, 0x0F, 0x22, 0x43, 0x00, 0x40, 0x1C, 0xC0, 0xB2, 0xCA, 0x54, 0x0B,
+	0x28, 0xF9, 0xD3, 0xD9, 0x48, 0x00, 0x78, 0x00, 0x28, 0x04, 0xD0, 0xFD, 0xF7, 0xCD, 0xFA, 0x00,
+	0x20, 0xFE, 0xF7, 0x5F, 0xFD, 
+	0x00, 0x01, 0x6A, 0x00, 0x80, 0xD5, 0x49, 0xA8, 0x7B, 0x08, 0x70, 0xEE, 0x70, 0x01, 0x20, 0x28,
+	0x70, 0xD3, 0x48, 0xEE, 0x73, 0x06, 0x80, 0xD3, 0x48, 0x06, 0x80, 0x00, 0xF0, 0x52, 0xFD, 0x02,
+	0x20, 0x28, 0x73, 0x01, 0xF0, 0x47, 0xF9, 0x68, 0x62, 0xCF, 0x48, 0x40, 0x68, 0xCF, 0x49, 0x08,
+	0x60, 0x68, 0x8B, 0x01, 0xF0, 0xB3, 0xF9, 0xF8, 0xBD, 0xCD, 0x49, 0x00, 0x20, 0x08, 0x70, 0x90,
+	0xE7, 0xC3, 0x48, 0xC0, 0x7A, 0x70, 0x47, 0xF8, 0xB5, 0x01, 0x24, 0x01, 0xF0, 0x33, 0xF9, 0x06,
+	0x46, 0xC8, 0x48, 0xC9, 0x4F, 0x05, 0x78, 0xBE, 0x49, 0x00, 0x2D, 0x02, 0xD1, 0x38, 0x78, 0x40,
+	0x07, 0x00, 0xD4, 0x4E, 0x62, 0xC8, 0x7A, 0x01, 0x28, 0x05, 0xD1, 0xC8, 0x7B, 0x05, 0x43, 0x3C,
+	0xD1, 0x00, 0xF0, 0x27, 0xFD, 0x39, 0xE0, 0xC1, 0x4A, 0x02, 0x28, 0x13, 0xD1, 0x00, 0x2D, 0x2B,
+	0xD1, 0x38, 0x78, 0x40, 0x07, 
+	0x00, 0x01, 0x6B, 0x00, 0x80, 0x31, 0xD5, 0x48, 0x6A, 0xCB, 0x8A, 0x30, 0x1A, 0x98, 0x42, 0x2C,
+	0xD9, 0x03, 0x20, 0xC8, 0x72, 0x08, 0x8B, 0x48, 0x83, 0xD0, 0x6E, 0x00, 0x28, 0x25, 0xD0, 0xFE,
+	0xF7, 0x1D, 0xFD, 0x22, 0xE0, 0x03, 0x28, 0x1E, 0xD1, 0xB4, 0x48, 0xC0, 0x6E, 0x00, 0x28, 0x0D,
+	0xD0, 0xB3, 0x48, 0xC0, 0x7E, 0x01, 0x28, 0x09, 0xD1, 0x00, 0x24, 0x00, 0xF0, 0x02, 0xFD, 0xB0,
+	0x49, 0x00, 0x20, 0xC8, 0x76, 0xA2, 0x48, 0x46, 0x62, 0x00, 0xF0, 0xAA, 0xFD, 0xAB, 0x48, 0xC0,
+	0x6E, 0x00, 0x28, 0x05, 0xD1, 0x00, 0x2D, 0x03, 0xD0, 0x00, 0x24, 0x00, 0xF0, 0xF8, 0xFC, 0x04,
+	0xE0, 0x38, 0x78, 0x40, 0x07, 0x01, 0xD4, 0x00, 0x24, 0xC2, 0xE7, 0x20, 0x46, 0xF8, 0xBD, 0xF0,
+	0xB5, 0x97, 0x4A, 0x91, 0xB0, 0xD1, 0x79, 0xA3, 0x4F, 0x49, 0x43, 0x07, 0x91, 0x11, 0x7A, 0x49,
+	0x43, 0x06, 0x91, 0x39, 0x78, 
+	0x00, 0x01, 0x6C, 0x00, 0x80, 0x10, 0x91, 0x88, 0x42, 0x00, 0xD9, 0x08, 0x46, 0x00, 0x25, 0x29,
+	0x46, 0x01, 0xAA, 0xFF, 0x23, 0x53, 0x54, 0x49, 0x1C, 0xC9, 0xB2, 0x0E, 0x29, 0xF9, 0xD9, 0x00,
+	0x21, 0x90, 0x4C, 0x0F, 0xE0, 0xCA, 0x00, 0x96, 0x4B, 0x8A, 0x18, 0xD2, 0x18, 0xD2, 0x79, 0x01,
+	0x23, 0x12, 0x07, 0x12, 0x0F, 0x93, 0x40, 0x26, 0x88, 0x1D, 0x43, 0x1E, 0x43, 0x26, 0x80, 0x01,
+	0xAE, 0xB1, 0x54, 0x49, 0x1C, 0x81, 0x42, 0xED, 0xD3, 0x85, 0x48, 0x22, 0x88, 0x01, 0x88, 0x11,
+	0x40, 0x00, 0x24, 0x01, 0x80, 0x22, 0x46, 0x83, 0xE0, 0x7E, 0x4E, 0x51, 0x00, 0x70, 0x5C, 0xC7,
+	0x43, 0x3F, 0x07, 0x72, 0xD0, 0x83, 0x06, 0x9B, 0x0F, 0x03, 0x2B, 0x70, 0xD0, 0x00, 0x07, 0x00,
+	0x0F, 0x01, 0x23, 0x83, 0x40, 0x89, 0x19, 0x49, 0x78, 0x9D, 0x43, 0x8E, 0x46, 0x01, 0xA9, 0x09,
+	0x5C, 0x9C, 0x46, 0xFF, 0x29, 
+	0x00, 0x01, 0x6D, 0x00, 0x80, 0x0C, 0xD1, 0x61, 0x00, 0x73, 0x46, 0x8F, 0x19, 0x7B, 0x70, 0x30,
+	0x23, 0x18, 0x43, 0x73, 0x4B, 0x70, 0x54, 0x19, 0x88, 0x60, 0x46, 0x81, 0x43, 0x19, 0x80, 0x52,
+	0xE0, 0x63, 0x00, 0x6C, 0x4E, 0x0F, 0x93, 0x9B, 0x19, 0x59, 0x70, 0xCB, 0x00, 0x74, 0x4E, 0xCB,
+	0x18, 0x9E, 0x19, 0x0E, 0x96, 0x73, 0x79, 0x37, 0x79, 0x1E, 0x02, 0x3E, 0x43, 0x65, 0x4F, 0x73,
+	0x46, 0x9B, 0x00, 0x7A, 0x37, 0x0D, 0x96, 0xFF, 0x5A, 0x0C, 0x97, 0xF6, 0x1B, 0x05, 0x96, 0x0E,
+	0x9E, 0x9E, 0x46, 0xF7, 0x78, 0xB3, 0x78, 0x3E, 0x02, 0x1E, 0x43, 0x5E, 0x4F, 0x73, 0x46, 0x7A,
+	0x37, 0xDB, 0x19, 0x0B, 0x96, 0x0A, 0x93, 0x5B, 0x88, 0x67, 0x46, 0xF3, 0x1A, 0x05, 0x9E, 0x5B,
+	0x43, 0x76, 0x43, 0xF3, 0x18, 0x56, 0x4E, 0x9E, 0x46, 0x36, 0x8C, 0x06, 0x9B, 0x09, 0x96, 0x37,
+	0x42, 0x00, 0xD1, 0x07, 0x9B, 
+	0x00, 0x01, 0x6E, 0x00, 0x80, 0x73, 0x45, 0x12, 0xD8, 0x20, 0x23, 0x18, 0x43, 0x51, 0x4E, 0x0F,
+	0x9B, 0xF0, 0x54, 0x88, 0x00, 0x31, 0x46, 0x7A, 0x31, 0x0D, 0x9B, 0x0B, 0x52, 0x40, 0x18, 0x0B,
+	0x9B, 0x43, 0x80, 0x09, 0x99, 0x60, 0x46, 0x4A, 0x4B, 0x08, 0x43, 0x18, 0x84, 0x0B, 0xE0, 0x49,
+	0x4E, 0x0F, 0x9B, 0xF0, 0x54, 0x33, 0x46, 0x7A, 0x33, 0x88, 0x00, 0x0C, 0x9E, 0x1E, 0x52, 0x0A,
+	0x99, 0xC0, 0x18, 0x49, 0x88, 0x41, 0x80, 0x64, 0x1C, 0x09, 0xE0, 0x0D, 0xE0, 0xFF, 0xE7, 0x00,
+	0x07, 0x00, 0x0F, 0x01, 0x23, 0x42, 0x49, 0x83, 0x40, 0x08, 0x88, 0x98, 0x43, 0x08, 0x80, 0x52,
+	0x1C, 0x10, 0x98, 0x82, 0x42, 0x00, 0xD2, 0x77, 0xE7, 0x00, 0x26, 0x38, 0xE0, 0xE8, 0x07, 0x33,
+	0xD0, 0x01, 0xA8, 0x87, 0x5D, 0xF8, 0x00, 0x39, 0x18, 0x41, 0x48, 0x08, 0x18, 0x08, 0x90, 0xC1,
+	0x78, 0x83, 0x78, 0x0A, 0x02, 
+	0x00, 0x01, 0x6F, 0x00, 0x80, 0x41, 0x79, 0x00, 0x79, 0x09, 0x02, 0x1A, 0x43, 0x01, 0x43, 0x30,
+	0x46, 0x01, 0x23, 0xF5, 0xF7, 0x07, 0xFF, 0x00, 0x28, 0x1E, 0xD1, 0x10, 0x20, 0x32, 0x46, 0x02,
+	0x43, 0x2C, 0x49, 0x60, 0x00, 0x0A, 0x54, 0x40, 0x18, 0x47, 0x70, 0x08, 0x98, 0x29, 0x4A, 0x41,
+	0x79, 0x00, 0x79, 0x09, 0x02, 0x01, 0x43, 0xB8, 0x00, 0x7A, 0x32, 0x11, 0x52, 0x08, 0x99, 0xCB,
+	0x78, 0x8F, 0x78, 0x19, 0x02, 0x39, 0x43, 0x80, 0x18, 0x41, 0x80, 0x21, 0x49, 0x01, 0x22, 0x08,
+	0x8C, 0xB2, 0x40, 0x90, 0x43, 0x08, 0x84, 0x64, 0x1C, 0x76, 0x1C, 0xF6, 0xB2, 0x6D, 0x08, 0x00,
+	0x2D, 0x03, 0xD0, 0x28, 0x48, 0x00, 0x78, 0x84, 0x42, 0xC0, 0xD3, 0x19, 0x48, 0xFF, 0x22, 0x44,
+	0x74, 0x24, 0x48, 0x18, 0x4B, 0x0F, 0x25, 0x01, 0x78, 0x04, 0xE0, 0x60, 0x00, 0x1D, 0x54, 0xC0,
+	0x18, 0x42, 0x70, 0x64, 0x1C, 
+	0x00, 0x01, 0x70, 0x00, 0x80, 0x8C, 0x42, 0xF8, 0xD3, 0x11, 0xB0, 0xF0, 0xBD, 0xF1, 0xB5, 0x10,
+	0x4F, 0x82, 0xB0, 0x38, 0x78, 0x00, 0x28, 0x03, 0xD0, 0x00, 0x20, 0x38, 0x70, 0x01, 0x25, 0x00,
+	0xE0, 0x00, 0x25, 0x14, 0x48, 0x17, 0x49, 0x00, 0x78, 0x09, 0x78, 0x88, 0x42, 0x00, 0xD9, 0x08,
+	0x46, 0xC0, 0xB2, 0xFF, 0xF7, 0xDC, 0xFE, 0x14, 0x48, 0x02, 0x78, 0x50, 0x06, 0x40, 0x0F, 0x27,
+	0xD1, 0x12, 0x48, 0x00, 0x78, 0x00, 0x28, 0x24, 0xD0, 0x01, 0x20, 0x22, 0xE0, 0xF0, 0xE9, 0x00,
+	0x00, 0x58, 0x02, 0x00, 0x20, 0xCE, 0x19, 0x00, 0x20, 0xB6, 0x02, 0x00, 0x20, 0xDF, 0x01, 0x00,
+	0x20, 0x86, 0x00, 0x00, 0x20, 0x88, 0x00, 0x00, 0x20, 0x00, 0x04, 0x01, 0x40, 0xD4, 0x02, 0x00,
+	0x20, 0xCA, 0x02, 0x00, 0x20, 0xEE, 0x00, 0x00, 0x20, 0xCC, 0x02, 0x00, 0x20, 0x80, 0xE6, 0x00,
+	0x00, 0x88, 0x03, 0x00, 0x20, 
+	0x00, 0x01, 0x71, 0x00, 0x80, 0x18, 0x03, 0x00, 0x20, 0xDE, 0x01, 0x00, 0x20, 0xEF, 0x00, 0x00,
+	0x20, 0x00, 0x20, 0x79, 0x7C, 0xFE, 0x4B, 0x00, 0x28, 0x02, 0xD1, 0x52, 0x00, 0x0A, 0x43, 0x07,
+	0xE0, 0x20, 0x22, 0x0A, 0x43, 0x59, 0x7F, 0xC9, 0x06, 0x89, 0x0F, 0x03, 0x29, 0x00, 0xD1, 0x01,
+	0x25, 0x79, 0x78, 0x81, 0x42, 0x05, 0xD0, 0x59, 0x7F, 0xC9, 0x06, 0x89, 0x0F, 0x00, 0xD0, 0x01,
+	0x25, 0x78, 0x70, 0xD1, 0xB2, 0xB8, 0x8B, 0x00, 0xF0, 0x88, 0xFB, 0xB8, 0x8B, 0x40, 0x1C, 0x84,
+	0xB2, 0x78, 0x7C, 0xC1, 0x00, 0x08, 0x1A, 0xEF, 0x49, 0x00, 0x19, 0x09, 0x38, 0x09, 0x68, 0x00,
+	0x26, 0x48, 0x72, 0x3B, 0xE0, 0xEC, 0x49, 0x70, 0x00, 0x0A, 0x5C, 0x40, 0x18, 0x00, 0x92, 0x40,
+	0x78, 0x91, 0x06, 0x8A, 0x0F, 0x00, 0xD0, 0x01, 0x25, 0x89, 0x0F, 0x03, 0x29, 0x03, 0xD0, 0xC1,
+	0x00, 0x41, 0x18, 0xE6, 0x48, 
+	0x00, 0x01, 0x72, 0x00, 0x80, 0x03, 0xE0, 0xC1, 0x00, 0x41, 0x18, 0xE3, 0x48, 0x16, 0x30, 0x0F,
+	0x18, 0x78, 0x79, 0x3A, 0x79, 0x01, 0x02, 0x11, 0x43, 0x20, 0x46, 0x00, 0xF0, 0x63, 0xFB, 0xF8,
+	0x78, 0xBA, 0x78, 0x01, 0x02, 0xA0, 0x1C, 0x11, 0x43, 0x80, 0xB2, 0x00, 0xF0, 0x5B, 0xFB, 0x20,
+	0x1D, 0x39, 0x7A, 0x80, 0xB2, 0x00, 0xF0, 0x51, 0xFB, 0xD6, 0x4A, 0x61, 0x1D, 0x13, 0x68, 0xB8,
+	0x79, 0x89, 0xB2, 0x59, 0x18, 0x00, 0x9B, 0x0B, 0x70, 0xA1, 0x1D, 0x12, 0x68, 0x40, 0x07, 0x89,
+	0xB2, 0x40, 0x0F, 0x51, 0x18, 0xE4, 0x1D, 0x08, 0x70, 0xA4, 0xB2, 0x76, 0x1C, 0xD0, 0x48, 0x40,
+	0x7C, 0x86, 0x42, 0xBF, 0xD3, 0xCC, 0x48, 0x16, 0x30, 0x80, 0x79, 0x00, 0x07, 0x00, 0x0F, 0x02,
+	0x28, 0x05, 0xD1, 0xCA, 0x49, 0x89, 0x79, 0x09, 0x07, 0x09, 0x0F, 0x03, 0x29, 0x07, 0xD0, 0x03,
+	0x28, 0x0C, 0xD1, 0xC6, 0x49, 
+	0x00, 0x01, 0x73, 0x00, 0x80, 0x89, 0x79, 0x09, 0x07, 0x09, 0x0F, 0x02, 0x29, 0x06, 0xD1, 0xC3,
+	0x49, 0x89, 0x79, 0x09, 0x07, 0x09, 0x0F, 0x88, 0x42, 0x00, 0xD0, 0x01, 0x25, 0xC1, 0x4C, 0xC2,
+	0x4E, 0x20, 0x78, 0x31, 0x78, 0x88, 0x42, 0x00, 0xD3, 0x08, 0x46, 0xC1, 0x00, 0x42, 0x18, 0xBA,
+	0x48, 0xBA, 0x49, 0x16, 0x30, 0x02, 0xF0, 0x12, 0xF8, 0xB9, 0x49, 0x30, 0x78, 0x88, 0x74, 0x48,
+	0x7C, 0x0A, 0x7C, 0x90, 0x42, 0x00, 0xD0, 0x01, 0x25, 0xB5, 0x49, 0x08, 0x74, 0x88, 0x78, 0x00,
+	0x28, 0x4E, 0xD0, 0xB6, 0x48, 0x01, 0x90, 0xC0, 0x6A, 0x01, 0x25, 0x20, 0x78, 0xC1, 0x00, 0x09,
+	0x1A, 0xAF, 0x48, 0x80, 0x8B, 0x08, 0x18, 0x40, 0x1C, 0x84, 0xB2, 0x00, 0x26, 0xAC, 0x49, 0x70,
+	0x00, 0x28, 0x31, 0x09, 0x5A, 0xAE, 0x4A, 0x48, 0x05, 0x40, 0x0D, 0x90, 0x42, 0x38, 0xD0, 0x03,
+	0x22, 0x92, 0x03, 0x11, 0x40, 
+	0x00, 0x01, 0x74, 0x00, 0x80, 0x1C, 0xD0, 0x01, 0x22, 0xD2, 0x03, 0x89, 0x1A, 0x2B, 0xD1, 0x01,
+	0x99, 0x49, 0x6A, 0x81, 0x42, 0x27, 0xD9, 0x47, 0x00, 0xA6, 0x48, 0xC1, 0x5B, 0x20, 0x46, 0x00,
+	0xF0, 0xE1, 0xFA, 0xA5, 0x48, 0xC1, 0x5B, 0x20, 0x46, 0x32, 0x30, 0x80, 0xB2, 0x00, 0xF0, 0xDA,
+	0xFA, 0xA2, 0x48, 0xC1, 0x5B, 0x20, 0x46, 0x64, 0x30, 0x80, 0xB2, 0x00, 0xF0, 0xD3, 0xFA, 0x12,
+	0xE0, 0x01, 0x99, 0x89, 0x6A, 0x81, 0x42, 0x0E, 0xD9, 0x47, 0x00, 0x9D, 0x48, 0xC1, 0x5B, 0x20,
+	0x46, 0x00, 0xF0, 0xC8, 0xFA, 0x9B, 0x48, 0xC1, 0x5B, 0x20, 0x46, 0x32, 0x30, 0x80, 0xB2, 0x00,
+	0xF0, 0xC1, 0xFA, 0x99, 0x48, 0xE5, 0xE7, 0xA4, 0x1C, 0x76, 0x1C, 0xA4, 0xB2, 0x19, 0x2E, 0xBD,
+	0xD3, 0x96, 0x48, 0x40, 0x68, 0x96, 0x49, 0x02, 0x9A, 0x09, 0x68, 0x41, 0x1A, 0x00, 0x20, 0xD2,
+	0x06, 0x00, 0xD5, 0x04, 0x20, 
+	0x00, 0x01, 0x75, 0x00, 0x80, 0x02, 0x9A, 0x92, 0x06, 0x0E, 0xD5, 0x92, 0x48, 0x92, 0x4A, 0x00,
+	0x68, 0x12, 0x68, 0x50, 0x43, 0xFF, 0x22, 0x00, 0x0A, 0x2E, 0x32, 0x50, 0x43, 0x00, 0x0A, 0x81,
+	0x42, 0x01, 0xD2, 0x08, 0x20, 0x00, 0xE0, 0x0C, 0x20, 0x02, 0x99, 0x09, 0x06, 0x00, 0xD5, 0x10,
+	0x20, 0x02, 0x99, 0xC9, 0x05, 0x01, 0xD5, 0x1C, 0x20, 0x01, 0xE0, 0x1C, 0x28, 0x05, 0xD1, 0x78,
+	0x49, 0xCA, 0x78, 0x00, 0x2A, 0x08, 0xD1, 0x01, 0x22, 0x04, 0xE0, 0x75, 0x49, 0xCA, 0x78, 0x01,
+	0x2A, 0x02, 0xD1, 0x00, 0x22, 0xCA, 0x70, 0x01, 0x25, 0x71, 0x49, 0xE3, 0x23, 0x4A, 0x7B, 0x1A,
+	0x40, 0x02, 0x43, 0x4A, 0x73, 0x00, 0x2D, 0x02, 0xD0, 0x48, 0x7B, 0x40, 0x30, 0x48, 0x73, 0x48,
+	0x7B, 0xDC, 0x21, 0x08, 0x40, 0x67, 0x49, 0x09, 0x68, 0x88, 0x72, 0x28, 0x46, 0xFE, 0xBD, 0x10,
+	0xB5, 0x00, 0xF0, 0x77, 0xFA, 
+	0x00, 0x01, 0x76, 0x00, 0x80, 0x66, 0x49, 0xFF, 0x20, 0x08, 0x71, 0x10, 0xBD, 0xF8, 0xB5, 0x73,
+	0x49, 0x00, 0x20, 0xFA, 0xF7, 0x1A, 0xFB, 0x62, 0x4C, 0x00, 0x26, 0x26, 0x71, 0x01, 0x20, 0x01,
+	0xF0, 0x4D, 0xFE, 0x6F, 0x49, 0x10, 0x20, 0x08, 0x61, 0x00, 0x20, 0xFA, 0xF7, 0x2E, 0xFB, 0x00,
+	0x20, 0xFA, 0xF7, 0x1C, 0xFB, 0x04, 0x20, 0xE0, 0x72, 0x6A, 0x48, 0x00, 0x78, 0x60, 0x83, 0x80,
+	0xB2, 0x00, 0xF0, 0xAC, 0xFE, 0x03, 0x20, 0xFE, 0xF7, 0xE5, 0xFB, 0xE0, 0x74, 0xE0, 0x7C, 0x00,
+	0x28, 0x01, 0xD0, 0x01, 0x20, 0x20, 0x75, 0xFE, 0xF7, 0x75, 0xFA, 0x4D, 0x4D, 0x62, 0x4F, 0x20,
+	0x35, 0x1D, 0xE0, 0x00, 0xF0, 0xEF, 0xFE, 0xFE, 0xF7, 0x07, 0xFC, 0x60, 0x48, 0x81, 0x68, 0x89,
+	0x07, 0xFC, 0xD5, 0x72, 0xB6, 0x00, 0xF0, 0x1E, 0xFE, 0xFD, 0xF7, 0x3F, 0xF9, 0xC0, 0x07, 0x62,
+	0xB6, 0x23, 0xD1, 0x38, 0x78, 
+	0x00, 0x01, 0x77, 0x00, 0x80, 0x00, 0x28, 0x00, 0xD0, 0x20, 0x71, 0xFE, 0xF7, 0x0D, 0xFC, 0x28,
+	0x78, 0x7D, 0x21, 0xC9, 0x00, 0x48, 0x43, 0x00, 0xF0, 0x7C, 0xFF, 0x00, 0xF0, 0xA7, 0xFE, 0x20,
+	0x79, 0x00, 0x28, 0xDE, 0xD0, 0x20, 0x79, 0xFF, 0x28, 0x01, 0xD0, 0x00, 0xF0, 0x22, 0xFA, 0x26,
+	0x75, 0xE6, 0x74, 0xFE, 0xF7, 0x4E, 0xFA, 0x00, 0xF0, 0x04, 0xFA, 0x60, 0x8B, 0x00, 0xF0, 0x6E,
+	0xFE, 0x21, 0x79, 0x03, 0x20, 0xFE, 0xF7, 0xA2, 0xFB, 0xF8, 0xBD, 0xD2, 0xE7, 0x70, 0xB5, 0x48,
+	0x48, 0x40, 0x69, 0xC1, 0xB2, 0x35, 0x48, 0x01, 0x29, 0x04, 0xD1, 0xC1, 0x69, 0x00, 0x6A, 0xC9,
+	0x05, 0x0C, 0x0E, 0x03, 0xE0, 0x01, 0x6A, 0xC0, 0x69, 0xC9, 0x05, 0x0C, 0x0E, 0xC0, 0x05, 0x05,
+	0x0E, 0x2B, 0x4E, 0x40, 0x48, 0xB1, 0x7B, 0x00, 0x88, 0x8A, 0x06, 0x04, 0xD5, 0x42, 0x06, 0x02,
+	0xD4, 0xDF, 0x22, 0x11, 0x40, 
+	0x00, 0x01, 0x78, 0x00, 0x80, 0xB1, 0x73, 0xB1, 0x7B, 0xCA, 0x06, 0x04, 0xD5, 0x80, 0x06, 0x02,
+	0xD4, 0xEF, 0x20, 0x01, 0x40, 0xB1, 0x73, 0x71, 0x79, 0xFA, 0x20, 0xFA, 0x29, 0x00, 0xD9, 0x70,
+	0x71, 0xB1, 0x79, 0xFA, 0x29, 0x00, 0xD9, 0xB0, 0x71, 0x31, 0x8B, 0x70, 0x79, 0x81, 0x42, 0x00,
+	0xD2, 0x30, 0x83, 0x31, 0x8B, 0xB0, 0x79, 0x81, 0x42, 0x00, 0xD2, 0x30, 0x83, 0x31, 0x8B, 0x7D,
+	0x20, 0xC0, 0x00, 0x81, 0x42, 0x00, 0xD9, 0x30, 0x83, 0xF1, 0x8A, 0x2B, 0x48, 0x81, 0x42, 0x00,
+	0xD9, 0xF0, 0x82, 0x00, 0xF0, 0x87, 0xFF, 0x26, 0x48, 0x40, 0x30, 0xC1, 0x8A, 0xF2, 0x8B, 0x91,
+	0x42, 0x01, 0xD9, 0xC0, 0x8A, 0xF0, 0x83, 0xF0, 0x8B, 0x00, 0x28, 0x02, 0xD1, 0x01, 0x20, 0xF0,
+	0x83, 0x04, 0xE0, 0x7D, 0x21, 0x09, 0x01, 0x88, 0x42, 0x00, 0xD9, 0xF1, 0x83, 0x70, 0x7A, 0xA0,
+	0x42, 0x00, 0xD9, 0x74, 0x72, 
+	0x00, 0x01, 0x79, 0x00, 0x80, 0xB0, 0x7A, 0xA8, 0x42, 0x00, 0xD9, 0xB5, 0x72, 0x70, 0xBD, 0x00,
+	0x00, 0x00, 0xE6, 0x00, 0x00, 0x28, 0x02, 0x00, 0x20, 0xCE, 0x19, 0x00, 0x20, 0x88, 0x03, 0x00,
+	0x20, 0x58, 0x02, 0x00, 0x20, 0x18, 0x03, 0x00, 0x20, 0xEE, 0x00, 0x00, 0x20, 0xF0, 0xE9, 0x00,
+	0x00, 0xFF, 0x07, 0x00, 0x00, 0xCC, 0x07, 0x00, 0x20, 0x1C, 0x0E, 0x00, 0x20, 0x32, 0x0B, 0x00,
+	0x20, 0x2C, 0x05, 0x00, 0x20, 0x7C, 0x0B, 0x00, 0x20, 0x92, 0x08, 0x00, 0x20, 0x00, 0x04, 0x01,
+	0x40, 0xD4, 0x02, 0x00, 0x20, 0xE8, 0x02, 0x00, 0x20, 0xE4, 0x02, 0x00, 0x20, 0xFB, 0xBA, 0x00,
+	0x00, 0x00, 0x00, 0x14, 0x40, 0x00, 0xE7, 0x00, 0x00, 0xF6, 0x01, 0x00, 0x20, 0x00, 0x00, 0x12,
+	0x40, 0xD0, 0xE7, 0x00, 0x00, 0x1A, 0x03, 0x00, 0x20, 0x60, 0xEA, 0x00, 0x00, 0x70, 0xB5, 0x03,
+	0x20, 0xFE, 0xF7, 0x08, 0xFB, 
+	0x00, 0x01, 0x7A, 0x00, 0x80, 0x05, 0x46, 0x04, 0x20, 0xFE, 0xF7, 0x04, 0xFB, 0x02, 0x46, 0x01,
+	0x24, 0xF0, 0x48, 0x00, 0x21, 0xCB, 0x00, 0xC3, 0x5C, 0xAB, 0x42, 0x23, 0xD1, 0xC9, 0x00, 0x08,
+	0x18, 0x45, 0x68, 0x40, 0x78, 0x00, 0x24, 0x90, 0x42, 0x1A, 0xD1, 0x01, 0x2A, 0x0E, 0xD0, 0x02,
+	0x2A, 0x11, 0xD0, 0x04, 0x2A, 0x14, 0xD1, 0x07, 0x20, 0xFE, 0xF7, 0xFD, 0xFA, 0x06, 0x46, 0x05,
+	0x20, 0xFE, 0xF7, 0xF9, 0xFA, 0x00, 0x04, 0x30, 0x18, 0x28, 0x60, 0x0F, 0xE0, 0x05, 0x20, 0xFE,
+	0xF7, 0xE1, 0xFA, 0x28, 0x70, 0x0A, 0xE0, 0x05, 0x20, 0xFE, 0xF7, 0xED, 0xFA, 0x28, 0x80, 0x05,
+	0xE0, 0x01, 0x24, 0x03, 0xE0, 0x49, 0x1C, 0xC9, 0xB2, 0x0B, 0x29, 0xD3, 0xD9, 0xFF, 0xF7, 0x2E,
+	0xFF, 0x00, 0x2C, 0x04, 0xD0, 0x00, 0x21, 0x04, 0x20, 0xFE, 0xF7, 0xC8, 0xFA, 0x86, 0xE7, 0xD6,
+	0x48, 0xD6, 0x49, 0x00, 0x68, 
+	0x00, 0x01, 0x7B, 0x00, 0x80, 0x09, 0x78, 0x00, 0x22, 0x40, 0x18, 0xD5, 0x49, 0x20, 0x38, 0x40,
+	0x7F, 0x8A, 0x5E, 0xD4, 0x49, 0x80, 0x18, 0x48, 0x60, 0xD3, 0x4A, 0xD1, 0x7A, 0x90, 0x79, 0x01,
+	0x29, 0x01, 0xD1, 0x50, 0x79, 0x02, 0xE0, 0x03, 0x29, 0x00, 0xD1, 0x10, 0x8B, 0xCF, 0x49, 0x09,
+	0x68, 0x88, 0x42, 0xE3, 0xD0, 0x80, 0xB2, 0x00, 0xF0, 0x71, 0xFD, 0x67, 0xE7, 0x70, 0xB5, 0x02,
+	0x20, 0xFE, 0xF7, 0xA8, 0xFA, 0x04, 0x46, 0x40, 0x06, 0x5D, 0xD4, 0x01, 0xE0, 0x00, 0xF0, 0xBA,
+	0xFD, 0xFE, 0xF7, 0xBA, 0xFA, 0x00, 0x28, 0xF9, 0xD1, 0xA1, 0x06, 0x89, 0x0E, 0x05, 0x29, 0x2F,
+	0xD0, 0x08, 0xDC, 0x00, 0x29, 0x3F, 0xD0, 0x02, 0x29, 0x27, 0xD0, 0x03, 0x29, 0x39, 0xD1, 0xFF,
+	0xF7, 0x85, 0xFF, 0x38, 0xE0, 0x06, 0x29, 0x31, 0xD0, 0x25, 0x29, 0x32, 0xD1, 0xF7, 0xF7, 0xFC,
+	0xF9, 0x01, 0x46, 0x03, 0x20, 
+	0x00, 0x01, 0x7C, 0x00, 0x80, 0xFE, 0xF7, 0x8C, 0xFA, 0xF7, 0xF7, 0xF9, 0xF9, 0x01, 0x46, 0x05,
+	0x20, 0xFE, 0xF7, 0x7C, 0xFA, 0xF7, 0xF7, 0xF6, 0xF9, 0x01, 0x46, 0x06, 0x20, 0xFE, 0xF7, 0x76,
+	0xFA, 0xF7, 0xF7, 0xF3, 0xF9, 0x01, 0x46, 0x07, 0x20, 0xFE, 0xF7, 0x70, 0xFA, 0xF7, 0xF7, 0xF6,
+	0xF9, 0x01, 0x46, 0x08, 0x20, 0xFE, 0xF7, 0x6A, 0xFA, 0x15, 0xE0, 0x00, 0xF0, 0xEC, 0xF8, 0x12,
+	0xE0, 0xAB, 0x49, 0xAC, 0x48, 0x01, 0xF0, 0x2C, 0xFD, 0x05, 0x46, 0x00, 0x21, 0x03, 0x20, 0xFE,
+	0xF7, 0x5D, 0xFA, 0x29, 0x46, 0x04, 0x20, 0xFE, 0xF7, 0x63, 0xFA, 0x04, 0xE0, 0xFF, 0xF7, 0x56,
+	0xFE, 0x01, 0xE0, 0xA4, 0x09, 0xA4, 0x01, 0xA4, 0x48, 0x80, 0x22, 0x01, 0x78, 0x51, 0x40, 0x01,
+	0x70, 0xC8, 0xB2, 0xC1, 0x09, 0xC9, 0x01, 0x21, 0x43, 0x40, 0x20, 0x01, 0x43, 0x02, 0x20, 0xFE,
+	0xF7, 0x45, 0xFA, 0x01, 0x20, 
+	0x00, 0x01, 0x7D, 0x00, 0x80, 0x02, 0xE7, 0x00, 0x20, 0x00, 0xE7, 0xF8, 0xB5, 0x96, 0x4E, 0x9B,
+	0x48, 0xB1, 0x7B, 0x9B, 0x4D, 0x01, 0x70, 0x28, 0x78, 0xC0, 0x07, 0x01, 0xD0, 0xFE, 0xF7, 0x21,
+	0xFA, 0x98, 0x4F, 0x99, 0x4C, 0x38, 0x78, 0x80, 0x07, 0x15, 0xD5, 0x20, 0x78, 0x00, 0x28, 0x01,
+	0xD0, 0xFC, 0xF7, 0x9C, 0xFF, 0x00, 0xF0, 0x5E, 0xFD, 0x38, 0x78, 0xFD, 0x21, 0x08, 0x40, 0x38,
+	0x70, 0xC1, 0xB2, 0x00, 0x20, 0xFE, 0xF7, 0x22, 0xFA, 0x20, 0x78, 0x00, 0x28, 0x01, 0xD0, 0xFC,
+	0xF7, 0x23, 0xFF, 0xFF, 0xF7, 0xC6, 0xFA, 0x28, 0x78, 0xC0, 0x07, 0x01, 0xD0, 0xFE, 0xF7, 0x01,
+	0xFA, 0x28, 0x78, 0x00, 0x28, 0x03, 0xD1, 0x00, 0xF0, 0x53, 0xF9, 0xFE, 0xF7, 0x4B, 0xF9, 0x20,
+	0x78, 0x00, 0x28, 0x04, 0xD0, 0x30, 0x78, 0x00, 0x28, 0x01, 0xD1, 0x00, 0xF0, 0xC0, 0xF8, 0xFF,
+	0xF7, 0x5D, 0xFF, 0x00, 0x28, 
+	0x00, 0x01, 0x7E, 0x00, 0x80, 0x01, 0xD0, 0x01, 0x20, 0xF0, 0x73, 0x28, 0x78, 0x00, 0x07, 0x01,
+	0xD5, 0xFE, 0xF7, 0xE7, 0xF9, 0xF0, 0x7B, 0x00, 0x28, 0x04, 0xD0, 0x28, 0x78, 0x00, 0x28, 0x01,
+	0xD1, 0x00, 0xF0, 0xFE, 0xF8, 0xFE, 0xF7, 0x28, 0xFA, 0x78, 0x48, 0x01, 0x69, 0x04, 0x22, 0x91,
+	0x43, 0x01, 0x61, 0x77, 0x48, 0x81, 0x68, 0x89, 0x07, 0xFC, 0xD5, 0x20, 0x78, 0x00, 0x28, 0x10,
+	0xD0, 0x72, 0xB6, 0x00, 0xF0, 0x37, 0xFC, 0xFC, 0xF7, 0x58, 0xFF, 0x04, 0x46, 0xC0, 0x07, 0x30,
+	0xD1, 0x62, 0xB6, 0x28, 0x78, 0x80, 0x07, 0x01, 0xD5, 0xFE, 0xF7, 0xC3, 0xF9, 0x20, 0x46, 0xFF,
+	0xF7, 0x55, 0xFC, 0xF0, 0x73, 0xFE, 0xF7, 0x20, 0xFA, 0x61, 0x48, 0x20, 0x30, 0x00, 0x78, 0x7D,
+	0x21, 0xC9, 0x00, 0x48, 0x43, 0x00, 0xF0, 0x8D, 0xFD, 0x00, 0x28, 0x04, 0xD0, 0x28, 0x78, 0x40,
+	0x07, 0x01, 0xD5, 0xFE, 0xF7, 
+	0x00, 0x01, 0x7F, 0x00, 0x80, 0xAE, 0xF9, 0xFF, 0xF7, 0xDE, 0xFA, 0x04, 0x46, 0x28, 0x78, 0xC0,
+	0x09, 0x01, 0xD0, 0xFE, 0xF7, 0xA6, 0xF9, 0x00, 0x2C, 0x01, 0xD0, 0x00, 0xF0, 0xA7, 0xFC, 0x30,
+	0x7B, 0xF1, 0x7A, 0x88, 0x42, 0x04, 0xD0, 0x70, 0x8B, 0x00, 0xF0, 0x78, 0xFC, 0xF0, 0x7A, 0x30,
+	0x73, 0xF8, 0xBD, 0xBF, 0xF3, 0x50, 0x8F, 0xBF, 0xF3, 0x60, 0x8F, 0x30, 0xBF, 0x62, 0xB6, 0xBF,
+	0xE7, 0x70, 0x47, 0x49, 0x48, 0x02, 0x21, 0xC1, 0x72, 0x81, 0x79, 0x41, 0x83, 0x70, 0x47, 0x46,
+	0x48, 0x01, 0x21, 0xC1, 0x72, 0x41, 0x79, 0x41, 0x83, 0x70, 0x47, 0x4E, 0x4A, 0x12, 0x68, 0x10,
+	0x18, 0x01, 0x70, 0x70, 0x47, 0x4B, 0x4A, 0x12, 0x68, 0x10, 0x18, 0x0A, 0x0A, 0x02, 0x70, 0x41,
+	0x70, 0x70, 0x47, 0x10, 0xB5, 0x00, 0x20, 0xFA, 0xF7, 0xC0, 0xF8, 0x00, 0x20, 0x01, 0xF0, 0xDE,
+	0xFB, 0x45, 0x49, 0x10, 0x20, 
+	0x00, 0x01, 0x80, 0x00, 0x80, 0x08, 0x61, 0x00, 0x20, 0xFA, 0xF7, 0xBF, 0xF8, 0x43, 0x49, 0x00,
+	0x20, 0xFA, 0xF7, 0x9B, 0xF8, 0x10, 0xBD, 0x70, 0xB5, 0x03, 0x20, 0xFE, 0xF7, 0x7B, 0xF9, 0x01,
+	0x23, 0x2C, 0x4A, 0x00, 0x21, 0xCC, 0x00, 0x14, 0x5D, 0x84, 0x42, 0x1D, 0xD1, 0xC8, 0x00, 0x80,
+	0x18, 0x45, 0x78, 0x44, 0x68, 0x29, 0x46, 0x04, 0x20, 0xFE, 0xF7, 0x68, 0xF9, 0x01, 0x2D, 0x0D,
+	0xD0, 0x02, 0x2D, 0x0E, 0xD0, 0x04, 0x2D, 0x15, 0xD1, 0x24, 0x68, 0x05, 0x20, 0x21, 0x0C, 0xFE,
+	0xF7, 0x67, 0xF9, 0xA1, 0xB2, 0x07, 0x20, 0xFE, 0xF7, 0x63, 0xF9, 0x17, 0xE6, 0x21, 0x78, 0x05,
+	0x20, 0x0A, 0xE0, 0x21, 0x88, 0x05, 0x20, 0xF6, 0xE7, 0x49, 0x1C, 0xC9, 0xB2, 0x0B, 0x29, 0xD9,
+	0xD9, 0x00, 0x2B, 0xF2, 0xD0, 0x00, 0x21, 0x04, 0x20, 0xFE, 0xF7, 0x48, 0xF9, 0x06, 0xE6, 0x70,
+	0xB5, 0x24, 0x48, 0x4E, 0x26, 
+	0x00, 0x01, 0x81, 0x00, 0x80, 0x05, 0x68, 0x18, 0x48, 0x81, 0x78, 0x00, 0x29, 0x00, 0xD0, 0xE4,
+	0x26, 0x41, 0x7B, 0x20, 0x20, 0x01, 0x43, 0x0A, 0x20, 0xFE, 0xF7, 0x38, 0xF9, 0x01, 0xE0, 0x00,
+	0xF0, 0x51, 0xFC, 0xFE, 0xF7, 0x51, 0xF9, 0x00, 0x28, 0xF9, 0xD1, 0x0B, 0x24, 0x0B, 0x36, 0x05,
+	0xE0, 0x29, 0x5D, 0x20, 0x46, 0xFE, 0xF7, 0x2A, 0xF9, 0x64, 0x1C, 0xA4, 0xB2, 0xB4, 0x42, 0xF7,
+	0xD3, 0x69, 0x7A, 0x09, 0x20, 0xFE, 0xF7, 0x22, 0xF9, 0xA9, 0x7A, 0x0A, 0x20, 0xFE, 0xF7, 0x1E,
+	0xF9, 0xDC, 0xE5, 0x00, 0x00, 0x9C, 0xDF, 0x00, 0x00, 0xF0, 0x02, 0x00, 0x20, 0xEC, 0x02, 0x00,
+	0x20, 0xEE, 0x02, 0x00, 0x20, 0x00, 0xFF, 0x01, 0x40, 0x58, 0x02, 0x00, 0x20, 0xE8, 0x02, 0x00,
+	0x20, 0x00, 0xE6, 0x00, 0x00, 0xFC, 0x07, 0x00, 0x00, 0xCA, 0x02, 0x00, 0x20, 0xDF, 0x01, 0x00,
+	0x20, 0xCB, 0x02, 0x00, 0x20, 
+	0x00, 0x01, 0x82, 0x00, 0x80, 0xCC, 0x02, 0x00, 0x20, 0xB6, 0x02, 0x00, 0x20, 0x00, 0xED, 0x00,
+	0xE0, 0x00, 0x00, 0x12, 0x40, 0x28, 0x02, 0x00, 0x20, 0x00, 0x00, 0x14, 0x40, 0xE3, 0xA1, 0x00,
+	0x00, 0x70, 0xB5, 0xFE, 0xF7, 0x2F, 0xF8, 0x00, 0x20, 0xFE, 0xF7, 0xF4, 0xF8, 0xC0, 0x09, 0xC0,
+	0x01, 0xFF, 0x4E, 0x70, 0x70, 0x00, 0x20, 0x30, 0x70, 0xFE, 0x4C, 0x60, 0x7F, 0x80, 0x07, 0x80,
+	0x0F, 0x01, 0x28, 0x1A, 0xD0, 0x02, 0x28, 0x1D, 0xD1, 0xFE, 0xF7, 0xC2, 0xF8, 0x30, 0x24, 0x0B,
+	0x25, 0x00, 0xF0, 0xF8, 0xFB, 0x00, 0x20, 0xFE, 0xF7, 0xDD, 0xF8, 0x01, 0x46, 0xF2, 0x78, 0x21,
+	0x40, 0x91, 0x42, 0x07, 0xD1, 0x01, 0x46, 0x29, 0x42, 0x04, 0xD1, 0xC0, 0x09, 0x71, 0x78, 0xC0,
+	0x01, 0x88, 0x42, 0xED, 0xD0, 0xFE, 0xF7, 0x06, 0xF8, 0x70, 0xBD, 0x01, 0x20, 0x30, 0x70, 0x00,
+	0xF0, 0x19, 0xFB, 0xF0, 0x60, 
+	0x00, 0x01, 0x83, 0x00, 0x80, 0xFE, 0xF7, 0xA4, 0xF8, 0x20, 0x7F, 0x00, 0xF0, 0x91, 0xFC, 0xF1,
+	0xE7, 0xF8, 0xB5, 0xE7, 0x4C, 0x20, 0x78, 0x00, 0x28, 0x20, 0xD0, 0xE6, 0x48, 0xC1, 0x7F, 0x80,
+	0x7F, 0x0D, 0x02, 0x05, 0x43, 0x30, 0x26, 0x0B, 0x27, 0x00, 0xF0, 0xCC, 0xFB, 0x00, 0x20, 0xFE,
+	0xF7, 0xB1, 0xF8, 0x01, 0x46, 0xE2, 0x78, 0x31, 0x40, 0x91, 0x42, 0x0D, 0xD1, 0x01, 0x46, 0x39,
+	0x42, 0x0A, 0xD1, 0xC0, 0x09, 0x61, 0x78, 0xC0, 0x01, 0x88, 0x42, 0x05, 0xD1, 0x00, 0xF0, 0xF2,
+	0xFA, 0xE1, 0x68, 0x40, 0x1A, 0xA8, 0x42, 0xE7, 0xD9, 0x00, 0x20, 0x20, 0x70, 0xF8, 0xBD, 0x10,
+	0xB5, 0xFD, 0xF7, 0xFA, 0xFE, 0xD4, 0x4B, 0x00, 0x21, 0xD3, 0x4A, 0x5C, 0x33, 0x8C, 0x00, 0x04,
+	0x59, 0x10, 0xC2, 0x49, 0x1C, 0x89, 0xB2, 0x9A, 0x42, 0xF8, 0xD3, 0xCF, 0x4A, 0xCE, 0x4B, 0x64,
+	0x32, 0xE8, 0x33, 0x8C, 0x00, 
+	0x00, 0x01, 0x84, 0x00, 0x80, 0x04, 0x59, 0x10, 0xC2, 0x49, 0x1C, 0x89, 0xB2, 0x9A, 0x42, 0xF8,
+	0xD9, 0x8A, 0x00, 0xCA, 0x4B, 0x82, 0x58, 0xDA, 0x60, 0x49, 0x1C, 0x89, 0xB2, 0x8A, 0x00, 0x83,
+	0x58, 0xC7, 0x4A, 0x53, 0x60, 0x49, 0x1C, 0x09, 0x04, 0x89, 0x0B, 0x40, 0x58, 0xD0, 0x60, 0x10,
+	0xBD, 0xF8, 0xB5, 0x82, 0x00, 0x0C, 0x46, 0xC3, 0x48, 0x00, 0x27, 0x1C, 0x21, 0x15, 0x18, 0x29,
+	0x60, 0xC0, 0x4A, 0xA0, 0x00, 0x86, 0x18, 0xFF, 0x2C, 0x00, 0xD0, 0x31, 0x60, 0x0A, 0x20, 0xF9,
+	0xF7, 0x75, 0xFF, 0x10, 0x20, 0x28, 0x60, 0x23, 0x20, 0xF9, 0xF7, 0x70, 0xFF, 0xB6, 0x48, 0x01,
+	0x68, 0x02, 0x03, 0x11, 0x43, 0x01, 0x60, 0xC1, 0x68, 0x09, 0x06, 0xFC, 0xD5, 0x80, 0x21, 0xC1,
+	0x60, 0x00, 0x20, 0x28, 0x60, 0xFF, 0x2C, 0x00, 0xD0, 0x30, 0x60, 0xAF, 0x48, 0xC0, 0x30, 0xC0,
+	0x68, 0xAB, 0x49, 0xFF, 0x38, 
+	0x00, 0x01, 0x85, 0x00, 0x80, 0x06, 0x22, 0xFF, 0x38, 0x8A, 0x5E, 0x02, 0x38, 0x50, 0x43, 0x00,
+	0x28, 0x00, 0xDA, 0x40, 0x42, 0x09, 0x69, 0x88, 0x42, 0x00, 0xD9, 0x01, 0x27, 0x38, 0x46, 0xF8,
+	0xBD, 0x70, 0xB5, 0xFD, 0xF7, 0x99, 0xFE, 0xA2, 0x4C, 0xA7, 0x4A, 0x21, 0x89, 0x00, 0x20, 0x43,
+	0x00, 0xD3, 0x5A, 0x8B, 0x42, 0x03, 0xD8, 0x40, 0x1C, 0xC0, 0xB2, 0x20, 0x28, 0xF7, 0xD3, 0x20,
+	0x28, 0x01, 0xD1, 0x1F, 0x20, 0x01, 0xE0, 0x00, 0x28, 0x0C, 0xD0, 0x43, 0x00, 0x9D, 0x18, 0x20,
+	0x3D, 0xED, 0x8B, 0xD3, 0x5A, 0x4D, 0x1B, 0x59, 0x1A, 0xAD, 0xB2, 0x89, 0xB2, 0x8D, 0x42, 0x01,
+	0xD2, 0x40, 0x1E, 0xC0, 0xB2, 0x41, 0x00, 0x51, 0x5A, 0x21, 0x81, 0x53, 0x21, 0x93, 0x4A, 0x49,
+	0x06, 0xD1, 0x60, 0x91, 0x4D, 0x95, 0x49, 0x69, 0x61, 0x8F, 0x4A, 0x95, 0x49, 0x40, 0x32, 0x51,
+	0x62, 0x01, 0x04, 0x94, 0x48, 
+	0x00, 0x01, 0x86, 0x00, 0x80, 0x01, 0x43, 0x8C, 0x48, 0x80, 0x30, 0x81, 0x63, 0x92, 0x49, 0xC1,
+	0x60, 0xC1, 0x6B, 0x89, 0x09, 0x89, 0x01, 0xC1, 0x63, 0x87, 0x4E, 0x90, 0x48, 0xC0, 0x36, 0x70,
+	0x60, 0x03, 0x20, 0xB0, 0x60, 0x8E, 0x48, 0x30, 0x61, 0x8E, 0x48, 0x30, 0x62, 0x00, 0x21, 0xB1,
+	0x61, 0x29, 0x61, 0x8D, 0x48, 0x28, 0x60, 0x28, 0x68, 0x40, 0x00, 0xFC, 0xD4, 0x01, 0x22, 0x80,
+	0x48, 0xD2, 0x07, 0x42, 0x60, 0x89, 0x4A, 0xC2, 0x60, 0x7E, 0x4B, 0x00, 0x20, 0x82, 0x00, 0xD2,
+	0x18, 0x11, 0x60, 0x40, 0x1C, 0xC0, 0xB2, 0x41, 0x28, 0xF8, 0xD3, 0x28, 0x69, 0x80, 0x21, 0x88,
+	0x43, 0x28, 0x61, 0x70, 0x68, 0x78, 0x49, 0x00, 0x07, 0xC0, 0x0E, 0x40, 0x31, 0x08, 0x5E, 0x21,
+	0x89, 0x01, 0xF0, 0xAF, 0xFB, 0xE0, 0x80, 0x70, 0xBD, 0x70, 0xB5, 0xFD, 0xF7, 0x2D, 0xFE, 0x6E,
+	0x4B, 0x00, 0x21, 0x6D, 0x4A, 
+	0x00, 0x01, 0x87, 0x00, 0x80, 0x5C, 0x33, 0x10, 0xCA, 0x8D, 0x00, 0x49, 0x1C, 0x44, 0x51, 0x89,
+	0xB2, 0x9A, 0x42, 0xF8, 0xD3, 0x68, 0x4A, 0x68, 0x4B, 0x64, 0x32, 0xE8, 0x33, 0x10, 0xCA, 0x8D,
+	0x00, 0x49, 0x1C, 0x44, 0x51, 0x89, 0xB2, 0x9A, 0x42, 0xF8, 0xD9, 0x64, 0x4A, 0xD2, 0x68, 0x8B,
+	0x00, 0xC2, 0x50, 0x63, 0x4A, 0x49, 0x1C, 0x53, 0x68, 0x89, 0xB2, 0x8C, 0x00, 0x03, 0x51, 0x49,
+	0x1C, 0xD2, 0x68, 0x09, 0x04, 0x89, 0x0B, 0x42, 0x50, 0x70, 0xBD, 0xF0, 0xB5, 0x85, 0xB0, 0x00,
+	0x20, 0x02, 0x90, 0x58, 0x48, 0x20, 0x30, 0xC1, 0x79, 0x83, 0x79, 0x0A, 0x02, 0x54, 0x49, 0x1A,
+	0x43, 0x0A, 0x81, 0x42, 0x79, 0x03, 0x79, 0x10, 0x02, 0x18, 0x43, 0x08, 0x61, 0xFF, 0xF7, 0xC4,
+	0xFF, 0xFF, 0xF7, 0x56, 0xFF, 0x09, 0x21, 0x5E, 0x48, 0x01, 0xF0, 0x4D, 0xFB, 0x00, 0x25, 0x68,
+	0x1C, 0xC4, 0xB2, 0x03, 0x90, 
+	0x00, 0x01, 0x88, 0x00, 0x80, 0x29, 0xE0, 0xEE, 0x08, 0xE7, 0x08, 0x6A, 0x07, 0x01, 0x21, 0x52,
+	0x0F, 0x08, 0x46, 0x90, 0x40, 0xC0, 0xB2, 0x01, 0x90, 0x60, 0x07, 0x40, 0x0F, 0x81, 0x40, 0xC8,
+	0xB2, 0x54, 0x4A, 0x00, 0x90, 0x91, 0x5D, 0x01, 0x98, 0x01, 0x42, 0x14, 0xD0, 0xD0, 0x5D, 0x00,
+	0x99, 0x08, 0x42, 0x10, 0xD0, 0x21, 0x46, 0x28, 0x46, 0xFF, 0xF7, 0xFA, 0xFE, 0x00, 0x28, 0x0A,
+	0xD0, 0x4B, 0x48, 0x01, 0x9A, 0x81, 0x5D, 0x11, 0x43, 0x81, 0x55, 0xC1, 0x5D, 0x00, 0x9A, 0x11,
+	0x43, 0xC1, 0x55, 0x01, 0x20, 0x02, 0x90, 0x64, 0x1C, 0xE4, 0xB2, 0x41, 0x2C, 0xD3, 0xD3, 0x00,
+	0xF0, 0x71, 0xFA, 0x03, 0x98, 0xC5, 0xB2, 0x41, 0x2D, 0xC9, 0xD3, 0xFF, 0xF7, 0xB8, 0xFE, 0x02,
+	0x98, 0x05, 0xB0, 0xF0, 0xBD, 0xF8, 0xB5, 0x2F, 0x48, 0x00, 0x27, 0x20, 0x30, 0x41, 0x7A, 0x03,
+	0x7A, 0x0A, 0x02, 0x2B, 0x49, 
+	0x00, 0x01, 0x89, 0x00, 0x80, 0x1A, 0x43, 0x0A, 0x81, 0x42, 0x79, 0x03, 0x79, 0x10, 0x02, 0x18,
+	0x43, 0x08, 0x61, 0xFF, 0xF7, 0x71, 0xFF, 0xFF, 0xF7, 0x03, 0xFF, 0x09, 0x21, 0x34, 0x48, 0x01,
+	0xF0, 0xFA, 0xFA, 0x00, 0x24, 0xE5, 0x08, 0x61, 0x07, 0x49, 0x0F, 0x01, 0x20, 0x88, 0x40, 0xC6,
+	0xB2, 0x30, 0x48, 0x40, 0x5D, 0x30, 0x42, 0x0A, 0xD0, 0xFF, 0x21, 0x20, 0x46, 0xFF, 0xF7, 0xB8,
+	0xFE, 0x00, 0x28, 0x04, 0xD0, 0x2A, 0x48, 0x41, 0x5D, 0x31, 0x43, 0x41, 0x55, 0x01, 0x27, 0x64,
+	0x1C, 0xE4, 0xB2, 0x41, 0x2C, 0xE6, 0xD3, 0xFF, 0xF7, 0x82, 0xFE, 0x38, 0x46, 0xF8, 0xBD, 0xF8,
+	0xB5, 0x09, 0x21, 0x24, 0x48, 0x01, 0xF0, 0xD7, 0xFA, 0x00, 0x20, 0x22, 0x4D, 0x22, 0x4F, 0x23,
+	0x4E, 0x0A, 0xE0, 0x3A, 0x5C, 0xD1, 0x08, 0x54, 0x07, 0x64, 0x0F, 0x6B, 0x5C, 0x01, 0x22, 0xA2,
+	0x40, 0x13, 0x43, 0x40, 0x1C, 
+	0x00, 0x01, 0x8A, 0x00, 0x80, 0x6B, 0x54, 0xC0, 0xB2, 0x71, 0x6A, 0x81, 0x42, 0xF1, 0xD8, 0x19,
+	0x48, 0xFF, 0xF7, 0xB0, 0xFF, 0x16, 0x49, 0x04, 0x46, 0x09, 0x22, 0x88, 0x18, 0x01, 0xF0, 0x5E,
+	0xFA, 0x14, 0x48, 0xFF, 0xF7, 0x52, 0xFF, 0x04, 0x43, 0x11, 0x49, 0x09, 0x22, 0x08, 0x46, 0x27,
+	0xE0, 0xB4, 0x02, 0x00, 0x20, 0x00, 0xE6, 0x00, 0x00, 0x00, 0x00, 0x11, 0x40, 0x00, 0x00, 0x01,
+	0x40, 0x00, 0x00, 0x03, 0x40, 0x00, 0x04, 0x11, 0x40, 0xFC, 0xDF, 0x00, 0x00, 0xFF, 0x01, 0x3A,
+	0xC0, 0x3A, 0xA0, 0x00, 0xF0, 0x40, 0x03, 0x00, 0x40, 0x01, 0x00, 0x03, 0xC0, 0x72, 0x40, 0x00,
+	0x80, 0x10, 0x0D, 0xCA, 0x98, 0x00, 0x02, 0x00, 0x80, 0x00, 0x03, 0x00, 0xC0, 0x51, 0x08, 0x00,
+	0x00, 0xB3, 0x19, 0x00, 0x20, 0xAA, 0x19, 0x00, 0x20, 0x00, 0xEB, 0x00, 0x00, 0xF0, 0xE9, 0x00,
+	0x00, 0x12, 0x30, 0x01, 0xF0, 
+	0x00, 0x01, 0x8B, 0x00, 0x80, 0x2B, 0xFA, 0x09, 0x22, 0x71, 0x49, 0x72, 0x48, 0x01, 0xF0, 0x26,
+	0xFA, 0x20, 0x46, 0xF8, 0xBD, 0x10, 0xB5, 0x70, 0x48, 0x70, 0x4B, 0x02, 0x88, 0x18, 0x46, 0xD9,
+	0x1D, 0x94, 0x05, 0x80, 0x30, 0xF9, 0x31, 0x00, 0x2C, 0x10, 0xDB, 0xC4, 0x1D, 0xF9, 0x34, 0x64,
+	0x69, 0x00, 0x2C, 0x22, 0xD1, 0x5C, 0x68, 0xA4, 0x06, 0x1F, 0xD1, 0x9C, 0x6D, 0xA4, 0x06, 0x1C,
+	0xD1, 0xC4, 0x6A, 0xA4, 0x06, 0x19, 0xD1, 0x0C, 0x68, 0xA4, 0x06, 0x16, 0xD1, 0xD2, 0x05, 0x16,
+	0xD4, 0xDA, 0x68, 0xF0, 0x24, 0x22, 0x40, 0x40, 0x2A, 0x0F, 0xD8, 0x1A, 0x6E, 0x22, 0x40, 0x40,
+	0x2A, 0x0B, 0xD8, 0x40, 0x6B, 0x20, 0x40, 0x40, 0x28, 0x07, 0xD8, 0x88, 0x68, 0x20, 0x40, 0x40,
+	0x28, 0x03, 0xD8, 0xF4, 0xF7, 0xB7, 0xFF, 0x04, 0x28, 0x01, 0xD9, 0x01, 0x20, 0x10, 0xBD, 0x00,
+	0x20, 0x10, 0xBD, 0x10, 0xB5, 
+	0x00, 0x01, 0x8C, 0x00, 0x80, 0x56, 0x49, 0x57, 0x48, 0x01, 0xF0, 0x4A, 0xF9, 0x56, 0x49, 0x09,
+	0x88, 0x88, 0x42, 0x01, 0xD0, 0x01, 0x20, 0x10, 0xBD, 0x00, 0x20, 0x10, 0xBD, 0x10, 0xB5, 0x53,
+	0x48, 0x00, 0x24, 0x01, 0x68, 0xEF, 0x22, 0x11, 0x40, 0x01, 0x29, 0x00, 0xD1, 0x01, 0x24, 0xFF,
+	0x21, 0x01, 0x60, 0x01, 0xF0, 0x53, 0xF9, 0xFF, 0xF7, 0xE4, 0xFF, 0x00, 0x28, 0x11, 0xD1, 0x02,
+	0x20, 0x04, 0x43, 0xFF, 0xF7, 0xA7, 0xFF, 0x00, 0x28, 0x0B, 0xD1, 0x01, 0x20, 0x40, 0x02, 0x04,
+	0x43, 0xFF, 0xF7, 0x45, 0xFF, 0x00, 0x28, 0x04, 0xD1, 0xFF, 0x21, 0x20, 0x46, 0x05, 0x31, 0x08,
+	0x43, 0x10, 0xBD, 0x20, 0x46, 0x10, 0xBD, 0xFF, 0xB5, 0x00, 0x25, 0x81, 0xB0, 0x16, 0x46, 0x1F,
+	0x46, 0x2C, 0x46, 0x02, 0x98, 0xF6, 0xF7, 0x24, 0xFE, 0x16, 0x21, 0x48, 0x43, 0x3C, 0x49, 0x09,
+	0x5A, 0x01, 0x20, 0xA0, 0x40, 
+	0x00, 0x01, 0x8D, 0x00, 0x80, 0x01, 0x42, 0x0A, 0xD0, 0x21, 0x46, 0x02, 0x98, 0xFB, 0xF7, 0x00,
+	0xFB, 0xC0, 0xB2, 0x86, 0x42, 0x01, 0xD3, 0x87, 0x42, 0x01, 0xD9, 0x6D, 0x1C, 0xAD, 0xB2, 0x64,
+	0x1C, 0x08, 0x2C, 0xE6, 0xD3, 0x28, 0x46, 0xE3, 0xE6, 0xF8, 0xB5, 0x0D, 0x46, 0x00, 0x26, 0xFD,
+	0xF7, 0x93, 0xFC, 0x01, 0x21, 0x49, 0x02, 0x00, 0x90, 0x01, 0xF0, 0xED, 0xF9, 0x2E, 0x49, 0x28,
+	0x4C, 0x2C, 0x48, 0x20, 0x34, 0x08, 0x60, 0xE1, 0x7B, 0xA0, 0x7B, 0x2B, 0x46, 0x00, 0x9A, 0xFB,
+	0xF7, 0x91, 0xFF, 0x00, 0x25, 0x29, 0x4F, 0x08, 0xE0, 0xA3, 0x7A, 0xE2, 0x7A, 0x29, 0x46, 0x00,
+	0x98, 0xFF, 0xF7, 0xC1, 0xFF, 0x80, 0x19, 0x86, 0xB2, 0x6D, 0x1C, 0x38, 0x6B, 0xA8, 0x42, 0xF3,
+	0xD8, 0x38, 0x6B, 0xF9, 0x6B, 0x41, 0x18, 0x21, 0x48, 0x40, 0x30, 0x00, 0x68, 0x23, 0x7B, 0x09,
+	0x18, 0x62, 0x7B, 0x00, 0x98, 
+	0x00, 0x01, 0x8E, 0x00, 0x80, 0xFF, 0xF7, 0xAF, 0xFF, 0x80, 0x19, 0xC0, 0xB2, 0xF8, 0xBD, 0x70,
+	0xB5, 0x04, 0x46, 0x13, 0x49, 0x13, 0x48, 0x01, 0xF0, 0xC3, 0xF8, 0x01, 0x46, 0x05, 0x20, 0xFD,
+	0xF7, 0xFF, 0xFD, 0x11, 0x48, 0x01, 0x88, 0x07, 0x20, 0xFD, 0xF7, 0xFA, 0xFD, 0x14, 0x4D, 0xA8,
+	0x78, 0x00, 0x28, 0x09, 0xD0, 0x20, 0x46, 0xFF, 0xF7, 0x9D, 0xFE, 0x20, 0x46, 0xFF, 0xF7, 0x45,
+	0xFE, 0x00, 0x21, 0x20, 0x46, 0xFF, 0xF7, 0xB0, 0xFF, 0xA8, 0x88, 0xC0, 0xB2, 0x70, 0xBD, 0x00,
+	0x00, 0xAA, 0x19, 0x00, 0x20, 0xB3, 0x19, 0x00, 0x20, 0x1A, 0x03, 0x00, 0x20, 0xB0, 0xE8, 0x00,
+	0x00, 0x00, 0xE6, 0x00, 0x00, 0xFC, 0x07, 0x00, 0x00, 0xFC, 0xED, 0x00, 0x00, 0x00, 0x00, 0x02,
+	0x40, 0x00, 0xEC, 0x00, 0x00, 0xC6, 0x0E, 0x00, 0x20, 0xD0, 0x01, 0x00, 0x20, 0xF0, 0xE9, 0x00,
+	0x00, 0xB4, 0x02, 0x00, 0x20, 
+	0x00, 0x01, 0x8F, 0x00, 0x80, 0x70, 0xB5, 0xDF, 0x4C, 0x25, 0x69, 0x61, 0x69, 0x40, 0x1B, 0x00,
+	0x02, 0x0E, 0x46, 0x01, 0xF0, 0x94, 0xF9, 0xFF, 0x28, 0x09, 0xD9, 0x01, 0x0A, 0x0A, 0x46, 0x72,
+	0x43, 0x52, 0x19, 0x22, 0x61, 0xE2, 0x68, 0x09, 0x02, 0x52, 0x18, 0x40, 0x1A, 0xE2, 0x60, 0xE1,
+	0x68, 0x08, 0x18, 0x70, 0xBD, 0xD4, 0x48, 0x40, 0x68, 0xE4, 0xE7, 0xF8, 0xB5, 0xD3, 0x4C, 0x21,
+	0x88, 0xD0, 0x4D, 0x28, 0x88, 0x06, 0x46, 0x01, 0xF0, 0x7A, 0xF9, 0x21, 0x88, 0x41, 0x43, 0xB1,
+	0x42, 0x00, 0xD2, 0x40, 0x1C, 0x03, 0x28, 0x00, 0xD2, 0x03, 0x20, 0x21, 0x88, 0x6A, 0x69, 0x51,
+	0x43, 0x09, 0x0A, 0xCB, 0x4A, 0x49, 0x1E, 0x91, 0x42, 0x00, 0xD9, 0x11, 0x46, 0x06, 0x04, 0x0E,
+	0x43, 0xF9, 0xF7, 0x9C, 0xFC, 0xC7, 0x4B, 0x05, 0x46, 0x19, 0x68, 0x03, 0x27, 0xBF, 0x03, 0x01,
+	0x20, 0xB9, 0x43, 0x80, 0x03, 
+	0x00, 0x01, 0x90, 0x00, 0x80, 0x08, 0x43, 0x18, 0x60, 0x01, 0x20, 0xC0, 0x03, 0x08, 0x43, 0x18,
+	0x60, 0xBD, 0x4C, 0x20, 0x69, 0xFF, 0x22, 0x02, 0x32, 0x90, 0x43, 0xBF, 0x4A, 0x10, 0x43, 0x20,
+	0x61, 0xBE, 0x48, 0x22, 0x69, 0x02, 0x42, 0xFC, 0xD1, 0xBD, 0x4A, 0x04, 0x20, 0x10, 0x60, 0xA6,
+	0x60, 0xBC, 0x48, 0xE0, 0x60, 0xBC, 0x48, 0x20, 0x61, 0x46, 0x00, 0x20, 0x69, 0x32, 0x46, 0x82,
+	0x43, 0xFB, 0xD1, 0x39, 0x43, 0x19, 0x60, 0xB9, 0x49, 0x02, 0x20, 0xF9, 0xF7, 0x7E, 0xFC, 0x03,
+	0x21, 0x02, 0x20, 0xF9, 0xF7, 0x81, 0xFC, 0x02, 0x20, 0xF9, 0xF7, 0x88, 0xFC, 0xB4, 0x49, 0x20,
+	0x69, 0x08, 0x42, 0xFC, 0xD1, 0xB3, 0x49, 0x00, 0x20, 0x08, 0x70, 0xE8, 0xB2, 0xF9, 0xF7, 0x62,
+	0xFC, 0xF8, 0xBD, 0xA6, 0x49, 0x00, 0x28, 0x01, 0xD1, 0x01, 0x20, 0x05, 0xE0, 0x4B, 0x22, 0x12,
+	0x01, 0x90, 0x42, 0x01, 0xD9, 
+	0x00, 0x01, 0x91, 0x00, 0x80, 0x0A, 0x80, 0x00, 0xE0, 0x08, 0x80, 0x96, 0xE7, 0xA0, 0x49, 0x9D,
+	0x4A, 0x88, 0x42, 0x01, 0xD9, 0x11, 0x80, 0x00, 0xE0, 0x10, 0x80, 0x8E, 0xE7, 0x10, 0xB5, 0x04,
+	0x46, 0x40, 0x00, 0x20, 0x18, 0xC8, 0x28, 0x00, 0xD2, 0xC8, 0x20, 0xFF, 0xF7, 0xEF, 0xFF, 0x95,
+	0x49, 0x20, 0x46, 0x8C, 0x61, 0xFF, 0xF7, 0xDD, 0xFF, 0x10, 0xBD, 0x1C, 0xB5, 0x68, 0x46, 0x01,
+	0xF0, 0x33, 0xF8, 0x00, 0x28, 0xFA, 0xD1, 0x6B, 0x46, 0x19, 0x79, 0x01, 0x20, 0x80, 0x07, 0x21,
+	0x29, 0x02, 0xD3, 0x99, 0x49, 0x49, 0x8A, 0xC1, 0x60, 0x01, 0x68, 0x49, 0x00, 0x49, 0x08, 0x01,
+	0x60, 0x96, 0x48, 0x01, 0x69, 0x04, 0x22, 0x11, 0x43, 0x01, 0x61, 0x1C, 0xBD, 0x10, 0xB5, 0xFD,
+	0xF7, 0x30, 0xFD, 0xFD, 0xF7, 0x69, 0xFB, 0xFF, 0xF7, 0xE0, 0xFF, 0x72, 0xB6, 0x90, 0x48, 0x81,
+	0x68, 0x89, 0x07, 0xFC, 0xD5, 
+	0x00, 0x01, 0x92, 0x00, 0x80, 0x62, 0xB6, 0x72, 0xB6, 0x8A, 0x4C, 0x20, 0x78, 0x00, 0x28, 0x0B,
+	0xD1, 0x06, 0xE0, 0xBF, 0xF3, 0x50, 0x8F, 0xBF, 0xF3, 0x60, 0x8F, 0x30, 0xBF, 0x62, 0xB6, 0x72,
+	0xB6, 0x20, 0x78, 0x00, 0x28, 0xF5, 0xD0, 0x01, 0xE0, 0xFF, 0xF7, 0x47, 0xFF, 0x00, 0x20, 0x20,
+	0x70, 0x75, 0x48, 0x40, 0x68, 0x73, 0x49, 0x48, 0x60, 0x62, 0xB6, 0xFD, 0xF7, 0x49, 0xFB, 0xFD,
+	0xF7, 0x1C, 0xFD, 0x10, 0xBD, 0x70, 0xB5, 0xF9, 0xF7, 0xF1, 0xFB, 0x72, 0x4A, 0x11, 0x68, 0x03,
+	0x23, 0x9B, 0x03, 0x01, 0x24, 0x99, 0x43, 0xA4, 0x03, 0x0C, 0x43, 0x14, 0x60, 0x01, 0x24, 0xE4,
+	0x03, 0x0C, 0x43, 0x14, 0x60, 0x68, 0x4D, 0x77, 0x4C, 0x2C, 0x61, 0x19, 0x43, 0x11, 0x60, 0xF9,
+	0xF7, 0xE1, 0xFB, 0x70, 0xBD, 0x10, 0xB5, 0x72, 0xB6, 0x7D, 0x20, 0xC0, 0x00, 0xFF, 0xF7, 0x79,
+	0xFF, 0x00, 0xF0, 0xB2, 0xF8, 
+	0x00, 0x01, 0x93, 0x00, 0x80, 0x63, 0x4C, 0x06, 0x20, 0x60, 0x60, 0x00, 0xF0, 0xA6, 0xF8, 0x6E,
+	0x48, 0x40, 0x7F, 0x40, 0x06, 0x80, 0x0F, 0x01, 0xD1, 0x02, 0x20, 0x04, 0xE0, 0x01, 0x28, 0x01,
+	0xD1, 0x03, 0x20, 0x00, 0xE0, 0x01, 0x20, 0xFD, 0xF7, 0x00, 0xFD, 0xFF, 0xF7, 0x86, 0xFF, 0xBF,
+	0xF3, 0x50, 0x8F, 0xBF, 0xF3, 0x60, 0x8F, 0x30, 0xBF, 0xFD, 0xF7, 0x38, 0xFD, 0x00, 0xF0, 0x94,
+	0xF8, 0x62, 0x48, 0x60, 0x60, 0x00, 0xF0, 0x89, 0xF8, 0xFF, 0xF7, 0xBC, 0xFF, 0x62, 0xB6, 0x10,
+	0xBD, 0x70, 0xB5, 0xF9, 0xF7, 0xAB, 0xFB, 0x4F, 0x4C, 0x21, 0x68, 0x03, 0x25, 0xAD, 0x03, 0x01,
+	0x22, 0xA9, 0x43, 0x92, 0x03, 0x0A, 0x43, 0x22, 0x60, 0x01, 0x22, 0xD2, 0x03, 0x0A, 0x43, 0x22,
+	0x60, 0x56, 0x4A, 0x62, 0x60, 0x44, 0x4A, 0xD3, 0x68, 0x55, 0x4E, 0x33, 0x40, 0xD3, 0x60, 0x13,
+	0x69, 0x05, 0x26, 0x36, 0x04, 
+	0x00, 0x01, 0x94, 0x00, 0x80, 0x33, 0x43, 0x13, 0x61, 0x13, 0x69, 0x9B, 0x03, 0xFC, 0xD5, 0x29,
+	0x43, 0x21, 0x60, 0x3C, 0x4C, 0x00, 0x21, 0xA1, 0x60, 0xE1, 0x60, 0x51, 0x68, 0xC0, 0xB2, 0x21,
+	0x61, 0xF9, 0xF7, 0x88, 0xFB, 0x01, 0x20, 0x40, 0x03, 0x60, 0x61, 0x70, 0xBD, 0x70, 0xB5, 0x4A,
+	0x4B, 0x48, 0x48, 0x58, 0x61, 0x05, 0x20, 0x18, 0x61, 0x72, 0xB6, 0x33, 0x48, 0x41, 0x68, 0x42,
+	0x68, 0x8A, 0x42, 0xFC, 0xD0, 0x00, 0x21, 0x99, 0x61, 0x44, 0x68, 0x41, 0x68, 0xA1, 0x42, 0xFC,
+	0xD0, 0x98, 0x69, 0x40, 0x49, 0x89, 0x1C, 0x0D, 0x1A, 0x04, 0x20, 0x18, 0x61, 0x62, 0xB6, 0x20,
+	0x46, 0xFF, 0xF7, 0x90, 0xFE, 0x27, 0x4E, 0x00, 0x2D, 0xF0, 0x60, 0x34, 0x61, 0xB0, 0x60, 0x0D,
+	0xD0, 0x3A, 0x48, 0x7D, 0x21, 0x00, 0x78, 0xC9, 0x02, 0x48, 0x43, 0x29, 0x46, 0x01, 0xF0, 0x1F,
+	0xF8, 0x70, 0x61, 0x00, 0x28, 
+	0x00, 0x01, 0x95, 0x00, 0x80, 0x01, 0xD1, 0x01, 0x20, 0x70, 0x61, 0x70, 0xBD, 0x01, 0x20, 0x40,
+	0x03, 0xFA, 0xE7, 0x10, 0xB5, 0x04, 0x46, 0xFF, 0xF7, 0x8D, 0xFE, 0x1A, 0x49, 0x89, 0x68, 0x40,
+	0x1A, 0xA0, 0x42, 0x03, 0xD3, 0xFF, 0xF7, 0xC2, 0xFF, 0x01, 0x20, 0x10, 0xBD, 0x00, 0x20, 0x10,
+	0xBD, 0x00, 0x28, 0x11, 0xD0, 0x2A, 0x49, 0x88, 0x42, 0x00, 0xD9, 0x08, 0x46, 0x27, 0x49, 0x09,
+	0x78, 0x48, 0x43, 0x25, 0x49, 0x48, 0x61, 0x05, 0x20, 0x08, 0x61, 0x00, 0x20, 0x88, 0x61, 0x08,
+	0x69, 0xC0, 0x03, 0xFC, 0xD5, 0x04, 0x20, 0x08, 0x61, 0x70, 0x47, 0x0E, 0x49, 0x08, 0x68, 0x03,
+	0x22, 0x92, 0x03, 0x10, 0x43, 0x08, 0x60, 0x70, 0x47, 0x0A, 0x49, 0x08, 0x68, 0x03, 0x22, 0x92,
+	0x03, 0x90, 0x43, 0x01, 0x22, 0x92, 0x03, 0x02, 0x43, 0x0A, 0x60, 0x01, 0x22, 0xD2, 0x03, 0x10,
+	0x43, 0x08, 0x60, 0x70, 0x47, 
+	0x00, 0x01, 0x96, 0x00, 0x80, 0xD0, 0x02, 0x00, 0x20, 0x00, 0x04, 0x01, 0x40, 0x38, 0x02, 0x00,
+	0x20, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x01, 0x40, 0x0C, 0x0C, 0x04, 0x00, 0x0A, 0x0A, 0x00,
+	0x00, 0x80, 0xE2, 0x00, 0xE0, 0x0D, 0x02, 0x00, 0x00, 0x01, 0x01, 0x01, 0x00, 0xBB, 0xA4, 0x00,
+	0x00, 0x08, 0x08, 0x08, 0x00, 0x3A, 0x02, 0x00, 0x20, 0x40, 0xF1, 0xFF, 0x0F, 0x00, 0xED, 0x00,
+	0xE0, 0x00, 0x00, 0x12, 0x40, 0x01, 0x09, 0x01, 0x00, 0x00, 0xE6, 0x00, 0x00, 0x06, 0x00, 0x00,
+	0x80, 0xFF, 0xF7, 0xFE, 0x20, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0xE0, 0x00, 0xE0, 0xEC, 0x02, 0x00,
+	0x20, 0x50, 0xC3, 0x00, 0x00, 0x10, 0xB5, 0x3A, 0x4B, 0x02, 0x24, 0x18, 0x78, 0x59, 0x68, 0xC0,
+	0x1E, 0xC0, 0xB2, 0x0A, 0x5C, 0x1C, 0x5F, 0x52, 0x42, 0xA2, 0x42, 0x00, 0xDD, 0x5A, 0x80, 0x09,
+	0x5C, 0xFF, 0x20, 0x40, 0x1A, 
+	0x00, 0x01, 0x97, 0x00, 0x80, 0x02, 0x21, 0x59, 0x5E, 0x88, 0x42, 0x00, 0xDA, 0x58, 0x80, 0x10,
+	0xBD, 0x30, 0x48, 0xC1, 0x7A, 0x24, 0x29, 0x01, 0xD2, 0x24, 0x20, 0x70, 0x47, 0xC1, 0x7A, 0x30,
+	0x29, 0x01, 0xD9, 0x30, 0x20, 0x70, 0x47, 0xC0, 0x7A, 0x70, 0x47, 0xF0, 0xB5, 0x2A, 0x4F, 0x00,
+	0x21, 0x3A, 0x7B, 0x7B, 0x7B, 0x8C, 0x46, 0x0E, 0x46, 0x14, 0x46, 0x1D, 0x46, 0x04, 0x21, 0x20,
+	0x2A, 0x00, 0xD0, 0x01, 0x26, 0x20, 0x2B, 0x01, 0xD0, 0x01, 0x22, 0x94, 0x46, 0x49, 0x1E, 0x0B,
+	0xD4, 0x4A, 0x00, 0x21, 0x4B, 0x8A, 0x18, 0xD7, 0x18, 0x7A, 0x78, 0xBB, 0x78, 0x3F, 0x78, 0x87,
+	0x42, 0xED, 0xD3, 0x14, 0x46, 0x1D, 0x46, 0xEA, 0xE7, 0x1C, 0x48, 0x00, 0x2E, 0x00, 0xD0, 0xC4,
+	0x61, 0x61, 0x46, 0x00, 0x29, 0x00, 0xD0, 0x05, 0x62, 0xF0, 0xBD, 0xF8, 0xB5, 0x04, 0x46, 0xC0,
+	0x1E, 0xC5, 0xB2, 0x20, 0x46, 
+	0x00, 0x01, 0x98, 0x00, 0x80, 0x18, 0x38, 0xC6, 0xB2, 0x15, 0x48, 0x11, 0x4F, 0x24, 0x2C, 0x0B,
+	0xD2, 0x14, 0x49, 0x89, 0x5D, 0x06, 0x46, 0x81, 0x60, 0x05, 0x20, 0xF9, 0xF7, 0x7F, 0xFA, 0x78,
+	0x68, 0x40, 0x5D, 0x70, 0x60, 0xF0, 0x20, 0x0A, 0xE0, 0x79, 0x68, 0x49, 0x5D, 0x05, 0x46, 0x41,
+	0x60, 0xF0, 0x20, 0xF9, 0xF7, 0x73, 0xFA, 0x0B, 0x48, 0x80, 0x5D, 0xA8, 0x60, 0x05, 0x20, 0xF9,
+	0xF7, 0x6D, 0xFA, 0x09, 0x49, 0x20, 0x46, 0x48, 0x43, 0xF9, 0xF7, 0xAC, 0xFA, 0xF8, 0xBD, 0x00,
+	0x00, 0xEC, 0x02, 0x00, 0x20, 0x00, 0xE6, 0x00, 0x00, 0xC0, 0xF1, 0xFF, 0x0F, 0x00, 0xFF, 0x00,
+	0x40, 0x00, 0xFF, 0x01, 0x40, 0x5C, 0xE0, 0x00, 0x00, 0x40, 0x42, 0x0F, 0x00, 0xF0, 0xB5, 0x01,
+	0x09, 0x00, 0x07, 0x00, 0x0F, 0x85, 0xB0, 0x00, 0x90, 0x01, 0x29, 0x01, 0xD8, 0x07, 0x28, 0x02,
+	0xD9, 0x00, 0x20, 0x05, 0xB0, 
+	0x00, 0x01, 0x99, 0x00, 0x80, 0xF0, 0xBD, 0x88, 0x00, 0x8A, 0x49, 0x0C, 0x58, 0xA0, 0x07, 0x03,
+	0x90, 0x0F, 0xD0, 0xE0, 0x07, 0x08, 0xD0, 0x25, 0x7A, 0x60, 0x7A, 0x00, 0x02, 0x05, 0x43, 0xA0,
+	0x7A, 0xE1, 0x7A, 0x09, 0x02, 0x08, 0x43, 0x01, 0xE0, 0x25, 0x89, 0x60, 0x89, 0x00, 0x04, 0x05,
+	0x43, 0x00, 0xE0, 0xA5, 0x68, 0x00, 0x98, 0x03, 0x9B, 0x41, 0x00, 0x42, 0x18, 0x07, 0x20, 0x90,
+	0x40, 0x29, 0x46, 0x81, 0x43, 0x02, 0x20, 0x90, 0x40, 0x00, 0x2B, 0x34, 0xD0, 0xE2, 0x07, 0x10,
+	0xD0, 0x08, 0x43, 0x20, 0x72, 0x01, 0x0A, 0x61, 0x72, 0x01, 0x0C, 0xA1, 0x72, 0x00, 0x0E, 0xE0,
+	0x72, 0x26, 0x7E, 0x60, 0x7E, 0x00, 0x02, 0x06, 0x43, 0xA0, 0x7E, 0xE1, 0x7E, 0x09, 0x02, 0x08,
+	0x43, 0x05, 0xE0, 0x08, 0x43, 0x20, 0x81, 0x00, 0x0C, 0x60, 0x81, 0x26, 0x8B, 0x60, 0x8B, 0x00,
+	0x04, 0x06, 0x43, 0x00, 0x98, 
+	0x00, 0x01, 0x9A, 0x00, 0x80, 0x01, 0x21, 0x81, 0x40, 0x30, 0x46, 0x03, 0x9A, 0x88, 0x43, 0x00,
+	0x2A, 0x37, 0xD0, 0xE2, 0x07, 0x13, 0xD0, 0x20, 0x76, 0x02, 0x0A, 0x62, 0x76, 0x02, 0x0C, 0xA2,
+	0x76, 0x00, 0x0E, 0xE0, 0x76, 0x27, 0x7D, 0x60, 0x7D, 0x00, 0x02, 0x07, 0x43, 0xA0, 0x7D, 0xE2,
+	0x7D, 0x12, 0x02, 0x10, 0x43, 0x08, 0xE0, 0x08, 0x43, 0xA0, 0x60, 0xA6, 0x69, 0xE1, 0xE7, 0x20,
+	0x83, 0x00, 0x0C, 0x60, 0x83, 0xA7, 0x8A, 0xE0, 0x8A, 0x00, 0x04, 0x07, 0x43, 0x00, 0x98, 0x0F,
+	0x22, 0x80, 0x00, 0x82, 0x40, 0x38, 0x46, 0x90, 0x43, 0x03, 0x9A, 0x00, 0x2A, 0x2B, 0xD0, 0xE2,
+	0x07, 0x12, 0xD0, 0x20, 0x75, 0x02, 0x0A, 0x62, 0x75, 0x02, 0x0C, 0xA2, 0x75, 0x00, 0x0E, 0xE0,
+	0x75, 0x20, 0x78, 0x62, 0x78, 0x12, 0x02, 0x10, 0x43, 0xA2, 0x78, 0xE3, 0x78, 0x1B, 0x02, 0x1A,
+	0x43, 0x07, 0xE0, 0xA0, 0x61, 
+	0x00, 0x01, 0x9B, 0x00, 0x80, 0x67, 0x69, 0xE1, 0xE7, 0xA0, 0x82, 0x00, 0x0C, 0xE0, 0x82, 0x20,
+	0x88, 0x62, 0x88, 0x12, 0x04, 0x10, 0x43, 0x01, 0x90, 0x01, 0x22, 0x88, 0x43, 0xA3, 0x07, 0x12,
+	0xD0, 0xE3, 0x07, 0x0B, 0xD0, 0x01, 0x43, 0x21, 0x70, 0x08, 0x0A, 0x60, 0x70, 0x08, 0x0C, 0xA0,
+	0x70, 0x08, 0x0E, 0xE0, 0x70, 0x09, 0xE0, 0x60, 0x61, 0x20, 0x68, 0xEC, 0xE7, 0x01, 0x43, 0x21,
+	0x80, 0x08, 0x0C, 0x60, 0x80, 0x01, 0xE0, 0x01, 0x43, 0x21, 0x60, 0x3B, 0x49, 0x08, 0x68, 0x02,
+	0x90, 0x80, 0x08, 0x80, 0x00, 0x10, 0x43, 0x08, 0x60, 0xC8, 0x20, 0xFF, 0xF7, 0x69, 0xFE, 0x03,
+	0x98, 0x00, 0x28, 0x0F, 0xD0, 0xE0, 0x07, 0x08, 0xD0, 0x20, 0x79, 0x61, 0x79, 0x09, 0x02, 0x08,
+	0x43, 0xA1, 0x79, 0xE2, 0x79, 0x12, 0x02, 0x11, 0x43, 0x01, 0xE0, 0xA0, 0x88, 0xE1, 0x88, 0x09,
+	0x04, 0x08, 0x43, 0x00, 0xE0, 
+	0x00, 0x01, 0x9C, 0x00, 0x80, 0x60, 0x68, 0x03, 0x99, 0x00, 0x29, 0x31, 0xD0, 0xE1, 0x07, 0x20,
+	0xD0, 0x25, 0x72, 0x29, 0x0A, 0x61, 0x72, 0x29, 0x0C, 0xA1, 0x72, 0x29, 0x0E, 0xE1, 0x72, 0x26,
+	0x76, 0x31, 0x0A, 0x61, 0x76, 0x31, 0x0C, 0xA1, 0x76, 0x31, 0x0E, 0xE1, 0x76, 0x27, 0x75, 0x39,
+	0x0A, 0x61, 0x75, 0x39, 0x0C, 0xA1, 0x75, 0x39, 0x0E, 0xE1, 0x75, 0x01, 0x99, 0x21, 0x70, 0x01,
+	0x99, 0x09, 0x0A, 0x61, 0x70, 0x01, 0x99, 0x09, 0x0C, 0xA1, 0x70, 0x01, 0x99, 0x09, 0x0E, 0xE1,
+	0x70, 0x13, 0xE0, 0x25, 0x81, 0x29, 0x0C, 0x61, 0x81, 0x26, 0x83, 0x31, 0x0C, 0x61, 0x83, 0xA7,
+	0x82, 0x39, 0x0C, 0xE1, 0x82, 0x01, 0x99, 0x21, 0x80, 0x01, 0x99, 0x09, 0x0C, 0x61, 0x80, 0x04,
+	0xE0, 0xA5, 0x60, 0xA6, 0x61, 0x67, 0x61, 0x01, 0x99, 0x21, 0x60, 0x0F, 0x4A, 0x02, 0x99, 0x11,
+	0x60, 0x00, 0x99, 0xC8, 0x40, 
+	0x00, 0x01, 0x9D, 0x00, 0x80, 0xC0, 0x07, 0xC0, 0x0F, 0xFB, 0xE6, 0x70, 0xB5, 0x0B, 0x4C, 0x60,
+	0x7D, 0xFF, 0xF7, 0xEC, 0xFE, 0xC5, 0x07, 0xED, 0x0F, 0xA0, 0x7D, 0xFF, 0xF7, 0xE7, 0xFE, 0xC0,
+	0x07, 0x86, 0x0F, 0x2E, 0x43, 0xE0, 0x7D, 0xFF, 0xF7, 0xE1, 0xFE, 0xC0, 0x07, 0x40, 0x0F, 0x30,
+	0x43, 0x70, 0xBD, 0x00, 0x00, 0x78, 0xE0, 0x00, 0x00, 0x00, 0x20, 0x14, 0x40, 0x20, 0xE6, 0x00,
+	0x00, 0xAC, 0x49, 0x00, 0x20, 0x08, 0x70, 0x70, 0x47, 0xAA, 0x49, 0x00, 0x28, 0x01, 0xD1, 0xAA,
+	0x48, 0x03, 0xE0, 0x01, 0x28, 0x02, 0xD1, 0xA8, 0x48, 0x08, 0x30, 0x48, 0x60, 0x70, 0x47, 0xF0,
+	0xB5, 0xA4, 0x4B, 0x93, 0xB0, 0x58, 0x68, 0x12, 0x90, 0x01, 0x78, 0x00, 0x20, 0x05, 0x46, 0x09,
+	0x90, 0x12, 0x98, 0x0A, 0x91, 0xC0, 0x88, 0x04, 0x90, 0x12, 0x98, 0x80, 0x88, 0x03, 0x90, 0x12,
+	0x98, 0x82, 0x78, 0x20, 0x21, 
+	0x00, 0x01, 0x9E, 0x00, 0x80, 0x08, 0x46, 0xD0, 0x40, 0x02, 0x90, 0x12, 0x98, 0x40, 0x78, 0xC1,
+	0x40, 0x01, 0x91, 0x0A, 0x99, 0x20, 0x20, 0x00, 0x29, 0x7C, 0xD0, 0x98, 0x49, 0xCA, 0x68, 0x52,
+	0x01, 0x40, 0x3A, 0x08, 0x92, 0x0A, 0x69, 0x52, 0x01, 0x40, 0x3A, 0x07, 0x92, 0xCA, 0x68, 0x52,
+	0x01, 0x10, 0x3A, 0x06, 0x92, 0x09, 0x69, 0x49, 0x01, 0x10, 0x39, 0x05, 0x91, 0x90, 0x49, 0x09,
+	0x78, 0x11, 0x91, 0x19, 0x46, 0x09, 0x78, 0x0E, 0x91, 0x11, 0xE0, 0xE9, 0x00, 0x6A, 0x18, 0x8D,
+	0x49, 0x51, 0x18, 0x10, 0x91, 0xCB, 0x79, 0x09, 0x9A, 0x06, 0x21, 0x4A, 0x43, 0x8A, 0x49, 0x0F,
+	0x93, 0x51, 0x18, 0x4C, 0x79, 0xA3, 0x42, 0x0A, 0xD0, 0x09, 0x99, 0x49, 0x1C, 0x09, 0x91, 0x09,
+	0x9A, 0x0E, 0x99, 0x8A, 0x42, 0x02, 0xD2, 0x11, 0x99, 0x8D, 0x42, 0xE6, 0xD3, 0xF3, 0xE0, 0x10,
+	0x9B, 0x5C, 0x79, 0x1E, 0x79, 
+	0x00, 0x01, 0x9F, 0x00, 0x80, 0x23, 0x02, 0x33, 0x43, 0x0D, 0x93, 0x10, 0x9B, 0xDC, 0x78, 0x9B,
+	0x78, 0x27, 0x02, 0x1F, 0x43, 0x10, 0x9B, 0x1C, 0x7A, 0x0D, 0x9B, 0x00, 0x2B, 0x0C, 0xD0, 0x77,
+	0x4B, 0xDB, 0x68, 0x0D, 0x9E, 0x5B, 0x1E, 0xB3, 0x42, 0x06, 0xD0, 0x00, 0x2F, 0x04, 0xD0, 0x73,
+	0x4B, 0x1B, 0x69, 0x5B, 0x1E, 0xBB, 0x42, 0x03, 0xD1, 0x0A, 0x9B, 0x80, 0x26, 0xB3, 0x43, 0x01,
+	0xE0, 0x12, 0x9B, 0x1B, 0x78, 0x0A, 0x93, 0x70, 0x4B, 0x9E, 0x5A, 0x4B, 0x88, 0x0C, 0x93, 0x09,
+	0x79, 0x0B, 0x91, 0x59, 0x09, 0x0A, 0x9B, 0x72, 0x09, 0x1B, 0x06, 0x4B, 0xD5, 0x0D, 0x98, 0xC9,
+	0x1B, 0x10, 0x1A, 0x40, 0x43, 0x49, 0x43, 0x0A, 0x18, 0x00, 0x21, 0x01, 0x20, 0xC0, 0x03, 0x00,
+	0xE0, 0x40, 0x08, 0x90, 0x42, 0xFC, 0xD8, 0x06, 0xE0, 0x09, 0x18, 0x0B, 0x46, 0x4B, 0x43, 0x93,
+	0x42, 0x00, 0xD9, 0x09, 0x1A, 
+	0x00, 0x01, 0xA0, 0x00, 0x80, 0x40, 0x08, 0x00, 0x28, 0xF6, 0xD1, 0x03, 0x98, 0x81, 0x42, 0x02,
+	0xD8, 0x01, 0x98, 0x12, 0xE0, 0xAC, 0xE0, 0x04, 0x98, 0x81, 0x42, 0x01, 0xD9, 0x02, 0x98, 0x0C,
+	0xE0, 0x03, 0x98, 0x01, 0x9A, 0x08, 0x1A, 0x02, 0x99, 0x89, 0x1A, 0x48, 0x43, 0x03, 0x9A, 0x04,
+	0x99, 0x89, 0x1A, 0x00, 0xF0, 0x44, 0xFD, 0x01, 0x99, 0x40, 0x18, 0x4F, 0x49, 0x09, 0x1F, 0x09,
+	0x7D, 0x01, 0x29, 0x08, 0xD1, 0x51, 0x49, 0xC9, 0x6B, 0x01, 0x29, 0x04, 0xD1, 0x50, 0x49, 0x09,
+	0x88, 0x89, 0x06, 0x00, 0xD5, 0x80, 0x08, 0x31, 0x46, 0x41, 0x43, 0x49, 0x09, 0x72, 0x1A, 0x0D,
+	0x99, 0x0C, 0x9B, 0x41, 0x43, 0x51, 0x18, 0x0C, 0x9A, 0x47, 0x43, 0x42, 0x43, 0x52, 0x09, 0x9A,
+	0x1A, 0xD2, 0x19, 0x02, 0xE0, 0x0D, 0x99, 0x49, 0x01, 0x7A, 0x01, 0x0A, 0x9B, 0x9B, 0x06, 0x0B,
+	0xD5, 0x12, 0x9B, 0xDB, 0x78, 
+	0x00, 0x01, 0xA1, 0x00, 0x80, 0x01, 0x2B, 0x0B, 0x9B, 0x02, 0xD1, 0xE3, 0x18, 0x5C, 0x08, 0x03,
+	0xE0, 0x5F, 0x00, 0xDB, 0x19, 0x1B, 0x19, 0x9C, 0x08, 0x0A, 0x9B, 0x5B, 0x06, 0x23, 0xD5, 0xB1,
+	0x42, 0x06, 0xD9, 0x08, 0x9B, 0x99, 0x42, 0x03, 0xD8, 0x10, 0x29, 0x01, 0xD9, 0x09, 0x1A, 0x07,
+	0xE0, 0xB1, 0x42, 0x05, 0xD2, 0x40, 0x29, 0x03, 0xD3, 0x06, 0x9B, 0x99, 0x42, 0x00, 0xD2, 0x09,
+	0x18, 0x0C, 0x9B, 0x9A, 0x42, 0x06, 0xD9, 0x07, 0x9B, 0x9A, 0x42, 0x03, 0xD8, 0x10, 0x2A, 0x01,
+	0xD9, 0x12, 0x1A, 0x08, 0xE0, 0x0C, 0x9B, 0x9A, 0x42, 0x05, 0xD2, 0x40, 0x2A, 0x03, 0xD3, 0x05,
+	0x9B, 0x9A, 0x42, 0x00, 0xD2, 0x12, 0x18, 0x0A, 0x9B, 0xDB, 0x06, 0x07, 0xD5, 0x0B, 0x9B, 0x9C,
+	0x42, 0x01, 0xD9, 0x64, 0x1E, 0x02, 0xE0, 0x9C, 0x42, 0x00, 0xD2, 0x64, 0x1C, 0x06, 0x23, 0x2E,
+	0x46, 0x5E, 0x43, 0x21, 0x4B, 
+	0x00, 0x01, 0xA2, 0x00, 0x80, 0x0F, 0x9F, 0xF3, 0x18, 0x5F, 0x71, 0x1F, 0x4F, 0xB9, 0x53, 0xC9,
+	0x02, 0x10, 0x9E, 0x09, 0x0C, 0x31, 0x71, 0x09, 0x0A, 0x71, 0x71, 0x5A, 0x80, 0xD1, 0x02, 0x10,
+	0x9A, 0x09, 0x0C, 0x91, 0x70, 0x09, 0x0A, 0xD1, 0x70, 0x1C, 0x71, 0x10, 0x99, 0x6D, 0x1C, 0x0C,
+	0x72, 0x1A, 0xE7, 0xE8, 0x00, 0x29, 0x18, 0x13, 0x48, 0x08, 0x18, 0x41, 0x79, 0x02, 0x79, 0x09,
+	0x02, 0x11, 0x43, 0x4B, 0x01, 0x29, 0x46, 0x06, 0x22, 0x51, 0x43, 0x0F, 0x4A, 0x53, 0x52, 0xC3,
+	0x78, 0x84, 0x78, 0x1B, 0x02, 0x23, 0x43, 0x5B, 0x01, 0x89, 0x18, 0x4B, 0x80, 0x02, 0x7A, 0x0A,
+	0x71, 0xC0, 0x79, 0x48, 0x71, 0x6D, 0x1C, 0x11, 0x98, 0x85, 0x42, 0xE2, 0xD3, 0x01, 0x49, 0x08,
+	0x70, 0x13, 0xB0, 0xF0, 0xBD, 0xF4, 0x02, 0x00, 0x20, 0x74, 0xE7, 0x00, 0x00, 0xD0, 0xE7, 0x00,
+	0x00, 0xEE, 0x00, 0x00, 0x20, 
+	0x00, 0x01, 0xA3, 0x00, 0x80, 0x88, 0x03, 0x00, 0x20, 0x74, 0x1A, 0x00, 0x20, 0x80, 0xE6, 0x00,
+	0x00, 0xF8, 0x01, 0x00, 0x20, 0xFC, 0xB5, 0x57, 0x4A, 0x00, 0x20, 0xD1, 0x78, 0x56, 0x4D, 0x49,
+	0x1C, 0xC9, 0xB2, 0xD1, 0x70, 0x01, 0x91, 0xEC, 0x6E, 0x11, 0x46, 0x0B, 0x78, 0x53, 0x49, 0x0A,
+	0x78, 0xD1, 0x1A, 0x8E, 0x46, 0x99, 0x1A, 0x00, 0x91, 0x29, 0x46, 0x60, 0x31, 0x01, 0x2C, 0x08,
+	0xD1, 0x9A, 0x42, 0x01, 0xD9, 0x72, 0x46, 0x00, 0xE0, 0x00, 0x9A, 0x09, 0x7C, 0x8A, 0x42, 0x12,
+	0xDD, 0x10, 0xE0, 0x49, 0x4C, 0xE7, 0x6E, 0x47, 0x4C, 0x65, 0x78, 0x48, 0x4C, 0x64, 0x78, 0x66,
+	0x1B, 0xB4, 0x46, 0x2E, 0x1B, 0x02, 0x2F, 0x0C, 0xD1, 0xAC, 0x42, 0x00, 0xD9, 0x66, 0x46, 0x49,
+	0x7C, 0x8E, 0x42, 0x00, 0xDD, 0x01, 0x20, 0x01, 0x99, 0x03, 0x29, 0x01, 0xD2, 0x40, 0x42, 0x40,
+	0xB2, 0xFC, 0xBD, 0x3D, 0x4F, 
+	0x00, 0x01, 0xA4, 0x00, 0x80, 0xFF, 0x6E, 0x03, 0x2F, 0xF5, 0xD1, 0x9A, 0x42, 0x01, 0xD9, 0x72,
+	0x46, 0x00, 0xE0, 0x00, 0x9A, 0x0B, 0x7C, 0x9A, 0x42, 0xEC, 0xDC, 0xE5, 0xE7, 0x35, 0x49, 0x48,
+	0x60, 0x36, 0x48, 0x02, 0x78, 0x0A, 0x70, 0x40, 0x78, 0x48, 0x70, 0x01, 0x20, 0xC8, 0x70, 0x70,
+	0x47, 0x30, 0x49, 0x00, 0x20, 0x48, 0x60, 0x08, 0x70, 0x48, 0x70, 0xC8, 0x70, 0x88, 0x70, 0x70,
+	0x47, 0xF8, 0xB5, 0x07, 0x46, 0x00, 0x20, 0x00, 0x90, 0xF7, 0xF7, 0x7A, 0xFC, 0x00, 0x26, 0xC0,
+	0xB2, 0x31, 0x46, 0x01, 0x28, 0x07, 0xD1, 0x29, 0x4A, 0xD3, 0x78, 0x05, 0x2B, 0x03, 0xD8, 0x92,
+	0x78, 0x05, 0x2A, 0x00, 0xD8, 0x01, 0x21, 0x23, 0x4D, 0x03, 0x24, 0xAA, 0x78, 0x00, 0x2A, 0x09,
+	0xD1, 0x00, 0x28, 0x3D, 0xD0, 0x00, 0x29, 0x31, 0xD0, 0x01, 0x20, 0xA8, 0x70, 0x38, 0x46, 0xFF,
+	0xF7, 0xCD, 0xFF, 0x35, 0xE0, 
+	0x00, 0x01, 0xA5, 0x00, 0x80, 0x1C, 0x4B, 0x60, 0x33, 0x01, 0x2A, 0x13, 0xD1, 0x00, 0x28, 0x2B,
+	0xD0, 0x68, 0x68, 0x5A, 0x8A, 0x38, 0x1A, 0x90, 0x42, 0x00, 0xD9, 0xAC, 0x70, 0x00, 0x29, 0x1D,
+	0xD0, 0xFF, 0xF7, 0x78, 0xFF, 0x01, 0x28, 0x02, 0xD1, 0x02, 0x20, 0xA8, 0x70, 0x20, 0xE0, 0x40,
+	0x1C, 0x1E, 0xD1, 0x13, 0xE0, 0x02, 0x2A, 0x13, 0xD1, 0x00, 0x28, 0x03, 0xD1, 0xAE, 0x70, 0x01,
+	0x20, 0x00, 0x90, 0x15, 0xE0, 0x68, 0x68, 0x5A, 0x8A, 0x38, 0x1A, 0x90, 0x42, 0x00, 0xD9, 0xAC,
+	0x70, 0x00, 0x29, 0x03, 0xD0, 0xFF, 0xF7, 0x5E, 0xFF, 0x01, 0x28, 0x09, 0xD0, 0xAC, 0x70, 0x07,
+	0xE0, 0x03, 0x2A, 0x03, 0xD1, 0x00, 0x28, 0x03, 0xD1, 0xAE, 0x70, 0x01, 0xE0, 0xFF, 0xF7, 0xA0,
+	0xFF, 0x00, 0x98, 0xF8, 0xBD, 0x88, 0x03, 0x00, 0x20, 0x80, 0xE6, 0x00, 0x00, 0x00, 0x01, 0x00,
+	0x20, 0xFB, 0x49, 0xFC, 0x4A, 
+	0x00, 0x01, 0xA6, 0x00, 0x80, 0x48, 0x60, 0x13, 0x78, 0x0B, 0x70, 0x52, 0x78, 0x4A, 0x70, 0x01,
+	0x22, 0xCA, 0x70, 0x08, 0x31, 0x48, 0x60, 0xF8, 0x48, 0x03, 0x78, 0x0B, 0x70, 0x40, 0x78, 0x48,
+	0x70, 0xCA, 0x70, 0x70, 0x47, 0xF2, 0x49, 0x00, 0x20, 0x48, 0x60, 0x08, 0x70, 0x48, 0x70, 0xC8,
+	0x70, 0x88, 0x70, 0x08, 0x31, 0x48, 0x60, 0x08, 0x70, 0x48, 0x70, 0xC8, 0x70, 0x88, 0x70, 0x70,
+	0x47, 0xF0, 0xB5, 0xEB, 0x4C, 0x00, 0x20, 0x84, 0x46, 0x0C, 0x3C, 0x20, 0x78, 0x00, 0x28, 0x04,
+	0xD0, 0x00, 0x20, 0x20, 0x70, 0x20, 0x71, 0x60, 0x71, 0x60, 0x70, 0xE6, 0x48, 0x01, 0x78, 0xE6,
+	0x48, 0x02, 0x78, 0x8E, 0x1A, 0x55, 0x1A, 0x91, 0x42, 0x01, 0xD9, 0x37, 0x46, 0x00, 0xE0, 0x2F,
+	0x46, 0xE2, 0x4B, 0x58, 0x7A, 0x87, 0x42, 0x45, 0xDB, 0x91, 0x42, 0x00, 0xD9, 0x35, 0x46, 0x9E,
+	0x7A, 0xB5, 0x42, 0x3F, 0xDC, 
+	0x00, 0x01, 0xA7, 0x00, 0x80, 0xDA, 0x4E, 0x30, 0x78, 0xC5, 0x1C, 0xA9, 0x42, 0x3A, 0xD8, 0xC0,
+	0x1E, 0x37, 0x46, 0x81, 0x42, 0x36, 0xDB, 0x35, 0x46, 0x08, 0x35, 0x28, 0x78, 0xD6, 0x49, 0xC6,
+	0x1C, 0xB2, 0x42, 0x2F, 0xD8, 0xC0, 0x1E, 0x82, 0x42, 0x2C, 0xDB, 0xD2, 0x48, 0x7A, 0x78, 0x40,
+	0x78, 0x90, 0x42, 0x01, 0xD9, 0x80, 0x1A, 0x00, 0xE0, 0x10, 0x1A, 0x49, 0x78, 0x6A, 0x78, 0xC0,
+	0xB2, 0x91, 0x42, 0x01, 0xD9, 0x89, 0x1A, 0x00, 0xE0, 0x51, 0x1A, 0x22, 0x79, 0x01, 0x26, 0x85,
+	0x1A, 0xF6, 0x43, 0xC9, 0xB2, 0xB5, 0x42, 0x15, 0xDB, 0x65, 0x79, 0x4D, 0x1B, 0xB5, 0x42, 0x11,
+	0xDB, 0x1D, 0x7A, 0x85, 0x42, 0x04, 0xD8, 0x1B, 0x7A, 0x8B, 0x42, 0x01, 0xD8, 0x01, 0x21, 0x8C,
+	0x46, 0x82, 0x42, 0x00, 0xD8, 0x02, 0x46, 0xD1, 0xB2, 0x22, 0x71, 0x81, 0x42, 0x00, 0xD8, 0x01,
+	0x46, 0x21, 0x71, 0x01, 0xE0, 
+	0x00, 0x01, 0xA8, 0x00, 0x80, 0x01, 0x20, 0x60, 0x70, 0x60, 0x46, 0xF0, 0xBD, 0xF0, 0xB5, 0x86,
+	0xB0, 0x00, 0x20, 0x00, 0x90, 0xB7, 0x48, 0xB6, 0x4A, 0x05, 0x78, 0xB5, 0x48, 0x08, 0x32, 0x06,
+	0x78, 0xB5, 0x4B, 0x30, 0x46, 0x76, 0x1D, 0x40, 0x1F, 0x05, 0x96, 0x04, 0x90, 0x10, 0x78, 0x41,
+	0x1D, 0x40, 0x1F, 0x02, 0x90, 0xB1, 0x48, 0x01, 0x90, 0x03, 0x91, 0xAE, 0x48, 0x59, 0x78, 0x40,
+	0x78, 0x52, 0x78, 0x44, 0x1A, 0xA4, 0x46, 0x0C, 0x1A, 0xA6, 0x46, 0x1C, 0x78, 0xA8, 0x4B, 0xB5,
+	0x42, 0x5B, 0x78, 0x26, 0xD8, 0x04, 0x9E, 0xB5, 0x42, 0x23, 0xDB, 0x5E, 0x1D, 0xB0, 0x42, 0x20,
+	0xD8, 0x5E, 0x1F, 0xB0, 0x42, 0x1D, 0xDB, 0x03, 0x9E, 0xB4, 0x42, 0x1A, 0xD8, 0x02, 0x9E, 0xB4,
+	0x42, 0x17, 0xDB, 0x91, 0x42, 0x01, 0xD9, 0x8E, 0x1A, 0x00, 0xE0, 0x56, 0x1A, 0x01, 0x9F, 0xFF,
+	0x7A, 0xBE, 0x42, 0x0E, 0xDB, 
+	0x00, 0x01, 0xA9, 0x00, 0x80, 0x90, 0x42, 0x01, 0xD9, 0x86, 0x1A, 0x00, 0xE0, 0x16, 0x1A, 0x88,
+	0x42, 0x01, 0xD9, 0x67, 0x46, 0x00, 0xE0, 0x77, 0x46, 0xBE, 0x42, 0x02, 0xDD, 0x01, 0x20, 0x06,
+	0xB0, 0xF0, 0xBD, 0x03, 0x9E, 0xB4, 0x42, 0x25, 0xD8, 0x02, 0x9E, 0xB4, 0x42, 0x22, 0xDB, 0x54,
+	0x1D, 0xA1, 0x42, 0x1F, 0xD8, 0x52, 0x1F, 0x91, 0x42, 0x1C, 0xDB, 0x05, 0x9A, 0x95, 0x42, 0x19,
+	0xD8, 0x04, 0x9A, 0x95, 0x42, 0x16, 0xDB, 0x98, 0x42, 0x01, 0xD9, 0xC2, 0x1A, 0x00, 0xE0, 0x1A,
+	0x1A, 0x01, 0x9C, 0xE4, 0x7A, 0xA2, 0x42, 0x0D, 0xDB, 0x99, 0x42, 0x01, 0xD9, 0xCA, 0x1A, 0x00,
+	0xE0, 0x5A, 0x1A, 0x81, 0x42, 0x01, 0xD9, 0x70, 0x46, 0x00, 0xE0, 0x60, 0x46, 0x82, 0x42, 0x01,
+	0xDD, 0x01, 0x20, 0x00, 0x90, 0x00, 0x98, 0xD2, 0xE7, 0xF8, 0xB5, 0x05, 0x46, 0x00, 0x20, 0x00,
+	0x90, 0xF7, 0xF7, 0xF7, 0xF8, 
+	0x00, 0x01, 0xAA, 0x00, 0x80, 0xC4, 0xB2, 0x7E, 0x48, 0x01, 0x78, 0x79, 0x48, 0x00, 0x29, 0x12,
+	0xD0, 0x01, 0x2C, 0x09, 0xD1, 0x80, 0x78, 0x00, 0x28, 0x0B, 0xD1, 0x05, 0x20, 0xFF, 0xF7, 0xBE,
+	0xF9, 0x77, 0x48, 0x00, 0x21, 0x01, 0x70, 0x04, 0xE0, 0x81, 0x78, 0x07, 0x29, 0x01, 0xD1, 0x00,
+	0x21, 0x81, 0x70, 0x00, 0x20, 0xF8, 0xBD, 0x07, 0x26, 0x02, 0x2C, 0x00, 0xD9, 0x86, 0x70, 0x71,
+	0x49, 0x0A, 0x78, 0x00, 0x2A, 0x02, 0xD0, 0x00, 0x22, 0x0A, 0x70, 0x86, 0x70, 0x01, 0x2C, 0x0C,
+	0xD1, 0x6A, 0x49, 0x68, 0x4B, 0x20, 0x39, 0xDA, 0x78, 0xCF, 0x7F, 0xBA, 0x42, 0x05, 0xD8, 0x9A,
+	0x78, 0x89, 0x7F, 0x8A, 0x42, 0x01, 0xD8, 0x01, 0x22, 0x00, 0xE0, 0x00, 0x22, 0x60, 0x48, 0x63,
+	0x4F, 0x81, 0x78, 0x00, 0x29, 0x18, 0xD1, 0x0C, 0x38, 0x81, 0x70, 0x00, 0x2A, 0x03, 0xD0, 0x5C,
+	0x49, 0x01, 0x20, 0x88, 0x70, 
+	0x00, 0x01, 0xAB, 0x00, 0x80, 0x06, 0xE0, 0x02, 0x2C, 0x0B, 0xD1, 0x59, 0x4A, 0x08, 0x21, 0x91,
+	0x70, 0x01, 0x21, 0x01, 0x70, 0x28, 0x46, 0xFF, 0xF7, 0xB3, 0xFE, 0x1E, 0x20, 0xFF, 0xF7, 0x7E,
+	0xF9, 0xEF, 0xE0, 0x53, 0x48, 0x86, 0x70, 0xF1, 0xE0, 0x51, 0x48, 0x01, 0x29, 0x22, 0xD1, 0x00,
+	0x2C, 0x09, 0xD1, 0x02, 0x21, 0x81, 0x70, 0x0C, 0x38, 0xC1, 0x78, 0x00, 0x29, 0x02, 0xD0, 0x00,
+	0x21, 0x85, 0x60, 0xC1, 0x70, 0xF2, 0xE0, 0x02, 0x2C, 0x11, 0xD1, 0x04, 0x46, 0x40, 0x68, 0x29,
+	0x1A, 0xF8, 0x89, 0x81, 0x42, 0x09, 0xD8, 0x28, 0x46, 0xFF, 0xF7, 0x92, 0xFE, 0x08, 0x20, 0xA0,
+	0x70, 0x43, 0x49, 0x01, 0x20, 0x0C, 0x39, 0x08, 0x70, 0xE0, 0xE0, 0xA6, 0x70, 0xD4, 0xE0, 0x00,
+	0x2A, 0x28, 0xD0, 0xC0, 0xE0, 0x44, 0x4B, 0x08, 0x29, 0x35, 0xD1, 0x02, 0x2C, 0xD1, 0xD1, 0x43,
+	0x48, 0x00, 0x78, 0x02, 0x28, 
+	0x00, 0x01, 0xAC, 0x00, 0x80, 0x1F, 0xD1, 0x18, 0x78, 0x80, 0x07, 0x1A, 0xD5, 0xFF, 0xF7, 0x98,
+	0xFE, 0x00, 0x28, 0x06, 0xD0, 0x36, 0x48, 0x0A, 0x21, 0x81, 0x70, 0x35, 0x49, 0x01, 0x20, 0x0C,
+	0x39, 0x88, 0x70, 0x33, 0x48, 0xFA, 0x88, 0x41, 0x68, 0x69, 0x1A, 0x91, 0x42, 0x04, 0xD8, 0x01,
+	0x46, 0x0C, 0x39, 0x49, 0x78, 0x00, 0x29, 0xB3, 0xD0, 0x86, 0x70, 0x2D, 0x48, 0x00, 0x21, 0x0C,
+	0x38, 0xA9, 0xE0, 0x2B, 0x48, 0x9B, 0xE0, 0x01, 0x28, 0xBC, 0xD1, 0x18, 0x78, 0x00, 0x07, 0xF8,
+	0xD5, 0xFF, 0xF7, 0xDC, 0xFE, 0x00, 0x28, 0x15, 0xD1, 0x25, 0x48, 0xBA, 0x89, 0x41, 0x68, 0x69,
+	0x1A, 0x91, 0x42, 0x2B, 0xD9, 0x8B, 0xE0, 0x22, 0x48, 0x0A, 0x29, 0x2E, 0xD1, 0x00, 0x2C, 0x0B,
+	0xD1, 0x00, 0x21, 0x02, 0x46, 0x81, 0x70, 0x0C, 0x3A, 0x90, 0x78, 0x00, 0x28, 0x02, 0xD0, 0x02,
+	0x20, 0x91, 0x70, 0xF8, 0xBD, 
+	0x00, 0x01, 0xAD, 0x00, 0x80, 0x04, 0x20, 0xF8, 0xBD, 0x01, 0x2C, 0x06, 0xD1, 0xC1, 0x78, 0x49,
+	0x1C, 0xC9, 0xB2, 0xC1, 0x70, 0x0A, 0x29, 0x5D, 0xD3, 0x71, 0xE0, 0x02, 0x2C, 0x6F, 0xD1, 0x14,
+	0x49, 0x0C, 0x39, 0x89, 0x78, 0x00, 0x29, 0x0A, 0xD0, 0x11, 0x48, 0x40, 0x68, 0x29, 0x1A, 0xF8,
+	0x88, 0x81, 0x42, 0xC6, 0xD8, 0xFF, 0xF7, 0x44, 0xFE, 0x00, 0x28, 0xC2, 0xD0, 0x61, 0xE0, 0x41,
+	0x68, 0xBA, 0x89, 0x69, 0x1A, 0x91, 0x42, 0x71, 0xD9, 0x59, 0xE0, 0x02, 0x29, 0x43, 0xD1, 0x00,
+	0x2C, 0x1E, 0xD1, 0x07, 0x49, 0xFF, 0x23, 0x0C, 0x39, 0x8A, 0x68, 0x00, 0x21, 0xAA, 0x1A, 0x2D,
+	0x33, 0x9A, 0x42, 0x00, 0xD9, 0x01, 0x21, 0x00, 0x29, 0x60, 0xD0, 0x86, 0x70, 0x50, 0xE0, 0x00,
+	0x00, 0x08, 0x03, 0x00, 0x20, 0x20, 0x01, 0x00, 0x20, 0x24, 0x01, 0x00, 0x20, 0x00, 0xE7, 0x00,
+	0x00, 0x6C, 0x02, 0x00, 0x20, 
+	0x00, 0x01, 0xAE, 0x00, 0x80, 0xEC, 0x00, 0x00, 0x20, 0x6B, 0x02, 0x00, 0x20, 0xEB, 0x00, 0x00,
+	0x20, 0x01, 0x2A, 0x34, 0xD1, 0x26, 0x49, 0xFF, 0x23, 0x8A, 0x68, 0x00, 0x21, 0xAA, 0x1A, 0x28,
+	0x3A, 0x05, 0x33, 0x9A, 0x42, 0x12, 0xD8, 0x23, 0x4D, 0x03, 0x78, 0x2A, 0x78, 0x9C, 0x1C, 0xA2,
+	0x42, 0x0C, 0xD8, 0x9B, 0x1E, 0x2C, 0x46, 0x9A, 0x42, 0x08, 0xDB, 0x43, 0x78, 0x62, 0x78, 0x9C,
+	0x1C, 0xA2, 0x42, 0x03, 0xD8, 0x9B, 0x1E, 0x9A, 0x42, 0x00, 0xDB, 0x01, 0x21, 0x01, 0x29, 0x16,
+	0xD1, 0x05, 0x21, 0x81, 0x70, 0x2A, 0xE0, 0x05, 0x29, 0x13, 0xD1, 0x00, 0x2C, 0x09, 0xD1, 0x00,
+	0x21, 0x81, 0x70, 0x18, 0x78, 0xC0, 0x07, 0x21, 0xD0, 0x01, 0x20, 0x11, 0x49, 0x00, 0x90, 0xC8,
+	0x70, 0x1C, 0xE0, 0x01, 0x2A, 0x03, 0xD1, 0x41, 0x68, 0xBA, 0x88, 0x69, 0x1A, 0xA2, 0xE7, 0x86,
+	0x70, 0x0A, 0xE0, 0x0B, 0x48, 
+	0x00, 0x01, 0xAF, 0x00, 0x80, 0x0C, 0x30, 0x80, 0x78, 0x07, 0x28, 0x0F, 0xD1, 0x00, 0x2C, 0x03,
+	0xD1, 0x07, 0x48, 0x00, 0x21, 0x0C, 0x30, 0x81, 0x70, 0x07, 0x48, 0x01, 0x24, 0x04, 0x70, 0x38,
+	0x78, 0xFF, 0xF7, 0x7C, 0xF8, 0x02, 0x49, 0x00, 0x20, 0x88, 0x70, 0xCC, 0x70, 0x00, 0x98, 0xF8,
+	0xBD, 0xFC, 0x02, 0x00, 0x20, 0x20, 0x01, 0x00, 0x20, 0x6C, 0x02, 0x00, 0x20, 0x0C, 0x49, 0xCA,
+	0x68, 0x03, 0x23, 0x1B, 0x02, 0x9A, 0x43, 0x00, 0x02, 0x02, 0x43, 0xCA, 0x60, 0x70, 0x47, 0x08,
+	0x49, 0x4A, 0x69, 0x0F, 0x23, 0x1B, 0x04, 0x9A, 0x43, 0x00, 0x04, 0x02, 0x43, 0x4A, 0x61, 0x70,
+	0x47, 0x03, 0x49, 0x8A, 0x69, 0x10, 0x23, 0x9A, 0x43, 0x00, 0x01, 0x02, 0x43, 0x8A, 0x61, 0x70,
+	0x47, 0x00, 0x00, 0x14, 0x40, 0x01, 0x78, 0x01, 0x29, 0x09, 0xD1, 0x40, 0x78, 0x41, 0x00, 0x15,
+	0x48, 0x01, 0x62, 0x41, 0x69, 
+	0x00, 0x01, 0xB0, 0x00, 0x80, 0x30, 0x22, 0x91, 0x43, 0x02, 0x22, 0x11, 0x43, 0x41, 0x61, 0x70,
+	0x47, 0x10, 0xB5, 0x10, 0x48, 0x41, 0x69, 0x41, 0x61, 0x02, 0x21, 0x41, 0x62, 0x00, 0x21, 0xC1,
+	0x62, 0x81, 0x62, 0xFF, 0x21, 0xC1, 0x60, 0x01, 0x21, 0x01, 0x61, 0x03, 0x20, 0xF8, 0xF7, 0xA5,
+	0xFC, 0x03, 0x21, 0x08, 0x46, 0xF8, 0xF7, 0x90, 0xFC, 0x07, 0x49, 0x03, 0x20, 0xF8, 0xF7, 0x85,
+	0xFC, 0x03, 0x20, 0xF8, 0xF7, 0x93, 0xFC, 0x10, 0xBD, 0x04, 0x4A, 0x80, 0x00, 0x80, 0x18, 0x01,
+	0x60, 0x70, 0x47, 0xFE, 0xE7, 0x00, 0x00, 0x12, 0x40, 0x75, 0xD9, 0x00, 0x00, 0x00, 0x10, 0x12,
+	0x40, 0x0E, 0x4A, 0x11, 0x68, 0xEF, 0x23, 0xC0, 0x07, 0x19, 0x40, 0xC0, 0x0E, 0x08, 0x43, 0x10,
+	0x60, 0x70, 0x47, 0x0A, 0x49, 0x8A, 0x68, 0x07, 0x23, 0x1B, 0x03, 0x9A, 0x43, 0x00, 0x03, 0x02,
+	0x43, 0x8A, 0x60, 0x70, 0x47, 
+	0x00, 0x01, 0xB1, 0x00, 0x80, 0x05, 0x48, 0x40, 0x68, 0xC0, 0x06, 0xC0, 0x0F, 0x70, 0x47, 0x03,
+	0x49, 0x08, 0x69, 0x10, 0x22, 0x10, 0x40, 0x08, 0x61, 0x00, 0x09, 0x70, 0x47, 0x00, 0x00, 0x14,
+	0x40, 0x70, 0xB5, 0x05, 0x46, 0x0B, 0x48, 0x00, 0x23, 0x0B, 0x4C, 0x10, 0xE0, 0xCA, 0x5C, 0x12,
+	0x02, 0x50, 0x40, 0x08, 0x22, 0x06, 0x04, 0x02, 0xD5, 0x40, 0x00, 0x60, 0x40, 0x00, 0xE0, 0x40,
+	0x00, 0x52, 0x1E, 0x12, 0x06, 0x80, 0xB2, 0x12, 0x0E, 0xF4, 0xD1, 0x5B, 0x1C, 0x9B, 0xB2, 0xAB,
+	0x42, 0xEC, 0xD3, 0x70, 0xBD, 0xFF, 0xFF, 0x00, 0x00, 0x21, 0x10, 0x00, 0x00, 0x1C, 0xB5, 0x68,
+	0x46, 0x00, 0xF0, 0x22, 0xF8, 0x00, 0x22, 0x0E, 0x49, 0x00, 0x28, 0x08, 0xD1, 0x6B, 0x46, 0x58,
+	0x88, 0x90, 0x28, 0x04, 0xD1, 0x18, 0x88, 0xC3, 0x1F, 0xF9, 0x3B, 0x5F, 0x2B, 0x02, 0xD3, 0x0A,
+	0x70, 0x4A, 0x80, 0x1C, 0xBD, 
+	0x00, 0x01, 0xB2, 0x00, 0x80, 0x07, 0x4A, 0x40, 0x00, 0x80, 0x18, 0xFF, 0x38, 0xFF, 0x38, 0x02,
+	0x38, 0x00, 0x88, 0x48, 0x80, 0x80, 0xB2, 0xC0, 0x06, 0xC0, 0x0E, 0x08, 0x70, 0x1C, 0xBD, 0x00,
+	0x00, 0x18, 0x03, 0x00, 0x20, 0x9C, 0xE0, 0x00, 0x00, 0x70, 0xB5, 0x05, 0x46, 0x11, 0x4E, 0x10,
+	0x48, 0xB0, 0x60, 0xF8, 0xF7, 0xFB, 0xFB, 0xF1, 0x02, 0x71, 0x60, 0x71, 0x68, 0x00, 0x29, 0xFC,
+	0xDB, 0xB4, 0x68, 0x71, 0x68, 0xC0, 0xB2, 0x0E, 0x05, 0x36, 0x0D, 0xF8, 0xF7, 0xF3, 0xFB, 0x20,
+	0x0F, 0x0A, 0x28, 0x01, 0xD0, 0x01, 0x20, 0x70, 0xBD, 0x2C, 0x80, 0x20, 0x0C, 0x28, 0x71, 0x20,
+	0x02, 0x00, 0x0F, 0x68, 0x71, 0x20, 0x03, 0x00, 0x0F, 0xA8, 0x71, 0x6E, 0x80, 0x00, 0x20, 0x70,
+	0xBD, 0xB6, 0xD3, 0x00, 0x00, 0x00, 0x00, 0x10, 0x40, 0x70, 0xB5, 0x15, 0x49, 0xC8, 0x68, 0x15,
+	0x4D, 0xC8, 0x60, 0x09, 0x69, 
+	0x00, 0x01, 0xB3, 0x00, 0x80, 0x14, 0x4C, 0x01, 0x40, 0x29, 0x60, 0x88, 0x07, 0x01, 0xD5, 0x20,
+	0x68, 0x80, 0x47, 0x28, 0x68, 0x40, 0x07, 0x01, 0xD5, 0x60, 0x68, 0x80, 0x47, 0x28, 0x68, 0x00,
+	0x07, 0x01, 0xD5, 0xA0, 0x68, 0x80, 0x47, 0x28, 0x68, 0xC0, 0x06, 0x01, 0xD5, 0xE0, 0x68, 0x80,
+	0x47, 0x28, 0x68, 0x80, 0x06, 0x01, 0xD5, 0x20, 0x69, 0x80, 0x47, 0x28, 0x68, 0x40, 0x06, 0x01,
+	0xD5, 0x60, 0x69, 0x80, 0x47, 0x28, 0x68, 0x00, 0x06, 0x01, 0xD5, 0xA0, 0x69, 0x80, 0x47, 0x70,
+	0xBD, 0x00, 0x00, 0x12, 0x40, 0x1C, 0x03, 0x00, 0x20, 0x80, 0xE0, 0x00, 0x00, 0xF8, 0xB5, 0x04,
+	0x2A, 0x2C, 0xD3, 0x83, 0x07, 0x12, 0xD0, 0x0B, 0x78, 0x49, 0x1C, 0x03, 0x70, 0x40, 0x1C, 0x52,
+	0x1E, 0x83, 0x07, 0x0B, 0xD0, 0x0B, 0x78, 0x49, 0x1C, 0x03, 0x70, 0x40, 0x1C, 0x52, 0x1E, 0x83,
+	0x07, 0x04, 0xD0, 0x0B, 0x78, 
+	0x00, 0x01, 0xB4, 0x00, 0x80, 0x49, 0x1C, 0x03, 0x70, 0x40, 0x1C, 0x52, 0x1E, 0x8B, 0x07, 0x9B,
+	0x0F, 0x02, 0xD1, 0xF3, 0xF7, 0x91, 0xFC, 0xF8, 0xBD, 0xC9, 0x1A, 0xDE, 0x00, 0x20, 0x23, 0x9D,
+	0x1B, 0x08, 0xC9, 0x07, 0xE0, 0xF3, 0x40, 0x1C, 0x46, 0x08, 0xC9, 0x1F, 0x46, 0xAF, 0x40, 0x27,
+	0x43, 0x80, 0xC0, 0x12, 0x1F, 0x04, 0x2A, 0xF5, 0xD2, 0xEB, 0x08, 0xC9, 0x1A, 0x52, 0x1E, 0xEA,
+	0xD4, 0x0B, 0x78, 0x49, 0x1C, 0x03, 0x70, 0x40, 0x1C, 0x52, 0x1E, 0xE4, 0xD4, 0x0B, 0x78, 0x49,
+	0x1C, 0x03, 0x70, 0x40, 0x1C, 0x52, 0x1E, 0xDE, 0xD4, 0x09, 0x78, 0x01, 0x70, 0xF8, 0xBD, 0x01,
+	0xE0, 0x04, 0xC0, 0x09, 0x1F, 0x04, 0x29, 0xFB, 0xD2, 0x8B, 0x07, 0x01, 0xD5, 0x02, 0x80, 0x80,
+	0x1C, 0xC9, 0x07, 0x00, 0xD0, 0x02, 0x70, 0x70, 0x47, 0x00, 0x29, 0x0B, 0xD0, 0xC3, 0x07, 0x02,
+	0xD0, 0x02, 0x70, 0x40, 0x1C, 
+	0x00, 0x01, 0xB5, 0x00, 0x80, 0x49, 0x1E, 0x02, 0x29, 0x04, 0xD3, 0x83, 0x07, 0x02, 0xD5, 0x02,
+	0x80, 0x80, 0x1C, 0x89, 0x1E, 0xE3, 0xE7, 0x00, 0x22, 0xEE, 0xE7, 0x00, 0x22, 0xDF, 0xE7, 0x82,
+	0x08, 0x81, 0x07, 0x92, 0x00, 0xC9, 0x0E, 0x0C, 0xCA, 0xC0, 0x78, 0xCA, 0x40, 0x49, 0x42, 0x20,
+	0x31, 0x8B, 0x40, 0x1A, 0x43, 0x11, 0x02, 0x09, 0x0A, 0x00, 0x06, 0x08, 0x43, 0x70, 0x47, 0x00,
+	0x22, 0x03, 0x09, 0x8B, 0x42, 0x2C, 0xD3, 0x03, 0x0A, 0x8B, 0x42, 0x11, 0xD3, 0x00, 0x23, 0x9C,
+	0x46, 0x4E, 0xE0, 0x03, 0x46, 0x0B, 0x43, 0x3C, 0xD4, 0x00, 0x22, 0x43, 0x08, 0x8B, 0x42, 0x31,
+	0xD3, 0x03, 0x09, 0x8B, 0x42, 0x1C, 0xD3, 0x03, 0x0A, 0x8B, 0x42, 0x01, 0xD3, 0x94, 0x46, 0x3F,
+	0xE0, 0xC3, 0x09, 0x8B, 0x42, 0x01, 0xD3, 0xCB, 0x01, 0xC0, 0x1A, 0x52, 0x41, 0x83, 0x09, 0x8B,
+	0x42, 0x01, 0xD3, 0x8B, 0x01, 
+	0x00, 0x01, 0xB6, 0x00, 0x80, 0xC0, 0x1A, 0x52, 0x41, 0x43, 0x09, 0x8B, 0x42, 0x01, 0xD3, 0x4B,
+	0x01, 0xC0, 0x1A, 0x52, 0x41, 0x03, 0x09, 0x8B, 0x42, 0x01, 0xD3, 0x0B, 0x01, 0xC0, 0x1A, 0x52,
+	0x41, 0xC3, 0x08, 0x8B, 0x42, 0x01, 0xD3, 0xCB, 0x00, 0xC0, 0x1A, 0x52, 0x41, 0x83, 0x08, 0x8B,
+	0x42, 0x01, 0xD3, 0x8B, 0x00, 0xC0, 0x1A, 0x52, 0x41, 0x43, 0x08, 0x8B, 0x42, 0x01, 0xD3, 0x4B,
+	0x00, 0xC0, 0x1A, 0x52, 0x41, 0x41, 0x1A, 0x00, 0xD2, 0x01, 0x46, 0x52, 0x41, 0x10, 0x46, 0x70,
+	0x47, 0x5D, 0xE0, 0xCA, 0x0F, 0x00, 0xD0, 0x49, 0x42, 0x03, 0x10, 0x00, 0xD3, 0x40, 0x42, 0x53,
+	0x40, 0x00, 0x22, 0x9C, 0x46, 0x03, 0x09, 0x8B, 0x42, 0x2D, 0xD3, 0x03, 0x0A, 0x8B, 0x42, 0x12,
+	0xD3, 0xFC, 0x22, 0x89, 0x01, 0x12, 0xBA, 0x03, 0x0A, 0x8B, 0x42, 0x0C, 0xD3, 0x89, 0x01, 0x92,
+	0x11, 0x8B, 0x42, 0x08, 0xD3, 
+	0x00, 0x01, 0xB7, 0x00, 0x80, 0x89, 0x01, 0x92, 0x11, 0x8B, 0x42, 0x04, 0xD3, 0x89, 0x01, 0x3A,
+	0xD0, 0x92, 0x11, 0x00, 0xE0, 0x89, 0x09, 0xC3, 0x09, 0x8B, 0x42, 0x01, 0xD3, 0xCB, 0x01, 0xC0,
+	0x1A, 0x52, 0x41, 0x83, 0x09, 0x8B, 0x42, 0x01, 0xD3, 0x8B, 0x01, 0xC0, 0x1A, 0x52, 0x41, 0x43,
+	0x09, 0x8B, 0x42, 0x01, 0xD3, 0x4B, 0x01, 0xC0, 0x1A, 0x52, 0x41, 0x03, 0x09, 0x8B, 0x42, 0x01,
+	0xD3, 0x0B, 0x01, 0xC0, 0x1A, 0x52, 0x41, 0xC3, 0x08, 0x8B, 0x42, 0x01, 0xD3, 0xCB, 0x00, 0xC0,
+	0x1A, 0x52, 0x41, 0x83, 0x08, 0x8B, 0x42, 0x01, 0xD3, 0x8B, 0x00, 0xC0, 0x1A, 0x52, 0x41, 0xD9,
+	0xD2, 0x43, 0x08, 0x8B, 0x42, 0x01, 0xD3, 0x4B, 0x00, 0xC0, 0x1A, 0x52, 0x41, 0x41, 0x1A, 0x00,
+	0xD2, 0x01, 0x46, 0x63, 0x46, 0x52, 0x41, 0x5B, 0x10, 0x10, 0x46, 0x01, 0xD3, 0x40, 0x42, 0x00,
+	0x2B, 0x00, 0xD5, 0x49, 0x42, 
+	0x00, 0x01, 0xB8, 0x00, 0x80, 0x70, 0x47, 0x63, 0x46, 0x5B, 0x10, 0x00, 0xD3, 0x40, 0x42, 0x01,
+	0xB5, 0x00, 0x20, 0xC0, 0x46, 0xC0, 0x46, 0x02, 0xBD, 0x04, 0x46, 0xC0, 0x46, 0xC0, 0x46, 0x20,
+	0x46, 0xF3, 0xF7, 0x7E, 0xFB, 0x02, 0x48, 0x03, 0x49, 0xAB, 0xBE, 0x70, 0x47, 0x0D, 0x00, 0x00,
+	0x00, 0x18, 0x00, 0x00, 0x00, 0x26, 0x00, 0x02, 0x00, 0x70, 0x47, 0x70, 0xB5, 0x8C, 0x18, 0x05,
+	0x78, 0x40, 0x1C, 0x6B, 0x07, 0x5B, 0x0F, 0x01, 0xD1, 0x03, 0x78, 0x40, 0x1C, 0x2A, 0x11, 0x06,
+	0xD1, 0x02, 0x78, 0x40, 0x1C, 0x03, 0xE0, 0x06, 0x78, 0x40, 0x1C, 0x0E, 0x70, 0x49, 0x1C, 0x5B,
+	0x1E, 0xF9, 0xD1, 0x2B, 0x07, 0x06, 0xD4, 0x00, 0x23, 0x01, 0xE0, 0x0B, 0x70, 0x49, 0x1C, 0x52,
+	0x1E, 0xFB, 0xD5, 0x0A, 0xE0, 0x03, 0x78, 0x40, 0x1C, 0xCB, 0x1A, 0x92, 0x1C, 0x03, 0xE0, 0x1D,
+	0x78, 0x5B, 0x1C, 0x0D, 0x70, 
+	0x00, 0x01, 0xB9, 0x00, 0x80, 0x49, 0x1C, 0x52, 0x1E, 0xF9, 0xD5, 0xA1, 0x42, 0xD7, 0xD3, 0x00,
+	0x20, 0x70, 0xBD, 0x30, 0xB4, 0x74, 0x46, 0x64, 0x1E, 0x25, 0x78, 0x64, 0x1C, 0xAB, 0x42, 0x00,
+	0xD2, 0x1D, 0x46, 0x63, 0x5D, 0x5B, 0x00, 0xE3, 0x18, 0x30, 0xBC, 0x18, 0x47, 0x01, 0x01, 0x01,
+	0x02, 0x01, 0x01, 0x02, 0x01, 0x01, 0x02, 0x01, 0x01, 0x02, 0x01, 0x01, 0x01, 0x00, 0x6F, 0x53,
+	0xB2, 0x00, 0x6F, 0x57, 0xB2, 0x00, 0x6F, 0x4B, 0xB2, 0x00, 0x6F, 0x4B, 0xB8, 0x00, 0x79, 0x43,
+	0xB2, 0x00, 0x68, 0x43, 0xB2, 0x00, 0x01, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x00, 0x01, 0x00,
+	0x00, 0x00, 0x01, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x55, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00,
+	0x00, 0x33, 0x00, 0x00, 0x00, 0x2A, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00,
+	0x00, 0x00, 0x30, 0x13, 0x40, 
+	0x00, 0x01, 0xBA, 0x00, 0x80, 0x00, 0x04, 0x00, 0x40, 0x13, 0x40, 0x00, 0x02, 0x01, 0x00, 0x13,
+	0x40, 0x56, 0x32, 0x13, 0x40, 0x34, 0x33, 0x13, 0x40, 0x01, 0x60, 0x13, 0x40, 0x83, 0x0F, 0x05,
+	0x03, 0x07, 0x14, 0x0D, 0x80, 0x11, 0x73, 0x13, 0x0C, 0x17, 0x5E, 0x19, 0x73, 0x1B, 0x04, 0x2D,
+	0x29, 0x2F, 0x10, 0x31, 0x60, 0x33, 0x10, 0x35, 0x80, 0x37, 0x0F, 0x39, 0x02, 0x3B, 0x80, 0x3F,
+	0x05, 0x40, 0x01, 0x45, 0x05, 0x46, 0x01, 0x48, 0x05, 0x49, 0xFF, 0x4A, 0x07, 0x4B, 0xFF, 0x4C,
+	0x40, 0x4D, 0x20, 0x4E, 0xF0, 0x4F, 0x05, 0x50, 0x08, 0x59, 0x04, 0x5A, 0x04, 0x5F, 0x01, 0x60,
+	0x40, 0x61, 0xA8, 0x62, 0x40, 0x63, 0x20, 0x85, 0x09, 0x86, 0x07, 0x87, 0xF0, 0x89, 0x14, 0x8C,
+	0x04, 0x8E, 0x01, 0x8F, 0x03, 0x90, 0x10, 0x91, 0x10, 0x93, 0xAC, 0x94, 0x04, 0x99, 0x0C, 0x9B,
+	0x71, 0x9C, 0x08, 0xA0, 0x01, 
+	0x00, 0x01, 0xBB, 0x00, 0x80, 0xA2, 0x02, 0xA4, 0x01, 0xA6, 0x06, 0xA9, 0x40, 0xAB, 0x10, 0xAD,
+	0xDC, 0xAF, 0x02, 0xB0, 0x07, 0xB2, 0x10, 0xB4, 0x08, 0xB5, 0xE0, 0xB7, 0x1F, 0xBA, 0x02, 0xBB,
+	0x20, 0xBE, 0x14, 0xC0, 0x42, 0xC1, 0x06, 0xC5, 0x0C, 0xC6, 0xBE, 0xC8, 0x0D, 0xC9, 0xFF, 0xCA,
+	0xFF, 0xCB, 0xFF, 0xCE, 0xF0, 0xCF, 0x44, 0xD0, 0x0C, 0xD4, 0x01, 0xD8, 0x04, 0xD9, 0x04, 0xDA,
+	0x04, 0xDB, 0x04, 0xDF, 0x01, 0xE6, 0xC0, 0xEA, 0x40, 0xEB, 0x02, 0x00, 0x04, 0x03, 0x02, 0x08,
+	0x01, 0x09, 0x40, 0x0A, 0x20, 0x0B, 0x80, 0x12, 0x20, 0x13, 0x02, 0x19, 0x04, 0x1A, 0x04, 0x1B,
+	0x02, 0x20, 0x08, 0x21, 0x40, 0x22, 0x20, 0x24, 0x04, 0x27, 0x5B, 0x2B, 0x06, 0x2F, 0x02, 0x32,
+	0x20, 0x33, 0x01, 0x36, 0x20, 0x37, 0x0A, 0x38, 0x24, 0x39, 0x80, 0x3D, 0x80, 0x3F, 0x04, 0x42,
+	0x04, 0x43, 0x01, 0x47, 0x40, 
+	0x00, 0x01, 0xBC, 0x00, 0x80, 0x48, 0x04, 0x4B, 0x04, 0x4E, 0x10, 0x4F, 0x08, 0x50, 0x10, 0x53,
+	0x40, 0x55, 0x40, 0x58, 0x01, 0x59, 0x14, 0x5A, 0x40, 0x61, 0x10, 0x63, 0x04, 0x8E, 0x40, 0x8F,
+	0x10, 0xC0, 0x05, 0xC2, 0x0D, 0xC4, 0x0C, 0xCA, 0x1C, 0xCC, 0xE5, 0xCE, 0x5E, 0xD0, 0x15, 0xD2,
+	0x04, 0xD6, 0x0F, 0x10, 0x01, 0x00, 0x01, 0x00, 0x01, 0x80, 0x00, 0x55, 0x00, 0x40, 0x00, 0x33,
+	0x00, 0x2A, 0x00, 0x24, 0x00, 0x20, 0x00, 0x00, 0x01, 0xB9, 0x00, 0x86, 0x00, 0x54, 0x00, 0x26,
+	0x00, 0x1B, 0x00, 0x27, 0x00, 0x37, 0x00, 0x52, 0x00, 0x94, 0x00, 0x00, 0x01, 0xBB, 0x8F, 0x00,
+	0x00, 0x79, 0x90, 0x00, 0x00, 0x2B, 0x92, 0x00, 0x00, 0x5D, 0x92, 0x00, 0x00, 0x7F, 0x92, 0x00,
+	0x00, 0x87, 0x91, 0x00, 0x00, 0x27, 0x93, 0x00, 0x00, 0xEB, 0x97, 0x00, 0x00, 0x43, 0x98, 0x00,
+	0x00, 0x47, 0x98, 0x00, 0x00, 
+	0x00, 0x01, 0xBD, 0x00, 0x80, 0x8B, 0x98, 0x00, 0x00, 0xCF, 0x98, 0x00, 0x00, 0x23, 0x99, 0x00,
+	0x00, 0xC9, 0x9A, 0x00, 0x00, 0x2D, 0x9B, 0x00, 0x00, 0x6F, 0x9B, 0x00, 0x00, 0xB7, 0x9B, 0x00,
+	0x00, 0xEB, 0x9B, 0x00, 0x00, 0x85, 0x9D, 0x00, 0x00, 0x23, 0x9E, 0x00, 0x00, 0x4B, 0x9E, 0x00,
+	0x00, 0xD7, 0x9E, 0x00, 0x00, 0xBB, 0x8F, 0x00, 0x00, 0xBB, 0x8F, 0x00, 0x00, 0xBB, 0x8F, 0x00,
+	0x00, 0xBB, 0x8F, 0x00, 0x00, 0xBB, 0x8F, 0x00, 0x00, 0xBB, 0x8F, 0x00, 0x00, 0xBB, 0x8F, 0x00,
+	0x00, 0xBB, 0x8F, 0x00, 0x00, 0xBB, 0x8F, 0x00, 0x00, 0xBB, 0x8F, 0x00, 0x00, 0xBB, 0x8F, 0x00,
+	0x00, 0x09, 0x98, 0x00, 0x00, 0x3F, 0x98, 0x00, 0x00, 0x97, 0x9F, 0x00, 0x00, 0xE7, 0x9F, 0x00,
+	0x00, 0xF7, 0x9F, 0x00, 0x00, 0x5B, 0xA0, 0x00, 0x00, 0x6B, 0xA0, 0x00, 0x00, 0xBB, 0x8F, 0x00,
+	0x00, 0xBB, 0x8F, 0x00, 0x00, 
+	0x00, 0x01, 0xBE, 0x00, 0x80, 0xA5, 0x01, 0x02, 0x03, 0xFF, 0xFE, 0xFD, 0x5A, 0x54, 0x53, 0x47,
+	0x34, 0x20, 0x44, 0x46, 0x54, 0x2C, 0x05, 0x00, 0x20, 0x32, 0x02, 0x00, 0x00, 0x7C, 0x0B, 0x00,
+	0x20, 0x32, 0x02, 0x00, 0x00, 0x92, 0x08, 0x00, 0x20, 0x32, 0x02, 0x00, 0x00, 0xCC, 0x07, 0x00,
+	0x20, 0x32, 0x01, 0x00, 0x00, 0x1C, 0x0E, 0x00, 0x20, 0x32, 0x01, 0x00, 0x00, 0x32, 0x0B, 0x00,
+	0x20, 0x32, 0x01, 0x00, 0x00, 0x02, 0x00, 0x03, 0xBB, 0x04, 0x00, 0x05, 0x10, 0x06, 0x00, 0x07,
+	0x32, 0x08, 0x00, 0x09, 0x34, 0x0A, 0x00, 0x0B, 0x41, 0x0C, 0x00, 0x0D, 0x5B, 0x0E, 0x00, 0x0F,
+	0x7B, 0x10, 0x00, 0x11, 0x02, 0x12, 0x01, 0x13, 0x01, 0x18, 0x00, 0x19, 0x06, 0x1A, 0x68, 0x1B,
+	0xB6, 0x22, 0x08, 0x2F, 0x02, 0x30, 0x02, 0x31, 0x01, 0x3E, 0x00, 0x3F, 0xFF, 0x41, 0x02, 0x42,
+	0x09, 0x49, 0x07, 0x4A, 0x00, 
+	0x00, 0x01, 0xBF, 0x00, 0x80, 0x4B, 0x0E, 0x4C, 0x02, 0x4D, 0x0E, 0x4E, 0x04, 0x4F, 0x08, 0x50,
+	0x05, 0x51, 0x04, 0x52, 0x85, 0x53, 0x02, 0x54, 0x06, 0x55, 0x03, 0x58, 0x00, 0x59, 0x00, 0x5A,
+	0x00, 0x4A, 0x01, 0x00, 0x00, 0x5F, 0x02, 0x00, 0x20, 0x4B, 0x01, 0x00, 0x00, 0x66, 0x02, 0x00,
+	0x20, 0x4C, 0x02, 0x00, 0x00, 0x70, 0x02, 0x00, 0x20, 0x4D, 0x01, 0x00, 0x00, 0x5D, 0x02, 0x00,
+	0x20, 0x4E, 0x02, 0x00, 0x00, 0x6E, 0x02, 0x00, 0x20, 0x4F, 0x01, 0x00, 0x00, 0x5E, 0x02, 0x00,
+	0x20, 0x50, 0x01, 0x00, 0x00, 0x60, 0x02, 0x00, 0x20, 0x51, 0x01, 0x00, 0x00, 0xE0, 0x01, 0x00,
+	0x20, 0x52, 0x02, 0x00, 0x00, 0xEE, 0x02, 0x00, 0x20, 0x53, 0x02, 0x00, 0x00, 0x76, 0x02, 0x00,
+	0x20, 0x81, 0x01, 0x00, 0x00, 0x61, 0x02, 0x00, 0x20, 0x82, 0x01, 0x00, 0x00, 0x62, 0x02, 0x00,
+	0x20, 0x28, 0x00, 0x2C, 0x00, 
+	0x00, 0x01, 0xC0, 0x00, 0x80, 0x30, 0x00, 0x34, 0x00, 0x38, 0x00, 0x3C, 0x00, 0x40, 0x00, 0x44,
+	0x00, 0x4C, 0x00, 0x54, 0x00, 0x5C, 0x00, 0x64, 0x00, 0x70, 0x00, 0x7C, 0x00, 0x88, 0x00, 0x98,
+	0x00, 0xA8, 0x00, 0xBC, 0x00, 0xD0, 0x00, 0xE8, 0x00, 0x00, 0x01, 0x1C, 0x01, 0x3C, 0x01, 0x60,
+	0x01, 0x88, 0x01, 0xB4, 0x01, 0xE8, 0x01, 0x20, 0x02, 0x60, 0x02, 0xA8, 0x02, 0xF8, 0x02, 0x50,
+	0x03, 0xC6, 0x08, 0x27, 0x09, 0x58, 0x09, 0x89, 0x09, 0xEB, 0x09, 0x4C, 0x0A, 0xAE, 0x0A, 0x10,
+	0x0B, 0x71, 0x0B, 0xD3, 0x0B, 0x35, 0x0C, 0x96, 0x0C, 0xF8, 0x0C, 0x59, 0x0D, 0xBB, 0x0D, 0x1D,
+	0x0E, 0x19, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20, 0x21, 0x22, 0x23, 0x25, 0x26, 0x27, 0x28, 0x29,
+	0x2A, 0x2B, 0x2E, 0x2F, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14,
+	0x40, 0x00, 0x10, 0x14, 0x40, 
+	0x00, 0x01, 0xC1, 0x00, 0x80, 0x4F, 0xD8, 0x00, 0x00, 0x4F, 0xD8, 0x00, 0x00, 0x4F, 0xD8, 0x00,
+	0x00, 0x4F, 0xD8, 0x00, 0x00, 0x4F, 0xD8, 0x00, 0x00, 0x4F, 0xD8, 0x00, 0x00, 0x4F, 0xD8, 0x00,
+	0x00, 0xEA, 0x03, 0xEA, 0x03, 0xEA, 0x03, 0xEA, 0x03, 0xEA, 0x03, 0xEA, 0x03, 0xEA, 0x03, 0xEA,
+	0x03, 0x0A, 0x03, 0x00, 0x00, 0x0A, 0x03, 0x00, 0x00, 0x0A, 0x01, 0x0A, 0x01, 0x0A, 0x01, 0x0A,
+	0x01, 0x0A, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x0A, 0x00, 0xE4, 0x03, 0xE4, 0x03, 0xE4, 0x03, 0xE4,
+	0x03, 0x04, 0x03, 0x04, 0x03, 0x04, 0x03, 0x04, 0x03, 0x04, 0x01, 0x04, 0x01, 0x04, 0x01, 0x04,
+	0x01, 0x04, 0x00, 0x04, 0x00, 0x04, 0x00, 0x04, 0x00, 0xE2, 0x03, 0xE2, 0x03, 0xE2, 0x03, 0xE2,
+	0x03, 0x02, 0x03, 0x02, 0x03, 0x02, 0x03, 0x02, 0x03, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02,
+	0x01, 0x02, 0x00, 0x02, 0x00, 
+	0x00, 0x01, 0xC2, 0x00, 0x80, 0x02, 0x00, 0x02, 0x00, 0x0A, 0x00, 0x0A, 0x00, 0x0A, 0x00, 0x0A,
+	0x00, 0x0A, 0x00, 0x0A, 0x00, 0x0A, 0x00, 0x0A, 0x03, 0x0A, 0x03, 0xEA, 0x03, 0x0A, 0x03, 0x00,
+	0x00, 0x02, 0x00, 0x02, 0x03, 0xEA, 0x03, 0x0A, 0x03, 0x0A, 0x03, 0x0A, 0x01, 0x05, 0x00, 0x0A,
+	0x00, 0x05, 0x01, 0x00, 0x00, 0x0A, 0x03, 0x05, 0x00, 0x05, 0x01, 0x00, 0x00, 0x0A, 0x03, 0x0A,
+	0x00, 0x0A, 0x01, 0x2A, 0x03, 0x2A, 0x03, 0x00, 0x00, 0x00, 0x00, 0xEA, 0x03, 0xEA, 0x03, 0xEA,
+	0x03, 0x02, 0x00, 0x04, 0x00, 0x02, 0x00, 0x04, 0x00, 0x00, 0x00, 0x02, 0x00, 0x04, 0x00, 0x00,
+	0x00, 0x8C, 0xE1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x80, 0x00, 0x00, 0x00, 0xC4, 0x12, 0x00,
+	0x00, 0x0C, 0xE2, 0x00, 0x00, 0x84, 0x00, 0x00, 0x20, 0x9C, 0x02, 0x00, 0x00, 0x36, 0xDC, 0x00,
+	0x00, 0x78, 0xE2, 0x00, 0x00, 
+	0x00, 0x01, 0xC3, 0x00, 0x80, 0x20, 0x03, 0x00, 0x20, 0x98, 0x17, 0x00, 0x00, 0xE0, 0x12, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 
+	0x00, 0x01, 0xC4, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x01, 0x48, 0x03, 0x1F, 0xD1, 0x24, 0x02, 0x3A, 0x03, 0x1A, 0x01, 0x02, 0x81, 0x13, 0x17,
+	0x08, 0x1B, 0x20, 0x18, 0x04, 0x1A, 0x16, 0x04, 0x1A, 0x36, 0x04, 0x1A, 0x37, 0x04, 0x1A, 0x35,
+	0x04, 0x1A, 0x55, 0x04, 0x1A, 0x56, 0x04, 0x1A, 0x54, 0x04, 0x1A, 0x74, 0x04, 0x1A, 0x75, 0x04,
+	0x1A, 0x73, 0x04, 0x41, 0x0B, 0x25, 0x64, 0xE8, 0x68, 0x59, 0xC4, 0x39, 0x07, 0x46, 0x51, 0x25,
+	0x02, 0xA0, 0x8C, 0x03, 0x28, 0x50, 0x46, 0x4B, 0xC6, 0x0E, 0x70, 0x01, 0x30, 0x5A, 0xFF, 0x01,
+	0x01, 0x28, 0x0A, 0x3D, 0x01, 0x20, 0x79, 0x78, 0x0A, 0x2E, 0x07, 0x02, 0x09, 0x1E, 0xC8, 0x01,
+	0x1A, 0x32, 0x24, 0x45, 0xD0, 0xF1, 0xFF, 0x0F, 0x0B, 0x24, 0x74, 0xE7, 0xA7, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 
+	0x00, 0x01, 0xC5, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 
+	0x00, 0x01, 0xC6, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 
+	0x00, 0x01, 0xC7, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 
+	0x00, 0x01, 0xC8, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 
+	0x00, 0x01, 0xC9, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 
+	0x00, 0x01, 0xCA, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 
+	0x00, 0x01, 0xCB, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 
+	0x00, 0x01, 0xCC, 0x00, 0x80, 0xFC, 0x07, 0xFC, 0x07, 0x4C, 0x00, 0x00, 0x00, 0x04, 0x00, 0x01,
+	0x24, 0xEC, 0x1D, 0x80, 0x34, 0x10, 0x00, 0x80, 0x0C, 0x03, 0x00, 0x14, 0x00, 0xE8, 0x03, 0x00,
+	0x00, 0x32, 0x08, 0xF4, 0x01, 0x1E, 0x00, 0x00, 0x00, 0x88, 0x13, 0x96, 0x00, 0x96, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x05, 0x02, 0x10, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 
+	0x00, 0x01, 0xCD, 0x00, 0x80, 0x70, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00,
+	0x00, 0x64, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,
+	0x00, 0x01, 0x00, 0x00, 0x00, 0xD0, 0x07, 0x00, 0x00, 0xE8, 0x03, 0x00, 0x00, 0x64, 0x00, 0x00,
+	0x00, 0xD8, 0xFF, 0xFF, 0xFF, 0x01, 0x00, 0x00, 0x00, 0xA0, 0x0F, 0x00, 0x00, 0x48, 0xF4, 0xFF,
+	0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00,
+	0x00, 0x14, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0xD0, 0x07, 0x00, 0x00, 0x01, 0x00, 0x00,
+	0x00, 0xA0, 0x00, 0xC4, 0xFF, 0xA0, 0x00, 0xC4, 0xFF, 0x06, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x0A, 0x0A, 0xD0, 0x07, 0xC8, 0x00, 0xC8, 0x00, 0x64, 0x00, 0x14,
+	0x00, 0x20, 0x03, 0x05, 0x05, 
+	0x00, 0x01, 0xCE, 0x00, 0x80, 0x64, 0x00, 0x00, 0x01, 0xE8, 0x03, 0xDC, 0x05, 0x0A, 0x02, 0x08,
+	0x0A, 0xB8, 0x0B, 0xE8, 0x03, 0x50, 0x14, 0x08, 0x06, 0x0A, 0x0A, 0x28, 0x00, 0x0A, 0x00, 0xFF,
+	0x00, 0x03, 0x01, 0x28, 0x00, 0x02, 0x0A, 0x0A, 0x00, 0xFE, 0x00, 0xC8, 0x00, 0x64, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x02, 0x3C, 0x00, 0xE8, 0x03, 0x0C, 0x03, 0x3C, 0x00, 0xE8,
+	0x03, 0x0C, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x1C, 0x00, 0x00, 0x00, 0xF0, 0x02, 0x00, 0x01, 0x32, 0x00, 0xFF,
+	0x00, 0xF0, 0x02, 0x00, 0x02, 
+	0x00, 0x01, 0xCF, 0x00, 0x80, 0x32, 0x00, 0xFF, 0x00, 0x01, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0xC3, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x02, 0x28, 0x0F, 0x96, 0x96, 0xFA, 0x00, 0x96, 0x00, 0x0F,
+	0x0C, 0xD0, 0x02, 0x00, 0x00, 0x6E, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00,
+	0x00, 0x01, 0x00, 0x2C, 0x01, 0x64, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x05, 0x70, 0x00, 0x97,
+	0x00, 0x6E, 0xFF, 0xC2, 0x01, 
+	0x00, 0x01, 0xD0, 0x00, 0x80, 0xD7, 0xFF, 0xCF, 0xFF, 0x9C, 0xFF, 0xD9, 0xFF, 0xDC, 0xFF, 0xDC,
+	0xFF, 0x4F, 0xFF, 0x07, 0x00, 0x91, 0xFF, 0x14, 0xFF, 0xB3, 0x00, 0x40, 0x1E, 0xC8, 0x32, 0xA0,
+	0x0F, 0x04, 0x01, 0x04, 0x01, 0x0E, 0x0E, 0x58, 0x01, 0x1E, 0x00, 0x14, 0x00, 0x02, 0x1E, 0x58,
+	0x1B, 0x70, 0x17, 0x64, 0x00, 0x05, 0x00, 0x02, 0x0A, 0xB0, 0x04, 0x96, 0x00, 0x02, 0x03, 0x0A,
+	0x01, 0x00, 0x00, 0x00, 0x00, 0x0B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x1A, 0x00, 0x00, 0x00, 0x77, 0x00, 0x00, 0x05, 0x00, 0x0F, 0x00,
+	0x14, 0x00, 0x0A, 0x00, 0x00, 0x77, 0x77, 0x01, 0x05, 0x00, 0x0F, 0x01, 0x14, 0x01, 0x14, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 
+	0x00, 0x01, 0xD1, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x0A, 0x14,
+	0x03, 0x96, 0x00, 0x64, 0x00, 0x08, 0x00, 0x0F, 0x00, 0x14, 0x00, 0x02, 0x0A, 0x0A, 0x01, 0x0A,
+	0x96, 0x50, 0x50, 0x50, 0x50, 0x50, 0xFA, 0x96, 0x0C, 0x0C, 0x0C, 0x28, 0x00, 0x02, 0x03, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0xA8, 0x01, 0x00, 0x00, 0x05, 0x04, 0xFF, 0x81, 0x02, 0x06, 0x00,
+	0x00, 0xCF, 0x00, 0xAF, 0xC0, 0xFF, 0xFF, 0xB0, 0x00, 0x22, 0x02, 0x7F, 0x81, 0x7F, 0x72, 0x01,
+	0x80, 0x01, 0x81, 0x40, 0x04, 0x5F, 0x0C, 0x5F, 0x0C, 0x12, 0x01, 0x01, 0x00, 0x04, 0x01, 0x08,
+	0x10, 0x01, 0x04, 0x00, 0x00, 0x44, 0x01, 0x02, 0x80, 0x01, 0x01, 0x00, 0x00, 0x80, 0x00, 0x01,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x90, 0x80, 0x00, 0xFF, 0x07, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 
+	0x00, 0x01, 0xD2, 0x00, 0x80, 0x3A, 0xA0, 0x00, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x05, 0x04, 0xFF,
+	0x81, 0x03, 0x0A, 0x00, 0x00, 0x8F, 0x02, 0xAF, 0x80, 0xFF, 0xFF, 0xD0, 0x00, 0x22, 0x02, 0x7F,
+	0x81, 0x7F, 0x72, 0x01, 0x80, 0x01, 0x81, 0x40, 0x04, 0x78, 0x11, 0x78, 0x11, 0x12, 0x01, 0x01,
+	0x00, 0x04, 0x01, 0x08, 0x10, 0x01, 0x04, 0x00, 0x00, 0x44, 0x01, 0x02, 0x80, 0x01, 0x01, 0x00,
+	0x00, 0x80, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x90, 0x80, 0x00, 0xFF,
+	0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3A, 0xA6, 0x00, 0xF0, 0x00, 0x00, 0x00,
+	0x00, 0x05, 0x04, 0xFF, 0x80, 0x02, 0x04, 0x00, 0x00, 0xAF, 0x08, 0xAF, 0xC0, 0xFF, 0xFF, 0xB0,
+	0x00, 0x22, 0x02, 0x7F, 0x81, 0x7F, 0x72, 0x01, 0x80, 0x01, 0x81, 0x40, 0x04, 0x64, 0x0F, 0x64,
+	0x0F, 0x11, 0x01, 0x01, 0x00, 
+	0x00, 0x01, 0xD3, 0x00, 0x80, 0x04, 0x01, 0x08, 0x10, 0x01, 0x04, 0x00, 0x00, 0x44, 0x01, 0x02,
+	0x80, 0x01, 0x01, 0x00, 0x00, 0x80, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00,
+	0x90, 0x80, 0x00, 0xFF, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3A, 0xA0, 0x00,
+	0xD0, 0x00, 0x00, 0x00, 0x00, 0x05, 0x04, 0xFF, 0x80, 0x02, 0x04, 0x00, 0x00, 0xFF, 0x00, 0xAF,
+	0xC0, 0xFF, 0xFF, 0xB0, 0x00, 0x22, 0x02, 0x7F, 0x81, 0x7F, 0x72, 0x01, 0x80, 0x01, 0x81, 0x40,
+	0x04, 0x64, 0x0F, 0x64, 0x0F, 0x11, 0x01, 0x01, 0x00, 0x04, 0x01, 0x08, 0x10, 0x01, 0x04, 0x00,
+	0x00, 0x44, 0x01, 0x02, 0x80, 0x01, 0x01, 0x00, 0x00, 0x80, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x01, 0x01, 0x00, 0x90, 0x80, 0x00, 0xFF, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x3A, 0xA0, 0x00, 0xD0, 
+	0x00, 0x01, 0xD4, 0x00, 0x80, 0x08, 0x04, 0x00, 0x00, 0x32, 0x00, 0x30, 0x30, 0x40, 0x03, 0x07,
+	0x40, 0x18, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x25, 0x00, 0x00, 0x00, 0x38, 0x01, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00,
+	0x00, 0x06, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0xE8, 0x03, 0x00, 0x00, 0xE8, 0x03, 0x00,
+	0x00, 0x64, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00,
+	0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00,
+	0x00, 0x6E, 0x56, 0x32, 0x01, 0x04, 0x00, 0x00, 0x00, 0x01, 0x01, 0xB8, 0x0B, 0x40, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 
+	0x00, 0x01, 0xD5, 0x00, 0x80, 0x34, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,
+	0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x37, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00,
+	0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0xC0, 0xF9, 0xA0,
+	0xF6, 0x90, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 
+	0x00, 0x01, 0xD6, 0x00, 0x80, 0x25, 0x24, 0x22, 0x18, 0x16, 0x13, 0x14, 0x11, 0x12, 0x17, 0x15,
+	0x19, 0x23, 0x30, 0x2F, 0x2C, 0x2B, 0x28, 0x27, 0x0F, 0x0E, 0x0B, 0x0A, 0x07, 0x06, 0x31, 0x2E,
+	0x2D, 0x2A, 0x29, 0x26, 0x10, 0x0D, 0x0C, 0x09, 0x08, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x0F, 0x30, 0x0F, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
+	0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 
+	0x00, 0x01, 0xD7, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x1F, 0x00, 0xFE, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x07, 0xFC,
+	0x07, 0x80, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 
+	0x00, 0x01, 0xD8, 0x00, 0x80, 0x7F, 0x00, 0x07, 0x05, 0x03, 0x07, 0x02, 0x05, 0x01, 0x00, 0x04,
+	0x00, 0x00, 0x0B, 0x0B, 0x0B, 0x09, 0x0B, 0x0B, 0x0A, 0x0F, 0x0F, 0xBE, 0x00, 0x06, 0x05, 0x00,
+	0x0B, 0x08, 0x0C, 0x06, 0x0A, 0x00, 0x09, 0x00, 0x0F, 0x0B, 0x0A, 0x0A, 0x09, 0x0A, 0x0F, 0x0A,
+	0x0F, 0xFF, 0x00, 0x08, 0x05, 0x0D, 0x19, 0x16, 0x10, 0x0F, 0x1B, 0x14, 0x0E, 0x00, 0x0B, 0x0A,
+	0x0B, 0x0B, 0x0B, 0x0B, 0x09, 0x0A, 0x0F, 0xFF, 0x00, 0x08, 0x05, 0x11, 0x1D, 0x1C, 0x15, 0x21,
+	0x20, 0x18, 0x12, 0x00, 0x0B, 0x0B, 0x0B, 0x0B, 0x0A, 0x0A, 0x0A, 0x0B, 0x0F, 0xE3, 0x00, 0x05,
+	0x30, 0x1F, 0x22, 0x00, 0x00, 0x00, 0x24, 0x1A, 0x13, 0x00, 0x0B, 0x0B, 0x0F, 0x0F, 0x0F, 0x0A,
+	0x0A, 0x0A, 0x0F, 0xC1, 0x00, 0x03, 0x05, 0x23, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1E, 0x17, 0x00,
+	0x0B, 0x0F, 0x0F, 0x0F, 0x0F, 
+	0x00, 0x01, 0xD9, 0x00, 0x80, 0x0F, 0x0B, 0x0A, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 
+	0x00, 0x01, 0xDA, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 
+	0x00, 0x01, 0xDB, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x62, 0x65, 0x00, 0x00, 
+	0x00, 0x01, 0xDC, 0x00, 0x80, 0x24, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0xF3, 0xCC, 
+	0x00, 0x01, 0xFF, 0x00, 0x80, 0x3C, 0x00, 0x3C, 0x00, 0x00, 0x12, 0x00, 0x00, 0x00, 0xD4, 0xFB,
+	0xDB, 0x81, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x99, 0xD6, 0x00, 0x00, 0xF8, 0x25, 0x13, 0x00, 0x00, 0x23, 0x00, 0x00, 0x00, 0xC0, 0xED,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 
+	
+};
+/* DTS2013012402104 houming 20130124 end >*/
+/* DTS2013050605374 shenjinming 20130508 end > */
\ No newline at end of file
diff --git a/drivers/input/touchscreen/cypress/cyttsp4_loader.c b/drivers/input/touchscreen/cypress/cyttsp4_loader.c
new file mode 100644
index 0000000..cd882be
--- /dev/null
+++ b/drivers/input/touchscreen/cypress/cyttsp4_loader.c
@@ -0,0 +1,1883 @@
+/*
+ * cyttsp4_loader.c
+ * Cypress TrueTouch(TM) Standard Product V4 FW loader module.
+ * For use with Cypress Txx4xx parts.
+ * Supported parts include:
+ * TMA4XX
+ * TMA1036
+ *
+ * Copyright (C) 2009-2012 Cypress Semiconductor, Inc.
+ * Copyright (C) 2011 Motorola Mobility, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2, and only version 2, as published by the
+ * Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * Contact Cypress Semiconductor at www.cypress.com <ttdrivers@cypress.com>
+ *
+ */
+
+#include <asm/unaligned.h>
+#include <linux/delay.h>
+#include <linux/gpio.h>
+#include <linux/interrupt.h>
+#include <linux/pm_runtime.h>
+#include <linux/slab.h>
+#include <linux/firmware.h>
+#include <linux/cyttsp4_bus.h>
+#include <linux/cyttsp4_core.h>
+#include "cyttsp4_regs.h"
+
+#define CYTTSP4_LOADER_NAME "cyttsp4_loader"
+#define CYTTSP4_AUTO_LOAD_FOR_CORRUPTED_FW 1
+
+#define CYTTSP4_FW_UPGRADE \
+	(defined(CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_PLATFORM_FW_UPGRADE) \
+	|| defined(CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_BINARY_FW_UPGRADE))
+
+#define CYTTSP4_TTCONFIG_UPGRADE \
+	(defined(CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_PLATFORM_TTCONFIG_UPGRADE) \
+	|| defined(CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_MANUAL_TTCONFIG_UPGRADE))
+
+/* Timeout values in ms. */
+#define CY_CMD_TIMEOUT					500
+#define CY_CMD_LDR_INIT_TIMEOUT				10000
+#define CY_LDR_REQUEST_EXCLUSIVE_TIMEOUT		5000
+
+#define CY_CMD_BYTE					1
+#define CY_STATUS_BYTE					1
+#define CY_MAX_STATUS_SIZE				32
+#define CY_START_OF_PACKET				0x01
+#define CY_END_OF_PACKET				0x17
+#define CY_DATA_ROW_SIZE				288
+#define CY_DATA_ROW_SIZE_TMA400				128
+#define CY_PACKET_DATA_LEN				96
+#define CY_MAX_PACKET_LEN				512
+#define CY_COMM_BUSY					0xFF
+#define CY_CMD_BUSY					0xFE
+#define CY_ARRAY_ID_OFFSET				0
+#define CY_ROW_NUM_OFFSET				1
+#define CY_ROW_SIZE_OFFSET				3
+#define CY_ROW_DATA_OFFSET				5
+#define CY_CMD_LDR_HOST_SYNC				0xFF /* tma400 */
+#define CY_CMD_LDR_EXIT					0x3B
+#define CY_CMD_LDR_EXIT_CMD_SIZE			7
+#define CY_CMD_LDR_EXIT_STAT_SIZE			7
+#define CY_CMD_LDR_ENTER				0x38
+#define CY_CMD_LDR_ENTER_CMD_SIZE			7
+#define CY_CMD_LDR_ENTER_STAT_SIZE			15
+#define CY_CMD_LDR_INIT					0x48
+#define CY_CMD_LDR_INIT_CMD_SIZE			15
+#define CY_CMD_LDR_INIT_STAT_SIZE			7
+#define CY_CMD_LDR_ERASE_ROW				0x34
+#define CY_CMD_LDR_ERASE_ROW_CMD_SIZE			10
+#define CY_CMD_LDR_ERASE_ROW_STAT_SIZE			7
+#define CY_CMD_LDR_SEND_DATA				0x37
+#define CY_CMD_LDR_SEND_DATA_CMD_SIZE			4 /* hdr bytes only */
+#define CY_CMD_LDR_SEND_DATA_STAT_SIZE			8
+#define CY_CMD_LDR_PROG_ROW				0x39
+#define CY_CMD_LDR_PROG_ROW_CMD_SIZE			7 /* hdr bytes only */
+#define CY_CMD_LDR_PROG_ROW_STAT_SIZE			7
+#define CY_CMD_LDR_VERIFY_ROW				0x3A
+#define CY_CMD_LDR_VERIFY_ROW_STAT_SIZE			8
+#define CY_CMD_LDR_VERIFY_ROW_CMD_SIZE			10
+#define CY_CMD_LDR_VERIFY_CHKSUM			0x31
+#define CY_CMD_LDR_VERIFY_CHKSUM_CMD_SIZE		7
+#define CY_CMD_LDR_VERIFY_CHKSUM_STAT_SIZE		8
+
+struct cyttsp4_loader_data {
+	struct cyttsp4_device *ttsp;
+	struct cyttsp4_sysinfo *si;
+	u8 status_buf[CY_MAX_STATUS_SIZE];
+	struct completion int_running;
+#ifdef CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_BINARY_FW_UPGRADE
+	struct completion builtin_bin_fw_complete;
+	int builtin_bin_fw_status;
+#endif
+	struct work_struct fw_and_config_upgrade;
+	struct work_struct calibration_work;
+	struct cyttsp4_loader_platform_data *loader_pdata;
+#ifdef CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_MANUAL_TTCONFIG_UPGRADE
+	struct mutex config_lock;
+	u8 *config_data;
+	int config_size;
+	bool config_loading;
+#endif
+};
+
+struct cyttsp4_dev_id {
+	u32 silicon_id;
+	u8 rev_id;
+	u32 bl_ver;
+};
+
+enum ldr_status {
+	ERROR_SUCCESS = 0,
+	ERROR_COMMAND = 1,
+	ERROR_FLASH_ARRAY = 2,
+	ERROR_PACKET_DATA = 3,
+	ERROR_PACKET_LEN = 4,
+	ERROR_PACKET_CHECKSUM = 5,
+	ERROR_FLASH_PROTECTION = 6,
+	ERROR_FLASH_CHECKSUM = 7,
+	ERROR_VERIFY_IMAGE = 8,
+	ERROR_UKNOWN1 = 9,
+	ERROR_UKNOWN2 = 10,
+	ERROR_UKNOWN3 = 11,
+	ERROR_UKNOWN4 = 12,
+	ERROR_UKNOWN5 = 13,
+	ERROR_UKNOWN6 = 14,
+	ERROR_INVALID_COMMAND = 15,
+	ERROR_INVALID
+};
+
+#if CYTTSP4_FW_UPGRADE || CYTTSP4_TTCONFIG_UPGRADE
+/*
+ * return code:
+ * -1: Firmware version compared is older
+ *  0: Firmware version compared is identical
+ *  1: Firmware version compared is newer
+ */
+static int cyttsp4_check_firmware_version(struct cyttsp4_device *ttsp,
+		u32 fw_ver_new, u32 fw_revctrl_new_h, u32 fw_revctrl_new_l)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_loader_data *data = dev_get_drvdata(dev);
+	u32 fw_ver_img;
+	u32 fw_revctrl_img_h;
+	u32 fw_revctrl_img_l;
+
+	fw_ver_img = data->si->si_ptrs.cydata->fw_ver_major << 8;
+	fw_ver_img += data->si->si_ptrs.cydata->fw_ver_minor;
+
+	dev_dbg(dev, "%s: img vers:0x%04X new vers:0x%04X\n", __func__,
+			fw_ver_img, fw_ver_new);
+
+	if (fw_ver_new > fw_ver_img)
+		return 1;
+
+	if (fw_ver_new < fw_ver_img)
+		return -1;
+
+	fw_revctrl_img_h = be32_to_cpu(
+		*(u32 *)(data->si->si_ptrs.cydata->revctrl + 0));
+
+	dev_dbg(dev, "%s: img revctrl_h:0x%04X new revctrl_h:0x%04X\n",
+			__func__, fw_revctrl_img_h, fw_revctrl_new_h);
+
+	if (fw_revctrl_new_h > fw_revctrl_img_h)
+		return 1;
+
+	if (fw_revctrl_new_h < fw_revctrl_img_h)
+		return -1;
+
+	fw_revctrl_img_l = be32_to_cpu(
+		*(u32 *)(data->si->si_ptrs.cydata->revctrl + 4));
+
+	dev_dbg(dev, "%s: img revctrl_l:0x%04X new revctrl_l:0x%04X\n",
+			__func__, fw_revctrl_img_l, fw_revctrl_new_l);
+
+	if (fw_revctrl_new_l > fw_revctrl_img_l)
+		return 1;
+
+	if (fw_revctrl_new_l < fw_revctrl_img_l)
+		return -1;
+
+	return 0;
+}
+#endif /* CYTTSP4_FW_UPGRADE || CYTTSP4_TTCONFIG_UPGRADE */
+
+
+#if CYTTSP4_FW_UPGRADE
+static u16 _cyttsp4_compute_crc(struct cyttsp4_device *ttsp, u8 *buf, int size)
+{
+	u16 crc = 0xffff;
+	u16 tmp;
+	int i;
+
+	if (size == 0)
+		crc = ~crc;
+	else {
+
+		do {
+			for (i = 0, tmp = 0x00ff & *buf++; i < 8;
+				i++, tmp >>= 1) {
+				if ((crc & 0x0001) ^ (tmp & 0x0001))
+					crc = (crc >> 1) ^ 0x8408;
+				else
+					crc >>= 1;
+			}
+		} while (--size);
+
+		crc = ~crc;
+		tmp = crc;
+		crc = (crc << 8) | (tmp >> 8 & 0xFF);
+	}
+
+	return crc;
+}
+
+static u16 _cyttsp4_get_short(u8 *buf)
+{
+	return ((u16)(*buf) << 8) + *(buf+1);
+}
+
+static u8 *_cyttsp4_get_row(struct cyttsp4_device *ttsp,
+			    u8 *row_buf, u8 *image_buf, int size)
+{
+	memcpy(row_buf, image_buf, size);
+	image_buf = image_buf + size;
+	return image_buf;
+}
+
+static int _cyttsp4_get_status(struct cyttsp4_device *ttsp,
+			       u8 *buf, int size, unsigned long timeout_ms)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_loader_data *data = dev_get_drvdata(dev);
+
+	unsigned long uretval;
+	int tries;
+	int retval = 0;
+
+	if (timeout_ms != 0) {
+		/* wait until status ready interrupt or timeout occurs */
+		uretval = wait_for_completion_timeout(
+			&data->int_running, msecs_to_jiffies(timeout_ms));
+
+		/* TODO: Reconsider purpose of having retries here */
+		for (tries = 0; tries < 2; tries++) {
+			retval = cyttsp4_read(ttsp, CY_MODE_BOOTLOADER,
+					      CY_REG_BASE, buf, size);
+			/*
+			 * retry if bus read error or
+			 * status byte shows not ready
+			 */
+			if (buf[1] == CY_COMM_BUSY || buf[1] == CY_CMD_BUSY)
+				msleep(20); /* TODO: Constant if code kept */
+			else
+				break;
+		}
+		dev_vdbg(dev,
+			"%s: tries=%d ret=%d status=%02X\n",
+			__func__, tries, retval, buf[1]);
+	}
+
+	return retval;
+}
+
+static int _cyttsp4_send_cmd(struct cyttsp4_device *ttsp, const u8 *cmd_buf,
+			     int cmd_size, u8 *stat_ret, size_t num_stat_byte,
+			     size_t status_size, unsigned long timeout_ms)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_loader_data *data = dev_get_drvdata(dev);
+
+	u8 *status_buf = data->status_buf;
+	int retval = 0;
+
+	if (cmd_buf == NULL)
+		goto _cyttsp4_send_cmd_exit;
+
+	if (cmd_size == 0)
+		goto _cyttsp4_send_cmd_exit;
+
+	if (timeout_ms > 0)
+		INIT_COMPLETION(data->int_running);
+	retval = cyttsp4_write(ttsp, CY_MODE_BOOTLOADER,
+			       CY_REG_BASE, cmd_buf, cmd_size);
+	if (retval < 0) {
+		dev_err(dev,
+			"%s: Fail writing command=%02X\n",
+			__func__, cmd_buf[CY_CMD_BYTE]);
+		goto _cyttsp4_send_cmd_exit;
+	}
+
+	if (timeout_ms > 0) {
+		memset(status_buf, 0, sizeof(data->status_buf));
+		retval = _cyttsp4_get_status(ttsp, status_buf,
+			status_size, timeout_ms);
+		if (retval < 0 || status_buf[0] != CY_START_OF_PACKET) {
+			dev_err(dev,
+				"%s: Error getting status r=%d"
+				" status_buf[0]=%02X\n",
+				__func__, retval, status_buf[0]);
+			if (!(retval < 0))
+				retval = -EIO;
+			goto _cyttsp4_send_cmd_exit;
+		} else {
+			if (status_buf[CY_STATUS_BYTE] != ERROR_SUCCESS) {
+				dev_err(dev,
+					"%s: Status=0x%02X error\n",
+					__func__, status_buf[CY_STATUS_BYTE]);
+				retval = -EIO;
+			} else if (stat_ret != NULL) {
+				if (num_stat_byte < status_size)
+					*stat_ret = status_buf[num_stat_byte];
+				else
+					*stat_ret = 0;
+			}
+		}
+	} else {
+		if (stat_ret != NULL)
+			*stat_ret = ERROR_SUCCESS;
+	}
+
+_cyttsp4_send_cmd_exit:
+	return retval;
+}
+
+static int _cyttsp4_ldr_enter(struct cyttsp4_device *ttsp,
+		struct cyttsp4_dev_id *dev_id)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_loader_data *data = dev_get_drvdata(dev);
+
+	u16 crc = 0;
+	int i = 0;
+	size_t cmd_size = 0;
+	u8 *status_buf = &data->status_buf[0];
+	u8 status = 0;
+	int retval;
+	/* +1 for TMA400 host sync byte */
+	u8 ldr_enter_cmd[CY_CMD_LDR_ENTER_CMD_SIZE+1];
+	memset(status_buf, 0, sizeof(data->status_buf));
+	dev_id->bl_ver = 0;
+	dev_id->rev_id = 0;
+	dev_id->silicon_id = 0;
+
+	ldr_enter_cmd[i++] = CY_CMD_LDR_HOST_SYNC;
+	ldr_enter_cmd[i++] = CY_START_OF_PACKET;
+	ldr_enter_cmd[i++] = CY_CMD_LDR_ENTER;
+	ldr_enter_cmd[i++] = 0x00;	/* data len lsb */
+	ldr_enter_cmd[i++] = 0x00;	/* data len msb */
+	crc = _cyttsp4_compute_crc(ttsp, &ldr_enter_cmd[1], i - 1);
+	cmd_size = sizeof(ldr_enter_cmd);
+	ldr_enter_cmd[i++] = (u8)crc;
+	ldr_enter_cmd[i++] = (u8)(crc >> 8);
+	ldr_enter_cmd[i++] = CY_END_OF_PACKET;
+
+	INIT_COMPLETION(data->int_running);
+
+	retval = cyttsp4_write(ttsp, CY_MODE_BOOTLOADER,
+		CY_REG_BASE, ldr_enter_cmd, cmd_size);
+	if (retval < 0) {
+		dev_err(dev,
+			"%s: write block failed %d\n", __func__, retval);
+		return retval;
+	}
+	retval = _cyttsp4_get_status(ttsp, status_buf,
+		CY_CMD_LDR_ENTER_STAT_SIZE, CY_CMD_TIMEOUT);
+
+	if (retval < 0) {
+		dev_err(dev,
+			"%s: Fail get status to Enter Loader command r=%d\n",
+			__func__, retval);
+		return retval;
+	}
+	status = status_buf[CY_STATUS_BYTE];
+	if (status == ERROR_SUCCESS) {
+		dev_id->bl_ver =
+			status_buf[11] << 16 |
+			status_buf[10] <<  8 |
+			status_buf[9] <<  0;
+		dev_id->rev_id =
+			status_buf[8] <<  0;
+		dev_id->silicon_id =
+			status_buf[7] << 24 |
+			status_buf[6] << 16 |
+			status_buf[5] <<  8 |
+			status_buf[4] <<  0;
+		retval = 0;
+	} else
+		retval = -EIO;
+	dev_vdbg(dev,
+		 "%s: status=%d "
+		 "bl_ver=%08X rev_id=%02X silicon_id=%08X\n",
+		 __func__, status,
+		 dev_id->bl_ver, dev_id->rev_id, dev_id->silicon_id);
+
+	return retval;
+}
+
+static int _cyttsp4_ldr_init(struct cyttsp4_device *ttsp)
+{
+	u16 crc;
+	int i = 0;
+	int retval = 0;
+	const u8 *cyttsp4_security_key;
+	int key_size;
+	/* +1 for TMA400 host sync byte */
+	u8 ldr_init_cmd[CY_CMD_LDR_INIT_CMD_SIZE+1];
+
+	cyttsp4_security_key = cyttsp4_get_security_key(ttsp, &key_size);
+
+	ldr_init_cmd[i++] = CY_CMD_LDR_HOST_SYNC;
+	ldr_init_cmd[i++] = CY_START_OF_PACKET;
+	ldr_init_cmd[i++] = CY_CMD_LDR_INIT;
+	ldr_init_cmd[i++] = 0x08;	/* data len lsb */
+	ldr_init_cmd[i++] = 0x00;	/* data len msb */
+	memcpy(&ldr_init_cmd[i], cyttsp4_security_key,
+			key_size);
+	i += key_size;
+	crc = _cyttsp4_compute_crc(ttsp, &ldr_init_cmd[1], i - 1);
+	ldr_init_cmd[i++] = (u8)crc;
+	ldr_init_cmd[i++] = (u8)(crc >> 8);
+	ldr_init_cmd[i++] = CY_END_OF_PACKET;
+
+	retval = _cyttsp4_send_cmd(ttsp, ldr_init_cmd, i, NULL, 0,
+				   CY_CMD_LDR_INIT_STAT_SIZE,
+				   CY_CMD_LDR_INIT_TIMEOUT);
+	if (retval < 0) {
+		dev_err(&ttsp->dev,
+			"%s: Fail ldr init r=%d\n",
+			__func__, retval);
+	}
+
+	return retval;
+}
+
+struct cyttsp4_hex_image {
+	u8 array_id;
+	u16 row_num;
+	u16 row_size;
+	u8 row_data[CY_DATA_ROW_SIZE];
+} __packed;
+
+static int _cyttsp4_ldr_parse_row(struct cyttsp4_device *ttsp, u8 *row_buf,
+	struct cyttsp4_hex_image *row_image)
+{
+	int retval = 0;
+
+	row_image->array_id = row_buf[CY_ARRAY_ID_OFFSET];
+	row_image->row_num = _cyttsp4_get_short(&row_buf[CY_ROW_NUM_OFFSET]);
+	row_image->row_size = _cyttsp4_get_short(&row_buf[CY_ROW_SIZE_OFFSET]);
+
+	if (row_image->row_size > ARRAY_SIZE(row_image->row_data)) {
+		dev_err(&ttsp->dev,
+			"%s: row data buffer overflow\n", __func__);
+		retval = -EOVERFLOW;
+		goto cyttsp4_ldr_parse_row_exit;
+	}
+
+	memcpy(row_image->row_data, &row_buf[CY_ROW_DATA_OFFSET],
+	       row_image->row_size);
+cyttsp4_ldr_parse_row_exit:
+	return retval;
+}
+
+static int _cyttsp4_ldr_prog_row(struct cyttsp4_device *ttsp,
+				 struct cyttsp4_hex_image *row_image)
+{
+	u16 crc;
+	int next;
+	int data;
+	int row_data;
+	u16 row_sum;
+	size_t data_len;
+	int retval = 0;
+
+	u8 *cmd = kzalloc(CY_MAX_PACKET_LEN, GFP_KERNEL);
+
+	if (cmd != NULL) {
+		row_data = 0;
+		row_sum = 0;
+		next = 0;
+		cmd[next++] = CY_CMD_LDR_HOST_SYNC;
+		cmd[next++] = CY_START_OF_PACKET;
+		cmd[next++] = CY_CMD_LDR_PROG_ROW;
+		/*
+		 * include array id size and row id size in CY_PACKET_DATA_LEN
+		 */
+		data_len = CY_DATA_ROW_SIZE_TMA400;
+		cmd[next++] = (u8)(data_len+3);
+		cmd[next++] = (u8)((data_len+3) >> 8);
+		cmd[next++] = row_image->array_id;
+		cmd[next++] = (u8)row_image->row_num;
+		cmd[next++] = (u8)(row_image->row_num >> 8);
+
+		for (data = 0;
+			data < data_len; data++) {
+			cmd[next] = row_image->row_data[row_data++];
+			row_sum += cmd[next];
+			next++;
+		}
+
+		crc = _cyttsp4_compute_crc(ttsp, &cmd[1], next - 1);
+		cmd[next++] = (u8)crc;
+		cmd[next++] = (u8)(crc >> 8);
+		cmd[next++] = CY_END_OF_PACKET;
+
+		retval = _cyttsp4_send_cmd(ttsp, cmd, next, NULL, 0,
+					   CY_CMD_LDR_PROG_ROW_STAT_SIZE,
+					   CY_CMD_TIMEOUT);
+
+		if (retval < 0) {
+			dev_err(&ttsp->dev,
+				"%s: prog row=%d fail r=%d\n",
+				__func__, row_image->row_num, retval);
+			goto cyttsp4_ldr_prog_row_exit;
+		}
+
+	} else {
+		dev_err(&ttsp->dev,
+			"%s prog row error - cmd buf is NULL\n", __func__);
+		retval = -EIO;
+	}
+
+cyttsp4_ldr_prog_row_exit:
+	kfree(cmd);
+	return retval;
+}
+
+static int _cyttsp4_ldr_verify_row(struct cyttsp4_device *ttsp,
+	struct cyttsp4_hex_image *row_image)
+{
+	u16 crc = 0;
+	int i = 0;
+	u8 verify_checksum;
+	int retval = 0;
+	/* +1 for TMA400 host sync byte */
+	u8 ldr_verify_row_cmd[CY_CMD_LDR_VERIFY_ROW_CMD_SIZE+1];
+
+	ldr_verify_row_cmd[i++] = CY_CMD_LDR_HOST_SYNC;
+	ldr_verify_row_cmd[i++] = CY_START_OF_PACKET;
+	ldr_verify_row_cmd[i++] = CY_CMD_LDR_VERIFY_ROW;
+	ldr_verify_row_cmd[i++] = 0x03;	/* data len lsb */
+	ldr_verify_row_cmd[i++] = 0x00;	/* data len msb */
+	ldr_verify_row_cmd[i++] = row_image->array_id;
+	ldr_verify_row_cmd[i++] = (u8)row_image->row_num;
+	ldr_verify_row_cmd[i++] = (u8)(row_image->row_num >> 8);
+	crc = _cyttsp4_compute_crc(ttsp, &ldr_verify_row_cmd[1], i - 1);
+	ldr_verify_row_cmd[i++] = (u8)crc;
+	ldr_verify_row_cmd[i++] = (u8)(crc >> 8);
+	ldr_verify_row_cmd[i++] = CY_END_OF_PACKET;
+
+	retval = _cyttsp4_send_cmd(ttsp, ldr_verify_row_cmd, i,
+				   &verify_checksum, 4,
+				   CY_CMD_LDR_VERIFY_ROW_STAT_SIZE,
+				   CY_CMD_TIMEOUT);
+
+	if (retval < 0) {
+		dev_err(&ttsp->dev,
+			"%s: verify row=%d fail r=%d\n",
+			__func__, row_image->row_num, retval);
+	}
+
+	return retval;
+}
+
+static int _cyttsp4_ldr_verify_chksum(struct cyttsp4_device *ttsp,
+	u8 *app_chksum)
+{
+	u16 crc = 0;
+	int i = 0;
+	int retval = 0;
+	/* +1 for TMA400 host sync byte */
+	u8 ldr_verify_chksum_cmd[CY_CMD_LDR_VERIFY_CHKSUM_CMD_SIZE+1];
+
+	ldr_verify_chksum_cmd[i++] = CY_CMD_LDR_HOST_SYNC;
+	ldr_verify_chksum_cmd[i++] = CY_START_OF_PACKET;
+	ldr_verify_chksum_cmd[i++] = CY_CMD_LDR_VERIFY_CHKSUM;
+	ldr_verify_chksum_cmd[i++] = 0x00;	/* data len lsb */
+	ldr_verify_chksum_cmd[i++] = 0x00;	/* data len msb */
+	crc = _cyttsp4_compute_crc(ttsp, &ldr_verify_chksum_cmd[1], i - 1);
+	ldr_verify_chksum_cmd[i++] = (u8)crc;
+	ldr_verify_chksum_cmd[i++] = (u8)(crc >> 8);
+	ldr_verify_chksum_cmd[i++] = CY_END_OF_PACKET;
+
+	retval = _cyttsp4_send_cmd(ttsp, ldr_verify_chksum_cmd, i,
+				   app_chksum, 4,
+				   CY_CMD_LDR_VERIFY_CHKSUM_STAT_SIZE,
+				   CY_CMD_TIMEOUT);
+
+	if (retval < 0) {
+		dev_err(&ttsp->dev,
+			"%s: verify checksum fail r=%d\n",
+			__func__, retval);
+	}
+
+	return retval;
+}
+
+/* Constructs loader exit command and sends via _cyttsp4_send_cmd() */
+static int _cyttsp4_ldr_exit(struct cyttsp4_device *ttsp)
+{
+	struct device *dev = &ttsp->dev;
+	u16 crc = 0;
+	int i = 0;
+	int retval;
+	/* +1 for TMA400 host sync byte */
+	u8 ldr_exit_cmd[CY_CMD_LDR_EXIT_CMD_SIZE+1];
+
+	ldr_exit_cmd[i++] = CY_CMD_LDR_HOST_SYNC;
+	ldr_exit_cmd[i++] = CY_START_OF_PACKET;
+	ldr_exit_cmd[i++] = CY_CMD_LDR_EXIT;
+	ldr_exit_cmd[i++] = 0x00;	/* data len lsb */
+	ldr_exit_cmd[i++] = 0x00;	/* data len msb */
+	crc = _cyttsp4_compute_crc(ttsp, &ldr_exit_cmd[1], i - 1);
+	ldr_exit_cmd[i++] = (u8)crc;
+	ldr_exit_cmd[i++] = (u8)(crc >> 8);
+	ldr_exit_cmd[i++] = CY_END_OF_PACKET;
+
+	retval = _cyttsp4_send_cmd(ttsp, ldr_exit_cmd, i, NULL, 0,
+				   CY_CMD_LDR_EXIT_STAT_SIZE, 0);
+
+	if (retval < 0) {
+		dev_err(dev,
+			"%s: BL Loader exit fail r=%d\n",
+			__func__, retval);
+	}
+
+	dev_vdbg(dev,
+		"%s: Exit BL Loader r=%d\n", __func__, retval);
+
+	return retval;
+}
+
+static int _cyttsp4_load_app(struct cyttsp4_device *ttsp, const u8 *fw,
+			     int fw_size)
+{
+	struct device *dev = &ttsp->dev;
+	u8 *p;
+	int ret;
+	int retval;	/* need separate return value at exit stage */
+	struct cyttsp4_dev_id *file_id = NULL;
+	struct cyttsp4_dev_id *dev_id = NULL;
+	struct cyttsp4_hex_image *row_image = NULL;
+	u8 app_chksum;
+
+	u8 *row_buf = NULL;
+	/* Prevent loading if TMA ver not defined. */
+	size_t image_rec_size = fw_size + 1;
+	size_t row_buf_size = 1024 > CY_MAX_PRBUF_SIZE ?
+		1024 : CY_MAX_PRBUF_SIZE;
+	int row_count = 0;
+
+	image_rec_size = CY_DATA_ROW_SIZE_TMA400 +
+		(sizeof(struct cyttsp4_hex_image) - CY_DATA_ROW_SIZE);
+	if (fw_size % image_rec_size != 0) {
+		dev_err(dev,
+			"%s: Firmware image is misaligned\n", __func__);
+		retval = -EINVAL;
+		goto _cyttsp4_load_app_exit;
+	}
+
+	dev_info(dev, "%s: start load app\n", __func__);
+
+	row_buf = kzalloc(row_buf_size, GFP_KERNEL);
+	row_image = kzalloc(sizeof(struct cyttsp4_hex_image), GFP_KERNEL);
+	file_id = kzalloc(sizeof(struct cyttsp4_dev_id), GFP_KERNEL);
+	dev_id = kzalloc(sizeof(struct cyttsp4_dev_id), GFP_KERNEL);
+	if (row_buf == NULL || row_image == NULL ||
+	    file_id == NULL || dev_id == NULL) {
+		dev_err(dev,
+			"%s: Unable to alloc row buffers(%p %p %p %p)\n",
+			__func__, row_buf, row_image, file_id, dev_id);
+		retval = -ENOMEM;
+		goto _cyttsp4_load_app_exit;
+	}
+
+	cyttsp4_request_stop_wd(ttsp);
+
+	p = (u8 *)fw;
+	/* Enter Loader and return Silicon ID and Rev */
+
+	retval = cyttsp4_request_reset(ttsp);
+	if (retval < 0) {
+		dev_err(dev,
+			"%s: Fail reset device r=%d\n", __func__, retval);
+		goto _cyttsp4_load_app_exit;
+	}
+
+	dev_info(dev, "%s: Send BL Loader Enter\n", __func__);
+
+	retval = _cyttsp4_ldr_enter(ttsp, dev_id);
+	if (retval < 0) {
+		dev_err(dev,
+			"%s: Error cannot start Loader (ret=%d)\n",
+			__func__, retval);
+		goto _cyttsp4_load_app_exit;
+	}
+
+	dev_vdbg(dev,
+		"%s: dev: silicon id=%08X rev=%02X bl=%08X\n",
+		__func__, dev_id->silicon_id,
+		dev_id->rev_id, dev_id->bl_ver);
+
+	udelay(1000);
+	retval = _cyttsp4_ldr_init(ttsp);
+	if (retval < 0) {
+		dev_err(dev,
+			"%s: Error cannot init Loader (ret=%d)\n",
+			__func__, retval);
+		goto _cyttsp4_load_app_exit;
+	}
+
+	dev_info(dev, "%s: Send BL Loader Blocks\n", __func__);
+
+	while (p < (fw + fw_size)) {
+		/* Get row */
+		dev_dbg(dev,
+			"%s: read row=%d\n", __func__, ++row_count);
+		memset(row_buf, 0, row_buf_size);
+		p = _cyttsp4_get_row(ttsp, row_buf, p, image_rec_size);
+
+		/* Parse row */
+		dev_vdbg(dev,
+			"%s: p=%p buf=%p buf[0]=%02X\n", __func__,
+			p, row_buf, row_buf[0]);
+		retval = _cyttsp4_ldr_parse_row(ttsp, row_buf, row_image);
+		dev_vdbg(dev,
+			"%s: array_id=%02X row_num=%04X(%d)"
+				" row_size=%04X(%d)\n", __func__,
+			row_image->array_id,
+			row_image->row_num, row_image->row_num,
+			row_image->row_size, row_image->row_size);
+		if (retval < 0) {
+			dev_err(dev,
+			"%s: Parse Row Error "
+				"(a=%d r=%d ret=%d\n",
+				__func__, row_image->array_id,
+				row_image->row_num,
+				retval);
+			goto bl_exit;
+		} else {
+			dev_vdbg(dev,
+				"%s: Parse Row "
+				"(a=%d r=%d ret=%d\n",
+				__func__, row_image->array_id,
+				row_image->row_num, retval);
+		}
+
+		/* program row */
+		retval = _cyttsp4_ldr_prog_row(ttsp, row_image);
+		if (retval < 0) {
+			dev_err(dev,
+			"%s: Program Row Error "
+				"(array=%d row=%d ret=%d)\n",
+				__func__, row_image->array_id,
+				row_image->row_num, retval);
+			goto _cyttsp4_load_app_exit;
+		}
+
+		/* verify row */
+		retval = _cyttsp4_ldr_verify_row(ttsp, row_image);
+		if (retval < 0) {
+			dev_err(dev,
+			"%s: Verify Row Error "
+				"(array=%d row=%d ret=%d)\n",
+				__func__, row_image->array_id,
+				row_image->row_num, retval);
+			goto _cyttsp4_load_app_exit;
+		}
+
+		dev_vdbg(dev,
+			"%s: array=%d row_cnt=%d row_num=%04X\n",
+			__func__, row_image->array_id, row_count,
+			row_image->row_num);
+	}
+
+	/* verify app checksum */
+	retval = _cyttsp4_ldr_verify_chksum(ttsp, &app_chksum);
+	dev_dbg(dev,
+		"%s: Application Checksum = %02X r=%d\n",
+		__func__, app_chksum, retval);
+	if (retval < 0) {
+		dev_err(dev,
+			"%s: ldr_verify_chksum fail r=%d\n", __func__, retval);
+		retval = 0;
+	}
+
+	/* exit loader */
+bl_exit:
+	dev_info(dev,
+			"%s: Send BL Loader Terminate\n", __func__);
+	ret = _cyttsp4_ldr_exit(ttsp);
+	if (ret) {
+		dev_err(dev,
+			"%s: Error on exit Loader (ret=%d)\n",
+			__func__, ret);
+		retval = ret;
+	}
+
+_cyttsp4_load_app_exit:
+	kfree(row_buf);
+	kfree(row_image);
+	kfree(file_id);
+	kfree(dev_id);
+	return retval;
+}
+
+static void cyttsp4_fw_calibrate(struct work_struct *calibration_work)
+{
+	struct cyttsp4_loader_data *data = container_of(calibration_work,
+			struct cyttsp4_loader_data, calibration_work);
+	struct cyttsp4_device *ttsp = data->ttsp;
+	struct device *dev = &ttsp->dev;
+	u8 cmd_buf[CY_CMD_CAT_CALIBRATE_IDAC_CMD_SZ];
+	u8 return_buf[CY_CMD_CAT_CALIBRATE_IDAC_RET_SZ];
+	int rc;
+
+	dev_vdbg(dev, "%s\n", __func__);
+
+	pm_runtime_get_sync(dev);
+
+	dev_vdbg(dev, "%s: Requesting exclusive\n", __func__);
+	rc = cyttsp4_request_exclusive(ttsp, CY_LDR_REQUEST_EXCLUSIVE_TIMEOUT);
+	if (rc < 0) {
+		dev_err(dev, "%s: Error on request exclusive r=%d\n",
+				__func__, rc);
+		goto exit;
+	}
+
+	dev_vdbg(dev, "%s: Requesting mode change to CAT\n", __func__);
+	rc = cyttsp4_request_set_mode(ttsp, CY_MODE_CAT);
+	if (rc < 0) {
+		dev_err(dev, "%s: Error on request set mode r=%d\n",
+				__func__, rc);
+		goto exit_release;
+	}
+
+	cmd_buf[0] = CY_CMD_CAT_CALIBRATE_IDACS;
+	cmd_buf[1] = 0x00; /* Mutual Capacitance Screen */
+	rc = cyttsp4_request_exec_cmd(ttsp, CY_MODE_CAT,
+			cmd_buf, CY_CMD_CAT_CALIBRATE_IDAC_CMD_SZ,
+			return_buf, CY_CMD_CAT_CALIBRATE_IDAC_RET_SZ,
+			CY_CALIBRATE_COMPLETE_TIMEOUT);
+	if (rc < 0) {
+		dev_err(dev, "%s: Unable to execute calibrate command.\n",
+			__func__);
+		goto exit_setmode;
+	}
+	if (return_buf[0] != CY_CMD_STATUS_SUCCESS) {
+		dev_err(dev, "%s: calibrate command unsuccessful\n", __func__);
+		goto exit_setmode;
+	}
+
+	cmd_buf[1] = 0x01; /* Mutual Capacitance Button */
+	rc = cyttsp4_request_exec_cmd(ttsp, CY_MODE_CAT,
+			cmd_buf, CY_CMD_CAT_CALIBRATE_IDAC_CMD_SZ,
+			return_buf, CY_CMD_CAT_CALIBRATE_IDAC_RET_SZ,
+			CY_CALIBRATE_COMPLETE_TIMEOUT);
+	if (rc < 0) {
+		dev_err(dev, "%s: Unable to execute calibrate command.\n",
+			__func__);
+		goto exit_setmode;
+	}
+	if (return_buf[0] != CY_CMD_STATUS_SUCCESS) {
+		dev_err(dev, "%s: calibrate command unsuccessful\n", __func__);
+		goto exit_setmode;
+	}
+
+	cmd_buf[1] = 0x02; /* Self Capacitance */
+	rc = cyttsp4_request_exec_cmd(ttsp, CY_MODE_CAT,
+			cmd_buf, CY_CMD_CAT_CALIBRATE_IDAC_CMD_SZ,
+			return_buf, CY_CMD_CAT_CALIBRATE_IDAC_RET_SZ,
+			CY_CALIBRATE_COMPLETE_TIMEOUT);
+	if (rc < 0) {
+		dev_err(dev, "%s: Unable to execute calibrate command.\n",
+			__func__);
+		goto exit_setmode;
+	}
+	if (return_buf[0] != CY_CMD_STATUS_SUCCESS) {
+		dev_err(dev, "%s: calibrate command unsuccessful\n", __func__);
+		goto exit_setmode;
+	}
+
+exit_setmode:
+	rc = cyttsp4_request_set_mode(ttsp, CY_MODE_OPERATIONAL);
+	if (rc < 0)
+		dev_err(dev, "%s: Error on request set mode 2 r=%d\n",
+				__func__, rc);
+
+exit_release:
+	rc = cyttsp4_release_exclusive(ttsp);
+	if (rc < 0)
+		dev_err(dev, "%s: Error on release exclusive r=%d\n",
+				__func__, rc);
+
+exit:
+	pm_runtime_put(dev);
+}
+
+static int cyttsp4_fw_calibration_attention(struct cyttsp4_device *ttsp)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_loader_data *data = dev_get_drvdata(dev);
+	int rc = 0;
+
+	dev_vdbg(dev, "%s\n", __func__);
+
+	schedule_work(&data->calibration_work);
+
+	cyttsp4_unsubscribe_attention(ttsp, CY_ATTEN_STARTUP,
+		cyttsp4_fw_calibration_attention, 0);
+
+	return rc;
+}
+
+static int cyttsp4_upgrade_firmware(struct cyttsp4_device *ttsp,
+		const u8 *fw_img, int fw_size)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_loader_data *data = dev_get_drvdata(dev);
+	int rc;
+
+	pm_runtime_get_sync(dev);
+
+	rc = cyttsp4_request_exclusive(ttsp, CY_LDR_REQUEST_EXCLUSIVE_TIMEOUT);
+	if (rc < 0)
+		goto exit;
+
+	rc = _cyttsp4_load_app(ttsp, fw_img, fw_size);
+	if (rc < 0) {
+		dev_err(dev, "%s: Firmware update failed with error code %d\n",
+			__func__, rc);
+	} else if (data->loader_pdata &&
+			(data->loader_pdata->flags &
+				CY_LOADER_FLAG_CALIBRATE_AFTER_FW_UPGRADE)) {
+		/* set up call back for startup */
+		dev_vdbg(dev, "%s: Adding callback for calibration\n",
+			__func__);
+		rc = cyttsp4_subscribe_attention(ttsp, CY_ATTEN_STARTUP,
+				cyttsp4_fw_calibration_attention, 0);
+		if (rc) {
+			dev_err(dev, "%s: Failed adding callback for calibration\n",
+				__func__);
+			dev_err(dev, "%s: No calibration will be performed\n",
+				__func__);
+			rc = 0;
+		}
+	}
+
+	cyttsp4_release_exclusive(ttsp);
+	cyttsp4_request_restart(ttsp, false);
+
+exit:
+	pm_runtime_put(dev);
+	return rc;
+}
+
+static int cyttsp4_loader_attention(struct cyttsp4_device *ttsp)
+{
+	struct cyttsp4_loader_data *data = dev_get_drvdata(&ttsp->dev);
+	complete(&data->int_running);
+	return 0;
+}
+#endif /* CYTTSP4_FW_UPGRADE */
+
+#ifdef CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_PLATFORM_FW_UPGRADE
+static int cyttsp4_check_firmware_version_platform(struct cyttsp4_device *ttsp,
+		struct cyttsp4_touch_firmware *fw)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_loader_data *data = dev_get_drvdata(dev);
+	u32 fw_ver_new;
+	u32 fw_revctrl_new_h;
+	u32 fw_revctrl_new_l;
+	int upgrade;
+
+	if (!data->si) {
+		dev_info(dev, "%s: No firmware infomation found, device FW may be corrupted\n",
+			__func__);
+		return CYTTSP4_AUTO_LOAD_FOR_CORRUPTED_FW;
+	}
+
+	fw_ver_new = get_unaligned_be16(fw->ver + 2);
+	fw_revctrl_new_h = get_unaligned_be32(fw->ver + 4);
+	fw_revctrl_new_l = get_unaligned_be32(fw->ver + 8);
+
+	upgrade = cyttsp4_check_firmware_version(ttsp, fw_ver_new,
+			fw_revctrl_new_h, fw_revctrl_new_l);
+
+	if (upgrade > 0)
+		return 1;
+
+	return 0;
+}
+
+static int upgrade_firmware_from_platform(struct cyttsp4_device *ttsp,
+		bool forced)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_loader_data *data = dev_get_drvdata(dev);
+	struct cyttsp4_touch_firmware *fw;
+	int rc = -ENOSYS;
+	int upgrade;
+
+	if (data->loader_pdata == NULL) {
+		dev_err(dev, "%s: No loader platform data\n", __func__);
+		return rc;
+	}
+
+	fw = data->loader_pdata->fw;
+	if (fw == NULL || fw->img == NULL || fw->size == 0) {
+		dev_err(dev, "%s: No platform firmware\n", __func__);
+		return rc;
+	}
+
+	if (fw->ver == NULL || fw->vsize == 0) {
+		dev_err(dev, "%s: No platform firmware version\n",
+			__func__);
+		return rc;
+	}
+
+	if (forced)
+		upgrade = forced;
+	else
+		upgrade = cyttsp4_check_firmware_version_platform(ttsp, fw);
+
+	if (upgrade)
+		return cyttsp4_upgrade_firmware(ttsp, fw->img, fw->size);
+
+	return rc;
+}
+#endif /* CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_PLATFORM_FW_UPGRADE */
+
+#ifdef CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_BINARY_FW_UPGRADE
+static void _cyttsp4_firmware_cont(const struct firmware *fw, void *context)
+{
+	struct cyttsp4_device *ttsp = context;
+	struct device *dev = &ttsp->dev;
+	u8 header_size = 0;
+
+	if (fw == NULL)
+		goto cyttsp4_firmware_cont_exit;
+
+	if (fw->data == NULL || fw->size == 0) {
+		dev_err(dev,
+			"%s: No firmware received\n", __func__);
+		goto cyttsp4_firmware_cont_release_exit;
+	}
+
+	header_size = fw->data[0];
+	if (header_size >= (fw->size + 1)) {
+		dev_err(dev,
+			"%s: Firmware format is invalid\n", __func__);
+		goto cyttsp4_firmware_cont_release_exit;
+	}
+
+	cyttsp4_upgrade_firmware(ttsp, &(fw->data[header_size + 1]),
+		fw->size - (header_size + 1));
+
+cyttsp4_firmware_cont_release_exit:
+	release_firmware(fw);
+
+cyttsp4_firmware_cont_exit:
+	return;
+}
+
+static int cyttsp4_check_firmware_version_builtin(struct cyttsp4_device *ttsp,
+		const struct firmware *fw)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_loader_data *data = dev_get_drvdata(dev);
+	u32 fw_ver_new;
+	u32 fw_revctrl_new_h;
+	u32 fw_revctrl_new_l;
+	int upgrade;
+
+	if (!data->si) {
+		dev_info(dev, "%s: No firmware infomation found, device FW may be corrupted\n",
+			__func__);
+		return CYTTSP4_AUTO_LOAD_FOR_CORRUPTED_FW;
+	}
+
+	fw_ver_new = get_unaligned_be16(fw->data + 3);
+	fw_revctrl_new_h = get_unaligned_be32(fw->data + 5);
+	fw_revctrl_new_l = get_unaligned_be32(fw->data + 9);
+
+	upgrade = cyttsp4_check_firmware_version(ttsp, fw_ver_new,
+			fw_revctrl_new_h, fw_revctrl_new_l);
+
+	if (upgrade > 0)
+		return 1;
+
+	return 0;
+}
+
+static void _cyttsp4_firmware_cont_builtin(const struct firmware *fw,
+		void *context)
+{
+	struct cyttsp4_device *ttsp = context;
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_loader_data *data = dev_get_drvdata(dev);
+	int upgrade;
+
+	if (fw == NULL) {
+		dev_info(dev, "%s: No builtin firmware\n", __func__);
+		goto _cyttsp4_firmware_cont_builtin_exit;
+	}
+
+	if (fw->data == NULL || fw->size == 0) {
+		dev_err(dev, "%s: Invalid builtin firmware\n", __func__);
+		goto _cyttsp4_firmware_cont_builtin_exit;
+	}
+
+	dev_dbg(dev, "%s: Found firmware\n", __func__);
+
+	upgrade = cyttsp4_check_firmware_version_builtin(ttsp, fw);
+	if (upgrade) {
+		_cyttsp4_firmware_cont(fw, ttsp);
+		data->builtin_bin_fw_status = 0;
+		complete(&data->builtin_bin_fw_complete);
+		return;
+	}
+
+_cyttsp4_firmware_cont_builtin_exit:
+	release_firmware(fw);
+
+	data->builtin_bin_fw_status = -EINVAL;
+	complete(&data->builtin_bin_fw_complete);
+}
+
+static int upgrade_firmware_from_class(struct cyttsp4_device *ttsp)
+{
+	int retval;
+
+	dev_vdbg(&ttsp->dev, "%s: Enabling firmware class loader\n", __func__);
+
+	retval = request_firmware_nowait(THIS_MODULE, FW_ACTION_NOHOTPLUG, "",
+			&ttsp->dev, GFP_KERNEL, ttsp, _cyttsp4_firmware_cont);
+	if (retval < 0) {
+		dev_err(&ttsp->dev, "%s: Fail request firmware class file load\n",
+			__func__);
+		return retval;
+	}
+
+	return 0;
+}
+
+static int upgrade_firmware_from_builtin(struct cyttsp4_device *ttsp)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_loader_data *data = dev_get_drvdata(dev);
+	int retval;
+
+	dev_vdbg(dev, "%s: Enabling firmware class loader built-in\n",
+		__func__);
+
+	retval = request_firmware_nowait(THIS_MODULE, FW_ACTION_HOTPLUG,
+			CY_FW_FILE_NAME, dev, GFP_KERNEL, ttsp,
+			_cyttsp4_firmware_cont_builtin);
+	if (retval < 0) {
+		dev_err(dev, "%s: Fail request firmware class file load\n",
+			__func__);
+		return retval;
+	}
+
+	/* wait until FW binary upgrade finishes */
+	wait_for_completion(&data->builtin_bin_fw_complete);
+
+	return data->builtin_bin_fw_status;
+}
+#endif /* CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_BINARY_FW_UPGRADE */
+
+#if CYTTSP4_TTCONFIG_UPGRADE
+static int cyttsp4_upgrade_ttconfig(struct cyttsp4_device *ttsp,
+		const u8 *ttconfig_data, int ttconfig_size)
+{
+	struct device *dev = &ttsp->dev;
+	int rc, rc2;
+
+	dev_vdbg(dev, "%s\n", __func__);
+
+	pm_runtime_get_sync(dev);
+
+	dev_vdbg(dev, "%s: Requesting exclusive\n", __func__);
+	rc = cyttsp4_request_exclusive(ttsp, CY_LDR_REQUEST_EXCLUSIVE_TIMEOUT);
+	if (rc < 0) {
+		dev_err(dev, "%s: Error on request exclusive r=%d\n",
+				__func__, rc);
+		goto exit;
+	}
+
+	dev_vdbg(dev, "%s: Requesting mode change to CAT\n", __func__);
+	rc = cyttsp4_request_set_mode(ttsp, CY_MODE_CAT);
+	if (rc < 0) {
+		dev_err(dev, "%s: Error on request set mode r=%d\n",
+				__func__, rc);
+		goto exit_release;
+	}
+
+	rc = cyttsp4_request_write_config(ttsp, CY_TCH_PARM_EBID,
+			0, (u8 *)ttconfig_data, ttconfig_size);
+	if (rc < 0) {
+		dev_err(dev, "%s: Error on request write config r=%d\n",
+				__func__, rc);
+		goto exit_setmode;
+	}
+
+exit_setmode:
+	rc2 = cyttsp4_request_set_mode(ttsp, CY_MODE_OPERATIONAL);
+	if (rc2 < 0)
+		dev_err(dev, "%s: Error on request set mode r=%d\n",
+				__func__, rc2);
+
+exit_release:
+	rc2 = cyttsp4_release_exclusive(ttsp);
+	if (rc < 0)
+		dev_err(dev, "%s: Error on release exclusive r=%d\n",
+				__func__, rc2);
+
+exit:
+	if (!rc)
+		cyttsp4_request_restart(ttsp, true);
+
+	pm_runtime_put(dev);
+
+	return rc;
+}
+#endif /* CYTTSP4_TTCONFIG_UPGRADE */
+
+#ifdef CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_PLATFORM_TTCONFIG_UPGRADE
+static int cyttsp4_get_ttconfig_crc(struct cyttsp4_device *ttsp,
+		const u8 *ttconfig_data, int ttconfig_size, u16 *crc)
+{
+	u16 crc_loc;
+
+	crc_loc = get_unaligned_le16(&ttconfig_data[2]);
+	if (ttconfig_size < crc_loc + 2)
+		return -EINVAL;
+
+	*crc = get_unaligned_le16(&ttconfig_data[crc_loc]);
+
+	return 0;
+}
+
+static int cyttsp4_get_ttconfig_version(struct cyttsp4_device *ttsp,
+		const u8 *ttconfig_data, int ttconfig_size, u16 *version)
+{
+	if (ttconfig_size < CY_TTCONFIG_VERSION_OFFSET
+			+ CY_TTCONFIG_VERSION_SIZE)
+		return -EINVAL;
+
+	*version = get_unaligned_le16(
+		&ttconfig_data[CY_TTCONFIG_VERSION_OFFSET]);
+
+	return 0;
+}
+
+static int cyttsp4_check_ttconfig_version(struct cyttsp4_device *ttsp,
+		const u8 *ttconfig_data, int ttconfig_size)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_loader_data *data = dev_get_drvdata(dev);
+	int rc;
+
+	if (!data->si)
+		return 0;
+
+	/* Check if device POST config CRC test failed */
+	if (!(data->si->si_ptrs.test->post_codel &
+			CY_POST_CODEL_CFG_DATA_CRC_FAIL)) {
+		dev_info(dev, "%s: Config CRC invalid, will upgrade\n",
+			__func__);
+		return 1;
+	}
+
+	/* Check for config version */
+	if (data->loader_pdata->flags &
+			CY_LOADER_FLAG_CHECK_TTCONFIG_VERSION) {
+		u16 cfg_ver_new;
+
+		rc = cyttsp4_get_ttconfig_version(ttsp, ttconfig_data,
+				ttconfig_size, &cfg_ver_new);
+		if (rc)
+			return 0;
+
+		dev_dbg(dev, "%s: img_ver:0x%04X new_ver:0x%04X\n",
+			__func__, data->si->ttconfig.version, cfg_ver_new);
+
+		/* Check if config version is newer */
+		if (cfg_ver_new > data->si->ttconfig.version) {
+			dev_dbg(dev, "%s: Config version newer, will upgrade\n",
+				__func__);
+			return 1;
+		}
+
+		dev_dbg(dev, "%s: Config version is identical or older, will NOT upgrade\n",
+			__func__);
+	/* Check for config CRC */
+	} else {
+		u16 cfg_crc_new;
+
+		rc = cyttsp4_get_ttconfig_crc(ttsp, ttconfig_data,
+				ttconfig_size, &cfg_crc_new);
+		if (rc)
+			return 0;
+
+		dev_dbg(dev, "%s: img_crc:0x%04X new_crc:0x%04X\n",
+			__func__, data->si->ttconfig.crc, cfg_crc_new);
+
+		/* Check if config CRC different. */
+		if (cfg_crc_new != data->si->ttconfig.crc) {
+			dev_dbg(dev, "%s: Config CRC different, will upgrade\n",
+				__func__);
+			return 1;
+		}
+
+		dev_dbg(dev, "%s: Config CRC equal, will NOT upgrade\n",
+			__func__);
+	}
+
+	return 0;
+}
+
+static int cyttsp4_check_ttconfig_version_platform(struct cyttsp4_device *ttsp,
+		struct cyttsp4_touch_config *ttconfig)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_loader_data *data = dev_get_drvdata(dev);
+	u32 fw_ver_config;
+	u32 fw_revctrl_config_h;
+	u32 fw_revctrl_config_l;
+
+	if (!data->si) {
+		dev_info(dev, "%s: No firmware infomation found, device FW may be corrupted\n",
+			__func__);
+		return 0;
+	}
+
+	fw_ver_config = get_unaligned_be16(ttconfig->fw_ver + 2);
+	fw_revctrl_config_h = get_unaligned_be32(ttconfig->fw_ver + 4);
+	fw_revctrl_config_l = get_unaligned_be32(ttconfig->fw_ver + 8);
+
+	/* FW versions should match */
+	if (cyttsp4_check_firmware_version(ttsp, fw_ver_config,
+			fw_revctrl_config_h, fw_revctrl_config_l)) {
+		dev_err(dev, "%s: FW versions mismatch\n", __func__);
+		return 0;
+	}
+
+	return cyttsp4_check_ttconfig_version(ttsp, ttconfig->param_regs->data,
+			ttconfig->param_regs->size);
+}
+
+static int upgrade_ttconfig_from_platform(struct cyttsp4_device *ttsp)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_loader_data *data = dev_get_drvdata(dev);
+	struct cyttsp4_touch_config *ttconfig;
+	struct touch_settings *param_regs;
+	struct cyttsp4_touch_fw;
+	int rc = -ENOSYS;
+	int upgrade;
+
+	if (data->loader_pdata == NULL) {
+		dev_info(dev, "%s: No loader platform data\n", __func__);
+		return rc;
+	}
+
+	ttconfig = data->loader_pdata->ttconfig;
+	if (ttconfig == NULL) {
+		dev_info(dev, "%s: No ttconfig data\n", __func__);
+		return rc;
+	}
+
+	param_regs = ttconfig->param_regs;
+	if (param_regs == NULL) {
+		dev_info(dev, "%s: No touch parameters\n", __func__);
+		return rc;
+	}
+
+	if (param_regs->data == NULL || param_regs->size == 0) {
+		dev_info(dev, "%s: Invalid touch parameters\n", __func__);
+		return rc;
+	}
+
+	if (ttconfig->fw_ver == NULL || ttconfig->fw_vsize == 0) {
+		dev_info(dev, "%s: Invalid FW version for touch parameters\n",
+			__func__);
+		return rc;
+	}
+
+	upgrade = cyttsp4_check_ttconfig_version_platform(ttsp, ttconfig);
+	if (upgrade)
+		return cyttsp4_upgrade_ttconfig(ttsp, param_regs->data,
+				param_regs->size);
+
+	return rc;
+}
+#endif /* CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_PLATFORM_TTCONFIG_UPGRADE */
+
+#ifdef CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_MANUAL_TTCONFIG_UPGRADE
+static ssize_t cyttsp4_config_data_write(struct file *filp,
+		struct kobject *kobj, struct bin_attribute *bin_attr,
+		char *buf, loff_t offset, size_t count)
+{
+	struct device *dev = container_of(kobj, struct device, kobj);
+	struct cyttsp4_loader_data *data = dev_get_drvdata(dev);
+	u8 *p;
+
+	dev_vdbg(dev, "%s: offset:%lld count:%d\n", __func__, offset, count);
+
+	mutex_lock(&data->config_lock);
+
+	if (!data->config_loading) {
+		mutex_unlock(&data->config_lock);
+		return -ENODEV;
+	}
+
+	p = krealloc(data->config_data, offset + count, GFP_KERNEL);
+	if (!p) {
+		kfree(data->config_data);
+		data->config_data = NULL;
+		data->config_size = 0;
+		data->config_loading = false;
+		mutex_unlock(&data->config_lock);
+		return -ENOMEM;
+	}
+	data->config_data = p;
+
+	memcpy(&data->config_data[offset], buf, count);
+	data->config_size += count;
+
+	mutex_unlock(&data->config_lock);
+
+	return count;
+}
+
+static struct bin_attribute bin_attr_config_data = {
+	.attr = {
+		.name = "config_data",
+		.mode = S_IWUSR,
+	},
+	.size = 0,
+	.write = cyttsp4_config_data_write,
+};
+
+static ssize_t cyttsp4_config_loading_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct cyttsp4_loader_data *data = dev_get_drvdata(dev);
+	bool config_loading;
+
+	mutex_lock(&data->config_lock);
+	config_loading = data->config_loading;
+	mutex_unlock(&data->config_lock);
+
+	return sprintf(buf, "%d\n", config_loading);
+}
+
+static int cyttsp4_verify_ttconfig_binary(struct cyttsp4_device *ttsp,
+		u8 *bin_config_data, int bin_config_size, u8 **start, int *len)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_loader_data *data = dev_get_drvdata(dev);
+	int header_size;
+	u16 config_size;
+	u16 max_config_size;
+	u32 fw_ver_config;
+	u32 fw_revctrl_config_h;
+	u32 fw_revctrl_config_l;
+
+	if (!data->si) {
+		dev_err(dev, "%s: No firmware infomation found, device FW may be corrupted\n",
+			__func__);
+		return -ENODEV;
+	}
+
+	/*
+	 * We need 11 bytes for FW version control info and at
+	 * least 6 bytes in config (Length + Max Length + CRC)
+	 */
+	header_size = bin_config_data[0] + 1;
+	if (header_size < 11 || header_size >= bin_config_size - 6) {
+		dev_err(dev, "%s: Invalid header size %d\n", __func__,
+			header_size);
+		return -EINVAL;
+	}
+
+	fw_ver_config = get_unaligned_be16(&bin_config_data[1]);
+	fw_revctrl_config_h = get_unaligned_be32(&bin_config_data[3]);
+	fw_revctrl_config_l = get_unaligned_be32(&bin_config_data[7]);
+
+	/* FW versions should match */
+	if (cyttsp4_check_firmware_version(ttsp, fw_ver_config,
+			fw_revctrl_config_h, fw_revctrl_config_l)) {
+		dev_err(dev, "%s: FW versions mismatch\n", __func__);
+		return -EINVAL;
+	}
+
+	config_size = get_unaligned_le16(&bin_config_data[header_size]);
+	max_config_size =
+		get_unaligned_le16(&bin_config_data[header_size + 2]);
+	/* Perform a simple size check (2 bytes for CRC) */
+	if (config_size != bin_config_size - header_size - 2) {
+		dev_err(dev, "%s: Config size invalid\n", __func__);
+		return -EINVAL;
+	}
+	/* Perform a size check against device config length */
+	if (config_size != data->si->ttconfig.length
+			|| max_config_size != data->si->ttconfig.max_length) {
+		dev_err(dev, "%s: Config size mismatch\n", __func__);
+		return -EINVAL;
+	}
+
+	*start = &bin_config_data[header_size];
+	*len = bin_config_size - header_size;
+
+	return 0;
+}
+
+/*
+ * 1: Start loading TT Config
+ * 0: End loading TT Config and perform upgrade
+ *-1: Exit loading
+ */
+static ssize_t cyttsp4_config_loading_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	struct cyttsp4_loader_data *data = dev_get_drvdata(dev);
+	long value;
+	u8 *start;
+	int length;
+	int rc;
+
+	rc = kstrtol(buf, 10, &value);
+	if (rc < 0 || value < -1 || value > 1) {
+		dev_err(dev, "%s: Invalid value\n", __func__);
+		return size;
+	}
+
+	mutex_lock(&data->config_lock);
+
+	if (value == 1)
+		data->config_loading = true;
+	else if (value == -1)
+		data->config_loading = false;
+	else if (value == 0 && data->config_loading) {
+		data->config_loading = false;
+		if (data->config_size == 0) {
+			dev_err(dev, "%s: No config data\n", __func__);
+			goto exit_free;
+		}
+
+		rc = cyttsp4_verify_ttconfig_binary(data->ttsp,
+				data->config_data, data->config_size,
+				&start, &length);
+		if (rc)
+			goto exit_free;
+
+		rc = cyttsp4_upgrade_ttconfig(data->ttsp, start, length);
+	}
+
+exit_free:
+	kfree(data->config_data);
+	data->config_data = NULL;
+	data->config_size = 0;
+
+	mutex_unlock(&data->config_lock);
+
+	if (rc)
+		return rc;
+
+	return size;
+}
+
+static DEVICE_ATTR(config_loading, S_IRUSR | S_IWUSR,
+	cyttsp4_config_loading_show, cyttsp4_config_loading_store);
+#endif /* CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_MANUAL_TTCONFIG_UPGRADE */
+
+static void cyttsp4_fw_and_config_upgrade(
+		struct work_struct *fw_and_config_upgrade)
+{
+	struct cyttsp4_loader_data *data = container_of(fw_and_config_upgrade,
+			struct cyttsp4_loader_data, fw_and_config_upgrade);
+	struct cyttsp4_device *ttsp = data->ttsp;
+	struct device *dev = &ttsp->dev;
+
+	data->si = cyttsp4_request_sysinfo(ttsp);
+	if (data->si == NULL)
+		dev_err(dev, "%s: Fail get sysinfo pointer from core\n",
+			__func__);
+
+#if !CYTTSP4_FW_UPGRADE
+	dev_info(dev, "%s: No FW upgrade method selected!\n", __func__);
+#endif
+
+#ifdef CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_PLATFORM_FW_UPGRADE
+	if (!upgrade_firmware_from_platform(ttsp, false))
+		return;
+#endif
+
+#ifdef CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_BINARY_FW_UPGRADE
+	if (!upgrade_firmware_from_builtin(ttsp))
+		return;
+#endif
+
+#ifdef CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_PLATFORM_TTCONFIG_UPGRADE
+	if (!upgrade_ttconfig_from_platform(ttsp))
+		return;
+#endif
+}
+
+#ifdef CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_PLATFORM_FW_UPGRADE
+static ssize_t cyttsp4_forced_upgrade_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	int rc;
+	struct cyttsp4_loader_data *data = dev_get_drvdata(dev);
+	rc = upgrade_firmware_from_platform(data->ttsp, true);
+	if (rc)
+		return rc;
+	return size;
+}
+
+static DEVICE_ATTR(forced_upgrade, S_IRUSR | S_IWUSR,
+	NULL, cyttsp4_forced_upgrade_store);
+#endif
+
+#ifdef CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_BINARY_FW_UPGRADE
+static ssize_t cyttsp4_manual_upgrade_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	struct cyttsp4_loader_data *data = dev_get_drvdata(dev);
+	upgrade_firmware_from_class(data->ttsp);
+	return size;
+}
+
+static DEVICE_ATTR(manual_upgrade, S_IRUSR | S_IWUSR,
+	NULL, cyttsp4_manual_upgrade_store);
+#endif
+
+static int cyttsp4_loader_probe(struct cyttsp4_device *ttsp)
+{
+	struct cyttsp4_loader_data *data;
+	struct device *dev = &ttsp->dev;
+	int rc;
+
+	dev_dbg(dev, "%s\n", __func__);
+	data = kzalloc(sizeof(*data), GFP_KERNEL);
+	if (data == NULL) {
+		dev_err(dev, "%s: Error, kzalloc\n", __func__);
+		rc = -ENOMEM;
+		goto error_alloc_data_failed;
+	}
+
+#ifdef CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_PLATFORM_FW_UPGRADE
+	rc = device_create_file(dev, &dev_attr_forced_upgrade);
+	if (rc) {
+		dev_err(dev, "%s: Error, could not create forced_upgrade\n",
+				__func__);
+		goto error_create_forced_upgrade;
+	}
+#endif
+
+#ifdef CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_BINARY_FW_UPGRADE
+	rc = device_create_file(dev, &dev_attr_manual_upgrade);
+	if (rc) {
+		dev_err(dev, "%s: Error, could not create manual_upgrade\n",
+				__func__);
+		goto error_create_manual_upgrade;
+	}
+#endif
+
+#ifdef CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_MANUAL_TTCONFIG_UPGRADE
+	rc = device_create_file(dev, &dev_attr_config_loading);
+	if (rc) {
+		dev_err(dev, "%s: Error, could not create config_loading\n",
+				__func__);
+		goto error_create_config_loading;
+	}
+
+	rc = device_create_bin_file(dev, &bin_attr_config_data);
+	if (rc) {
+		dev_err(dev, "%s: Error, could not create config_data\n",
+				__func__);
+		goto error_create_config_data;
+	}
+#endif
+
+	data->loader_pdata = cyttsp4_request_loader_pdata(ttsp);
+	data->ttsp = ttsp;
+	dev_set_drvdata(dev, data);
+
+	pm_runtime_enable(dev);
+
+#if CYTTSP4_FW_UPGRADE
+	init_completion(&data->int_running);
+#ifdef CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_BINARY_FW_UPGRADE
+	init_completion(&data->builtin_bin_fw_complete);
+#endif
+	cyttsp4_subscribe_attention(ttsp, CY_ATTEN_IRQ,
+		cyttsp4_loader_attention, CY_MODE_BOOTLOADER);
+
+	INIT_WORK(&data->calibration_work, cyttsp4_fw_calibrate);
+#endif
+
+#ifdef CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_MANUAL_TTCONFIG_UPGRADE
+	mutex_init(&data->config_lock);
+#endif
+	INIT_WORK(&data->fw_and_config_upgrade, cyttsp4_fw_and_config_upgrade);
+	schedule_work(&data->fw_and_config_upgrade);
+
+	dev_info(dev, "%s: Successful probe %s\n", __func__, ttsp->name);
+	return 0;
+
+
+#ifdef CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_MANUAL_TTCONFIG_UPGRADE
+error_create_config_data:
+	device_remove_file(dev, &dev_attr_config_loading);
+error_create_config_loading:
+#ifdef CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_BINARY_FW_UPGRADE
+	device_remove_file(dev, &dev_attr_manual_upgrade);
+#endif
+#endif
+#ifdef CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_BINARY_FW_UPGRADE
+error_create_manual_upgrade:
+#endif
+#ifdef CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_PLATFORM_FW_UPGRADE
+	device_remove_file(dev, &dev_attr_forced_upgrade);
+error_create_forced_upgrade:
+#endif
+	kfree(data);
+error_alloc_data_failed:
+	dev_err(dev, "%s failed.\n", __func__);
+	return rc;
+}
+
+static int cyttsp4_loader_release(struct cyttsp4_device *ttsp)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_loader_data *data = dev_get_drvdata(dev);
+	int retval = 0;
+
+	dev_dbg(dev, "%s\n", __func__);
+#if CYTTSP4_FW_UPGRADE
+	retval = cyttsp4_unsubscribe_attention(ttsp, CY_ATTEN_IRQ,
+		cyttsp4_loader_attention, CY_MODE_BOOTLOADER);
+	if (retval < 0) {
+		dev_err(dev,
+			"%s: Failed to restart IC with error code %d\n",
+			__func__, retval);
+	}
+#endif
+	pm_runtime_suspend(dev);
+	pm_runtime_disable(dev);
+#ifdef CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_MANUAL_TTCONFIG_UPGRADE
+	device_remove_bin_file(dev, &bin_attr_config_data);
+	device_remove_file(dev, &dev_attr_config_loading);
+	kfree(data->config_data);
+#endif
+#ifdef CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_BINARY_FW_UPGRADE
+	device_remove_file(dev, &dev_attr_manual_upgrade);
+#endif
+#ifdef CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_PLATFORM_FW_UPGRADE
+	device_remove_file(dev, &dev_attr_forced_upgrade);
+#endif
+	dev_set_drvdata(dev, NULL);
+	kfree(data);
+	return retval;
+}
+
+static struct cyttsp4_driver cyttsp4_loader_driver = {
+	.probe = cyttsp4_loader_probe,
+	.remove = cyttsp4_loader_release,
+	.driver = {
+		.name = CYTTSP4_LOADER_NAME,
+		.bus = &cyttsp4_bus_type,
+		.owner = THIS_MODULE,
+	},
+};
+
+static const char cyttsp4_loader_name[] = CYTTSP4_LOADER_NAME;
+static struct cyttsp4_device_info cyttsp4_loader_infos[CY_MAX_NUM_CORE_DEVS];
+
+static char *core_ids[CY_MAX_NUM_CORE_DEVS] = {
+	CY_DEFAULT_CORE_ID,
+	NULL,
+	NULL,
+	NULL,
+	NULL
+};
+
+static int num_core_ids = 1;
+
+module_param_array(core_ids, charp, &num_core_ids, 0);
+MODULE_PARM_DESC(core_ids,
+	"Core id list of cyttsp4 core devices for loader module");
+
+static int __init cyttsp4_loader_init(void)
+{
+	int rc = 0;
+	int i, j;
+
+	/* Check for invalid or duplicate core_ids */
+	for (i = 0; i < num_core_ids; i++) {
+		if (!strlen(core_ids[i])) {
+			pr_err("%s: core_id %d is empty\n",
+				__func__, i+1);
+			return -EINVAL;
+		}
+		for (j = i+1; j < num_core_ids; j++)
+			if (!strcmp(core_ids[i], core_ids[j])) {
+				pr_err("%s: core_ids %d and %d are same\n",
+					__func__, i+1, j+1);
+				return -EINVAL;
+			}
+	}
+
+	for (i = 0; i < num_core_ids; i++) {
+		cyttsp4_loader_infos[i].name = cyttsp4_loader_name;
+		cyttsp4_loader_infos[i].core_id = core_ids[i];
+		pr_info("%s: Registering loader device for core_id: %s\n",
+			__func__, cyttsp4_loader_infos[i].core_id);
+		rc = cyttsp4_register_device(&cyttsp4_loader_infos[i]);
+		if (rc < 0) {
+			pr_err("%s: Error, failed registering device\n",
+				__func__);
+			goto fail_unregister_devices;
+		}
+	}
+	rc = cyttsp4_register_driver(&cyttsp4_loader_driver);
+	if (rc) {
+		pr_err("%s: Error, failed registering driver\n", __func__);
+		goto fail_unregister_devices;
+	}
+
+	pr_info("%s: Cypress TTSP FW loader (Built %s) rc=%d\n",
+		 __func__, CY_DRIVER_DATE, rc);
+	return 0;
+
+fail_unregister_devices:
+	for (i--; i >= 0; i--) {
+		cyttsp4_unregister_device(cyttsp4_loader_infos[i].name,
+			cyttsp4_loader_infos[i].core_id);
+		pr_info("%s: Unregistering loader device for core_id: %s\n",
+			__func__, cyttsp4_loader_infos[i].core_id);
+	}
+	return rc;
+}
+module_init(cyttsp4_loader_init);
+
+static void __exit cyttsp4_loader_exit(void)
+{
+	int i;
+
+	cyttsp4_unregister_driver(&cyttsp4_loader_driver);
+	for (i = 0; i < num_core_ids; i++) {
+		cyttsp4_unregister_device(cyttsp4_loader_infos[i].name,
+			cyttsp4_loader_infos[i].core_id);
+		pr_info("%s: Unregistering loader device for core_id: %s\n",
+			__func__, cyttsp4_loader_infos[i].core_id);
+	}
+	pr_info("%s: module exit\n", __func__);
+}
+module_exit(cyttsp4_loader_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Cypress TrueTouch(R) Standard touchscreen FW loader");
+MODULE_AUTHOR("Cypress Semiconductor");
diff --git a/drivers/input/touchscreen/cypress/cyttsp4_mt_common.c b/drivers/input/touchscreen/cypress/cyttsp4_mt_common.c
new file mode 100644
index 0000000..4913ea4
--- /dev/null
+++ b/drivers/input/touchscreen/cypress/cyttsp4_mt_common.c
@@ -0,0 +1,711 @@
+/*
+ * cyttsp4_mt_common.c
+ * Cypress TrueTouch(TM) Standard Product V4 Multi-touch module.
+ * For use with Cypress Txx4xx parts.
+ * Supported parts include:
+ * TMA4XX
+ * TMA1036
+ *
+ * Copyright (C) 2012 Cypress Semiconductor
+ * Copyright (C) 2011 Sony Ericsson Mobile Communications AB.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2, and only version 2, as published by the
+ * Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * Contact Cypress Semiconductor at www.cypress.com <ttdrivers@cypress.com>
+ *
+ */
+
+#include "cyttsp4_mt_common.h"
+
+static void cyttsp4_lift_all(struct cyttsp4_mt_data *md)
+{
+	if (!md->si)
+		return;
+
+	if (md->num_prv_rec != 0) {
+		if (md->mt_function.report_slot_liftoff)
+			md->mt_function.report_slot_liftoff(md,
+				md->si->si_ofs.tch_abs[CY_TCH_T].max);
+		input_sync(md->input);
+		md->num_prv_rec = 0;
+	}
+}
+
+static void cyttsp4_mt_process_touch(struct cyttsp4_mt_data *md,
+	struct cyttsp4_touch *touch)
+{
+	//struct device *dev = &md->ttsp->dev;
+	int tmp;
+	bool flipped;
+
+	if (md->pdata->flags & CY_MT_FLAG_FLIP) {
+		tmp = touch->abs[CY_TCH_X];
+		touch->abs[CY_TCH_X] = touch->abs[CY_TCH_Y];
+		touch->abs[CY_TCH_Y] = tmp;
+		flipped = true;
+	} else
+		flipped = false;
+
+	if (md->pdata->flags & CY_MT_FLAG_INV_X) {
+		if (flipped)
+			touch->abs[CY_TCH_X] = md->si->si_ofs.max_y -
+				touch->abs[CY_TCH_X];
+		else
+			touch->abs[CY_TCH_X] = md->si->si_ofs.max_x -
+				touch->abs[CY_TCH_X];
+	}
+	if (md->pdata->flags & CY_MT_FLAG_INV_Y) {
+		if (flipped)
+			touch->abs[CY_TCH_Y] = md->si->si_ofs.max_x -
+				touch->abs[CY_TCH_Y];
+		else
+			touch->abs[CY_TCH_Y] = md->si->si_ofs.max_y -
+				touch->abs[CY_TCH_Y];
+	}
+#if 0
+	dev_vdbg(dev, "%s: flip=%s inv-x=%s inv-y=%s x=%04X(%d) y=%04X(%d)\n",
+		__func__, flipped ? "true" : "false",
+		md->pdata->flags & CY_MT_FLAG_INV_X ? "true" : "false",
+		md->pdata->flags & CY_MT_FLAG_INV_Y ? "true" : "false",
+		touch->abs[CY_TCH_X], touch->abs[CY_TCH_X],
+		touch->abs[CY_TCH_Y], touch->abs[CY_TCH_Y]);
+#endif
+}
+
+static void cyttsp4_get_mt_touches(struct cyttsp4_mt_data *md, int num_cur_rec)
+{
+	struct device *dev = &md->ttsp->dev;
+	struct cyttsp4_sysinfo *si = md->si;
+	struct cyttsp4_touch tch;
+	int sig;
+	int i, j, t = 0;
+	int mt_sync_count = 0;
+	DECLARE_BITMAP(ids, max(CY_TMA1036_MAX_TCH, CY_TMA4XX_MAX_TCH));
+
+	bitmap_zero(ids, si->si_ofs.tch_abs[CY_TCH_T].max);
+
+	for (i = 0; i < num_cur_rec; i++) {
+		cyttsp4_get_touch_record(md->ttsp, i, tch.abs);
+
+		/* Discard proximity event */
+		if (tch.abs[CY_TCH_O] == CY_OBJ_PROXIMITY) {
+			//dev_dbg(dev, "%s: Discarding proximity event\n",
+			//	__func__);
+			continue;
+		}
+
+		if ((tch.abs[CY_TCH_T] < md->pdata->frmwrk->abs
+			[(CY_ABS_ID_OST * CY_NUM_ABS_SET) + CY_MIN_OST]) ||
+			(tch.abs[CY_TCH_T] > md->pdata->frmwrk->abs
+			[(CY_ABS_ID_OST * CY_NUM_ABS_SET) + CY_MAX_OST])) {
+			dev_err(dev, "%s: tch=%d -> bad trk_id=%d max_id=%d\n",
+				__func__, i, tch.abs[CY_TCH_T],
+				md->pdata->frmwrk->abs[(CY_ABS_ID_OST *
+				CY_NUM_ABS_SET) + CY_MAX_OST]);
+			if (md->mt_function.input_sync)
+				md->mt_function.input_sync(md->input);
+			mt_sync_count++;
+			continue;
+		}
+
+		/* Process touch */
+		cyttsp4_mt_process_touch(md, &tch);
+
+		/* use 0 based track id's */
+		sig = md->pdata->frmwrk->abs
+			[(CY_ABS_ID_OST * CY_NUM_ABS_SET) + 0];
+		if (sig != CY_IGNORE_VALUE) {
+			t = tch.abs[CY_TCH_T] - md->pdata->frmwrk->abs
+				[(CY_ABS_ID_OST * CY_NUM_ABS_SET) + CY_MIN_OST];
+			if (tch.abs[CY_TCH_E] == CY_EV_LIFTOFF) {
+				//dev_dbg(dev, "%s: t=%d e=%d lift-off\n",
+				//	__func__, t, tch.abs[CY_TCH_E]);
+				goto cyttsp4_get_mt_touches_pr_tch;
+			}
+			if (md->mt_function.input_report)
+				md->mt_function.input_report(md->input, sig,
+					t, tch.abs[CY_TCH_O]);
+			__set_bit(t, ids);
+		}
+
+		/* all devices: position and pressure fields */
+		for (j = 0; j <= CY_ABS_W_OST ; j++) {
+			sig = md->pdata->frmwrk->abs[((CY_ABS_X_OST + j) *
+				CY_NUM_ABS_SET) + 0];
+			if (sig != CY_IGNORE_VALUE)
+				input_report_abs(md->input, sig,
+					tch.abs[CY_TCH_X + j]);
+		}
+		if (IS_TTSP_VER_GE(si, 2, 3)) {
+			/*
+			 * TMA400 size and orientation fields:
+			 * if pressure is non-zero and major touch
+			 * signal is zero, then set major and minor touch
+			 * signals to minimum non-zero value
+			 */
+			if (tch.abs[CY_TCH_P] > 0 && tch.abs[CY_TCH_MAJ] == 0)
+				tch.abs[CY_TCH_MAJ] = tch.abs[CY_TCH_MIN] = 1;
+
+			/* Get the extended touch fields */
+			for (j = 0; j < CY_NUM_EXT_TCH_FIELDS; j++) {
+				sig = md->pdata->frmwrk->abs
+					[((CY_ABS_MAJ_OST + j) *
+					CY_NUM_ABS_SET) + 0];
+				if (sig != CY_IGNORE_VALUE)
+					input_report_abs(md->input, sig,
+						tch.abs[CY_TCH_MAJ + j]);
+			}
+		}
+		if (md->mt_function.input_sync)
+			md->mt_function.input_sync(md->input);
+		mt_sync_count++;
+
+cyttsp4_get_mt_touches_pr_tch:
+			printk("x y z\n");
+#if 0
+		if (IS_TTSP_VER_GE(si, 2, 3))
+			dev_dbg(dev,
+				"%s: t=%d x=%d y=%d z=%d M=%d m=%d o=%d e=%d\n",
+				__func__, t,
+				tch.abs[CY_TCH_X],
+				tch.abs[CY_TCH_Y],
+				tch.abs[CY_TCH_P],
+				tch.abs[CY_TCH_MAJ],
+				tch.abs[CY_TCH_MIN],
+				tch.abs[CY_TCH_OR],
+				tch.abs[CY_TCH_E]);
+		else
+			dev_dbg(dev,
+				"%s: t=%d x=%d y=%d z=%d e=%d\n", __func__,
+				t,
+				tch.abs[CY_TCH_X],
+				tch.abs[CY_TCH_Y],
+				tch.abs[CY_TCH_P],
+				tch.abs[CY_TCH_E]);
+#endif
+	}
+
+	if (md->mt_function.final_sync)
+		md->mt_function.final_sync(md->input,
+			si->si_ofs.tch_abs[CY_TCH_T].max, mt_sync_count, ids);
+
+	md->num_prv_rec = num_cur_rec;
+	md->prv_tch_type = tch.abs[CY_TCH_O];
+
+	return;
+}
+
+/* read xy_data for all current touches */
+static int cyttsp4_xy_worker(struct cyttsp4_mt_data *md)
+{
+	struct device *dev = &md->ttsp->dev;
+	struct cyttsp4_sysinfo *si = md->si;
+	u8 num_cur_rec;
+	u8 rep_len;
+	u8 rep_stat;
+	u8 tt_stat;
+	int rc = 0;
+
+	/*
+	 * Get event data from cyttsp4 device.
+	 * The event data includes all data
+	 * for all active touches.
+	 * Event data also includes button data
+	 */
+	rep_len = si->xy_mode[si->si_ofs.rep_ofs];
+	rep_stat = si->xy_mode[si->si_ofs.rep_ofs + 1];
+	tt_stat = si->xy_mode[si->si_ofs.tt_stat_ofs];
+
+	num_cur_rec = GET_NUM_TOUCH_RECORDS(tt_stat);
+
+	if (rep_len == 0 && num_cur_rec > 0) {
+		dev_err(dev, "%s: report length error rep_len=%d num_tch=%d\n",
+			__func__, rep_len, num_cur_rec);
+		goto cyttsp4_xy_worker_exit;
+	}
+
+	/* check any error conditions */
+	if (IS_BAD_PKT(rep_stat)) {
+		//dev_dbg(dev, "%s: Invalid buffer detected\n", __func__);
+		rc = 0;
+		goto cyttsp4_xy_worker_exit;
+	}
+
+	if (IS_LARGE_AREA(tt_stat)) {
+		//dev_dbg(dev, "%s: Large area detected\n", __func__);
+		/* Do not report touch if configured so */
+		if (md->pdata->flags & CY_MT_FLAG_NO_TOUCH_ON_LO)
+			num_cur_rec = 0;
+	}
+
+	if (num_cur_rec > si->si_ofs.max_tchs) {
+		dev_err(dev, "%s: %s (n=%d c=%d)\n", __func__,
+			"too many tch; set to max tch",
+			num_cur_rec, si->si_ofs.max_tchs);
+		num_cur_rec = si->si_ofs.max_tchs;
+	}
+
+	/* extract xy_data for all currently reported touches */
+	//dev_vdbg(dev, "%s: extract data num_cur_rec=%d\n", __func__,
+	//	num_cur_rec);
+	if (num_cur_rec)
+		cyttsp4_get_mt_touches(md, num_cur_rec);
+	else
+		cyttsp4_lift_all(md);
+
+	//dev_vdbg(dev, "%s: done\n", __func__);
+	rc = 0;
+
+cyttsp4_xy_worker_exit:
+	return rc;
+}
+
+static void cyttsp4_mt_send_dummy_event(struct cyttsp4_mt_data *md)
+{
+	unsigned long ids = 0;
+
+	/* for easy wakeup */
+	if (md->mt_function.input_report)
+		md->mt_function.input_report(md->input, ABS_MT_TRACKING_ID,
+			0, CY_OBJ_STANDARD_FINGER);
+	if (md->mt_function.input_sync)
+		md->mt_function.input_sync(md->input);
+	if (md->mt_function.final_sync)
+		md->mt_function.final_sync(md->input, 0, 1, &ids);
+	if (md->mt_function.report_slot_liftoff)
+		md->mt_function.report_slot_liftoff(md, 1);
+	if (md->mt_function.final_sync)
+		md->mt_function.final_sync(md->input, 1, 1, &ids);
+}
+
+static int cyttsp4_mt_attention(struct cyttsp4_device *ttsp)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_mt_data *md = dev_get_drvdata(dev);
+	int rc = 0;
+
+	//dev_vdbg(dev, "%s\n", __func__);
+
+	mutex_lock(&md->report_lock);
+	if (!md->is_suspended) {
+		/* core handles handshake */
+		rc = cyttsp4_xy_worker(md);
+	}
+	mutex_unlock(&md->report_lock);
+	if (rc < 0)
+		dev_err(dev, "%s: xy_worker error r=%d\n", __func__, rc);
+
+	return rc;
+}
+
+static int cyttsp4_mt_wake_attention(struct cyttsp4_device *ttsp)
+{
+	struct cyttsp4_mt_data *md = dev_get_drvdata(&ttsp->dev);
+
+	mutex_lock(&md->report_lock);
+	cyttsp4_mt_send_dummy_event(md);
+	mutex_unlock(&md->report_lock);
+	return 0;
+}
+
+static int cyttsp4_startup_attention(struct cyttsp4_device *ttsp)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_mt_data *md = dev_get_drvdata(dev);
+	int rc = 0;
+
+	//dev_vdbg(dev, "%s\n", __func__);
+
+	mutex_lock(&md->report_lock);
+	cyttsp4_lift_all(md);
+	mutex_unlock(&md->report_lock);
+	return rc;
+}
+
+static int cyttsp4_mt_open(struct input_dev *input)
+{
+	struct device *dev = input->dev.parent;
+	struct cyttsp4_device *ttsp =
+		container_of(dev, struct cyttsp4_device, dev);
+
+//	dev_dbg(dev, "%s\n", __func__);
+
+	pm_runtime_get(dev);
+
+//	dev_vdbg(dev, "%s: setup subscriptions\n", __func__);
+
+	/* set up touch call back */
+	cyttsp4_subscribe_attention(ttsp, CY_ATTEN_IRQ,
+		cyttsp4_mt_attention, CY_MODE_OPERATIONAL);
+
+	/* set up startup call back */
+	cyttsp4_subscribe_attention(ttsp, CY_ATTEN_STARTUP,
+		cyttsp4_startup_attention, 0);
+
+	/* set up wakeup call back */
+	cyttsp4_subscribe_attention(ttsp, CY_ATTEN_WAKE,
+		cyttsp4_mt_wake_attention, 0);
+
+	return 0;
+}
+
+static void cyttsp4_mt_close(struct input_dev *input)
+{
+	struct device *dev = input->dev.parent;
+	struct cyttsp4_device *ttsp =
+		container_of(dev, struct cyttsp4_device, dev);
+
+	//dev_dbg(dev, "%s\n", __func__);
+
+	cyttsp4_unsubscribe_attention(ttsp, CY_ATTEN_IRQ,
+		cyttsp4_mt_attention, CY_MODE_OPERATIONAL);
+
+	cyttsp4_unsubscribe_attention(ttsp, CY_ATTEN_STARTUP,
+		cyttsp4_startup_attention, 0);
+
+	cyttsp4_unsubscribe_attention(ttsp, CY_ATTEN_WAKE,
+		cyttsp4_mt_wake_attention, 0);
+
+	pm_runtime_put(dev);
+}
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+static void cyttsp4_mt_early_suspend(struct early_suspend *h)
+{
+	struct cyttsp4_mt_data *md =
+		container_of(h, struct cyttsp4_mt_data, es);
+	struct device *dev = &md->ttsp->dev;
+
+	//dev_dbg(dev, "%s\n", __func__);
+
+#ifndef CONFIG_PM_RUNTIME
+	mutex_lock(&md->report_lock);
+	md->is_suspended = true;
+	cyttsp4_lift_all(md);
+	mutex_unlock(&md->report_lock);
+#endif
+
+	pm_runtime_put(dev);
+}
+
+static void cyttsp4_mt_late_resume(struct early_suspend *h)
+{
+	struct cyttsp4_mt_data *md =
+		container_of(h, struct cyttsp4_mt_data, es);
+	struct device *dev = &md->ttsp->dev;
+
+	//dev_dbg(dev, "%s\n", __func__);
+
+#ifndef CONFIG_PM_RUNTIME
+	mutex_lock(&md->report_lock);
+	md->is_suspended = false;
+	mutex_unlock(&md->report_lock);
+#endif
+
+	pm_runtime_get(dev);
+}
+
+static void cyttsp4_setup_early_suspend(struct cyttsp4_mt_data *md)
+{
+	md->es.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN + 1;
+	md->es.suspend = cyttsp4_mt_early_suspend;
+	md->es.resume = cyttsp4_mt_late_resume;
+
+	register_early_suspend(&md->es);
+}
+#endif
+
+#if defined(CONFIG_PM_SLEEP) || defined(CONFIG_PM_RUNTIME)
+static int cyttsp4_mt_suspend(struct device *dev)
+{
+	struct cyttsp4_mt_data *md = dev_get_drvdata(dev);
+
+	//dev_dbg(dev, "%s\n", __func__);
+
+	mutex_lock(&md->report_lock);
+	md->is_suspended = true;
+	cyttsp4_lift_all(md);
+	mutex_unlock(&md->report_lock);
+
+	return 0;
+}
+
+static int cyttsp4_mt_rt_resume(struct device *dev)
+{
+	struct cyttsp4_mt_data *md = dev_get_drvdata(dev);
+
+	//dev_dbg(dev, "%s\n", __func__);
+
+	mutex_lock(&md->report_lock);
+	md->is_suspended = false;
+	mutex_unlock(&md->report_lock);
+
+	return 0;
+}
+
+static int cyttsp4_mt_resume(struct device *dev)
+{
+	struct cyttsp4_mt_data *md = dev_get_drvdata(dev);
+
+	//dev_dbg(dev, "%s\n", __func__);
+
+	mutex_lock(&md->report_lock);
+	md->is_suspended = false;
+	mutex_unlock(&md->report_lock);
+	return 0;
+}
+#endif
+
+static const struct dev_pm_ops cyttsp4_mt_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(cyttsp4_mt_suspend, cyttsp4_mt_resume)
+	SET_RUNTIME_PM_OPS(cyttsp4_mt_suspend, cyttsp4_mt_rt_resume, NULL)
+};
+
+static int cyttsp4_setup_input_device(struct cyttsp4_device *ttsp)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_mt_data *md = dev_get_drvdata(dev);
+	int signal = CY_IGNORE_VALUE;
+	int max_x, max_y, max_p, min, max;
+	int max_x_tmp, max_y_tmp;
+	int i;
+	int rc;
+
+	//dev_vdbg(dev, "%s: Initialize event signals\n", __func__);
+	__set_bit(EV_ABS, md->input->evbit);
+	__set_bit(EV_REL, md->input->evbit);
+	__set_bit(EV_KEY, md->input->evbit);
+#ifdef INPUT_PROP_DIRECT
+	__set_bit(INPUT_PROP_DIRECT, md->input->propbit);
+#endif
+
+	/* If virtualkeys enabled, don't use all screen */
+	if (md->pdata->flags & CY_MT_FLAG_VKEYS) {
+		max_x_tmp = md->pdata->vkeys_x;
+		max_y_tmp = md->pdata->vkeys_y;
+	} else {
+		max_x_tmp = md->si->si_ofs.max_x;
+		max_y_tmp = md->si->si_ofs.max_y;
+	}
+	//max_y_tmp=1280;
+		printk(" resolution is %dx%d\n",max_x_tmp,max_y_tmp);
+	max_y_tmp=960;
+	/* get maximum values from the sysinfo data */
+	if (md->pdata->flags & CY_MT_FLAG_FLIP) {
+		max_x = max_y_tmp - 1;
+		max_y = max_x_tmp - 1;
+	} else {
+		max_x = max_x_tmp - 1;
+		max_y = max_y_tmp - 1;
+	}
+	max_p = md->si->si_ofs.max_p;
+
+	/* set event signal capabilities */
+	for (i = 0; i < (md->pdata->frmwrk->size / CY_NUM_ABS_SET); i++) {
+		signal = md->pdata->frmwrk->abs
+			[(i * CY_NUM_ABS_SET) + CY_SIGNAL_OST];
+		if (signal != CY_IGNORE_VALUE) {
+			__set_bit(signal, md->input->absbit);
+			min = md->pdata->frmwrk->abs
+				[(i * CY_NUM_ABS_SET) + CY_MIN_OST];
+			max = md->pdata->frmwrk->abs
+				[(i * CY_NUM_ABS_SET) + CY_MAX_OST];
+			if (i == CY_ABS_ID_OST) {
+				/* shift track ids down to start at 0 */
+				max = max - min;
+				min = min - min;
+			} else if (i == CY_ABS_X_OST)
+				max = max_x;
+			else if (i == CY_ABS_Y_OST)
+				max = max_y;
+			else if (i == CY_ABS_P_OST)
+				max = max_p;
+			input_set_abs_params(md->input, signal, min, max,
+				md->pdata->frmwrk->abs
+				[(i * CY_NUM_ABS_SET) + CY_FUZZ_OST],
+				md->pdata->frmwrk->abs
+				[(i * CY_NUM_ABS_SET) + CY_FLAT_OST]);
+			//dev_dbg(dev, "%s: register signal=%02X min=%d max=%d\n",
+			//	__func__, signal, min, max);
+			if (i == CY_ABS_ID_OST && !IS_TTSP_VER_GE(md->si, 2, 3))
+				break;
+		}
+	}
+
+	rc = md->mt_function.input_register_device(md->input,
+			md->si->si_ofs.tch_abs[CY_TCH_T].max);
+	if (rc < 0)
+		dev_err(dev, "%s: Error, failed register input device r=%d\n",
+			__func__, rc);
+	else
+		md->input_device_registered = true;
+
+	return rc;
+}
+
+static int cyttsp4_setup_input_attention(struct cyttsp4_device *ttsp)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_mt_data *md = dev_get_drvdata(dev);
+	int rc = 0;
+
+	//dev_vdbg(dev, "%s\n", __func__);
+
+	md->si = cyttsp4_request_sysinfo(ttsp);
+	if (!md->si)
+		return -EINVAL;
+
+	rc = cyttsp4_setup_input_device(ttsp);
+
+	cyttsp4_unsubscribe_attention(ttsp, CY_ATTEN_STARTUP,
+		cyttsp4_setup_input_attention, 0);
+
+	return rc;
+}
+
+static int cyttsp4_mt_release(struct cyttsp4_device *ttsp)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_mt_data *md = dev_get_drvdata(dev);
+
+	//dev_dbg(dev, "%s\n", __func__);
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	/*
+	 * This check is to prevent pm_runtime usage_count drop below zero
+	 * because of removing the module while in suspended state
+	 */
+	if (md->is_suspended)
+		pm_runtime_get_noresume(dev);
+
+	unregister_early_suspend(&md->es);
+#endif
+
+	if (md->input_device_registered) {
+		input_unregister_device(md->input);
+	} else {
+		input_free_device(md->input);
+		cyttsp4_unsubscribe_attention(ttsp, CY_ATTEN_STARTUP,
+			cyttsp4_setup_input_attention, 0);
+	}
+
+	pm_runtime_suspend(dev);
+	pm_runtime_disable(dev);
+
+	dev_set_drvdata(dev, NULL);
+	kfree(md);
+	return 0;
+}
+
+static int cyttsp4_mt_probe(struct cyttsp4_device *ttsp)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_mt_data *md;
+	struct cyttsp4_mt_platform_data *pdata = dev_get_platdata(dev);
+	u8 pannel_id;
+	int rc = 0;
+
+	dev_info(dev, "%s\n", __func__);
+	//dev_dbg(dev, "%s: debug on\n", __func__);
+	//dev_vdbg(dev, "%s: verbose debug on\n", __func__);
+
+	if (pdata == NULL) {
+		dev_err(dev, "%s: Missing platform data\n", __func__);
+		rc = -ENODEV;
+		goto error_no_pdata;
+	}
+
+	md = kzalloc(sizeof(*md), GFP_KERNEL);
+	if (md == NULL) {
+		dev_err(dev, "%s: Error, kzalloc\n", __func__);
+		rc = -ENOMEM;
+		goto error_alloc_data_failed;
+	}
+
+	cyttsp4_init_function_ptrs(md);
+
+	mutex_init(&md->report_lock);
+	md->prv_tch_type = CY_OBJ_STANDARD_FINGER;
+	md->ttsp = ttsp;
+	md->pdata = pdata;
+	dev_set_drvdata(dev, md);
+	/* Create the input device and register it. */
+	//dev_vdbg(dev, "%s: Create the input device and register it\n",
+	//	__func__);
+	md->input = input_allocate_device();
+	if (md->input == NULL) {
+		dev_err(dev, "%s: Error, failed to allocate input device\n",
+			__func__);
+		rc = -ENOSYS;
+		goto error_alloc_failed;
+	}
+
+	md->input->name = ttsp->name;
+	scnprintf(md->phys, sizeof(md->phys)-1, "%s", dev_name(dev));
+	md->input->phys = md->phys;
+	md->input->dev.parent = &md->ttsp->dev;
+	md->input->open = cyttsp4_mt_open;
+	md->input->close = cyttsp4_mt_close;
+	input_set_drvdata(md->input, md);
+
+	pm_runtime_enable(dev);
+
+	/* get sysinfo */
+	md->si = cyttsp4_request_sysinfo(ttsp);
+	if (md->si) {
+		rc = cyttsp4_setup_input_device(ttsp);
+		if (rc)
+			goto error_init_input;
+	} else {
+		dev_err(dev, "%s: Fail get sysinfo pointer from core p=%p\n",
+			__func__, md->si);
+		cyttsp4_subscribe_attention(ttsp, CY_ATTEN_STARTUP,
+			cyttsp4_setup_input_attention, 0);
+	}
+
+	pannel_id = md->si->si_ptrs.pcfg->panel_info0;
+	printk("pannel_id is %0x\n",pannel_id);
+
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	cyttsp4_setup_early_suspend(md);
+#endif
+
+	//dev_dbg(dev, "%s: OK\n", __func__);
+	return 0;
+
+error_init_input:
+	pm_runtime_suspend(dev);
+	pm_runtime_disable(dev);
+	input_free_device(md->input);
+error_alloc_failed:
+	dev_set_drvdata(dev, NULL);
+	kfree(md);
+error_alloc_data_failed:
+error_no_pdata:
+	dev_err(dev, "%s failed.\n", __func__);
+	return rc;
+}
+
+struct cyttsp4_driver cyttsp4_mt_driver = {
+	.probe = cyttsp4_mt_probe,
+	.remove = cyttsp4_mt_release,
+	.driver = {
+		.name = CYTTSP4_MT_NAME,
+		.bus = &cyttsp4_bus_type,
+		.pm = &cyttsp4_mt_pm_ops,
+	},
+};
+
diff --git a/drivers/input/touchscreen/cypress/cyttsp4_mt_common.h b/drivers/input/touchscreen/cypress/cyttsp4_mt_common.h
new file mode 100644
index 0000000..94fa791
--- /dev/null
+++ b/drivers/input/touchscreen/cypress/cyttsp4_mt_common.h
@@ -0,0 +1,86 @@
+/*
+ * cyttsp4_mt_common.h
+ * Cypress TrueTouch(TM) Standard Product V4 Multi-touch module.
+ * For use with Cypress Txx4xx parts.
+ * Supported parts include:
+ * TMA4XX
+ * TMA1036
+ *
+ * Copyright (C) 2012 Cypress Semiconductor
+ * Copyright (C) 2011 Sony Ericsson Mobile Communications AB.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2, and only version 2, as published by the
+ * Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * Contact Cypress Semiconductor at www.cypress.com <ttdrivers@cypress.com>
+ *
+ */
+
+#include <linux/cyttsp4_bus.h>
+
+#include <linux/delay.h>
+#ifdef CONFIG_HAS_EARLYSUSPEND
+#include <linux/earlysuspend.h>
+#endif
+#include <linux/gpio.h>
+#include <linux/input.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/limits.h>
+#include <linux/module.h>
+#include <linux/pm_runtime.h>
+#include <linux/slab.h>
+#include <linux/workqueue.h>
+
+#include <linux/cyttsp4_core.h>
+#include <linux/cyttsp4_mt.h>
+#include "cyttsp4_regs.h"
+
+struct cyttsp4_mt_data;
+struct cyttsp4_mt_function {
+	int (*mt_release)(struct cyttsp4_device *ttsp);
+	int (*mt_probe)(struct cyttsp4_device *ttsp,
+			struct cyttsp4_mt_data *md);
+	void (*report_slot_liftoff)(struct cyttsp4_mt_data *md, int max_slots);
+	void (*input_sync)(struct input_dev *input);
+	void (*input_report)(struct input_dev *input, int sig, int t,
+			int type);
+	void (*final_sync)(struct input_dev *input, int max_slots,
+			int mt_sync_count, unsigned long *ids);
+	int (*input_register_device)(struct input_dev *input, int max_slots);
+};
+
+struct cyttsp4_mt_data {
+	struct cyttsp4_device *ttsp;
+	struct cyttsp4_mt_platform_data *pdata;
+	struct cyttsp4_sysinfo *si;
+	struct input_dev *input;
+	struct cyttsp4_mt_function mt_function;
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	struct early_suspend es;
+#endif
+	struct mutex report_lock;
+	bool is_suspended;
+	bool input_device_registered;
+	char phys[NAME_MAX];
+	int num_prv_rec; /* Number of previous touch records */
+	int prv_tch_type;
+#ifdef VERBOSE_DEBUG
+	u8 pr_buf[CY_MAX_PRBUF_SIZE];
+#endif
+};
+
+extern void cyttsp4_init_function_ptrs(struct cyttsp4_mt_data *md);
+extern struct cyttsp4_driver cyttsp4_mt_driver;
+
diff --git a/drivers/input/touchscreen/cypress/cyttsp4_mta.c b/drivers/input/touchscreen/cypress/cyttsp4_mta.c
new file mode 100644
index 0000000..aee4124
--- /dev/null
+++ b/drivers/input/touchscreen/cypress/cyttsp4_mta.c
@@ -0,0 +1,108 @@
+/*
+ * cyttsp4_mta.c
+ * Cypress TrueTouch(TM) Standard Product V4 Multi-touch module.
+ * For use with Cypress Txx4xx parts.
+ * Supported parts include:
+ * TMA4XX
+ * TMA1036
+ *
+ * Copyright (C) 2012 Cypress Semiconductor
+ * Copyright (C) 2011 Sony Ericsson Mobile Communications AB.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2, and only version 2, as published by the
+ * Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * Contact Cypress Semiconductor at www.cypress.com <ttdrivers@cypress.com>
+ *
+ */
+
+#include <linux/input.h>
+#include <linux/cyttsp4_core.h>
+
+#include "cyttsp4_mt_common.h"
+
+static void cyttsp4_final_sync(struct input_dev *input, int max_slots,
+		int mt_sync_count, unsigned long *ids)
+{
+	if (mt_sync_count)
+		input_sync(input);
+}
+
+static void cyttsp4_input_sync(struct input_dev *input)
+{
+	input_mt_sync(input);
+}
+
+static void cyttsp4_input_report(struct input_dev *input, int sig,
+		 int t, int type)
+{
+	if (type == CY_OBJ_STANDARD_FINGER || type == CY_OBJ_GLOVE) {
+		input_report_key(input, BTN_TOOL_FINGER, CY_BTN_PRESSED);
+		input_report_key(input, BTN_TOOL_PEN, CY_BTN_RELEASED);
+	} else if (type == CY_OBJ_STYLUS) {
+		input_report_key(input, BTN_TOOL_PEN, CY_BTN_PRESSED);
+		input_report_key(input, BTN_TOOL_FINGER, CY_BTN_RELEASED);
+	}
+	input_report_key(input, BTN_TOUCH, CY_BTN_PRESSED);
+
+	input_report_abs(input, sig, t);
+}
+
+static void cyttsp4_report_slot_liftoff(struct cyttsp4_mt_data *md,
+		int max_slots)
+{
+	input_report_key(md->input, BTN_TOUCH, CY_BTN_RELEASED);
+	input_report_key(md->input, BTN_TOOL_FINGER, CY_BTN_RELEASED);
+	input_report_key(md->input, BTN_TOOL_PEN, CY_BTN_RELEASED);
+
+}
+
+static int cyttsp4_input_register_device(struct input_dev *input, int max_slots)
+{
+	__set_bit(BTN_TOUCH, input->keybit);
+	__set_bit(BTN_TOOL_FINGER, input->keybit);
+	__set_bit(BTN_TOOL_PEN, input->keybit);
+	return input_register_device(input);
+}
+
+void cyttsp4_init_function_ptrs(struct cyttsp4_mt_data *md)
+{
+	md->mt_function.report_slot_liftoff = cyttsp4_report_slot_liftoff;
+	md->mt_function.final_sync = cyttsp4_final_sync;
+	md->mt_function.input_sync = cyttsp4_input_sync;
+	md->mt_function.input_report = cyttsp4_input_report;
+	md->mt_function.input_register_device = cyttsp4_input_register_device;
+}
+
+static int __init cyttsp4_mt_init(void)
+{
+	int rc;
+	cyttsp4_mt_driver.driver.owner = THIS_MODULE;
+	rc = cyttsp4_register_driver(&cyttsp4_mt_driver);
+	pr_info("%s: Cypress TTSP MT v4 multi-touch (Built %s), rc=%d\n",
+		 __func__, CY_DRIVER_DATE, rc);
+	return rc;
+}
+module_init(cyttsp4_mt_init);
+
+static void __exit cyttsp4_mt_exit(void)
+{
+	cyttsp4_unregister_driver(&cyttsp4_mt_driver);
+	pr_info("%s: module exit\n", __func__);
+}
+module_exit(cyttsp4_mt_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Cypress TrueTouch(R) Standard 2D multi-touch driver");
+MODULE_AUTHOR("Cypress Semiconductor");
diff --git a/drivers/input/touchscreen/cypress/cyttsp4_mtb.c b/drivers/input/touchscreen/cypress/cyttsp4_mtb.c
new file mode 100644
index 0000000..19c96c4c
--- /dev/null
+++ b/drivers/input/touchscreen/cypress/cyttsp4_mtb.c
@@ -0,0 +1,115 @@
+/*
+ * cyttsp4_mtb.c
+ * Cypress TrueTouch(TM) Standard Product V4 Multi-touch module.
+ * For use with Cypress Txx4xx parts.
+ * Supported parts include:
+ * TMA4XX
+ * TMA1036
+ *
+ * Copyright (C) 2012 Cypress Semiconductor
+ * Copyright (C) 2011 Sony Ericsson Mobile Communications AB.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2, and only version 2, as published by the
+ * Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * Contact Cypress Semiconductor at www.cypress.com <ttdrivers@cypress.com>
+ *
+ */
+
+#include <linux/input.h>
+#include <linux/input/mt.h>
+#include <linux/cyttsp4_core.h>
+
+#include "cyttsp4_mt_common.h"
+
+static void cyttsp4_final_sync(struct input_dev *input, int max_slots,
+		int mt_sync_count, unsigned long *ids)
+{
+	int t;
+
+	for (t = 0; t < max_slots; t++) {
+		if (test_bit(t, ids))
+			continue;
+		input_mt_slot(input, t);
+		input_mt_report_slot_state(input, MT_TOOL_FINGER, false);
+	}
+
+	input_sync(input);
+}
+
+static void cyttsp4_input_report(struct input_dev *input, int sig,
+		int t, int type)
+{
+	input_mt_slot(input, t);
+
+	if (type == CY_OBJ_STANDARD_FINGER || type == CY_OBJ_GLOVE)
+		input_mt_report_slot_state(input, MT_TOOL_FINGER, true);
+	else if (type == CY_OBJ_STYLUS)
+		input_mt_report_slot_state(input, MT_TOOL_PEN, true);
+}
+
+static void cyttsp4_report_slot_liftoff(struct cyttsp4_mt_data *md,
+		int max_slots)
+{
+	int t;
+
+	if (md->num_prv_rec == 0)
+		return;
+
+	for (t = 0; t < max_slots; t++) {
+		input_mt_slot(md->input, t);
+		input_mt_report_slot_state(md->input,
+			MT_TOOL_FINGER, false);
+	}
+}
+
+static int cyttsp4_input_register_device(struct input_dev *input, int max_slots)
+{
+	input_set_abs_params(input, ABS_MT_TOOL_TYPE,
+			0, MT_TOOL_MAX, 0, 0);
+
+	input_mt_init_slots(input, max_slots);
+	return input_register_device(input);
+}
+
+void cyttsp4_init_function_ptrs(struct cyttsp4_mt_data *md)
+{
+	md->mt_function.report_slot_liftoff = cyttsp4_report_slot_liftoff;
+	md->mt_function.final_sync = cyttsp4_final_sync;
+	md->mt_function.input_sync = NULL;
+	md->mt_function.input_report = cyttsp4_input_report;
+	md->mt_function.input_register_device = cyttsp4_input_register_device;
+}
+
+static int __init cyttsp4_mt_init(void)
+{
+	int rc;
+	cyttsp4_mt_driver.driver.owner = THIS_MODULE;
+	rc = cyttsp4_register_driver(&cyttsp4_mt_driver);
+	pr_info("%s: Cypress TTSP MT v4 multi-touch (Built %s), rc=%d\n",
+		 __func__, CY_DRIVER_DATE, rc);
+	return rc;
+}
+module_init(cyttsp4_mt_init);
+
+static void __exit cyttsp4_mt_exit(void)
+{
+	cyttsp4_unregister_driver(&cyttsp4_mt_driver);
+	pr_info("%s: module exit\n", __func__);
+}
+module_exit(cyttsp4_mt_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Cypress TrueTouch(R) Standard 2D multi-touch driver");
+MODULE_AUTHOR("Cypress Semiconductor");
diff --git a/drivers/input/touchscreen/cypress/cyttsp4_platform.c b/drivers/input/touchscreen/cypress/cyttsp4_platform.c
new file mode 100644
index 0000000..4a19db6
--- /dev/null
+++ b/drivers/input/touchscreen/cypress/cyttsp4_platform.c
@@ -0,0 +1,235 @@
+/*
+ * cyttsp4_platform.c
+ * Cypress TrueTouch(TM) Standard Product V4 Platform Module.
+ * For use with Cypress Txx4xx parts.
+ * Supported parts include:
+ * TMA4XX
+ * TMA1036
+ *
+ * Copyright (C) 2013 Cypress Semiconductor
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2, and only version 2, as published by the
+ * Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * Contact Cypress Semiconductor at www.cypress.com <ttdrivers@cypress.com>
+ *
+ */
+
+#include <linux/device.h>
+#include <linux/gpio.h>
+#include <linux/delay.h>
+
+/* cyttsp */
+#include <linux/cyttsp4_bus.h>
+#include <linux/cyttsp4_core.h>
+
+#ifdef CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_PLATFORM_FW_UPGRADE
+#include "cyttsp4_img.h"
+static struct cyttsp4_touch_firmware cyttsp4_firmware = {
+	.img = cyttsp4_img,
+	.size = ARRAY_SIZE(cyttsp4_img),
+	.ver = cyttsp4_ver,
+	.vsize = ARRAY_SIZE(cyttsp4_ver),
+};
+#else
+static struct cyttsp4_touch_firmware cyttsp4_firmware = {
+	.img = NULL,
+	.size = 0,
+	.ver = NULL,
+	.vsize = 0,
+};
+#endif
+
+#ifdef CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_PLATFORM_TTCONFIG_UPGRADE
+#include "cyttsp4_params.h"
+static struct touch_settings cyttsp4_sett_param_regs = {
+	.data = (uint8_t *)&cyttsp4_param_regs[0],
+	.size = ARRAY_SIZE(cyttsp4_param_regs),
+	.tag = 0,
+};
+
+static struct touch_settings cyttsp4_sett_param_size = {
+	.data = (uint8_t *)&cyttsp4_param_size[0],
+	.size = ARRAY_SIZE(cyttsp4_param_size),
+	.tag = 0,
+};
+
+static struct cyttsp4_touch_config cyttsp4_ttconfig = {
+	.param_regs = &cyttsp4_sett_param_regs,
+	.param_size = &cyttsp4_sett_param_size,
+	.fw_ver = ttconfig_fw_ver,
+	.fw_vsize = ARRAY_SIZE(ttconfig_fw_ver),
+};
+#else
+static struct cyttsp4_touch_config cyttsp4_ttconfig = {
+	.param_regs = NULL,
+	.param_size = NULL,
+	.fw_ver = NULL,
+	.fw_vsize = 0,
+};
+#endif
+
+struct cyttsp4_loader_platform_data _cyttsp4_loader_platform_data = {
+	.fw = &cyttsp4_firmware,
+	.ttconfig = &cyttsp4_ttconfig,
+	.flags = CY_LOADER_FLAG_NONE,
+};
+
+int cyttsp4_xres(struct cyttsp4_core_platform_data *pdata,
+		struct device *dev)
+{
+	int rst_gpio = pdata->rst_gpio;
+	int rc = 0;
+
+	gpio_set_value(rst_gpio, 1);
+	msleep(20);
+	gpio_set_value(rst_gpio, 0);
+	msleep(40);
+	gpio_set_value(rst_gpio, 1);
+	msleep(20);
+	dev_info(dev,
+		"%s: RESET CYTTSP gpio=%d r=%d\n", __func__,
+		pdata->rst_gpio, rc);
+	return rc;
+}
+
+int cyttsp4_init(struct cyttsp4_core_platform_data *pdata,
+		int on, struct device *dev)
+{
+	int rst_gpio = pdata->rst_gpio;
+	int irq_gpio = pdata->irq_gpio;
+	int rc = 0;
+
+	if (on) {
+		rc = gpio_request(rst_gpio, NULL);
+		if (rc < 0) {
+			gpio_free(rst_gpio);
+			rc = gpio_request(rst_gpio, NULL);
+		}
+		if (rc < 0) {
+			dev_err(dev,
+				"%s: Fail request gpio=%d\n", __func__,
+				rst_gpio);
+		} else {
+			rc = gpio_direction_output(rst_gpio, 1);
+			if (rc < 0) {
+				pr_err("%s: Fail set output gpio=%d\n",
+					__func__, rst_gpio);
+				gpio_free(rst_gpio);
+			} else {
+				rc = gpio_request(irq_gpio, NULL);
+				if (rc < 0) {
+					gpio_free(irq_gpio);
+					rc = gpio_request(irq_gpio,
+						NULL);
+				}
+				if (rc < 0) {
+					dev_err(dev,
+						"%s: Fail request gpio=%d\n",
+						__func__, irq_gpio);
+					gpio_free(rst_gpio);
+				} else {
+					gpio_direction_input(irq_gpio);
+				}
+			}
+		}
+	} else {
+		gpio_free(rst_gpio);
+		gpio_free(irq_gpio);
+	}
+
+	dev_info(dev,
+		"%s: INIT CYTTSP RST gpio=%d and IRQ gpio=%d r=%d\n",
+		__func__, rst_gpio, irq_gpio, rc);
+	return rc;
+}
+
+static int cyttsp4_wakeup(struct cyttsp4_core_platform_data *pdata,
+		struct device *dev, atomic_t *ignore_irq)
+{
+	int irq_gpio = pdata->irq_gpio;
+	int rc = 0;
+
+	if (ignore_irq)
+		atomic_set(ignore_irq, 1);
+	rc = gpio_direction_output(irq_gpio, 0);
+	if (rc < 0) {
+		if (ignore_irq)
+			atomic_set(ignore_irq, 0);
+		dev_err(dev,
+			"%s: Fail set output gpio=%d\n",
+			__func__, irq_gpio);
+	} else {
+		udelay(2000);
+		rc = gpio_direction_input(irq_gpio);
+		if (ignore_irq)
+			atomic_set(ignore_irq, 0);
+		if (rc < 0) {
+			dev_err(dev,
+				"%s: Fail set input gpio=%d\n",
+				__func__, irq_gpio);
+		}
+	}
+
+	dev_info(dev,
+		"%s: WAKEUP CYTTSP gpio=%d r=%d\n", __func__,
+		irq_gpio, rc);
+	return rc;
+}
+
+static int cyttsp4_sleep(struct cyttsp4_core_platform_data *pdata,
+		struct device *dev, atomic_t *ignore_irq)
+{
+	return 0;
+}
+
+int cyttsp4_power(struct cyttsp4_core_platform_data *pdata,
+		int on, struct device *dev, atomic_t *ignore_irq)
+{
+	if (on)
+		return cyttsp4_wakeup(pdata, dev, ignore_irq);
+
+	return cyttsp4_sleep(pdata, dev, ignore_irq);
+}
+
+int cyttsp4_irq_stat(struct cyttsp4_core_platform_data *pdata,
+		struct device *dev)
+{
+	return gpio_get_value(pdata->irq_gpio);
+}
+
+#ifdef CYTTSP4_DETECT_HW
+int cyttsp4_detect(struct cyttsp4_core_platform_data *pdata,
+		struct device *dev, cyttsp4_platform_read read)
+{
+	int retry = 3;
+	int rc;
+	char buf[1];
+
+	while (retry--) {
+		/* Perform reset, wait for 100 ms and perform read */
+		dev_vdbg(dev, "%s: Performing a reset\n", __func__);
+		pdata->xres(pdata, dev);
+		msleep(100);
+		rc = read(dev, 0, buf, 1);
+		if (!rc)
+			return 0;
+
+		dev_vdbg(dev, "%s: Read unsuccessful, try=%d\n",
+			__func__, 3 - retry);
+	}
+
+	return rc;
+}
+#endif
diff --git a/drivers/input/touchscreen/cypress/cyttsp4_proximity.c b/drivers/input/touchscreen/cypress/cyttsp4_proximity.c
new file mode 100644
index 0000000..f714f95
--- /dev/null
+++ b/drivers/input/touchscreen/cypress/cyttsp4_proximity.c
@@ -0,0 +1,585 @@
+/*
+ * cyttsp4_proximity.c
+ * Cypress TrueTouch(TM) Standard Product V4 Proximity touch reports module.
+ * For use with Cypress Txx4xx parts.
+ * Supported parts include:
+ * TMA4XX
+ * TMA1036
+ *
+ * Copyright (C) 2013 Cypress Semiconductor
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2, and only version 2, as published by the
+ * Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * Contact Cypress Semiconductor at www.cypress.com <ttdrivers@cypress.com>
+ *
+ */
+
+#include <linux/cyttsp4_bus.h>
+
+#include <linux/delay.h>
+#include <linux/gpio.h>
+#include <linux/input.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/limits.h>
+#include <linux/module.h>
+#include <linux/pm_runtime.h>
+#include <linux/slab.h>
+#include <linux/workqueue.h>
+
+#include <linux/cyttsp4_core.h>
+#include <linux/cyttsp4_mt.h>
+#include <linux/cyttsp4_proximity.h>
+#include "cyttsp4_regs.h"
+
+/* Timeout value in ms. */
+#define CY_PROXIMITY_REQUEST_EXCLUSIVE_TIMEOUT		1000
+
+#define CY_PROXIMITY_ON 0
+#define CY_PROXIMITY_OFF 1
+
+static int cyttsp4_proximity_attention(struct cyttsp4_device *ttsp);
+static int cyttsp4_startup_attention(struct cyttsp4_device *ttsp);
+
+struct cyttsp4_proximity_data {
+	struct cyttsp4_device *ttsp;
+	struct cyttsp4_proximity_platform_data *pdata;
+	struct cyttsp4_sysinfo *si;
+	struct input_dev *input;
+	struct mutex report_lock;
+	struct mutex sysfs_lock;
+	int enable_count;
+	bool is_suspended;
+	bool input_device_registered;
+	char phys[NAME_MAX];
+	u8 pr_buf[CY_MAX_PRBUF_SIZE];
+};
+
+static void cyttsp4_report_proximity(struct cyttsp4_proximity_data *pd,
+	bool on)
+{
+	int val = on ? CY_PROXIMITY_ON : CY_PROXIMITY_OFF;
+
+	input_report_abs(pd->input, ABS_DISTANCE, val);
+	input_sync(pd->input);
+}
+
+static void cyttsp4_get_proximity_touch(struct cyttsp4_proximity_data *pd,
+		int num_cur_rec)
+{
+	struct cyttsp4_touch tch;
+	int i;
+
+	for (i = 0; i < num_cur_rec; i++) {
+		cyttsp4_get_touch_record(pd->ttsp, i, tch.abs);
+
+		/* Check for proximity event */
+		if (tch.abs[CY_TCH_O] == CY_OBJ_PROXIMITY) {
+			if (tch.abs[CY_TCH_E] == CY_EV_TOUCHDOWN)
+				cyttsp4_report_proximity(pd, true);
+			else if (tch.abs[CY_TCH_E] == CY_EV_LIFTOFF)
+				cyttsp4_report_proximity(pd, false);
+			break;
+		}
+	}
+}
+
+/* read xy_data for all current touches */
+static int cyttsp4_xy_worker(struct cyttsp4_proximity_data *pd)
+{
+	struct device *dev = &pd->ttsp->dev;
+	struct cyttsp4_sysinfo *si = pd->si;
+	u8 num_cur_rec;
+	u8 rep_len;
+	u8 rep_stat;
+	u8 tt_stat;
+	int rc = 0;
+
+	/*
+	 * Get event data from cyttsp4 device.
+	 * The event data includes all data
+	 * for all active touches.
+	 * Event data also includes button data
+	 */
+	rep_len = si->xy_mode[si->si_ofs.rep_ofs];
+	rep_stat = si->xy_mode[si->si_ofs.rep_ofs + 1];
+	tt_stat = si->xy_mode[si->si_ofs.tt_stat_ofs];
+
+	num_cur_rec = GET_NUM_TOUCH_RECORDS(tt_stat);
+
+	if (rep_len == 0 && num_cur_rec > 0) {
+		dev_err(dev, "%s: report length error rep_len=%d num_rec=%d\n",
+			__func__, rep_len, num_cur_rec);
+		goto cyttsp4_xy_worker_exit;
+	}
+
+	/* check any error conditions */
+	if (IS_BAD_PKT(rep_stat)) {
+		dev_dbg(dev, "%s: Invalid buffer detected\n", __func__);
+		rc = 0;
+		goto cyttsp4_xy_worker_exit;
+	}
+
+	if (IS_LARGE_AREA(tt_stat))
+		dev_dbg(dev, "%s: Large area detected\n", __func__);
+
+	if (num_cur_rec > si->si_ofs.max_tchs) {
+		dev_err(dev, "%s: %s (n=%d c=%d)\n", __func__,
+			"too many tch; set to max tch",
+			num_cur_rec, si->si_ofs.max_tchs);
+		num_cur_rec = si->si_ofs.max_tchs;
+	}
+
+	/* extract xy_data for all currently reported touches */
+	dev_vdbg(dev, "%s: extract data num_cur_rec=%d\n", __func__,
+		num_cur_rec);
+	if (num_cur_rec)
+		cyttsp4_get_proximity_touch(pd, num_cur_rec);
+	else
+		cyttsp4_report_proximity(pd, false);
+
+	dev_vdbg(dev, "%s: done\n", __func__);
+	rc = 0;
+
+cyttsp4_xy_worker_exit:
+	return rc;
+}
+
+static int _cyttsp4_proximity_enable(struct cyttsp4_proximity_data *pd)
+{
+	struct cyttsp4_device *ttsp = pd->ttsp;
+	struct device *dev = &ttsp->dev;
+	int rc = 0;
+
+	dev_dbg(dev, "%s\n", __func__);
+
+	/* We use pm_runtime_get_sync to activate
+	 * the core device until it is disabled back
+	 */
+	pm_runtime_get_sync(dev);
+
+	rc = cyttsp4_request_exclusive(ttsp,
+			CY_PROXIMITY_REQUEST_EXCLUSIVE_TIMEOUT);
+	if (rc < 0) {
+		dev_err(dev, "%s: Error on request exclusive r=%d\n",
+				__func__, rc);
+		goto exit;
+	}
+
+	rc = cyttsp4_request_enable_scan_type(ttsp, CY_ST_PROXIMITY);
+	if (rc < 0) {
+		dev_err(dev, "%s: Error on request enable proximity scantype r=%d\n",
+				__func__, rc);
+		goto exit_release;
+	}
+
+	dev_vdbg(dev, "%s: setup subscriptions\n", __func__);
+
+	/* set up touch call back */
+	cyttsp4_subscribe_attention(ttsp, CY_ATTEN_IRQ,
+		cyttsp4_proximity_attention, CY_MODE_OPERATIONAL);
+
+	/* set up startup call back */
+	cyttsp4_subscribe_attention(ttsp, CY_ATTEN_STARTUP,
+		cyttsp4_startup_attention, 0);
+
+exit_release:
+	cyttsp4_release_exclusive(ttsp);
+exit:
+	return rc;
+}
+
+static int _cyttsp4_proximity_disable(struct cyttsp4_proximity_data *pd,
+		bool force)
+{
+	struct cyttsp4_device *ttsp = pd->ttsp;
+	struct device *dev = &ttsp->dev;
+	int rc = 0;
+
+	dev_dbg(dev, "%s\n", __func__);
+
+	rc = cyttsp4_request_exclusive(ttsp,
+			CY_PROXIMITY_REQUEST_EXCLUSIVE_TIMEOUT);
+	if (rc < 0) {
+		dev_err(dev, "%s: Error on request exclusive r=%d\n",
+				__func__, rc);
+		goto exit;
+	}
+
+	rc = cyttsp4_request_disable_scan_type(ttsp, CY_ST_PROXIMITY);
+	if (rc < 0) {
+		dev_err(dev, "%s: Error on request disable proximity scan r=%d\n",
+				__func__, rc);
+		goto exit_release;
+	}
+
+exit_release:
+	cyttsp4_release_exclusive(ttsp);
+
+exit:
+	if (!rc || force) {
+		cyttsp4_unsubscribe_attention(ttsp, CY_ATTEN_IRQ,
+			cyttsp4_proximity_attention, CY_MODE_OPERATIONAL);
+
+		cyttsp4_unsubscribe_attention(ttsp, CY_ATTEN_STARTUP,
+			cyttsp4_startup_attention, 0);
+
+		pm_runtime_put(dev);
+	}
+
+	return rc;
+}
+
+static ssize_t cyttsp4_proximity_enable_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct cyttsp4_proximity_data *pd = dev_get_drvdata(dev);
+	int val = 0;
+
+	mutex_lock(&pd->sysfs_lock);
+	val = pd->enable_count;
+	mutex_unlock(&pd->sysfs_lock);
+
+	return scnprintf(buf, CY_MAX_PRBUF_SIZE, "%d\n", val);
+}
+
+static ssize_t cyttsp4_proximity_enable_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	struct cyttsp4_proximity_data *pd = dev_get_drvdata(dev);
+	unsigned long value;
+	int rc;
+
+	rc = kstrtoul(buf, 10, &value);
+	if (rc < 0 || (value != 0 && value != 1)) {
+		dev_err(dev, "%s: Invalid value\n", __func__);
+		return -EINVAL;
+	}
+
+	mutex_lock(&pd->sysfs_lock);
+	if (value) {
+		if (pd->enable_count++) {
+			dev_vdbg(dev, "%s: '%s' already enabled\n", __func__,
+				pd->ttsp->name);
+		} else {
+			rc = _cyttsp4_proximity_enable(pd);
+			if (rc)
+				pd->enable_count--;
+		}
+	} else {
+		if (--pd->enable_count) {
+			if (pd->enable_count < 0) {
+				dev_err(dev, "%s: '%s' unbalanced disable\n",
+					__func__, pd->ttsp->name);
+				pd->enable_count = 0;
+			}
+		} else {
+			rc = _cyttsp4_proximity_disable(pd, false);
+			if (rc)
+				pd->enable_count++;
+		}
+	}
+	mutex_unlock(&pd->sysfs_lock);
+
+	if (rc)
+		return rc;
+
+	return size;
+}
+
+static DEVICE_ATTR(enable, S_IRUSR | S_IWUSR,
+		cyttsp4_proximity_enable_show,
+		cyttsp4_proximity_enable_store);
+
+static int cyttsp4_proximity_attention(struct cyttsp4_device *ttsp)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_proximity_data *pd = dev_get_drvdata(dev);
+	int rc = 0;
+
+	dev_vdbg(dev, "%s\n", __func__);
+
+	mutex_lock(&pd->report_lock);
+	if (!pd->is_suspended) {
+		/* core handles handshake */
+		rc = cyttsp4_xy_worker(pd);
+	} else {
+		dev_vdbg(dev, "%s: Ignoring report while suspended\n",
+			__func__);
+	}
+	mutex_unlock(&pd->report_lock);
+	if (rc < 0)
+		dev_err(dev, "%s: xy_worker error r=%d\n", __func__, rc);
+
+	return rc;
+}
+
+static int cyttsp4_startup_attention(struct cyttsp4_device *ttsp)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_proximity_data *pd = dev_get_drvdata(dev);
+
+	dev_vdbg(dev, "%s\n", __func__);
+
+	mutex_lock(&pd->report_lock);
+	cyttsp4_report_proximity(pd, false);
+	mutex_unlock(&pd->report_lock);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM_RUNTIME
+static int cyttsp4_proximity_suspend(struct device *dev)
+{
+	struct cyttsp4_proximity_data *pd = dev_get_drvdata(dev);
+
+	dev_dbg(dev, "%s\n", __func__);
+
+	mutex_lock(&pd->report_lock);
+	pd->is_suspended = true;
+	cyttsp4_report_proximity(pd, false);
+	mutex_unlock(&pd->report_lock);
+
+	return 0;
+}
+
+static int cyttsp4_proximity_resume(struct device *dev)
+{
+	struct cyttsp4_proximity_data *pd = dev_get_drvdata(dev);
+
+	dev_dbg(dev, "%s\n", __func__);
+
+	mutex_lock(&pd->report_lock);
+	pd->is_suspended = false;
+	mutex_unlock(&pd->report_lock);
+
+	return 0;
+}
+#endif
+
+static const struct dev_pm_ops cyttsp4_proximity_pm_ops = {
+	SET_RUNTIME_PM_OPS(cyttsp4_proximity_suspend,
+		cyttsp4_proximity_resume, NULL)
+};
+
+static int cyttsp4_setup_input_device_and_sysfs(struct cyttsp4_device *ttsp)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_proximity_data *pd = dev_get_drvdata(dev);
+	int signal = CY_IGNORE_VALUE;
+	int min, max;
+	int i;
+	int rc;
+
+	rc = device_create_file(dev, &dev_attr_enable);
+	if (rc) {
+		dev_err(dev, "%s: Error, could not create enable\n",
+				__func__);
+		goto exit;
+	}
+
+	dev_vdbg(dev, "%s: Initialize event signals\n", __func__);
+
+	__set_bit(EV_ABS, pd->input->evbit);
+
+	for (i = 0; i < (pd->pdata->frmwrk->size / CY_NUM_ABS_SET); i++) {
+		signal = pd->pdata->frmwrk->abs
+			[(i * CY_NUM_ABS_SET) + CY_SIGNAL_OST];
+		if (signal != CY_IGNORE_VALUE) {
+			min = pd->pdata->frmwrk->abs
+				[(i * CY_NUM_ABS_SET) + CY_MIN_OST];
+			max = pd->pdata->frmwrk->abs
+				[(i * CY_NUM_ABS_SET) + CY_MAX_OST];
+			input_set_abs_params(pd->input, signal, min, max,
+				pd->pdata->frmwrk->abs
+				[(i * CY_NUM_ABS_SET) + CY_FUZZ_OST],
+				pd->pdata->frmwrk->abs
+				[(i * CY_NUM_ABS_SET) + CY_FLAT_OST]);
+		}
+	}
+
+	rc = input_register_device(pd->input);
+	if (rc) {
+		dev_err(dev, "%s: Error, failed register input device r=%d\n",
+			__func__, rc);
+		goto unregister_enable;
+	}
+
+	pd->input_device_registered = true;
+	return rc;
+
+unregister_enable:
+	device_remove_file(dev, &dev_attr_enable);
+exit:
+	return rc;
+}
+
+static int cyttsp4_setup_input_attention(struct cyttsp4_device *ttsp)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_proximity_data *pd = dev_get_drvdata(dev);
+	int rc;
+
+	dev_vdbg(dev, "%s\n", __func__);
+
+	pd->si = cyttsp4_request_sysinfo(ttsp);
+	if (!pd->si)
+		return -EINVAL;
+
+	rc = cyttsp4_setup_input_device_and_sysfs(ttsp);
+
+	cyttsp4_unsubscribe_attention(ttsp, CY_ATTEN_STARTUP,
+		cyttsp4_setup_input_attention, 0);
+
+	return rc;
+}
+
+static int cyttsp4_proximity_probe(struct cyttsp4_device *ttsp)
+{
+	struct cyttsp4_proximity_data *pd;
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_proximity_platform_data *pdata = dev_get_platdata(dev);
+	int rc = 0;
+
+	dev_info(dev, "%s\n", __func__);
+	dev_dbg(dev, "%s: debug on\n", __func__);
+	dev_vdbg(dev, "%s: verbose debug on\n", __func__);
+
+	if (pdata == NULL) {
+		dev_err(dev, "%s: Missing platform data\n", __func__);
+		rc = -ENODEV;
+		goto error_no_pdata;
+	}
+
+	pd = kzalloc(sizeof(*pd), GFP_KERNEL);
+	if (pd == NULL) {
+		dev_err(dev, "%s: Error, kzalloc\n", __func__);
+		rc = -ENOMEM;
+		goto error_alloc_data_failed;
+	}
+
+	mutex_init(&pd->report_lock);
+	mutex_init(&pd->sysfs_lock);
+	pd->ttsp = ttsp;
+	pd->pdata = pdata;
+	dev_set_drvdata(dev, pd);
+	/* Create the input device and register it. */
+	dev_vdbg(dev, "%s: Create the input device and register it\n",
+		__func__);
+	pd->input = input_allocate_device();
+	if (pd->input == NULL) {
+		dev_err(dev, "%s: Error, failed to allocate input device\n",
+			__func__);
+		rc = -ENOSYS;
+		goto error_alloc_failed;
+	}
+
+	pd->input->name = ttsp->name;
+	scnprintf(pd->phys, sizeof(pd->phys)-1, "%s", dev_name(dev));
+	pd->input->phys = pd->phys;
+	pd->input->dev.parent = &pd->ttsp->dev;
+	input_set_drvdata(pd->input, pd);
+
+	pm_runtime_enable(dev);
+
+	/* get sysinfo */
+	pd->si = cyttsp4_request_sysinfo(ttsp);
+	if (pd->si) {
+		rc = cyttsp4_setup_input_device_and_sysfs(ttsp);
+		if (rc)
+			goto error_init_input;
+	} else {
+		dev_err(dev, "%s: Fail get sysinfo pointer from core p=%p\n",
+			__func__, pd->si);
+		cyttsp4_subscribe_attention(ttsp, CY_ATTEN_STARTUP,
+			cyttsp4_setup_input_attention, 0);
+	}
+
+	dev_dbg(dev, "%s: ok\n", __func__);
+	return 0;
+
+error_init_input:
+	pm_runtime_suspend(dev);
+	pm_runtime_disable(dev);
+	input_free_device(pd->input);
+error_alloc_failed:
+	dev_set_drvdata(dev, NULL);
+	kfree(pd);
+error_alloc_data_failed:
+error_no_pdata:
+	dev_err(dev, "%s failed.\n", __func__);
+	return rc;
+}
+
+static int cyttsp4_proximity_release(struct cyttsp4_device *ttsp)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_proximity_data *pd = dev_get_drvdata(dev);
+
+	dev_dbg(dev, "%s\n", __func__);
+
+	if (pd->input_device_registered) {
+		/* Disable proximity sensing */
+		mutex_lock(&pd->sysfs_lock);
+		if (pd->enable_count)
+			_cyttsp4_proximity_disable(pd, true);
+		mutex_unlock(&pd->sysfs_lock);
+		device_remove_file(dev, &dev_attr_enable);
+		input_unregister_device(pd->input);
+	} else {
+		input_free_device(pd->input);
+		cyttsp4_unsubscribe_attention(ttsp, CY_ATTEN_STARTUP,
+			cyttsp4_setup_input_attention, 0);
+	}
+
+	pm_runtime_suspend(dev);
+	pm_runtime_disable(dev);
+
+	dev_set_drvdata(dev, NULL);
+	kfree(pd);
+	return 0;
+}
+
+static struct cyttsp4_driver cyttsp4_proximity_driver = {
+	.probe = cyttsp4_proximity_probe,
+	.remove = cyttsp4_proximity_release,
+	.driver = {
+		.name = CYTTSP4_PROXIMITY_NAME,
+		.bus = &cyttsp4_bus_type,
+		.owner = THIS_MODULE,
+		.pm = &cyttsp4_proximity_pm_ops,
+	},
+};
+
+static int __init cyttsp4_proximity_init(void)
+{
+	int rc = 0;
+	rc = cyttsp4_register_driver(&cyttsp4_proximity_driver);
+	pr_info("%s: Cypress TTSP MT v4 Proximity (Built %s), rc=%d\n",
+		 __func__, CY_DRIVER_DATE, rc);
+	return rc;
+}
+module_init(cyttsp4_proximity_init);
+
+static void __exit cyttsp4_proximity_exit(void)
+{
+	cyttsp4_unregister_driver(&cyttsp4_proximity_driver);
+	pr_info("%s: module exit\n", __func__);
+}
+module_exit(cyttsp4_proximity_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Cypress TTSP Proximity driver");
+MODULE_AUTHOR("Cypress Semiconductor");
diff --git a/drivers/input/touchscreen/cypress/cyttsp4_regs.h b/drivers/input/touchscreen/cypress/cyttsp4_regs.h
new file mode 100644
index 0000000..a9c0fb0
--- /dev/null
+++ b/drivers/input/touchscreen/cypress/cyttsp4_regs.h
@@ -0,0 +1,578 @@
+/*
+ * cyttsp4_regs.h
+ * Cypress TrueTouch(TM) Standard Product V4 registers.
+ * For use with Cypress Txx4xx parts.
+ * Supported parts include:
+ * TMA4XX
+ * TMA1036
+ *
+ * Copyright (C) 2012 Cypress Semiconductor
+ * Copyright (C) 2011 Sony Ericsson Mobile Communications AB.
+ *
+ * Author: Aleksej Makarov <aleksej.makarov@sonyericsson.com>
+ * Modified by: Cypress Semiconductor to add test modes and commands
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2, and only version 2, as published by the
+ * Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * Contact Cypress Semiconductor at www.cypress.com <ttdrivers@cypress.com>
+ *
+ */
+
+#ifndef _CYTTSP4_REGS_H
+#define _CYTTSP4_REGS_H
+
+#define CY_FW_FILE_NAME			"cyttsp4_fw.bin"
+
+#define CY_DEFAULT_ADAP_MAX_XFER	512
+#define CY_ADAP_MIN_XFER		140
+
+#define CY_MAX_PRBUF_SIZE		PIPE_BUF
+#define CY_PR_TRUNCATED			" truncated..."
+
+#define CY_DEFAULT_CORE_ID		"main_ttsp_core"
+#define CY_MAX_NUM_CORE_DEVS		5
+
+#define CY_TMA1036_MAX_TCH		0x0E
+#define CY_TMA4XX_MAX_TCH		0x1E
+
+#define IS_BOOTLOADER(hst_mode, reset_detect) \
+		((hst_mode) & 0x01 || (reset_detect) != 0)
+#define IS_BOOTLOADER_IDLE(hst_mode, reset_detect) \
+		((hst_mode) & 0x01 && (reset_detect) & 0x01)
+
+#define GET_HSTMODE(reg)		((reg & 0x70) >> 4)
+#define GET_TOGGLE(reg)			((reg & 0x80) >> 7)
+
+#define IS_LITTLEENDIAN(reg)		((reg & 0x01) == 1)
+#define GET_PANELID(reg)		(reg & 0x07)
+
+#define HI_BYTE(x)			(u8)(((x) >> 8) & 0xFF)
+#define LO_BYTE(x)			(u8)((x) & 0xFF)
+
+#define CY_REG_BASE			0x00
+#define CY_NUM_REVCTRL			8
+#define CY_NUM_DDATA			32
+#define CY_NUM_MDATA			64
+
+#define CY_REG_CAT_CMD			2
+#define CY_CMD_COMPLETE_MASK		(1 << 6)
+#define CY_CMD_MASK			0x3F
+
+#define CY_TTCONFIG_VERSION_OFFSET	8
+#define CY_TTCONFIG_VERSION_SIZE	2
+#define CY_TTCONFIG_VERSION_ROW		0
+
+#define CY_CONFIG_LENGTH_INFO_OFFSET	0
+#define CY_CONFIG_LENGTH_INFO_SIZE	4
+#define CY_CONFIG_LENGTH_OFFSET		0
+#define CY_CONFIG_LENGTH_SIZE		2
+#define CY_CONFIG_MAXLENGTH_OFFSET	2
+#define CY_CONFIG_MAXLENGTH_SIZE	2
+
+enum cyttsp4_ic_ebid {
+	CY_TCH_PARM_EBID,
+	CY_MDATA_EBID,
+	CY_DDATA_EBID,
+	CY_EBID_NUM,
+};
+
+/* touch record system information offset masks and shifts */
+#define CY_BYTE_OFS_MASK		0x1F
+#define CY_BOFS_MASK			0xE0
+#define CY_BOFS_SHIFT			5
+
+/* helpers */
+#define GET_NUM_TOUCH_RECORDS(x)	((x) & 0x1F)
+#define IS_LARGE_AREA(x)		((x) & 0x20)
+#define IS_BAD_PKT(x)			((x) & 0x20)
+#define IS_TTSP_VER_GE(p, maj, min) \
+		((p)->si_ptrs.cydata == NULL ? \
+		0 : \
+		((p)->si_ptrs.cydata->ttsp_ver_major < (maj) ? \
+			0 : \
+			((p)->si_ptrs.cydata->ttsp_ver_minor < (min) ? \
+				0 : \
+				1)))
+
+/* Timeout in ms. */
+#define CY_COMMAND_COMPLETE_TIMEOUT	500
+#define CY_CALIBRATE_COMPLETE_TIMEOUT	5000
+#define CY_WATCHDOG_TIMEOUT		1000
+
+/* drv_debug commands */
+#define CY_DBG_SUSPEND			4
+#define CY_DBG_RESUME			5
+#define CY_DBG_SOFT_RESET		97
+#define CY_DBG_RESET			98
+
+/* scan types */
+#define CY_SCAN_TYPE_GLOVE		0x8
+#define CY_SCAN_TYPE_STYLUS		0x10
+#define CY_SCAN_TYPE_PROXIMITY		0x40
+#define CY_SCAN_TYPE_APA_MC		0x80
+
+enum cyttsp4_hst_mode_bits {
+	CY_HST_TOGGLE      = (1 << 7),
+	CY_HST_MODE_CHANGE = (1 << 3),
+	CY_HST_DEVICE_MODE = (7 << 4),
+	CY_HST_OPERATE     = (0 << 4),
+	CY_HST_SYSINFO     = (1 << 4),
+	CY_HST_CAT         = (2 << 4),
+	CY_HST_LOWPOW      = (1 << 2),
+	CY_HST_SLEEP       = (1 << 1),
+	CY_HST_RESET       = (1 << 0),
+};
+
+enum cyttsp_cmd_bits {
+	CY_CMD_COMPLETE    = (1 << 6),
+};
+
+enum cyttsp4_cmd_cat {
+	CY_CMD_CAT_NULL,
+	CY_CMD_CAT_RESERVED_1,
+	CY_CMD_CAT_GET_CFG_ROW_SZ,
+	CY_CMD_CAT_READ_CFG_BLK,
+	CY_CMD_CAT_WRITE_CFG_BLK,
+	CY_CMD_CAT_RESERVED_2,
+	CY_CMD_CAT_LOAD_SELF_TEST_DATA,
+	CY_CMD_CAT_RUN_SELF_TEST,
+	CY_CMD_CAT_GET_SELF_TEST_RESULT,
+	CY_CMD_CAT_CALIBRATE_IDACS,
+	CY_CMD_CAT_INIT_BASELINES,
+	CY_CMD_CAT_EXEC_PANEL_SCAN,
+	CY_CMD_CAT_RETRIEVE_PANEL_SCAN,
+	CY_CMD_CAT_START_SENSOR_DATA_MODE,
+	CY_CMD_CAT_STOP_SENSOR_DATA_MODE,
+	CY_CMD_CAT_INT_PIN_MODE,
+	CY_CMD_CAT_RETRIEVE_DATA_STRUCTURE,
+	CY_CMD_CAT_VERIFY_CFG_BLK_CRC,
+	CY_CMD_CAT_RESERVED_N,
+};
+
+enum cyttsp4_cmd_op {
+	CY_CMD_OP_NULL,
+	CY_CMD_OP_RESERVED_1,
+	CY_CMD_OP_GET_PARAM,
+	CY_CMD_OP_SET_PARAM,
+	CY_CMD_OP_RESERVED_2,
+	CY_CMD_OP_GET_CRC,
+	CY_CMD_OP_WAIT_FOR_EVENT,
+};
+
+enum cyttsp4_cmd_status {
+	CY_CMD_STATUS_SUCCESS,
+	CY_CMD_STATUS_FAILURE,
+};
+
+/* Operational Mode Command Sizes */
+/* NULL Command */
+#define CY_CMD_OP_NULL_CMD_SZ			1
+#define CY_CMD_OP_NULL_RET_SZ			0
+/* Get Parameter */
+#define CY_CMD_OP_GET_PARAM_CMD_SZ		2
+#define CY_CMD_OP_GET_PARAM_RET_SZ		6
+/* Set Parameter */
+#define CY_CMD_OP_SET_PARAM_CMD_SZ		7
+#define CY_CMD_OP_SET_PARAM_RET_SZ		2
+/* Get Config Block CRC */
+#define CY_CMD_OP_GET_CFG_BLK_CRC_CMD_SZ	2
+#define CY_CMD_OP_GET_CFG_BLK_CRC_RET_SZ	3
+/* Wait For Event */
+#define CY_CMD_OP_WAIT_FOR_EVENT_CMD_SZ		2
+
+/* CaT Mode Command Sizes */
+/* NULL Command */
+#define CY_CMD_CAT_NULL_CMD_SZ			1
+#define CY_CMD_CAT_NULL_RET_SZ			0
+/* Get Config Row Size */
+#define CY_CMD_CAT_GET_CFG_ROW_SIZE_CMD_SZ	1
+#define CY_CMD_CAT_GET_CFG_ROW_SIZE_RET_SZ	2
+/* Read Config Block */
+#define CY_CMD_CAT_READ_CFG_BLK_CMD_SZ		6
+#define CY_CMD_CAT_READ_CFG_BLK_RET_SZ		7 /* + Data */
+#define CY_CMD_CAT_READ_CFG_BLK_RET_HDR_SZ	5
+/* Write Config Block */
+#define CY_CMD_CAT_WRITE_CFG_BLK_CMD_SZ		8 /* + Data + Security Key */
+#define CY_CMD_CAT_WRITE_CFG_BLK_RET_SZ		5
+#define CY_CMD_CAT_WRITE_CFG_BLK_CMD_HDR_SZ	6
+/* Load Self-Test Data */
+#define CY_CMD_CAT_LOAD_SELFTEST_DATA_CMD_SZ	6
+#define CY_CMD_CAT_LOAD_SELFTEST_DATA_RET_SZ	5 /* + Data */
+/* Run Self-Test */
+#define CY_CMD_CAT_RUN_SELFTEST_CMD_SZ		2
+#define CY_CMD_CAT_RUN_SELFTEST_RET_SZ		3
+/* Calibrate IDACs */
+#define CY_CMD_CAT_CALIBRATE_IDAC_CMD_SZ	2
+#define CY_CMD_CAT_CALIBRATE_IDAC_RET_SZ	1
+/* Get Self-Test Results */
+#define CY_CMD_CAT_GET_SELFTEST_RES_CMD_SZ	6
+#define CY_CMD_CAT_GET_SELFTEST_RES_RET_SZ	5 /* + Data */
+/* Initialize Baselines */
+#define CY_CMD_CAT_INIT_BASELINE_CMD_SZ		2
+#define CY_CMD_CAT_INIT_BASELINE_RET_SZ		1
+/* Execute Panel Scan */
+#define CY_CMD_CAT_EXECUTE_PANEL_SCAN_CMD_SZ	1
+#define CY_CMD_CAT_EXECUTE_PANEL_SCAN_RET_SZ	1
+/* Retrieve Panel Scan */
+#define CY_CMD_CAT_RETRIEVE_PANEL_SCAN_CMD_SZ	6
+#define CY_CMD_CAT_RETRIEVE_PANEL_SCAN_RET_SZ	5 /* + Data */
+/* Start Sensor Data Mode */
+#define CY_CMD_CAT_START_SENSOR_MODE_CMD_SZ	1 /* + Data */
+#define CY_CMD_CAT_START_SENSOR_MODE_RET_SZ	0 /* + Data */
+/* Stop Sensor Data Mode */
+#define CY_CMD_CAT_STOP_SENSOR_MODE_CMD_SZ	1
+#define CY_CMD_CAT_STOP_SENSOR_MODE_RET_SZ	0
+/* Interrupt Pin Override */
+#define CY_CMD_CAT_INT_PIN_OVERRIDE_CMD_SZ	2
+#define CY_CMD_CAT_INT_PIN_OVERRIDE_RET_SZ	1
+/* Retrieve Data Structure */
+#define CY_CMD_CAT_RETRIEVE_DATA_STRUCT_CMD_SZ	6
+#define CY_CMD_CAT_RETRIEVE_DATA_STRUCT_RET_SZ	5 /* + Data */
+/* Verify Config Block CRC */
+#define CY_CMD_CAT_VERIFY_CFG_BLK_CRC_CMD_SZ	2
+#define CY_CMD_CAT_VERIFY_CFG_BLK_CRC_RET_SZ	5
+
+#define CY_RAM_ID_ACTIVE_DISTANCE		0x4A
+#define CY_RAM_ID_SCAN_TYPE			0x4B
+#define CY_RAM_ID_LOW_POWER_INTERVAL		0x4C
+#define CY_RAM_ID_REFRESH_INTERVAL		0x4D
+#define CY_RAM_ID_ACTIVE_MODE_TIMEOUT		0x4E
+#define CY_RAM_ID_ACTIVE_LFT_INTERVAL		0x4F
+#define CY_RAM_ID_ACTIVE_DISTANCE2		0x50
+#define CY_RAM_ID_CHARGER_STATUS		0x51
+#define CY_RAM_ID_IMO_TRIM_VALUE		0x52
+#define CY_RAM_ID_FINGER_THRESHOLH		0x93
+#define CY_RAM_ID_DETECT_AREA_MARGIN_X		0x58
+#define CY_RAM_ID_DETECT_AREA_MARGIN_Y		0x59
+#define CY_RAM_ID_GRIP_XEDGE_A			0x70
+#define CY_RAM_ID_GRIP_XEDGE_B			0x71
+#define CY_RAM_ID_GRIP_XEXC_A			0x72
+#define CY_RAM_ID_GRIP_XEXC_B			0x73
+#define CY_RAM_ID_GRIP_YEDGE_A			0x74
+#define CY_RAM_ID_GRIP_YEDGE_B			0x75
+#define CY_RAM_ID_GRIP_YEXC_A			0x76
+#define CY_RAM_ID_GRIP_YEXC_B			0x77
+#define CY_RAM_ID_GRIP_FIRST_EXC		0x78
+#define CY_RAM_ID_GRIP_EXC_EDGE_ORIGIN		0x79
+#define CY_RAM_ID_PROX_ACTIVE_DIST_Z_VALUE	0x9B
+
+enum cyttsp4_scan_type {
+	CY_ST_APA_MC,
+	CY_ST_GLOVE,
+	CY_ST_STYLUS,
+	CY_ST_PROXIMITY,
+};
+
+enum cyttsp4_mode {
+	CY_MODE_UNKNOWN      = 0,
+	CY_MODE_BOOTLOADER   = (1 << 1),
+	CY_MODE_OPERATIONAL  = (1 << 2),
+	CY_MODE_SYSINFO      = (1 << 3),
+	CY_MODE_CAT          = (1 << 4),
+	CY_MODE_STARTUP      = (1 << 5),
+	CY_MODE_LOADER       = (1 << 6),
+	CY_MODE_CHANGE_MODE  = (1 << 7),
+	CY_MODE_CHANGED      = (1 << 8),
+	CY_MODE_CMD_COMPLETE = (1 << 9),
+};
+
+enum cyttsp4_int_state {
+	CY_INT_NONE,
+	CY_INT_IGNORE      = (1 << 0),
+	CY_INT_MODE_CHANGE = (1 << 1),
+	CY_INT_EXEC_CMD    = (1 << 2),
+	CY_INT_AWAKE       = (1 << 3),
+};
+
+enum cyttsp4_ic_grpnum {
+	CY_IC_GRPNUM_RESERVED,
+	CY_IC_GRPNUM_CMD_REGS,
+	CY_IC_GRPNUM_TCH_REP,
+	CY_IC_GRPNUM_DATA_REC,
+	CY_IC_GRPNUM_TEST_REC,
+	CY_IC_GRPNUM_PCFG_REC,
+	CY_IC_GRPNUM_TCH_PARM_VAL,
+	CY_IC_GRPNUM_TCH_PARM_SIZE,
+	CY_IC_GRPNUM_RESERVED1,
+	CY_IC_GRPNUM_RESERVED2,
+	CY_IC_GRPNUM_OPCFG_REC,
+	CY_IC_GRPNUM_DDATA_REC,
+	CY_IC_GRPNUM_MDATA_REC,
+	CY_IC_GRPNUM_TEST_REGS,
+	CY_IC_GRPNUM_BTN_KEYS,
+	CY_IC_GRPNUM_TTHE_REGS,
+	CY_IC_GRPNUM_NUM
+};
+
+enum cyttsp4_event_id {
+	CY_EV_NO_EVENT,
+	CY_EV_TOUCHDOWN,
+	CY_EV_MOVE,		/* significant displacement (> act dist) */
+	CY_EV_LIFTOFF,		/* record reports last position */
+};
+
+enum cyttsp4_object_id {
+	CY_OBJ_STANDARD_FINGER = 0,
+	CY_OBJ_PROXIMITY       = 1,
+	CY_OBJ_STYLUS          = 2,
+	CY_OBJ_GLOVE           = 4,
+};
+
+#define CY_POST_CODEL_WDG_RST           0x01
+#define CY_POST_CODEL_CFG_DATA_CRC_FAIL 0x02
+#define CY_POST_CODEL_PANEL_TEST_FAIL   0x04
+
+/* test mode NULL command driver codes */
+enum cyttsp4_null_test_cmd_code {
+	CY_NULL_CMD_NULL,
+	CY_NULL_CMD_MODE,
+	CY_NULL_CMD_STATUS_SIZE,
+	CY_NULL_CMD_HANDSHAKE,
+	CY_NULL_CMD_LOW_POWER,
+};
+
+enum cyttsp4_test_mode {
+	CY_TEST_MODE_NORMAL_OP,		/* Send touch data to OS; normal op */
+	CY_TEST_MODE_CAT,		/* Configuration and Test */
+	CY_TEST_MODE_SYSINFO,		/* System information mode */
+	CY_TEST_MODE_CLOSED_UNIT,	/* Send scan data to sysfs */
+};
+
+struct cyttsp4_test_mode_params {
+	int cur_mode;
+	int cur_cmd;
+	size_t cur_status_size;
+};
+
+/* GEN4/SOLO Operational interface definitions */
+/* TTSP System Information interface definitions */
+struct cyttsp4_cydata {
+	u8 ttpidh;
+	u8 ttpidl;
+	u8 fw_ver_major;
+	u8 fw_ver_minor;
+	u8 revctrl[CY_NUM_REVCTRL];
+	u8 blver_major;
+	u8 blver_minor;
+	u8 jtag_si_id3;
+	u8 jtag_si_id2;
+	u8 jtag_si_id1;
+	u8 jtag_si_id0;
+	u8 mfgid_sz;
+	u8 cyito_idh;
+	u8 cyito_idl;
+	u8 cyito_verh;
+	u8 cyito_verl;
+	u8 ttsp_ver_major;
+	u8 ttsp_ver_minor;
+	u8 device_info;
+	u8 mfg_id[];
+} __packed;
+
+struct cyttsp4_test {
+	u8 post_codeh;
+	u8 post_codel;
+} __packed;
+
+struct cyttsp4_pcfg {
+	u8 electrodes_x;
+	u8 electrodes_y;
+	u8 len_xh;
+	u8 len_xl;
+	u8 len_yh;
+	u8 len_yl;
+	u8 res_xh;
+	u8 res_xl;
+	u8 res_yh;
+	u8 res_yl;
+	u8 max_zh;
+	u8 max_zl;
+	u8 panel_info0;
+} __packed;
+
+enum cyttsp4_tch_abs {	/* for ordering within the extracted touch data array */
+	CY_TCH_X,	/* X */
+	CY_TCH_Y,	/* Y */
+	CY_TCH_P,	/* P (Z) */
+	CY_TCH_T,	/* TOUCH ID */
+	CY_TCH_E,	/* EVENT ID */
+	CY_TCH_O,	/* OBJECT ID */
+	CY_TCH_W,	/* SIZE */
+	CY_TCH_MAJ,	/* TOUCH_MAJOR */
+	CY_TCH_MIN,	/* TOUCH_MINOR */
+	CY_TCH_OR,	/* ORIENTATION */
+	CY_TCH_NUM_ABS
+};
+
+static const char * const cyttsp4_tch_abs_string[] = {
+	[CY_TCH_X]	= "X",
+	[CY_TCH_Y]	= "Y",
+	[CY_TCH_P]	= "P",
+	[CY_TCH_T]	= "T",
+	[CY_TCH_E]	= "E",
+	[CY_TCH_O]	= "O",
+	[CY_TCH_W]	= "W",
+	[CY_TCH_MAJ]	= "MAJ",
+	[CY_TCH_MIN]	= "MIN",
+	[CY_TCH_OR]	= "OR",
+	[CY_TCH_NUM_ABS] = "INVALID"
+};
+
+#define CY_NUM_TCH_FIELDS		7
+#define CY_NUM_EXT_TCH_FIELDS		3
+
+struct cyttsp4_tch_rec_params {
+	u8 loc;
+	u8 size;
+} __packed;
+
+struct cyttsp4_opcfg {
+	u8 cmd_ofs;
+	u8 rep_ofs;
+	u8 rep_szh;
+	u8 rep_szl;
+	u8 num_btns;
+	u8 tt_stat_ofs;
+	u8 obj_cfg0;
+	u8 max_tchs;
+	u8 tch_rec_size;
+	struct cyttsp4_tch_rec_params tch_rec_old[CY_NUM_TCH_FIELDS];
+	u8 btn_rec_size;/* btn record size (in bytes) */
+	u8 btn_diff_ofs;/* btn data loc ,diff counts, (Op-Mode byte ofs) */
+	u8 btn_diff_size;/* btn size of diff counts (in bits) */
+	struct cyttsp4_tch_rec_params tch_rec_new[CY_NUM_EXT_TCH_FIELDS];
+	u8 noise_data_ofs;
+	u8 noise_data_sz;
+} __packed;
+
+struct cyttsp4_sysinfo_data {
+	u8 hst_mode;
+	u8 reserved;
+	u8 map_szh;
+	u8 map_szl;
+	u8 cydata_ofsh;
+	u8 cydata_ofsl;
+	u8 test_ofsh;
+	u8 test_ofsl;
+	u8 pcfg_ofsh;
+	u8 pcfg_ofsl;
+	u8 opcfg_ofsh;
+	u8 opcfg_ofsl;
+	u8 ddata_ofsh;
+	u8 ddata_ofsl;
+	u8 mdata_ofsh;
+	u8 mdata_ofsl;
+} __packed;
+
+struct cyttsp4_sysinfo_ptr {
+	struct cyttsp4_cydata *cydata;
+	struct cyttsp4_test *test;
+	struct cyttsp4_pcfg *pcfg;
+	struct cyttsp4_opcfg *opcfg;
+	struct cyttsp4_ddata *ddata;
+	struct cyttsp4_mdata *mdata;
+} __packed;
+
+struct cyttsp4_touch {
+	int abs[CY_TCH_NUM_ABS];
+};
+
+struct cyttsp4_tch_abs_params {
+	size_t ofs;	/* abs byte offset */
+	size_t size;	/* size in bits */
+	size_t max;	/* max value */
+	size_t bofs;	/* bit offset */
+};
+
+#define CY_NORMAL_ORIGIN		0	/* upper, left corner */
+#define CY_INVERT_ORIGIN		1	/* lower, right corner */
+
+struct cyttsp4_sysinfo_ofs {
+	size_t chip_type;
+	size_t cmd_ofs;
+	size_t rep_ofs;
+	size_t rep_sz;
+	size_t num_btns;
+	size_t num_btn_regs;	/* ceil(num_btns/4) */
+	size_t tt_stat_ofs;
+	size_t tch_rec_size;
+	size_t obj_cfg0;
+	size_t max_tchs;
+	size_t mode_size;
+	size_t data_size;
+	size_t rep_hdr_size;
+	size_t map_sz;
+	size_t max_x;
+	size_t x_origin;	/* left or right corner */
+	size_t max_y;
+	size_t y_origin;	/* upper or lower corner */
+	size_t max_p;
+	size_t cydata_ofs;
+	size_t test_ofs;
+	size_t pcfg_ofs;
+	size_t opcfg_ofs;
+	size_t ddata_ofs;
+	size_t mdata_ofs;
+	size_t cydata_size;
+	size_t test_size;
+	size_t pcfg_size;
+	size_t opcfg_size;
+	size_t ddata_size;
+	size_t mdata_size;
+	size_t btn_keys_size;
+	struct cyttsp4_tch_abs_params tch_abs[CY_TCH_NUM_ABS];
+	size_t btn_rec_size; /* btn record size (in bytes) */
+	size_t btn_diff_ofs;/* btn data loc ,diff counts, (Op-Mode byte ofs) */
+	size_t btn_diff_size;/* btn size of diff counts (in bits) */
+	size_t noise_data_ofs;
+	size_t noise_data_sz;
+};
+
+/* button to keycode support */
+#define CY_NUM_BTN_PER_REG		4
+#define CY_BITS_PER_BTN			2
+
+enum cyttsp4_btn_state {
+	CY_BTN_RELEASED = 0,
+	CY_BTN_PRESSED = 1,
+	CY_BTN_NUM_STATE
+};
+
+struct cyttsp4_btn {
+	bool enabled;
+	int state;	/* CY_BTN_PRESSED, CY_BTN_RELEASED */
+	int key_code;
+};
+
+struct cyttsp4_ttconfig {
+	u16 version;
+	u16 length;
+	u16 max_length;
+	u16 crc;
+};
+
+struct cyttsp4_sysinfo {
+	bool ready;
+	struct cyttsp4_sysinfo_data si_data;
+	struct cyttsp4_sysinfo_ptr si_ptrs;
+	struct cyttsp4_sysinfo_ofs si_ofs;
+	struct cyttsp4_ttconfig ttconfig;
+	struct cyttsp4_btn *btn;	/* button states */
+	u8 *btn_rec_data;		/* button diff count data */
+	u8 *xy_mode;			/* operational mode and status regs */
+	u8 *xy_data;			/* operational touch regs */
+};
+
+#endif /* _CYTTSP4_REGS_H */
diff --git a/drivers/input/touchscreen/cypress/cyttsp4_spi.c b/drivers/input/touchscreen/cypress/cyttsp4_spi.c
new file mode 100644
index 0000000..4f2662b
--- /dev/null
+++ b/drivers/input/touchscreen/cypress/cyttsp4_spi.c
@@ -0,0 +1,462 @@
+/*
+ * cyttsp4_spi.c
+ * Cypress TrueTouch(TM) Standard Product V4 SPI Driver module.
+ * For use with Cypress Txx4xx parts.
+ * Supported parts include:
+ * TMA4XX
+ * TMA1036
+ *
+ * Copyright (C) 2012 Cypress Semiconductor
+ * Copyright (C) 2011 Sony Ericsson Mobile Communications AB.
+ *
+ * Author: Aleksej Makarov <aleksej.makarov@sonyericsson.com>
+ * Modified by: Cypress Semiconductor for test with device
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2, and only version 2, as published by the
+ * Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * Contact Cypress Semiconductor at www.cypress.com <ttdrivers@cypress.com>
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/spi/spi.h>
+#include <linux/delay.h>
+#include <linux/mutex.h>
+#include <linux/of_device.h>
+#include <linux/pm_runtime.h>
+#include <linux/hrtimer.h>
+#include <linux/cyttsp4_bus.h>
+#include <linux/cyttsp4_core.h>
+#include "cyttsp4_spi.h"
+
+#include "cyttsp4_devtree.h"
+
+#define CY_SPI_WR_OP		0x00 /* r/~w */
+#define CY_SPI_RD_OP		0x01
+#define CY_SPI_A8_BIT		0x02
+#define CY_SPI_WR_HEADER_BYTES	2
+#define CY_SPI_RD_HEADER_BYTES	1
+#define CY_SPI_SYNC_BYTE	0
+#define CY_SPI_SYNC_ACK		0x62 /* from TRM *A protocol */
+#define CY_SPI_DATA_SIZE	(3 * 256)
+#define CY_SPI_BITS_PER_WORD	8
+#define CY_SPI_NUM_RETRY	3
+
+#define CY_SPI_MAX_HEADER_BYTES	\
+		max(CY_SPI_WR_HEADER_BYTES, CY_SPI_RD_HEADER_BYTES)
+
+struct cyttsp4_spi {
+	struct spi_device *client;
+	char const *id;
+	struct mutex lock;
+};
+
+static void _cyttsp4_spi_pr_buf(struct cyttsp4_spi *ts_spi, u8 *buf,
+			int size, char const *info)
+{
+#ifdef VERBOSE_DEBUG
+	static char b[CY_SPI_DATA_SIZE * 3 + 1];
+	unsigned i, k;
+
+	for (i = k = 0; i < size; i++, k += 3)
+		snprintf(b + k, sizeof(b) - k, "%02x ", buf[i]);
+	dev_dbg(&ts_spi->client->dev, "%s: %s\n", info, b);
+#endif
+}
+
+static int cyttsp4_spi_xfer(u8 op, struct cyttsp4_spi *ts,
+			u16 reg, u8 *buf, int length)
+{
+	struct device *dev = &ts->client->dev;
+	struct spi_message msg;
+	struct spi_transfer xfer[2];
+	u8 wr_hdr_buf[CY_SPI_MAX_HEADER_BYTES];
+	u8 rd_hdr_buf[CY_SPI_MAX_HEADER_BYTES];
+	int rc;
+
+	memset(wr_hdr_buf, 0, CY_SPI_MAX_HEADER_BYTES);
+	memset(rd_hdr_buf, 0, CY_SPI_MAX_HEADER_BYTES);
+	memset(xfer, 0, sizeof(xfer));
+
+	spi_message_init(&msg);
+
+	/* Header buffer */
+	xfer[0].tx_buf = wr_hdr_buf;
+	xfer[0].rx_buf = rd_hdr_buf;
+
+	switch (op) {
+	case CY_SPI_WR_OP:
+		if (length + CY_SPI_WR_HEADER_BYTES > CY_SPI_DATA_SIZE) {
+			dev_vdbg(dev,
+				"%s: length+%d=%d is greater than SPI max=%d\n",
+				__func__, CY_SPI_WR_HEADER_BYTES,
+				length + CY_SPI_WR_HEADER_BYTES,
+				CY_SPI_DATA_SIZE);
+			rc = -EINVAL;
+			goto cyttsp4_spi_xfer_exit;
+		}
+
+		/* Header byte 0 */
+		if (reg > 255)
+			wr_hdr_buf[0] = CY_SPI_WR_OP + CY_SPI_A8_BIT;
+		else
+			wr_hdr_buf[0] = CY_SPI_WR_OP;
+
+		/* Header byte 1 */
+		wr_hdr_buf[1] = reg % 256;
+
+		xfer[0].len = CY_SPI_WR_HEADER_BYTES;
+
+		spi_message_add_tail(&xfer[0], &msg);
+
+		/* Data buffer */
+		if (buf) {
+			xfer[1].tx_buf = buf;
+			xfer[1].len = length;
+
+			spi_message_add_tail(&xfer[1], &msg);
+		}
+		break;
+
+	case CY_SPI_RD_OP:
+		if (!buf) {
+			dev_err(dev, "%s: No read buffer\n", __func__);
+			rc = -EINVAL;
+			goto cyttsp4_spi_xfer_exit;
+		}
+
+		if ((length + CY_SPI_RD_HEADER_BYTES) > CY_SPI_DATA_SIZE) {
+			dev_vdbg(dev,
+				"%s: length+%d=%d is greater than SPI max=%d\n",
+				__func__, CY_SPI_RD_HEADER_BYTES,
+				length + CY_SPI_RD_HEADER_BYTES,
+				CY_SPI_DATA_SIZE);
+			rc = -EINVAL;
+			goto cyttsp4_spi_xfer_exit;
+		}
+
+		/* Header byte 0 */
+		wr_hdr_buf[0] = CY_SPI_RD_OP;
+
+		xfer[0].len = CY_SPI_RD_HEADER_BYTES;
+
+		spi_message_add_tail(&xfer[0], &msg);
+
+		/* Data buffer */
+		xfer[1].rx_buf = buf;
+		xfer[1].len = length;
+
+		spi_message_add_tail(&xfer[1], &msg);
+		break;
+
+	default:
+		dev_dbg(dev, "%s: bad op code=%d\n", __func__, op);
+		rc = -EINVAL;
+		goto cyttsp4_spi_xfer_exit;
+	}
+
+	rc = spi_sync(ts->client, &msg);
+	if (rc < 0) {
+		dev_vdbg(dev, "%s: spi_sync() error %d, len=%d, op=%d\n",
+			__func__, rc, xfer[0].len, op);
+		/*
+		 * do not return here since probably a bad ACK sequence
+		 * let the following ACK check handle any errors and
+		 * allow silent retries
+		 */
+	}
+
+	if (rd_hdr_buf[CY_SPI_SYNC_BYTE] != CY_SPI_SYNC_ACK) {
+		/* signal ACK error so silent retry */
+		rc = 1;
+
+		switch (op) {
+		case CY_SPI_WR_OP:
+			_cyttsp4_spi_pr_buf(ts, wr_hdr_buf,
+				CY_SPI_WR_HEADER_BYTES,
+				"spi_wr_buf HEAD");
+			if (buf)
+				_cyttsp4_spi_pr_buf(ts, buf,
+					length, "spi_wr_buf DATA");
+			break;
+
+		case CY_SPI_RD_OP:
+			_cyttsp4_spi_pr_buf(ts, rd_hdr_buf,
+				CY_SPI_RD_HEADER_BYTES, "spi_rd_buf HEAD");
+			_cyttsp4_spi_pr_buf(ts, buf, length,
+				"spi_rd_buf DATA");
+			break;
+
+		default:
+			/*
+			 * should not get here due to error check
+			 * in first switch
+			 */
+			break;
+		}
+	}
+
+cyttsp4_spi_xfer_exit:
+	return rc;
+}
+
+static s32 cyttsp4_spi_read_block_data(struct cyttsp4_spi *ts, u16 addr,
+				int length, void *data, int max_xfer)
+{
+	int rc = -EINVAL;
+	int retry = 0;
+	int trans_len;
+	struct device *dev = &ts->client->dev;
+
+	dev_vdbg(dev, "%s: Enter\n", __func__);
+
+	while (length > 0) {
+		trans_len = min(length, max_xfer);
+
+		/* Write address */
+		rc = cyttsp4_spi_xfer(CY_SPI_WR_OP, ts, addr, NULL, 0);
+		if (rc < 0) {
+			dev_err(dev, "%s: Fail write address r=%d\n",
+				__func__, rc);
+			return rc;
+		}
+
+		/* Read data */
+		rc = cyttsp4_spi_xfer(CY_SPI_RD_OP, ts, addr, data, trans_len);
+		if (rc < 0) {
+			dev_err(dev, "%s: Fail read r=%d\n", __func__, rc);
+			goto exit;
+		} else if (rc > 0) {
+			/* Perform retry or fail */
+			if (retry++ < CY_SPI_NUM_RETRY) {
+				dev_dbg(dev, "%s: ACK error, retry %d\n",
+					__func__, retry);
+				continue;
+			} else {
+				dev_err(dev, "%s: ACK error\n", __func__);
+				rc = -EIO;
+				goto exit;
+			}
+		}
+
+		length -= trans_len;
+		data += trans_len;
+		addr += trans_len;
+	}
+exit:
+	return rc;
+}
+
+static s32 cyttsp4_spi_write_block_data(struct cyttsp4_spi *ts, u16 addr,
+				int length, const void *data, int max_xfer)
+{
+	int rc = -EINVAL;
+	int retry = 0;
+	int trans_len;
+	struct device *dev = &ts->client->dev;
+
+	dev_vdbg(dev, "%s: Enter\n", __func__);
+
+	while (length > 0) {
+		trans_len = min(length, max_xfer);
+
+		rc = cyttsp4_spi_xfer(CY_SPI_WR_OP, ts, addr, (void *)data,
+				trans_len);
+		if (rc < 0) {
+			dev_err(dev, "%s: Fail write r=%d\n", __func__, rc);
+			goto exit;
+		} else if (rc > 0) {
+			/* Perform retry or fail */
+			if (retry++ < CY_SPI_NUM_RETRY) {
+				dev_dbg(dev, "%s: ACK error, retry %d\n",
+					__func__, retry);
+				continue;
+			} else {
+				dev_err(dev, "%s: ACK error\n", __func__);
+				rc = -EIO;
+				goto exit;
+			}
+		}
+
+		length -= trans_len;
+		data += trans_len;
+		addr += trans_len;
+	}
+exit:
+	return rc;
+}
+
+static int cyttsp4_spi_write(struct cyttsp4_adapter *adap, u16 addr,
+		const void *buf, int size, int max_xfer)
+{
+	struct cyttsp4_spi *ts = dev_get_drvdata(adap->dev);
+	int rc;
+
+	pm_runtime_get_noresume(adap->dev);
+	mutex_lock(&ts->lock);
+	rc = cyttsp4_spi_write_block_data(ts, addr, size, buf, max_xfer);
+	mutex_unlock(&ts->lock);
+	pm_runtime_put_noidle(adap->dev);
+
+	return rc;
+}
+
+static int cyttsp4_spi_read(struct cyttsp4_adapter *adap, u16 addr,
+		void *buf, int size, int max_xfer)
+{
+	struct cyttsp4_spi *ts = dev_get_drvdata(adap->dev);
+	int rc;
+
+	pm_runtime_get_noresume(adap->dev);
+	mutex_lock(&ts->lock);
+	rc = cyttsp4_spi_read_block_data(ts, addr, size, buf, max_xfer);
+	mutex_unlock(&ts->lock);
+	pm_runtime_put_noidle(adap->dev);
+
+	return rc;
+}
+
+static struct cyttsp4_ops ops = {
+	.write = cyttsp4_spi_write,
+	.read = cyttsp4_spi_read,
+};
+
+static struct of_device_id cyttsp4_spi_of_match[] = {
+	{ .compatible = "cy,cyttsp4_spi_adapter", }, { }
+};
+MODULE_DEVICE_TABLE(of, cyttsp4_spi_of_match);
+
+static int __devinit cyttsp4_spi_probe(struct spi_device *spi)
+{
+	struct cyttsp4_spi *ts_spi;
+	int rc = 0;
+	struct device *dev = &spi->dev;
+	const struct of_device_id *match;
+	char const *adap_id;
+
+	dev_dbg(dev, "%s: Probing ...\n", __func__);
+
+	spi->bits_per_word = CY_SPI_BITS_PER_WORD;
+	spi->mode = SPI_MODE_0;
+
+	rc = spi_setup(spi);
+	if (rc < 0) {
+		dev_err(dev, "%s: SPI setup error %d\n", __func__, rc);
+		return rc;
+	}
+
+	ts_spi = kzalloc(sizeof(*ts_spi), GFP_KERNEL);
+	if (ts_spi == NULL) {
+		dev_err(dev, "%s: Error, kzalloc\n", __func__);
+		rc = -ENOMEM;
+		goto error_alloc_data_failed;
+	}
+
+	match = of_match_device(of_match_ptr(cyttsp4_spi_of_match), dev);
+	if (match) {
+		rc = of_property_read_string(dev->of_node, "cy,adapter_id",
+				&adap_id);
+		if (rc) {
+			dev_err(dev, "%s: OF error rc=%d\n", __func__, rc);
+			goto error_free_data;
+		}
+		cyttsp4_devtree_register_devices(dev);
+	} else {
+		adap_id = dev_get_platdata(dev);
+	}
+
+	mutex_init(&ts_spi->lock);
+	ts_spi->client = spi;
+	ts_spi->id = (adap_id) ? adap_id : CYTTSP4_SPI_NAME;
+	dev_set_drvdata(&spi->dev, ts_spi);
+
+	dev_dbg(dev, "%s: add adap='%s' (CYTTSP4_SPI_NAME=%s)\n", __func__,
+		ts_spi->id, CYTTSP4_SPI_NAME);
+
+	pm_runtime_enable(&spi->dev);
+
+	rc = cyttsp4_add_adapter(ts_spi->id, &ops, dev);
+	if (rc) {
+		dev_err(dev, "%s: Error on probe %s\n", __func__,
+			CYTTSP4_SPI_NAME);
+		goto add_adapter_err;
+	}
+
+	dev_info(dev, "%s: Successful prob %s\n", __func__, CYTTSP4_SPI_NAME);
+
+	return 0;
+
+add_adapter_err:
+	pm_runtime_disable(&spi->dev);
+	dev_set_drvdata(&spi->dev, NULL);
+error_free_data:
+	kfree(ts_spi);
+error_alloc_data_failed:
+	return rc;
+}
+
+static int __devexit cyttsp4_spi_remove(struct spi_device *spi)
+{
+	struct device *dev = &spi->dev;
+	struct cyttsp4_spi *ts_spi = dev_get_drvdata(dev);
+
+	dev_info(dev, "%s\n", __func__);
+	cyttsp4_del_adapter(ts_spi->id);
+	pm_runtime_disable(&spi->dev);
+	dev_set_drvdata(&spi->dev, NULL);
+	kfree(ts_spi);
+	return 0;
+}
+
+static const struct spi_device_id cyttsp4_spi_id[] = {
+	{ CYTTSP4_SPI_NAME, 0 },  { }
+};
+MODULE_DEVICE_TABLE(spi, cyttsp4_spi_id);
+
+static struct spi_driver cyttsp4_spi_driver = {
+	.driver = {
+		.name = CYTTSP4_SPI_NAME,
+		.bus = &spi_bus_type,
+		.owner = THIS_MODULE,
+		.of_match_table = cyttsp4_spi_of_match,
+	},
+	.probe = cyttsp4_spi_probe,
+	.remove = __devexit_p(cyttsp4_spi_remove),
+	.id_table = cyttsp4_spi_id,
+};
+
+static int __init cyttsp4_spi_init(void)
+{
+	int err;
+
+	err = spi_register_driver(&cyttsp4_spi_driver);
+	pr_info("%s: Cypress TTSP SPI Touchscreen Driver (Built %s) rc=%d\n",
+		 __func__, CY_DRIVER_DATE, err);
+
+	return err;
+}
+module_init(cyttsp4_spi_init);
+
+static void __exit cyttsp4_spi_exit(void)
+{
+	spi_unregister_driver(&cyttsp4_spi_driver);
+	pr_info("%s: module exit\n", __func__);
+}
+module_exit(cyttsp4_spi_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Cypress TrueTouch(R) Standard Product SPI driver");
+MODULE_AUTHOR("Aleksej Makarov <aleksej.makarov@sonyericsson.com>");
diff --git a/drivers/input/touchscreen/cypress/cyttsp4_spi.h b/drivers/input/touchscreen/cypress/cyttsp4_spi.h
new file mode 100644
index 0000000..b6401b6
--- /dev/null
+++ b/drivers/input/touchscreen/cypress/cyttsp4_spi.h
@@ -0,0 +1,37 @@
+/*
+ * cyttsp4_spi.h
+ * Cypress TrueTouch(TM) Standard Product V4 SPI Driver module.
+ * For use with Cypress Txx4xx parts.
+ * Supported parts include:
+ * TMA4XX
+ * TMA1036
+ *
+ * Copyright (C) 2012 Cypress Semiconductor
+ * Copyright (C) 2011 Sony Ericsson Mobile Communications AB.
+ *
+ * Author: Aleksej Makarov <aleksej.makarov@sonyericsson.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2, and only version 2, as published by the
+ * Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * Contact Cypress Semiconductor at www.cypress.com <ttdrivers@cypress.com>
+ *
+ */
+
+#ifndef _LINUX_CYTTSP4_SPI_H
+#define _LINUX_CYTTSP4_SPI_H
+
+#define CYTTSP4_SPI_NAME "cyttsp4_spi_adapter"
+
+#endif /* _LINUX_CYTTSP4_SPI_H */
diff --git a/drivers/input/touchscreen/cypress/cyttsp4_test_device_access_api.c b/drivers/input/touchscreen/cypress/cyttsp4_test_device_access_api.c
new file mode 100644
index 0000000..92308d8
--- /dev/null
+++ b/drivers/input/touchscreen/cypress/cyttsp4_test_device_access_api.c
@@ -0,0 +1,196 @@
+/*
+ * cyttsp4_test_device_access_api.c
+ * Cypress TrueTouch(TM) Standard Product V4 Device Access API test module.
+ * For use with Cypress Txx4xx parts.
+ * Supported parts include:
+ * TMA4XX
+ * TMA1036
+ *
+ * Copyright (C) 2012 Cypress Semiconductor
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2, and only version 2, as published by the
+ * Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * Contact Cypress Semiconductor at www.cypress.com <ttdrivers@cypress.com>
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/cyttsp4_device_access-api.h>
+
+#define CONFIG_VER_OFFSET	8
+#define CONFIG_VER_SIZE		2
+
+#define BUFFER_SIZE		256
+
+static u8 buffer[BUFFER_SIZE];
+static int active_refresh_interval;
+
+static int __init cyttsp4_test_device_access_api_init(void)
+{
+	u16 config_ver;
+	int i;
+	int j;
+	int value;
+	int rc;
+
+	pr_info("%s: Enter\n", __func__);
+
+	/*
+	 * CASE 1 - Get CONFIG_VER and update it
+	 */
+
+	/*
+	 * Get CONFIG_VER
+	 * Group 6 read requires to fetch from offset to the end of row
+	 * The return buffer should be at least read config block command
+	 * return size + config row size bytes
+	 */
+	rc = cyttsp4_device_access_read_command(NULL,
+			GRPNUM_TOUCH_CONFIG, CONFIG_VER_OFFSET,
+			buffer, BUFFER_SIZE);
+	if (rc < 0) {
+		pr_err("%s: cyttsp4_device_access_read_command failed, rc=%d\n",
+			__func__, rc);
+		goto exit;
+	}
+
+	pr_info("%s: cyttsp4_device_access_read_command returned %d bytes\n",
+		__func__, rc);
+
+	/* Calculate CONFIG_VER (Little Endian) */
+	config_ver = buffer[0] + (buffer[1] << 8);
+
+	pr_info("%s: Old CONFIG_VER:%04X New CONFIG_VER:%04X\n", __func__,
+		config_ver, config_ver + 1);
+
+	config_ver++;
+
+	/* Store CONFIG_VER (Little Endian) */
+	buffer[0] = config_ver & 0xFF;
+	buffer[1] = config_ver >> 8;
+
+	/*
+	 * Set CONFIG_VER
+	 * Group 6 write supports writing arbitrary number of bytes
+	 */
+	rc = cyttsp4_device_access_write_command(NULL,
+			GRPNUM_TOUCH_CONFIG, CONFIG_VER_OFFSET,
+			buffer, CONFIG_VER_SIZE);
+	if (rc < 0) {
+		pr_err("%s: cyttsp4_device_access_write_command failed, rc=%d\n",
+			__func__, rc);
+		goto exit;
+	}
+
+	/*
+	 * CASE 2 - Get Operational mode parameters
+	 */
+	for (i = OP_PARAM_ACTIVE_DISTANCE;
+			i <= OP_PARAM_ACTIVE_LOOK_FOR_TOUCH_INTERVAL; i++) {
+		buffer[0] = OP_CMD_GET_PARAMETER;
+		buffer[1] = i;
+
+		rc = cyttsp4_device_access_write_command(NULL,
+				GRPNUM_OP_COMMAND, 0, buffer, 2);
+		if (rc < 0) {
+			pr_err("%s: cyttsp4_device_access_write_command failed, rc=%d\n",
+				__func__, rc);
+			goto exit;
+		}
+
+		/*
+		 * The return buffer should be at least
+		 * number of command data registers + 1
+		 */
+		rc = cyttsp4_device_access_read_command(NULL,
+				GRPNUM_OP_COMMAND, 0, buffer, 7);
+		if (rc < 0) {
+			pr_err("%s: cyttsp4_device_access_read_command failed, rc=%d\n",
+				__func__, rc);
+			goto exit;
+		}
+
+		if (buffer[0] != OP_CMD_GET_PARAMETER || buffer[1] != i) {
+			pr_err("%s: Invalid response\n", __func__);
+			rc = -EINVAL;
+			goto exit;
+		}
+
+		/*
+		 * Get value stored starting at &buffer[3] whose
+		 * size (in bytes) is specified at buffer[2]
+		 */
+		value = 0;
+		j = 0;
+		while (buffer[2]--)
+			value += buffer[3 + j++] << (8 * buffer[2]);
+
+		/* Store Active mode refresh interval to restore */
+		if (i == OP_PARAM_REFRESH_INTERVAL)
+			active_refresh_interval = value;
+
+		pr_info("%s: Parameter %02X: %d\n", __func__, i, value);
+	}
+
+	/*
+	 * CASE 3 - Set Active mode refresh interval to 200 ms
+	 */
+	buffer[0] = OP_CMD_SET_PARAMETER; /* Set Parameter */
+	buffer[1] = OP_PARAM_REFRESH_INTERVAL; /* Refresh Interval parameter */
+	buffer[2] = 1; /* Parameter length - 1 byte */
+	buffer[3] = 200; /* 200 ms */
+
+	rc = cyttsp4_device_access_write_command(NULL,
+			GRPNUM_OP_COMMAND, 0, buffer, 4);
+	if (rc < 0) {
+		pr_err("%s: cyttsp4_device_access_write_command failed, rc=%d\n",
+			__func__, rc);
+		goto exit;
+	}
+
+exit:
+	return 0;
+}
+module_init(cyttsp4_test_device_access_api_init);
+
+static void __exit cyttsp4_test_device_access_api_exit(void)
+{
+	int rc;
+
+	pr_info("%s: Exit\n", __func__);
+
+	/*
+	 * CASE 4 - Restore Active mode refresh interval to original
+	 */
+	if (active_refresh_interval) {
+		buffer[0] = OP_CMD_SET_PARAMETER; /* Set Parameter */
+		buffer[1] = OP_PARAM_REFRESH_INTERVAL;
+					/* Refresh Interval parameter */
+		buffer[2] = 1; /* Parameter length - 1 byte */
+		buffer[3] = (u8)active_refresh_interval;
+
+		rc = cyttsp4_device_access_write_command(NULL,
+				GRPNUM_OP_COMMAND, 0, buffer, 4);
+		if (rc < 0) {
+			pr_err("%s: cyttsp4_device_access_write_command failed, rc=%d\n",
+				__func__, rc);
+		}
+	}
+}
+module_exit(cyttsp4_test_device_access_api_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Cypress TrueTouch(R) Standard touchscreen device access API tester");
+MODULE_AUTHOR("Cypress Semiconductor");
diff --git a/drivers/media/platform/msm/camera_v2/sensor/msm_sensor.c b/drivers/media/platform/msm/camera_v2/sensor/msm_sensor.c
index adbfbe7..cd585c3 100644
--- a/drivers/media/platform/msm/camera_v2/sensor/msm_sensor.c
+++ b/drivers/media/platform/msm/camera_v2/sensor/msm_sensor.c
@@ -1076,6 +1076,16 @@ int32_t msm_sensor_power_up(struct msm_sensor_ctrl_t *s_ctrl)
 		goto power_up_failed;
 	}
 
+	/*if the sensor need identify module info, the sensor driver can implement this interface.
+	  sensor driver can dynamic modify the "s_ctrl->sensordata->sensor_name" var. 
+	  like: ov5648_sunny or ov5648_foxconn
+	*/
+	if (s_ctrl->func_tbl->sensor_match_module)
+		rc = s_ctrl->func_tbl->sensor_match_module(s_ctrl);
+	if (rc < 0) {
+		pr_err("%s:%d match id failed rc %d\n", __func__, __LINE__, rc);
+	}
+
 	CDBG("%s exit\n", __func__);
 	return 0;
 power_up_failed:
diff --git a/drivers/media/platform/msm/camera_v2/sensor/msm_sensor.h b/drivers/media/platform/msm/camera_v2/sensor/msm_sensor.h
index 80a2bd4..d6de0ae 100644
--- a/drivers/media/platform/msm/camera_v2/sensor/msm_sensor.h
+++ b/drivers/media/platform/msm/camera_v2/sensor/msm_sensor.h
@@ -48,6 +48,8 @@ struct msm_sensor_fn_t {
 		(struct msm_sensor_ctrl_t *);
 	int (*sensor_power_up) (struct msm_sensor_ctrl_t *);
 	int32_t (*sensor_match_id)(struct msm_sensor_ctrl_t *s_ctrl);
+	/*add detect camera module interface*/
+	int (*sensor_match_module) (struct msm_sensor_ctrl_t *);
 };
 
 struct msm_sensor_ctrl_t {
diff --git a/drivers/video/msm/mdss/Makefile b/drivers/video/msm/mdss/Makefile
index 017fa8e..327a7bd 100644
--- a/drivers/video/msm/mdss/Makefile
+++ b/drivers/video/msm/mdss/Makefile
@@ -17,6 +17,7 @@ obj-$(CONFIG_DEBUG_FS) += mdss_debug.o
 endif
 
 dsi-v2-objs = dsi_v2.o dsi_host_v2.o dsi_io_v2.o dsi_panel_v2.o
+dsi-v2-objs += hw_lcd_common.o
 obj-$(CONFIG_FB_MSM_MDSS) += dsi-v2.o
 
 mdss-dsi-objs := mdss_dsi.o mdss_dsi_host.o
diff --git a/drivers/video/msm/mdss/dsi_panel_v2.c b/drivers/video/msm/mdss/dsi_panel_v2.c
index 022d911..4c601aa 100644
--- a/drivers/video/msm/mdss/dsi_panel_v2.c
+++ b/drivers/video/msm/mdss/dsi_panel_v2.c
@@ -25,6 +25,8 @@
 
 #include "dsi_v2.h"
 
+#include <linux/hw_lcd_common.h>
+
 #define DT_CMD_HDR 6
 
 struct dsi_panel_private {
@@ -809,10 +811,10 @@ static int __devinit dsi_panel_probe(struct platform_device *pdev)
 
 	panel_name = of_get_property(pdev->dev.of_node, "label", NULL);
 	if (!panel_name)
-		pr_debug("%s:%d, panel name not specified\n",
+		pr_info("%s:%d, panel name not specified\n",
 						__func__, __LINE__);
 	else
-		pr_debug("%s: Panel Name = %s\n", __func__, panel_name);
+		pr_info("%s: Panel Name = %s\n", __func__, panel_name);
 
 	rc = dsi_panel_init();
 	if (rc) {
@@ -851,23 +853,19 @@ static int __devexit dsi_panel_remove(struct platform_device *pdev)
 	return 0;
 }
 
-
-static const struct of_device_id dsi_panel_match[] = {
-	{.compatible = "qcom,dsi-panel-v2"},
-	{}
-};
-
 static struct platform_driver this_driver = {
 	.probe  = dsi_panel_probe,
 	.remove = __devexit_p(dsi_panel_remove),
 	.driver = {
 		.name = "dsi_v2_panel",
-		.of_match_table = dsi_panel_match,
+		.of_match_table = huawei_mdss_dsi_panel_match,
 	},
 };
 
 static int __init dsi_panel_module_init(void)
 {
+	//get the real lcd panel type from lcd_id0 and lcd_id1 gpios
+	hw_get_lcd_panel();
 	return platform_driver_register(&this_driver);
 }
 module_init(dsi_panel_module_init);
diff --git a/drivers/video/msm/mdss/hw_lcd_common.c b/drivers/video/msm/mdss/hw_lcd_common.c
new file mode 100644
index 0000000..ac06a7b
--- /dev/null
+++ b/drivers/video/msm/mdss/hw_lcd_common.c
@@ -0,0 +1,278 @@
+/* Copyright (c) 2009, Code HUAWEI. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Code Aurora Forum nor
+ *       the names of its contributors may be used to endorse or promote
+ *       products derived from this software without specific prior written
+ *       permission.
+ *
+ * Alternatively, provided that this notice is retained in full, this software
+ * may be relicensed by the recipient under the terms of the GNU General Public
+ * License version 2 ("GPL") and only version 2, in which case the provisions of
+ * the GPL apply INSTEAD OF those given above.  If the recipient relicenses the
+ * software under the GPL, then the identification text in the MODULE_LICENSE
+ * macro must be changed to reflect "GPLv2" instead of "Dual BSD/GPL".  Once a
+ * recipient changes the license terms to the GPL, subsequent recipients shall
+ * not relicense under alternate licensing terms, including the BSD or dual
+ * BSD/GPL terms.  In addition, the following license statement immediately
+ * below and between the words START and END shall also then apply when this
+ * software is relicensed under the GPL:
+ *
+ * START
+ *
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License version 2 and only version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
+ * details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * END
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#include <linux/kernel.h>
+#include <linux/gpio.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/regulator/consumer.h>
+#include <linux/err.h>
+
+	 
+#include<linux/init.h>
+#include<linux/module.h>
+	 
+#include <linux/hw_lcd_common.h>
+#include <linux/of.h>
+
+
+
+//two gpios use to identify lcd module for 8x12 platform
+#define LCD_ID_0_GPIO    76
+#define LCD_ID_1_GPIO    93
+
+
+#define GET_GPIO_FAIL  -1
+#define GET_LCD_ID_FAIL  -1 
+#define LCD_ID_PULL_UP  1
+#define LCD_ID_PULL_DOWN  0
+
+
+struct of_device_id huawei_mdss_dsi_panel_match[] = {
+	{.compatible = "huawei,lcd_panel_id"},
+	{}
+};
+
+
+/****************************************************************
+function: get lcd id by gpio
+
+*data structure*
+*	   ID1	  ID0   * 
+ *	----------------- * 
+ *	|   |   |   |   | * 
+ *	|   |   |   |   | * 
+ *	----------------- *
+ For each Gpio :
+		00 means low  ,
+		01 means high ,
+		10 means float,
+		11 is not defined,
+
+ lcd id(hex):
+ 0	:ID0 low,	ID1 low
+ 1	:ID0 high,	ID1 low
+ 2	:ID0 float,	ID1 low
+
+ 4	:ID0 low,	ID1 high
+ 5	:ID0 high,	ID1 high
+ 6	:ID0 float,	ID1 high
+
+ 8	:ID0 low,	ID1 float
+ 9	:ID0 high,	ID1 float
+ A	:ID0 float,	ID1 float, used for emulator
+ ***************************************************************/
+/*
+G730:
+BOE:     ID[1:0]   {1:1} --->is is 5
+tianma:  ID[1:0]   {0:0} --->id is 0
+youda:   ID[1:0]   {1:0} --->id is 4
+BYD:     ID[1:0]   {0:1} --->id is 1
+
+
+BOE    IC     NT35517 
+tianma IC     HX8389-B 
+youda  IC     RM68190 
+BYD    IC     NT35517 
+*/
+int hw_get_lcd_id(void)
+{
+	int ret = 0;
+	int id0,id1;
+	int gpio_id0,gpio_id1;
+	int pullup_read,pulldown_read;
+	static int lcd_id = GET_LCD_ID_FAIL;
+	
+	id0=0;
+	id1=0;
+	pullup_read = 0;
+	pulldown_read = 0;
+	gpio_id0 = LCD_ID_0_GPIO;
+	gpio_id1 = LCD_ID_1_GPIO;
+
+	
+	if( (lcd_id >= 0x0) && (lcd_id <= 0xA) )//if lcd_id had read successfully,just return lcd_id.
+		return lcd_id;
+	
+	if(gpio_id0 <= GET_GPIO_FAIL ||gpio_id1 <= GET_GPIO_FAIL)
+		return GET_LCD_ID_FAIL;
+	
+    LCD_DEBUG("gpio_lcd_id0:%d gpio_lcd_id1:%d\n",gpio_id0,gpio_id1);
+	
+    ret = gpio_request(gpio_id0, "lcd_id0");
+      if (ret) {
+         printk(KERN_ERR"lcd_id0 gpio[%d] request failed\n", gpio_id0);
+         goto lcd_id0_req_fail;
+          }
+	  
+    ret = gpio_request(gpio_id1, "lcd_id1");
+	if (ret) {
+	     printk(KERN_ERR"lcd_id1 gpio[%d] request failed\n", gpio_id1);
+         goto lcd_id1_req_fail;
+	}
+	
+	/*config id0 to pull down and read*/
+	ret = gpio_tlmm_config(GPIO_CFG(gpio_id0,0,GPIO_CFG_INPUT,GPIO_CFG_PULL_DOWN,GPIO_CFG_2MA),GPIO_CFG_ENABLE);
+	  if (ret) {
+	     printk(KERN_ERR"config id0 to pull down failed\n");
+	     goto get_lcd_id_fail;	
+	    }
+	udelay(10);
+	pulldown_read = gpio_get_value(gpio_id0);
+	
+	/*config id0 to pull up and read*/
+	ret = gpio_tlmm_config(GPIO_CFG(gpio_id0,0,GPIO_CFG_INPUT,GPIO_CFG_PULL_UP,GPIO_CFG_2MA),GPIO_CFG_ENABLE);
+	  if (ret) {
+	       printk(KERN_ERR"config id0 to pull up failed\n");
+	       goto get_lcd_id_fail;	
+	     }
+	udelay(10);
+	pullup_read = gpio_get_value(gpio_id0);
+	if(pulldown_read != pullup_read)//float
+	{
+		id0 = BIT(1);
+		gpio_tlmm_config(GPIO_CFG(gpio_id0,0,GPIO_CFG_INPUT,GPIO_CFG_PULL_DOWN,GPIO_CFG_2MA),GPIO_CFG_ENABLE);
+	}
+	else//connect 
+	{
+		id0 = pullup_read;//pullup_read==pulldown_read
+		switch(id0)
+		{
+			case LCD_ID_PULL_DOWN:
+			case LCD_ID_PULL_UP:
+			default:
+				gpio_tlmm_config(GPIO_CFG(gpio_id0,0,GPIO_CFG_INPUT,GPIO_CFG_NO_PULL,GPIO_CFG_2MA),GPIO_CFG_ENABLE);
+				break;
+		}
+			
+	}
+	
+	/*config id1 to pull down and read*/
+	ret = gpio_tlmm_config(GPIO_CFG(gpio_id1,0,GPIO_CFG_INPUT,GPIO_CFG_PULL_DOWN,GPIO_CFG_2MA),GPIO_CFG_ENABLE);
+	  if (ret) {
+	     printk(KERN_ERR"config id1 to pull down failed\n");
+	     goto get_lcd_id_fail;	
+	    }
+	udelay(10);
+	pulldown_read = gpio_get_value(gpio_id1);
+	
+	/*config id1 to pull up and read*/
+	ret = gpio_tlmm_config(GPIO_CFG(gpio_id1,0,GPIO_CFG_INPUT,GPIO_CFG_PULL_UP,GPIO_CFG_2MA),GPIO_CFG_ENABLE);
+	if (ret) {
+	     printk(KERN_ERR"config id1 to pull up failed\n");
+	     goto get_lcd_id_fail;	
+	    }
+	udelay(10);
+	pullup_read = gpio_get_value(gpio_id1);
+	if(pulldown_read != pullup_read)//float
+	{
+		id1 = BIT(1);
+		gpio_tlmm_config(GPIO_CFG(gpio_id1,0,GPIO_CFG_INPUT,GPIO_CFG_PULL_DOWN,GPIO_CFG_2MA),GPIO_CFG_ENABLE);
+	}
+	else//connect
+	{
+		id1 = pullup_read;//pullup_read==pulldown_read
+		switch(id1)
+		{
+			case LCD_ID_PULL_DOWN:
+			case LCD_ID_PULL_UP:
+			default:
+				gpio_tlmm_config(GPIO_CFG(gpio_id1,0,GPIO_CFG_INPUT,GPIO_CFG_NO_PULL,GPIO_CFG_2MA),GPIO_CFG_ENABLE);
+				break;
+		}
+	}
+	
+	gpio_free(gpio_id0);
+    gpio_free(gpio_id1);
+
+	lcd_id = (id1<<2) | id0;
+
+    LCD_DEBUG("%s: lcd id = %d \n", __func__,lcd_id);
+	return lcd_id;
+get_lcd_id_fail:
+	gpio_free(gpio_id1);
+lcd_id1_req_fail:
+    gpio_free(gpio_id0);
+lcd_id0_req_fail:
+    return GET_LCD_ID_FAIL;
+}
+
+void hw_get_lcd_panel(void)
+{
+	char *psKey = NULL;
+	int id = 0;
+	int ret = 0;
+	psKey = kmalloc(30, GFP_KERNEL);
+    if (NULL == psKey)  
+    {
+		ret = false;
+		return ;
+    }
+    memset(psKey, 0, 30);
+	
+	id = hw_get_lcd_id();
+    //if the psKey is equal the compatible from dts, the panel will be used.
+	sprintf(psKey, "huawei,lcd_panel_id%X", id);
+	strcpy(huawei_mdss_dsi_panel_match->compatible,psKey);
+
+    printk(KERN_INFO "%s: %s\n",__func__,huawei_mdss_dsi_panel_match->compatible);
+	
+    kfree(psKey);
+	return;
+	
+};
diff --git a/include/linux/cyttsp4_btn.h b/include/linux/cyttsp4_btn.h
new file mode 100644
index 0000000..9793c37
--- /dev/null
+++ b/include/linux/cyttsp4_btn.h
@@ -0,0 +1,39 @@
+/*
+ * cyttsp4_btn.h
+ * Cypress TrueTouch(TM) Standard Product V4 CapSense touch reports module.
+ * For use with Cypress Txx4xx parts.
+ * Supported parts include:
+ * TMA4XX
+ * TMA1036
+ *
+ * Copyright (C) 2012 Cypress Semiconductor
+ * Copyright (C) 2011 Sony Ericsson Mobile Communications AB.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2, and only version 2, as published by the
+ * Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * Contact Cypress Semiconductor at www.cypress.com <ttdrivers@cypress.com>
+ *
+ */
+
+#ifndef _LINUX_CYTTSP4_BTN_H
+#define _LINUX_CYTTSP4_BTN_H
+
+#define CYTTSP4_BTN_NAME "cyttsp4_btn"
+
+struct cyttsp4_btn_platform_data {
+	char const *inp_dev_name;
+};
+
+#endif /* _LINUX_CYTTSP4_BTN_H */
diff --git a/include/linux/cyttsp4_bus.h b/include/linux/cyttsp4_bus.h
new file mode 100644
index 0000000..0f00755
--- /dev/null
+++ b/include/linux/cyttsp4_bus.h
@@ -0,0 +1,346 @@
+/*
+ * cyttsp4_bus.h
+ * Cypress TrueTouch(TM) Standard Product V4 Bus Driver.
+ * For use with Cypress Txx4xx parts.
+ * Supported parts include:
+ * TMA4XX
+ * TMA1036
+ *
+ * Copyright (C) 2012 Cypress Semiconductor
+ * Copyright (C) 2011 Sony Ericsson Mobile Communications AB.
+ *
+ * Author: Aleksej Makarov <aleksej.makarov@sonyericsson.com>
+ * Modified by: Cypress Semiconductor to add device functions
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2, and only version 2, as published by the
+ * Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * Contact Cypress Semiconductor at www.cypress.com <ttdrivers@cypress.com>
+ *
+ */
+
+#ifndef _LINUX_CYTTSP4_BUS_H
+#define _LINUX_CYTTSP4_BUS_H
+
+#include <linux/device.h>
+#include <linux/list.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/limits.h>
+
+
+extern struct bus_type cyttsp4_bus_type;
+
+struct cyttsp4_driver;
+struct cyttsp4_device;
+struct cyttsp4_adapter;
+
+enum cyttsp4_atten_type {
+	CY_ATTEN_IRQ,
+	CY_ATTEN_STARTUP,
+	CY_ATTEN_EXCLUSIVE,
+	CY_ATTEN_WAKE,
+	CY_ATTEN_NUM_ATTEN,
+};
+
+typedef int (*cyttsp4_atten_func) (struct cyttsp4_device *);
+
+struct cyttsp4_ops {
+	int (*write)(struct cyttsp4_adapter *dev, u16 addr,
+		const void *buf, int size, int max_xfer);
+	int (*read)(struct cyttsp4_adapter *dev, u16 addr, void *buf,
+		int size, int max_xfer);
+};
+
+struct cyttsp4_adapter {
+	struct list_head node;
+	char id[NAME_MAX];
+	struct device *dev;
+	int (*write)(struct cyttsp4_adapter *dev, u16 addr,
+		const void *buf, int size, int max_xfer);
+	int (*read)(struct cyttsp4_adapter *dev, u16 addr, void *buf,
+		int size, int max_xfer);
+};
+#define to_cyttsp4_adapter(d) container_of(d, struct cyttsp4_adapter, dev)
+
+struct cyttsp4_core_info {
+	char const *name;
+	char const *id;
+	char const *adap_id;
+	void *platform_data;
+};
+
+struct cyttsp4_core {
+	struct list_head node;
+	char const *name;
+	char const *id;
+	char const *adap_id;
+	struct device dev;
+	struct cyttsp4_adapter *adap;
+};
+#define to_cyttsp4_core(d) container_of(d, struct cyttsp4_core, dev)
+
+struct cyttsp4_device_info {
+	char const *name;
+	char const *core_id;
+	void *platform_data;
+};
+
+struct cyttsp4_device {
+	struct list_head node;
+	char const *name;
+	char const *core_id;
+	struct device dev;
+	struct cyttsp4_core *core;
+};
+#define to_cyttsp4_device(d) container_of(d, struct cyttsp4_device, dev)
+
+struct cyttsp4_core_driver {
+	struct device_driver driver;
+	int (*probe)(struct cyttsp4_core *core);
+	int (*remove)(struct cyttsp4_core *core);
+	int (*subscribe_attention)(struct cyttsp4_device *ttsp,
+				enum cyttsp4_atten_type type,
+				cyttsp4_atten_func func,
+				int flags);
+	int (*unsubscribe_attention)(struct cyttsp4_device *ttsp,
+				enum cyttsp4_atten_type type,
+				cyttsp4_atten_func func,
+				int flags);
+	int (*request_exclusive)(struct cyttsp4_device *ttsp, int timeout_ms);
+	int (*release_exclusive)(struct cyttsp4_device *ttsp);
+	int (*request_reset)(struct cyttsp4_device *ttsp);
+	int (*request_restart)(struct cyttsp4_device *ttsp, bool wait);
+	int (*request_set_mode)(struct cyttsp4_device *ttsp, int mode);
+	struct cyttsp4_sysinfo *(*request_sysinfo)(struct cyttsp4_device *ttsp);
+	struct cyttsp4_loader_platform_data
+		*(*request_loader_pdata)(struct cyttsp4_device *ttsp);
+	int (*request_handshake)(struct cyttsp4_device *ttsp, u8 mode);
+	int (*request_exec_cmd)(struct cyttsp4_device *ttsp, u8 mode,
+			u8 *cmd_buf, size_t cmd_size, u8 *return_buf,
+			size_t return_buf_size, int timeout_ms);
+	int (*request_stop_wd)(struct cyttsp4_device *ttsp);
+	int (*request_toggle_lowpower)(struct cyttsp4_device *ttsp, u8 mode);
+	int (*request_config_row_size)(struct cyttsp4_device *ttsp,
+			u16 *config_row_size);
+	int (*request_write_config)(struct cyttsp4_device *ttsp, u8 ebid,
+			u16 offset, u8 *data, u16 length);
+	int (*request_enable_scan_type)(struct cyttsp4_device *ttsp,
+			u8 scan_type);
+	int (*request_disable_scan_type)(struct cyttsp4_device *ttsp,
+			u8 scan_type);
+	const u8 *(*get_security_key)(struct cyttsp4_device *ttsp, int *size);
+	void (*get_touch_record)(struct cyttsp4_device *ttsp, int rec_no,
+			int *rec_abs);
+	int (*write)(struct cyttsp4_device *ttsp, int mode,
+		u16 addr, const void *buf, int size);
+	int (*read)(struct cyttsp4_device *ttsp, int mode,
+		u16 addr, void *buf, int size);
+};
+#define to_cyttsp4_core_driver(d) \
+	container_of(d, struct cyttsp4_core_driver, driver)
+
+struct cyttsp4_driver {
+	struct device_driver driver;
+	int (*probe)(struct cyttsp4_device *dev);
+	int (*remove)(struct cyttsp4_device *fev);
+};
+#define to_cyttsp4_driver(d) container_of(d, struct cyttsp4_driver, driver)
+
+extern int cyttsp4_register_driver(struct cyttsp4_driver *drv);
+extern void cyttsp4_unregister_driver(struct cyttsp4_driver *drv);
+
+extern int cyttsp4_register_core_driver(struct cyttsp4_core_driver *drv);
+extern void cyttsp4_unregister_core_driver(struct cyttsp4_core_driver *drv);
+
+extern int cyttsp4_register_device(struct cyttsp4_device_info const *dev_info);
+extern int cyttsp4_unregister_device(char const *name, char const *core_id);
+
+extern int cyttsp4_register_core_device(
+		struct cyttsp4_core_info const *core_info);
+
+extern int cyttsp4_add_adapter(char const *id, struct cyttsp4_ops const *ops,
+		struct device *parent);
+
+extern int cyttsp4_del_adapter(char const *id);
+
+static inline int cyttsp4_read(struct cyttsp4_device *ttsp, int mode, u16 addr,
+		void *buf, int size)
+{
+	struct cyttsp4_core *cd = ttsp->core;
+	struct cyttsp4_core_driver *d = to_cyttsp4_core_driver(cd->dev.driver);
+	return d->read(ttsp, mode, addr, buf, size);
+}
+
+static inline int cyttsp4_write(struct cyttsp4_device *ttsp, int mode, u16 addr,
+		const void *buf, int size)
+{
+	struct cyttsp4_core *cd = ttsp->core;
+	struct cyttsp4_core_driver *d = to_cyttsp4_core_driver(cd->dev.driver);
+	return d->write(ttsp, mode, addr, buf, size);
+}
+
+static inline int cyttsp4_subscribe_attention(struct cyttsp4_device *ttsp,
+		enum cyttsp4_atten_type type, cyttsp4_atten_func func,
+		int flags)
+{
+	struct cyttsp4_core *cd = ttsp->core;
+	struct cyttsp4_core_driver *d = to_cyttsp4_core_driver(cd->dev.driver);
+	return d->subscribe_attention(ttsp, type, func, flags);
+}
+
+static inline int cyttsp4_unsubscribe_attention(struct cyttsp4_device *ttsp,
+		enum cyttsp4_atten_type type, cyttsp4_atten_func func,
+		int flags)
+{
+	struct cyttsp4_core *cd = ttsp->core;
+	struct cyttsp4_core_driver *d = to_cyttsp4_core_driver(cd->dev.driver);
+	return d->unsubscribe_attention(ttsp, type, func, flags);
+}
+
+static inline int cyttsp4_request_exclusive(struct cyttsp4_device *ttsp,
+		int timeout_ms)
+{
+	struct cyttsp4_core *cd = ttsp->core;
+	struct cyttsp4_core_driver *d = to_cyttsp4_core_driver(cd->dev.driver);
+	return d->request_exclusive(ttsp, timeout_ms);
+}
+
+static inline int cyttsp4_release_exclusive(struct cyttsp4_device *ttsp)
+{
+	struct cyttsp4_core *cd = ttsp->core;
+	struct cyttsp4_core_driver *d = to_cyttsp4_core_driver(cd->dev.driver);
+	return d->release_exclusive(ttsp);
+}
+
+static inline int cyttsp4_request_reset(struct cyttsp4_device *ttsp)
+{
+	struct cyttsp4_core *cd = ttsp->core;
+	struct cyttsp4_core_driver *d = to_cyttsp4_core_driver(cd->dev.driver);
+	return d->request_reset(ttsp);
+}
+
+static inline int cyttsp4_request_restart(struct cyttsp4_device *ttsp,
+		bool wait)
+{
+	struct cyttsp4_core *cd = ttsp->core;
+	struct cyttsp4_core_driver *d = to_cyttsp4_core_driver(cd->dev.driver);
+	return d->request_restart(ttsp, wait);
+}
+
+static inline int cyttsp4_request_set_mode(struct cyttsp4_device *ttsp,
+		int mode)
+{
+	struct cyttsp4_core *cd = ttsp->core;
+	struct cyttsp4_core_driver *d = to_cyttsp4_core_driver(cd->dev.driver);
+	return d->request_set_mode(ttsp, mode);
+}
+
+static inline struct cyttsp4_sysinfo *cyttsp4_request_sysinfo(
+		struct cyttsp4_device *ttsp)
+{
+	struct cyttsp4_core *cd = ttsp->core;
+	struct cyttsp4_core_driver *d = to_cyttsp4_core_driver(cd->dev.driver);
+	return d->request_sysinfo(ttsp);
+}
+
+static inline struct cyttsp4_loader_platform_data *cyttsp4_request_loader_pdata(
+		struct cyttsp4_device *ttsp)
+{
+	struct cyttsp4_core *cd = ttsp->core;
+	struct cyttsp4_core_driver *d = to_cyttsp4_core_driver(cd->dev.driver);
+	return d->request_loader_pdata(ttsp);
+}
+
+static inline int cyttsp4_request_handshake(struct cyttsp4_device *ttsp,
+		u8 mode)
+{
+	struct cyttsp4_core *cd = ttsp->core;
+	struct cyttsp4_core_driver *d = to_cyttsp4_core_driver(cd->dev.driver);
+	return d->request_handshake(ttsp, mode);
+}
+
+static inline int cyttsp4_request_exec_cmd(struct cyttsp4_device *ttsp,
+		u8 mode, u8 *cmd_buf, size_t cmd_size, u8 *return_buf,
+		size_t return_buf_size, int timeout_ms)
+{
+	struct cyttsp4_core *cd = ttsp->core;
+	struct cyttsp4_core_driver *d = to_cyttsp4_core_driver(cd->dev.driver);
+	return d->request_exec_cmd(ttsp, mode, cmd_buf, cmd_size, return_buf,
+			return_buf_size, timeout_ms);
+}
+
+static inline int cyttsp4_request_stop_wd(struct cyttsp4_device *ttsp)
+{
+	struct cyttsp4_core *cd = ttsp->core;
+	struct cyttsp4_core_driver *d = to_cyttsp4_core_driver(cd->dev.driver);
+	return d->request_stop_wd(ttsp);
+}
+
+static inline int cyttsp4_request_toggle_lowpower(struct cyttsp4_device *ttsp,
+		u8 mode)
+{
+	struct cyttsp4_core *cd = ttsp->core;
+	struct cyttsp4_core_driver *d = to_cyttsp4_core_driver(cd->dev.driver);
+	return d->request_toggle_lowpower(ttsp, mode);
+}
+
+static inline int cyttsp4_request_config_row_size(struct cyttsp4_device *ttsp,
+		u16 *config_row_size)
+{
+	struct cyttsp4_core *cd = ttsp->core;
+	struct cyttsp4_core_driver *d = to_cyttsp4_core_driver(cd->dev.driver);
+	return d->request_config_row_size(ttsp, config_row_size);
+}
+
+static inline int cyttsp4_request_write_config(struct cyttsp4_device *ttsp,
+		u8 ebid, u16 offset, u8 *data, u16 length)
+{
+	struct cyttsp4_core *cd = ttsp->core;
+	struct cyttsp4_core_driver *d = to_cyttsp4_core_driver(cd->dev.driver);
+	return d->request_write_config(ttsp, ebid, offset, data, length);
+}
+
+static inline int cyttsp4_request_enable_scan_type(struct cyttsp4_device *ttsp,
+		u8 scan_type)
+{
+	struct cyttsp4_core *cd = ttsp->core;
+	struct cyttsp4_core_driver *d = to_cyttsp4_core_driver(cd->dev.driver);
+	return d->request_enable_scan_type(ttsp, scan_type);
+}
+
+static inline int cyttsp4_request_disable_scan_type(struct cyttsp4_device *ttsp,
+		u8 scan_type)
+{
+	struct cyttsp4_core *cd = ttsp->core;
+	struct cyttsp4_core_driver *d = to_cyttsp4_core_driver(cd->dev.driver);
+	return d->request_disable_scan_type(ttsp, scan_type);
+}
+
+static inline const u8 *cyttsp4_get_security_key(struct cyttsp4_device *ttsp,
+		int *size)
+{
+	struct cyttsp4_core *cd = ttsp->core;
+	struct cyttsp4_core_driver *d = to_cyttsp4_core_driver(cd->dev.driver);
+	return d->get_security_key(ttsp, size);
+}
+
+static inline void cyttsp4_get_touch_record(struct cyttsp4_device *ttsp,
+		int rec_no, int *rec_abs)
+{
+	struct cyttsp4_core *cd = ttsp->core;
+	struct cyttsp4_core_driver *d = to_cyttsp4_core_driver(cd->dev.driver);
+	d->get_touch_record(ttsp, rec_no, rec_abs);
+}
+#endif /* _LINUX_CYTTSP4_BUS_H */
diff --git a/include/linux/cyttsp4_core.h b/include/linux/cyttsp4_core.h
new file mode 100644
index 0000000..748c425
--- /dev/null
+++ b/include/linux/cyttsp4_core.h
@@ -0,0 +1,148 @@
+/*
+ * cyttsp4_core.h
+ * Cypress TrueTouch(TM) Standard Product V4 Core driver module.
+ * For use with Cypress Txx4xx parts.
+ * Supported parts include:
+ * TMA4XX
+ * TMA1036
+ *
+ * Copyright (C) 2012 Cypress Semiconductor
+ * Copyright (C) 2011 Sony Ericsson Mobile Communications AB.
+ *
+ * Author: Aleksej Makarov <aleksej.makarov@sonyericsson.com>
+ * Modifed by: Cypress Semiconductor to add touch settings
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2, and only version 2, as published by the
+ * Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * Contact Cypress Semiconductor at www.cypress.com <ttdrivers@cypress.com>
+ *
+ */
+
+#ifndef _LINUX_CYTTSP4_CORE_H
+#define _LINUX_CYTTSP4_CORE_H
+
+#include <linux/stringify.h>
+
+#define CYTTSP4_CORE_NAME "cyttsp4_core"
+
+#define CY_DRIVER_NAME TTDA
+#define CY_DRIVER_MAJOR 02
+#define CY_DRIVER_MINOR 03
+#define CY_DRIVER_SUBRELEASE 01
+
+#define CY_DRIVER_REVCTRL 485332
+
+#define CY_DRIVER_VERSION		    \
+__stringify(CY_DRIVER_NAME)		    \
+"." __stringify(CY_DRIVER_MAJOR)	    \
+"." __stringify(CY_DRIVER_MINOR)	    \
+"." __stringify(CY_DRIVER_SUBRELEASE)	    \
+"." __stringify(CY_DRIVER_REVCTRL)
+
+#define CY_DRIVER_DATE "20130612"	/* YYYYMMDD */
+
+/* x-axis resolution of panel in pixels */
+#define CY_PCFG_RESOLUTION_X_MASK 0x7F
+
+/* y-axis resolution of panel in pixels */
+#define CY_PCFG_RESOLUTION_Y_MASK 0x7F
+
+/* x-axis, 0:origin is on left side of panel, 1: right */
+#define CY_PCFG_ORIGIN_X_MASK 0x80
+
+/* y-axis, 0:origin is on top side of panel, 1: bottom */
+#define CY_PCFG_ORIGIN_Y_MASK 0x80
+
+#define CY_TOUCH_SETTINGS_MAX 32
+#define CY_TOUCH_SETTINGS_PARAM_REGS 6
+
+enum cyttsp4_core_platform_flags {
+	CY_CORE_FLAG_NONE = 0x00,
+	CY_CORE_FLAG_WAKE_ON_GESTURE = 0x01,
+};
+
+enum cyttsp4_core_platform_easy_wakeup_gesture {
+	CY_CORE_EWG_NONE = 0x00,
+	CY_CORE_EWG_TAP_TAP = 0x01,
+	CY_CORE_EWG_TWO_FINGER_SLIDE = 0x02,
+	CY_CORE_EWG_RESERVED = 0x03,
+	CY_CORE_EWG_WAKE_ON_INT_FROM_HOST = 0xFF,
+};
+
+enum cyttsp4_loader_platform_flags {
+	CY_LOADER_FLAG_NONE = 0x00,
+	CY_LOADER_FLAG_CALIBRATE_AFTER_FW_UPGRADE = 0x01,
+	/* Use CONFIG_VER field in TT_CFG to decide TT_CFG update */
+	CY_LOADER_FLAG_CHECK_TTCONFIG_VERSION = 0x02,
+};
+
+struct touch_settings {
+	const uint8_t *data;
+	uint32_t size;
+	uint8_t tag;
+} __packed;
+
+struct cyttsp4_touch_firmware {
+	const uint8_t *img;
+	uint32_t size;
+	const uint8_t *ver;
+	uint8_t vsize;
+} __packed;
+
+struct cyttsp4_touch_config {
+	struct touch_settings *param_regs;
+	struct touch_settings *param_size;
+	const uint8_t *fw_ver;
+	uint8_t fw_vsize;
+};
+
+struct cyttsp4_loader_platform_data {
+	struct cyttsp4_touch_firmware *fw;
+	struct cyttsp4_touch_config *ttconfig;
+	u32 flags;
+} __packed;
+
+typedef int (*cyttsp4_platform_read) (struct device *dev, u16 addr,
+	void *buf, int size);
+
+struct cyttsp4_core_platform_data {
+	int irq_gpio;
+	int rst_gpio;
+	int level_irq_udelay;
+	int max_xfer_len;
+	int (*xres)(struct cyttsp4_core_platform_data *pdata,
+		struct device *dev);
+	int (*init)(struct cyttsp4_core_platform_data *pdata,
+		int on, struct device *dev);
+	int (*power)(struct cyttsp4_core_platform_data *pdata,
+		int on, struct device *dev, atomic_t *ignore_irq);
+	int (*detect)(struct cyttsp4_core_platform_data *pdata,
+		struct device *dev, cyttsp4_platform_read read);
+	int (*irq_stat)(struct cyttsp4_core_platform_data *pdata,
+		struct device *dev);
+	struct touch_settings *sett[CY_TOUCH_SETTINGS_MAX];
+	struct cyttsp4_loader_platform_data *loader_pdata;
+	u32 flags;
+	u8 easy_wakeup_gesture;
+};
+
+#ifdef VERBOSE_DEBUG
+extern void cyttsp4_pr_buf(struct device *dev, u8 *pr_buf, u8 *dptr, int size,
+			   const char *data_name);
+#else
+#define cyttsp4_pr_buf(a, b, c, d, e) do { } while (0)
+#endif
+
+#endif /* _LINUX_CYTTSP4_CORE_H */
diff --git a/include/linux/cyttsp4_device_access-api.h b/include/linux/cyttsp4_device_access-api.h
new file mode 100644
index 0000000..63f3716
--- /dev/null
+++ b/include/linux/cyttsp4_device_access-api.h
@@ -0,0 +1,56 @@
+/*
+ * cyttsp4_device_access-api.h
+ * Cypress TrueTouch(TM) Standard Product V4 Device Access API module.
+ * For use with Cypress Txx4xx parts.
+ * Supported parts include:
+ * TMA4XX
+ * TMA1036
+ *
+ * Copyright (C) 2012 Cypress Semiconductor
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2, and only version 2, as published by the
+ * Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * Contact Cypress Semiconductor at www.cypress.com <ttdrivers@cypress.com>
+ *
+ */
+
+#ifndef _LINUX_CYTTSP4_DEVICE_ACCESS_API_H
+#define _LINUX_CYTTSP4_DEVICE_ACCESS_API_H
+
+#include <linux/types.h>
+#include <linux/device.h>
+
+#define GRPNUM_OP_COMMAND	1
+#define GRPNUM_TOUCH_CONFIG	6
+
+#define OP_CMD_NULL		0
+#define OP_CMD_GET_PARAMETER	2
+#define OP_CMD_SET_PARAMETER	3
+#define OP_CMD_GET_CONFIG_CRC	5
+
+#define OP_PARAM_ACTIVE_DISTANCE		0x4A
+#define OP_PARAM_SCAN_TYPE			0x4B
+#define OP_PARAM_LOW_POWER_INTERVAL		0x4C
+#define OP_PARAM_REFRESH_INTERVAL		0x4D
+#define OP_PARAM_ACTIVE_MODE_TIMEOUT		0x4E
+#define OP_PARAM_ACTIVE_LOOK_FOR_TOUCH_INTERVAL 0x4F
+
+extern int cyttsp4_device_access_read_command(const char *core_name,
+		int ic_grpnum, int ic_grpoffset, u8 *buf, int buf_size);
+
+extern int cyttsp4_device_access_write_command(const char *core_name,
+		int ic_grpnum, int ic_grpoffset, u8 *buf, int length);
+
+#endif /* _LINUX_CYTTSP4_DEVICE_ACCESS_API_H */
diff --git a/include/linux/cyttsp4_mt.h b/include/linux/cyttsp4_mt.h
new file mode 100644
index 0000000..44007c8
--- /dev/null
+++ b/include/linux/cyttsp4_mt.h
@@ -0,0 +1,84 @@
+/*
+ * cyttsp4_mt.h
+ * Cypress TrueTouch(TM) Standard Product V4 Multi-touch module.
+ * For use with Cypress Txx4xx parts.
+ * Supported parts include:
+ * TMA4XX
+ * TMA1036
+ *
+ * Copyright (C) 2012 Cypress Semiconductor
+ * Copyright (C) 2011 Sony Ericsson Mobile Communications AB.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2, and only version 2, as published by the
+ * Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * Contact Cypress Semiconductor at www.cypress.com <ttdrivers@cypress.com>
+ *
+ */
+
+#ifndef _LINUX_CYTTSP4_MT_H
+#define _LINUX_CYTTSP4_MT_H
+
+#define CYTTSP4_MT_NAME "cyttsp4_mt"
+
+/* abs settings */
+#define CY_IGNORE_VALUE             0xFFFF
+/* abs signal capabilities offsets in the frameworks array */
+enum cyttsp4_sig_caps {
+	CY_SIGNAL_OST,
+	CY_MIN_OST,
+	CY_MAX_OST,
+	CY_FUZZ_OST,
+	CY_FLAT_OST,
+	CY_NUM_ABS_SET	/* number of signal capability fields */
+};
+
+/* abs axis signal offsets in the framworks array  */
+enum cyttsp4_sig_ost {
+	CY_ABS_X_OST,
+	CY_ABS_Y_OST,
+	CY_ABS_P_OST,
+	CY_ABS_W_OST,
+	CY_ABS_ID_OST,
+	CY_ABS_MAJ_OST,
+	CY_ABS_MIN_OST,
+	CY_ABS_OR_OST,
+	CY_NUM_ABS_OST	/* number of abs signals */
+};
+
+enum cyttsp4_mt_platform_flags {
+	CY_MT_FLAG_NONE = 0x00,
+	CY_MT_FLAG_HOVER = 0x04,
+	CY_MT_FLAG_FLIP = 0x08,
+	CY_MT_FLAG_INV_X = 0x10,
+	CY_MT_FLAG_INV_Y = 0x20,
+	CY_MT_FLAG_VKEYS = 0x40,
+	CY_MT_FLAG_NO_TOUCH_ON_LO = 0x80,
+};
+
+struct touch_framework {
+	const uint16_t  *abs;
+	uint8_t         size;
+	uint8_t         enable_vkeys;
+} __packed;
+
+struct cyttsp4_mt_platform_data {
+	struct touch_framework *frmwrk;
+	unsigned short flags;
+	char const *inp_dev_name;
+	int vkeys_x;
+	int vkeys_y;
+};
+
+#endif /* _LINUX_CYTTSP4_MT_H */
diff --git a/include/linux/cyttsp4_platform.h b/include/linux/cyttsp4_platform.h
new file mode 100644
index 0000000..d5b1c7c
--- /dev/null
+++ b/include/linux/cyttsp4_platform.h
@@ -0,0 +1,61 @@
+/*
+ * cyttsp4_platform.h
+ * Cypress TrueTouch(TM) Standard Product V4 Platform Module.
+ * For use with Cypress Txx4xx parts.
+ * Supported parts include:
+ * TMA4XX
+ * TMA1036
+ *
+ * Copyright (C) 2013 Cypress Semiconductor
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2, and only version 2, as published by the
+ * Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * Contact Cypress Semiconductor at www.cypress.com <ttdrivers@cypress.com>
+ *
+ */
+
+#ifndef _LINUX_CYTTSP4_PLATFORM_H
+#define _LINUX_CYTTSP4_PLATFORM_H
+
+#include <linux/cyttsp4_core.h>
+
+#if IS_ENABLED(CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4)
+extern struct cyttsp4_loader_platform_data _cyttsp4_loader_platform_data;
+
+extern int cyttsp4_xres(struct cyttsp4_core_platform_data *pdata,
+		struct device *dev);
+extern int cyttsp4_init(struct cyttsp4_core_platform_data *pdata,
+		int on, struct device *dev);
+extern int cyttsp4_power(struct cyttsp4_core_platform_data *pdata,
+		int on, struct device *dev, atomic_t *ignore_irq);
+extern int cyttsp4_irq_stat(struct cyttsp4_core_platform_data *pdata,
+		struct device *dev);
+#ifdef CYTTSP4_DETECT_HW
+extern int cyttsp4_detect(struct cyttsp4_core_platform_data *pdata,
+		struct device *dev, cyttsp4_platform_read read);
+#else
+#define cyttsp4_detect		NULL
+#endif
+
+#else /* !CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4 */
+static struct cyttsp4_loader_platform_data _cyttsp4_loader_platform_data;
+#define cyttsp4_xres		NULL
+#define cyttsp4_init		NULL
+#define cyttsp4_power		NULL
+#define cyttsp4_irq_stat	NULL
+#define cyttsp4_detect		NULL
+#endif /* CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4 */
+
+#endif /* _LINUX_CYTTSP4_PLATFORM_H */
diff --git a/include/linux/cyttsp4_proximity.h b/include/linux/cyttsp4_proximity.h
new file mode 100644
index 0000000..39a8262
--- /dev/null
+++ b/include/linux/cyttsp4_proximity.h
@@ -0,0 +1,42 @@
+/*
+ * cyttsp4_proximity.h
+ * Cypress TrueTouch(TM) Standard Product V4 Proximity touch reports module.
+ * For use with Cypress Txx4xx parts.
+ * Supported parts include:
+ * TMA4XX
+ * TMA1036
+ *
+ * Copyright (C) 2012 Cypress Semiconductor
+ * Copyright (C) 2011 Sony Ericsson Mobile Communications AB.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2, and only version 2, as published by the
+ * Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * Contact Cypress Semiconductor at www.cypress.com <ttdrivers@cypress.com>
+ *
+ */
+
+#ifndef _LINUX_CYTTSP4_PROXIMITY_H
+#define _LINUX_CYTTSP4_PROXIMITY_H
+
+#include <linux/cyttsp4_mt.h>
+
+#define CYTTSP4_PROXIMITY_NAME "cyttsp4_proximity"
+
+struct cyttsp4_proximity_platform_data {
+	struct touch_framework *frmwrk;
+	char const *inp_dev_name;
+};
+
+#endif /* _LINUX_CYTTSP4_PROXIMITY_H */
diff --git a/include/linux/hw_lcd_common.h b/include/linux/hw_lcd_common.h
new file mode 100644
index 0000000..774188c
--- /dev/null
+++ b/include/linux/hw_lcd_common.h
@@ -0,0 +1,95 @@
+/* Copyright (c), Code HUAWEI. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Code Aurora nor
+ *       the names of its contributors may be used to endorse or promote
+ *       products derived from this software without specific prior written
+ *       permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef HW_LCD_COMMON_H
+#define HW_LCD_COMMON_H
+
+#include "dsi_v2.h"
+
+
+/* Move from the every LCD file ,those are common */
+#define TRACE_LCD_DEBUG 1
+#if TRACE_LCD_DEBUG
+#define LCD_DEBUG(x...) printk(KERN_ERR "[LCD_DEBUG] " x)
+#else
+#define LCD_DEBUG(x...) do {} while (0)
+#endif
+/* LCD_MDELAY will select mdelay or msleep according value */
+#define LCD_MDELAY(time_ms)   	\
+	do							\
+	{ 							\
+		if (time_ms>10)			\
+			msleep(time_ms);	\
+		else					\
+			mdelay(time_ms);	\
+	}while(0)	
+
+
+typedef unsigned int boolean;
+		
+#ifndef TRUE
+#define TRUE 1
+#endif
+		
+#ifndef FALSE
+#define FALSE 0
+#endif
+
+#define LCD_HW_ID_STATUS_LOW     0
+#define LCD_HW_ID_STATUS_HIGH    1
+#define LCD_HW_ID_STATUS_FLOAT   2
+
+#define MIPI_DCS_COMMAND (1<<0)
+#define MIPI_GEN_COMMAND 4
+#define MIPI_TYPE_END 0XFF
+#define TYPE_PARAMETER   (1<<1)
+
+
+enum {
+	HUAWEI_LCD_ID0,
+	HUAWEI_LCD_ID1,
+	HUAWEI_LCD_ID2,
+	HUAWEI_LCD_ID4,
+	HUAWEI_LCD_ID5,
+	HUAWEI_LCD_ID6,
+	HUAWEI_LCD_ID8,
+	HUAWEI_LCD_ID9,
+	HUAWEI_LCD_IDA,
+};
+
+struct sequence{
+    uint32_t reg;
+    uint32_t value;
+    uint32_t time; //unit is ms
+};
+
+
+extern struct of_device_id huawei_mdss_dsi_panel_match[2];
+
+void hw_get_lcd_panel(void);
+#endif		
-- 
1.7.8.3

