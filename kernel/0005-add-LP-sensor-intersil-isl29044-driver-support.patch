From db47979bd35324f6e1570db47985f88e4df9f880 Mon Sep 17 00:00:00 2001
From: lnxbuild <lnxbuild@localhost>
Date: Fri, 16 Aug 2013 12:45:30 +0800
Subject: [PATCH 5/7] add LP-sensor intersil isl29044 driver support

Change-Id: I975e89c70ed9265ebc4fcaca01d908cba156b64e
---
 arch/arm/boot/dts/msm8610-qrd.dtsi |   21 +-
 arch/arm/configs/msm8610_defconfig |    2 +
 drivers/input/misc/Kconfig         |   16 +
 drivers/input/misc/Makefile        |    2 +
 drivers/input/misc/isl29044.c      | 1149 +++++++++++++++++++++++++++
 drivers/input/misc/tmd277x.c       | 1538 ++++++++++++++++++++++++++++++++++++
 include/linux/i2c/tmd277x.h        |  100 +++
 7 files changed, 2827 insertions(+), 1 deletions(-)
 create mode 100644 drivers/input/misc/isl29044.c
 create mode 100644 drivers/input/misc/tmd277x.c
 create mode 100644 include/linux/i2c/tmd277x.h

diff --git a/arch/arm/boot/dts/msm8610-qrd.dtsi b/arch/arm/boot/dts/msm8610-qrd.dtsi
index af78a24..d79d5e6 100644
--- a/arch/arm/boot/dts/msm8610-qrd.dtsi
+++ b/arch/arm/boot/dts/msm8610-qrd.dtsi
@@ -184,7 +184,26 @@
 			lis3dh,negate_x = <0>;
 			lis3dh,negate_y = <0>;
 			lis3dh,negate_z = <1>;
-        };
+        	};
+	intersil@44 {
+                       compatible = "intersil,isl29044";
+                       reg = <0x44>;
+                       vdd-supply = <&pm8110_l19>;
+                       vddio-supply = <&pm8110_l14>;
+		};
+
+        tmd2772@39 {
+            compatible = "tmd2772,tmd2772";
+            reg = <0x39>;
+                       interrupt-parent = <&msmgpio>;
+            interrupts = <80 0x2>;
+                       tmd2772,int_gpio = <80>;
+                       tmd2772,proximity_can_wake;
+                       tmd2772,prox_th_min = <255>;
+                       tmd2772,prox_th_max = <480>;
+                       tmd2772,als_gate = <10>;
+        	};
+
 	};
 
 	flashlight {
diff --git a/arch/arm/configs/msm8610_defconfig b/arch/arm/configs/msm8610_defconfig
index 36e8cc5..c611e25 100644
--- a/arch/arm/configs/msm8610_defconfig
+++ b/arch/arm/configs/msm8610_defconfig
@@ -266,6 +266,8 @@ CONFIG_HW_RANDOM_MSM=y
 CONFIG_I2C=y
 CONFIG_I2C_CHARDEV=y
 CONFIG_I2C_QUP=y
+CONFIG_SENSORS_TMD27723=y
+CONFIG_INTERSIL_ISL29044=y
 CONFIG_INPUT_MPU3050=y
 CONFIG_BMP18X=y
 CONFIG_BMP18X_I2C=y
diff --git a/drivers/input/misc/Kconfig b/drivers/input/misc/Kconfig
index 7c12885..4d13731 100644
--- a/drivers/input/misc/Kconfig
+++ b/drivers/input/misc/Kconfig
@@ -713,4 +713,20 @@ config SENSORS_STK3X1X
 	  To compile this driver as a module, choose M here: the
 	  module will be called stk3x1x.
 
+config SENSORS_TMD27723
+	tristate "TAOS TMD27723 proximity and ambient light sensor"
+	depends on I2C
+	default n
+	help
+	 If you say yes here you get support for the TAOS tmd27723,
+	 proximity and ambient light sensors.
+	 This driver can also be built as a module.  If so, the module
+	 will be called tmd277x.
+
+config INTERSIL_ISL29044
+	tristate "INTERSIL P/L sensor"
+	depends on I2C
+	help
+	  This option enables support for the INTERSIL ISL29044 P/L sensor.
+
 endif
diff --git a/drivers/input/misc/Makefile b/drivers/input/misc/Makefile
index 6a6df2f..9530c47d 100644
--- a/drivers/input/misc/Makefile
+++ b/drivers/input/misc/Makefile
@@ -65,4 +65,6 @@ obj-$(CONFIG_BMP18X)			+= bmp18x-core.o
 obj-$(CONFIG_BMP18X_I2C)		+= bmp18x-i2c.o
 obj-$(CONFIG_SENSORS_MMA8X5X)	  	+= mma8x5x.o
 obj-$(CONFIG_SENSORS_STK3X1X)		+= stk3x1x.o
+obj-$(CONFIG_SENSORS_TMD27723)          += tmd277x.o
+obj-$(CONFIG_INTERSIL_ISL29044)         += isl29044.o
 obj-$(CONFIG_INPUT_KIONIX_ACCEL)	+= kionix_accel.o
diff --git a/drivers/input/misc/isl29044.c b/drivers/input/misc/isl29044.c
new file mode 100644
index 0000000..0885b9e
--- /dev/null
+++ b/drivers/input/misc/isl29044.c
@@ -0,0 +1,1149 @@
+/******************************************************************************
+ * isl29044.h - Linux kernel module for Intersil isl29044 ambient light sensor
+ *				and proximity sensor
+ *
+ * Copyright 2008-2012 Intersil Inc..
+ *
+ * DESCRIPTION:
+ *	- This is the linux driver for isl29044.
+ *		Kernel version 3.0.8
+ *
+ * modification history
+ * --------------------
+ * v1.0   2010/04/06, Shouxian Chen(Simon Chen) create this file
+ * v1.1   2012/06/05, Shouxian Chen(Simon Chen) modified for Android 4.0 and
+ *			linux 3.0.8
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ ******************************************************************************/
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/init.h>
+#include <linux/input.h>
+#include <linux/idr.h>
+#include <linux/fs.h>
+#include <linux/timer.h>
+#include <linux/sched.h>
+#include <linux/seq_file.h>
+#include <asm/io.h>
+#include <linux/ioctl.h>
+#include <linux/types.h>
+#include <linux/spinlock.h>
+#include <asm/uaccess.h>
+#include <linux/workqueue.h>
+#include <linux/pm.h>
+#include <linux/regulator/consumer.h>
+
+#define ISL29044_ADDR	0x44
+#define	DEVICE_NAME		"isl29044"
+#define	DRIVER_VERSION	"1.1"
+
+#define ALS_EN_MSK		(1 << 0)
+#define PS_EN_MSK		(1 << 1)
+
+#define PS_POLL_TIME	100	 	/* unit is ms */
+
+/* Each client has this additional data */
+struct isl29044_data_t {
+	struct i2c_client* client;
+	u8 als_pwr_status;
+	u8 ps_pwr_status;
+	u8 ps_led_drv_cur;	/* led driver current, 0: 110mA, 1: 220mA */
+	u8 als_range;		/* als range, 0: 125 Lux, 1: 2000Lux */
+	u8 als_mode;		/* als mode, 0: Visible light, 1: IR light */
+	u8 ps_lt;			/* ps low limit */
+	u8 ps_ht;			/* ps high limit */
+	int poll_delay;		/* poll delay set by hal */
+	u8 show_als_raw;	/* show als raw data flag, used for debug */
+	u8 show_ps_raw;	/* show als raw data flag, used for debug */
+	struct timer_list als_timer;	/* als poll timer */
+	struct timer_list ps_timer;	/* ps poll timer */
+	spinlock_t als_timer_lock;
+	spinlock_t ps_timer_lock;
+	struct work_struct als_work;
+	struct work_struct ps_work;
+	struct input_dev *als_input_dev;
+	struct input_dev *ps_input_dev;
+	int last_ps;
+	u8 als_range_using;		/* the als range using now */
+	u8 als_pwr_before_suspend;
+	u8 ps_pwr_before_suspend;
+};
+
+/* Do not scan isl29028 automatic */
+static const unsigned short normal_i2c[] = {ISL29044_ADDR, I2C_CLIENT_END };
+
+/* data struct for isl29044 device */
+struct isl29044_data_t	isl29044_data = {
+	.client = NULL,
+	.als_pwr_status = 0,
+	.ps_pwr_status = 0,
+	.als_input_dev = NULL,
+	.ps_input_dev = NULL
+};
+
+static void do_als_timer(unsigned long arg)
+{
+	struct isl29044_data_t *dev_dat;
+
+	dev_dat = (struct isl29044_data_t *)arg;
+
+	/* timer handler is atomic context, so don't need sinp_lock() */
+	//spin_lock(&dev_dat->als_timer);
+	if(dev_dat->als_pwr_status == 0)
+	{
+		//spin_unlock(&dev_dat->als_timer);
+		return ;
+	}
+	//spin_unlock(&dev_dat->als_timer);
+
+	/* start a work queue, I cannot do i2c oepration in timer context for
+	   this context is atomic and i2c function maybe sleep. */
+	schedule_work(&dev_dat->als_work);
+}
+
+static void do_ps_timer(unsigned long arg)
+{
+	struct isl29044_data_t *dev_dat;
+
+	dev_dat = (struct isl29044_data_t *)arg;
+
+	if(dev_dat->ps_pwr_status == 0)
+	{
+		return ;
+	}
+
+	/* start a work queue, I cannot do i2c oepration in timer context for
+	   this context is atomic and i2c function maybe sleep. */
+	schedule_work(&dev_dat->ps_work);
+}
+
+static void do_als_work(struct work_struct *work)
+{
+	struct isl29044_data_t *dev_dat;
+	int ret;
+	static int als_dat;
+	u8 show_raw_dat;
+	int lux;
+	u8 als_range;
+
+	dev_dat = container_of(work, struct isl29044_data_t, als_work);
+
+	spin_lock(&dev_dat->ps_timer_lock);
+	show_raw_dat = dev_dat->show_als_raw;
+	spin_unlock(&dev_dat->ps_timer_lock);
+
+	als_range = dev_dat->als_range_using;
+
+	ret = i2c_smbus_read_byte_data(dev_dat->client, 0x09);
+	if(ret < 0) goto err_rd;
+	als_dat = (u8)ret;
+
+	ret = i2c_smbus_read_byte_data(dev_dat->client, 0x0a);
+	if(ret < 0) goto err_rd;
+	als_dat = als_dat + ( ((u8)ret & 0x0f) << 8 );
+	if(als_range)
+	{
+		lux = (als_dat * 2000) / 4096;
+	}
+	else
+	{
+		lux = (als_dat * 125) / 4096;
+	}
+
+	input_report_abs(dev_dat->als_input_dev, ABS_MISC, lux);
+	input_sync(dev_dat->als_input_dev);
+	if(show_raw_dat)
+	{
+		printk(KERN_INFO "now als raw data is = %d, LUX = %d\n", als_dat, lux);
+	}
+
+	/* restart timer */
+	spin_lock(&dev_dat->als_timer_lock);
+	if(dev_dat->als_pwr_status == 0)
+	{
+		spin_unlock(&dev_dat->als_timer_lock);
+		return ;
+	}
+	dev_dat->als_timer.expires = jiffies + (HZ * dev_dat->poll_delay) / 1000;
+	spin_unlock(&dev_dat->als_timer_lock);
+	add_timer(&dev_dat->als_timer);
+
+	return ;
+
+err_rd:
+	printk(KERN_ERR "Read ps sensor error, ret = %d\n", ret);
+	return ;
+}
+
+static void do_ps_work(struct work_struct *work)
+{
+	struct isl29044_data_t *dev_dat;
+	int last_ps;
+	int ret;
+	u8 show_raw_dat;
+
+	dev_dat = container_of(work, struct isl29044_data_t, ps_work);
+
+	spin_lock(&dev_dat->ps_timer_lock);
+	show_raw_dat = dev_dat->show_ps_raw;
+	spin_unlock(&dev_dat->ps_timer_lock);
+
+	ret = i2c_smbus_read_byte_data(dev_dat->client, 0x02);
+	if(ret < 0) goto err_rd;
+
+	last_ps = dev_dat->last_ps;
+	dev_dat->last_ps = (ret & 0x80) ? 0 : 1;
+
+	if(show_raw_dat)
+	{
+		ret = i2c_smbus_read_byte_data(dev_dat->client, 0x08);
+		if(ret < 0) goto err_rd;
+		printk(KERN_INFO "ps raw data = %d\n", ret);
+	}
+
+	if(last_ps != dev_dat->last_ps)
+	{
+		input_report_abs(dev_dat->ps_input_dev, ABS_DISTANCE, dev_dat->last_ps);
+		input_sync(dev_dat->ps_input_dev);
+		if(show_raw_dat)
+		{
+			printk(KERN_INFO "ps status changed, now = %d\n",dev_dat->last_ps);
+		}
+	}
+
+	/* restart timer */
+	spin_lock(&dev_dat->ps_timer_lock);
+	if(dev_dat->ps_pwr_status == 0)
+	{
+		spin_unlock(&dev_dat->ps_timer_lock);
+		return ;
+	}
+	dev_dat->ps_timer.expires = jiffies + (HZ * PS_POLL_TIME) / 1000;
+	spin_unlock(&dev_dat->ps_timer_lock);
+	add_timer(&dev_dat->ps_timer);
+
+	return ;
+
+err_rd:
+	printk(KERN_ERR "Read als sensor error, ret = %d\n", ret);
+	return ;
+}
+
+/* enable to run als */
+static int set_sensor_reg(struct isl29044_data_t *dev_dat)
+{
+	u8 reg_dat[5];
+	int i, ret;
+
+	reg_dat[2] = 0x22;
+	reg_dat[3] = dev_dat->ps_lt;
+	reg_dat[4] = dev_dat->ps_ht;
+
+	reg_dat[1] = 0x50;	/* set ps sleep time to 50ms */
+	spin_lock(&dev_dat->als_timer_lock);
+	if(dev_dat->als_pwr_status) reg_dat[1] |= 0x04;
+	spin_unlock(&dev_dat->als_timer_lock);
+
+	spin_lock(&dev_dat->ps_timer_lock);
+	if(dev_dat->ps_pwr_status) reg_dat[1] |= 0x80;
+	spin_unlock(&dev_dat->ps_timer_lock);
+
+	if(dev_dat->als_mode) reg_dat[1] |= 0x01;
+	if(dev_dat->als_range) reg_dat[1] |= 0x02;
+	if(dev_dat->ps_led_drv_cur) reg_dat[1] |= 0x08;
+
+	for(i = 2 ; i <= 4; i++)
+	{
+		ret = i2c_smbus_write_byte_data(dev_dat->client, i, reg_dat[i]);
+		if(ret < 0) return ret;
+	}
+
+	ret = i2c_smbus_write_byte_data(dev_dat->client, 0x01, reg_dat[1]);
+	if(ret < 0) return ret;
+
+	return 0;
+}
+
+/* set power status */
+static int set_als_pwr_st(u8 state, struct isl29044_data_t *dat)
+{
+	int ret = 0;
+
+	if(state)
+	{
+		spin_lock(&dat->als_timer_lock);
+		if(dat->als_pwr_status)
+		{
+			spin_unlock(&dat->als_timer_lock);
+			return ret;
+		}
+		dat->als_pwr_status = 1;
+		spin_unlock(&dat->als_timer_lock);
+		ret = set_sensor_reg(dat);
+		if(ret < 0)
+		{
+			printk(KERN_ERR "set light sensor reg error, ret = %d\n", ret);
+			return ret;
+		}
+
+		/* start timer */
+		dat->als_timer.function = &do_als_timer;
+		dat->als_timer.data = (unsigned long)dat;
+		spin_lock(&dat->als_timer_lock);
+		dat->als_timer.expires = jiffies + (HZ * dat->poll_delay) / 1000;
+		spin_unlock(&dat->als_timer_lock);
+
+		dat->als_range_using = dat->als_range;
+		add_timer(&dat->als_timer);
+	}
+	else
+	{
+		spin_lock(&dat->als_timer_lock);
+		if(dat->als_pwr_status == 0)
+		{
+			spin_unlock(&dat->als_timer_lock);
+			return ret;
+		}
+		dat->als_pwr_status = 0;
+		spin_unlock(&dat->als_timer_lock);
+		ret = set_sensor_reg(dat);
+
+		/* delete timer */
+		del_timer_sync(&dat->als_timer);
+	}
+
+	return ret;
+}
+
+static int set_ps_pwr_st(u8 state, struct isl29044_data_t *dat)
+{
+	int ret = 0;
+
+	if(state)
+	{
+		spin_lock(&dat->ps_timer_lock);
+		if(dat->ps_pwr_status)
+		{
+			spin_unlock(&dat->ps_timer_lock);
+			return ret;
+		}
+		dat->ps_pwr_status = 1;
+		spin_unlock(&dat->ps_timer_lock);
+
+		dat->last_ps = -1;
+		ret = set_sensor_reg(dat);
+		if(ret < 0)
+		{
+			printk(KERN_ERR "set proximity sensor reg error, ret = %d\n", ret);
+			return ret;
+		}
+
+		/* start timer */
+		dat->ps_timer.function = &do_ps_timer;
+		dat->ps_timer.data = (unsigned long)dat;
+		dat->ps_timer.expires = jiffies + (HZ * PS_POLL_TIME) / 1000;
+		add_timer(&dat->ps_timer);
+	}
+	else
+	{
+		spin_lock(&dat->ps_timer_lock);
+		if(dat->ps_pwr_status == 0)
+		{
+			spin_unlock(&dat->ps_timer_lock);
+			return ret;
+		}
+		dat->ps_pwr_status = 0;
+		spin_unlock(&dat->ps_timer_lock);
+
+		ret = set_sensor_reg(dat);
+
+		/* delete timer */
+		del_timer_sync(&dat->ps_timer);
+	}
+
+	return ret;
+}
+
+/* device attribute */
+/* enable als attribute */
+static ssize_t show_enable_als_sensor(struct device *dev,
+			  struct device_attribute *attr, char *buf)
+{
+	struct isl29044_data_t *dat;
+	u8 pwr_status;
+
+	dat = (struct isl29044_data_t *)dev->platform_data;
+	spin_lock(&dat->als_timer_lock);
+	pwr_status = dat->als_pwr_status;
+	spin_unlock(&dat->als_timer_lock);
+
+	return snprintf(buf, PAGE_SIZE, "%d\n", pwr_status);
+}
+static ssize_t store_enable_als_sensor(struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct isl29044_data_t *dat;
+	ssize_t ret;
+	unsigned long val;
+
+	dat = (struct isl29044_data_t *)dev->platform_data;
+
+	val = simple_strtoul(buf, NULL, 10);
+	ret = set_als_pwr_st(val, dat);
+
+	if(ret == 0) ret = count;
+	return ret;
+}
+static DEVICE_ATTR(enable_als_sensor, S_IWUGO|S_IRUGO, show_enable_als_sensor,
+	store_enable_als_sensor);
+
+/* enable ps attribute */
+static ssize_t show_enable_ps_sensor(struct device *dev,
+			  struct device_attribute *attr, char *buf)
+{
+	struct isl29044_data_t *dat;
+	u8 pwr_status;
+
+	dat = (struct isl29044_data_t *)dev->platform_data;
+	spin_lock(&dat->ps_timer_lock);
+	pwr_status = dat->ps_pwr_status;
+	spin_unlock(&dat->ps_timer_lock);
+
+	return snprintf(buf, PAGE_SIZE, "%d\n", pwr_status);
+}
+static ssize_t store_enable_ps_sensor(struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct isl29044_data_t *dat;
+	ssize_t ret;
+	unsigned long val;
+
+	dat = (struct isl29044_data_t *)dev->platform_data;
+
+	val = simple_strtoul(buf, NULL, 10);
+	ret = set_ps_pwr_st(val, dat);
+
+	if(ret == 0) ret = count;
+	return ret;
+}
+static DEVICE_ATTR(enable_ps_sensor, S_IWUGO|S_IRUGO, show_enable_ps_sensor,
+	store_enable_ps_sensor);
+
+/* ps led driver current attribute */
+static ssize_t show_ps_led_drv(struct device *dev,
+			  struct device_attribute *attr, char *buf)
+{
+	struct isl29044_data_t *dat;
+
+	dat = (struct isl29044_data_t *)dev->platform_data;
+	return snprintf(buf, PAGE_SIZE, "%d\n", dat->ps_led_drv_cur);
+}
+static ssize_t store_ps_led_drv(struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct isl29044_data_t *dat;
+	int val;
+
+	if(sscanf(buf, "%d", &val) != 1)
+	{
+		return -EINVAL;
+	}
+
+	dat = (struct isl29044_data_t *)dev->platform_data;
+	if(val) dat->ps_led_drv_cur = 1;
+	else dat->ps_led_drv_cur = 0;
+
+	return count;
+}
+static DEVICE_ATTR(ps_led_driver_current, S_IWUGO|S_IRUGO, show_ps_led_drv,
+	store_ps_led_drv);
+
+/* als range attribute */
+static ssize_t show_als_range(struct device *dev,
+			  struct device_attribute *attr, char *buf)
+{
+	struct isl29044_data_t *dat;
+	u8 range;
+
+	dat = (struct isl29044_data_t *)dev->platform_data;
+	spin_lock(&dat->als_timer_lock);
+	range = dat->als_range;
+	spin_unlock(&dat->als_timer_lock);
+
+	return snprintf(buf, PAGE_SIZE, "%d\n", range);
+}
+static ssize_t store_als_range(struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct isl29044_data_t *dat;
+	int val;
+
+	if(sscanf(buf, "%d", &val) != 1)
+	{
+		return -EINVAL;
+	}
+
+	dat = (struct isl29044_data_t *)dev->platform_data;
+
+	spin_lock(&dat->als_timer_lock);
+	if(val) dat->als_range = 1;
+	else dat->als_range = 0;
+	spin_unlock(&dat->als_timer_lock);
+
+	return count;
+}
+static DEVICE_ATTR(als_range, S_IWUGO|S_IRUGO, show_als_range, store_als_range);
+
+/* als mode attribute */
+static ssize_t show_als_mode(struct device *dev,
+			  struct device_attribute *attr, char *buf)
+{
+	struct isl29044_data_t *dat;
+
+	dat = (struct isl29044_data_t *)dev->platform_data;
+	return snprintf(buf, PAGE_SIZE, "%d\n", dat->als_mode);
+}
+static ssize_t store_als_mode(struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct isl29044_data_t *dat;
+	int val;
+
+	if(sscanf(buf, "%d", &val) != 1)
+	{
+		return -EINVAL;
+	}
+
+	dat = (struct isl29044_data_t *)dev->platform_data;
+	if(val) dat->als_mode = 1;
+	else dat->als_mode = 0;
+
+	return count;
+}
+static DEVICE_ATTR(als_mode, S_IWUGO|S_IRUGO, show_als_mode, store_als_mode);
+
+/* ps limit range attribute */
+static ssize_t show_ps_limit(struct device *dev,
+			  struct device_attribute *attr, char *buf)
+{
+	struct isl29044_data_t *dat;
+
+	dat = (struct isl29044_data_t *)dev->platform_data;
+	return snprintf(buf, PAGE_SIZE, "%d %d\n", dat->ps_lt, dat->ps_ht);
+}
+static ssize_t store_ps_limit(struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct isl29044_data_t *dat;
+	int lt, ht;
+
+	if(sscanf(buf, "%d %d", &lt, &ht) != 2)
+	{
+		return -EINVAL;
+	}
+
+	dat = (struct isl29044_data_t *)dev->platform_data;
+
+	if(lt > 255) dat->ps_lt = 255;
+	else if(lt < 0) dat->ps_lt = 0;
+	else  dat->ps_lt = lt;
+
+	if(ht > 255) dat->ps_ht = 255;
+	else if(ht < 0) dat->ps_ht = 0;
+	else  dat->ps_ht = ht;
+
+	return count;
+}
+static DEVICE_ATTR(ps_limit, S_IWUGO|S_IRUGO, show_ps_limit, store_ps_limit);
+
+/* poll delay attribute */
+static ssize_t show_poll_delay (struct device *dev,
+			  struct device_attribute *attr, char *buf)
+{
+	struct isl29044_data_t *dat;
+	int delay;
+
+	dat = (struct isl29044_data_t *)dev->platform_data;
+	spin_lock(&dat->als_timer_lock);
+	delay = dat->poll_delay;
+	spin_unlock(&dat->als_timer_lock);
+
+	return snprintf(buf, PAGE_SIZE, "%d\n", delay);
+}
+static ssize_t store_poll_delay (struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct isl29044_data_t *dat;
+	unsigned long ns;
+	int delay;
+
+	if(sscanf(buf, "%ld", &ns) != 1)
+	{
+		return -EINVAL;
+	}
+	//printk("ns=%ld\n",ns);
+	delay = ns / 1000 / 1000;
+
+	dat = (struct isl29044_data_t *)dev->platform_data;
+
+	spin_lock(&dat->als_timer_lock);
+	if(delay  < 120) dat->poll_delay = 120;
+	else if(delay > 65535) dat->poll_delay = 65535;
+	else dat->poll_delay = delay;
+	spin_unlock(&dat->als_timer_lock);
+
+	return count;
+}
+static DEVICE_ATTR(poll_delay, S_IWUGO|S_IRUGO, show_poll_delay,
+	store_poll_delay);
+
+/* show als raw data attribute */
+static ssize_t show_als_show_raw (struct device *dev,
+			  struct device_attribute *attr, char *buf)
+{
+	struct isl29044_data_t *dat;
+	u8 flag;
+
+	dat = (struct isl29044_data_t *)dev->platform_data;
+	spin_lock(&dat->als_timer_lock);
+	flag = dat->show_als_raw;
+	spin_unlock(&dat->als_timer_lock);
+
+	return snprintf(buf, PAGE_SIZE, "%d\n", flag);
+}
+static ssize_t store_als_show_raw (struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct isl29044_data_t *dat;
+	int flag;
+
+	if(sscanf(buf, "%d", &flag) != 1)
+	{
+		return -EINVAL;
+	}
+
+	dat = (struct isl29044_data_t *)dev->platform_data;
+
+	spin_lock(&dat->als_timer_lock);
+	if(flag == 0) dat->show_als_raw = 0;
+	else dat->show_als_raw = 1;
+	spin_unlock(&dat->als_timer_lock);
+
+	return count;
+}
+static DEVICE_ATTR(als_show_raw, S_IWUGO|S_IRUGO, show_als_show_raw,
+	store_als_show_raw);
+
+
+/* show ps raw data attribute */
+static ssize_t show_ps_show_raw (struct device *dev,
+			  struct device_attribute *attr, char *buf)
+{
+	struct isl29044_data_t *dat;
+	u8 flag;
+
+	dat = (struct isl29044_data_t *)dev->platform_data;
+	spin_lock(&dat->als_timer_lock);
+	flag = dat->show_ps_raw;
+	spin_unlock(&dat->als_timer_lock);
+
+	return snprintf(buf, PAGE_SIZE, "%d\n", flag);
+}
+static ssize_t store_ps_show_raw (struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct isl29044_data_t *dat;
+	int flag;
+
+	if(sscanf(buf, "%d", &flag) != 1)
+	{
+		return -EINVAL;
+	}
+
+	dat = (struct isl29044_data_t *)dev->platform_data;
+
+	spin_lock(&dat->als_timer_lock);
+	if(flag == 0) dat->show_ps_raw = 0;
+	else dat->show_ps_raw = 1;
+	spin_unlock(&dat->als_timer_lock);
+
+	return count;
+}
+static DEVICE_ATTR(ps_show_raw, S_IWUGO|S_IRUGO, show_ps_show_raw,
+	store_ps_show_raw);
+
+static struct attribute *als_attr[] = {
+	&dev_attr_enable_als_sensor.attr,
+	&dev_attr_als_range.attr,
+	&dev_attr_als_mode.attr,
+	&dev_attr_poll_delay.attr,
+	&dev_attr_als_show_raw.attr,
+	NULL
+};
+
+static struct attribute_group als_attr_grp = {
+//	.name = "light sensor",
+	.attrs = als_attr
+};
+
+static struct attribute *ps_attr[] = {
+	&dev_attr_enable_ps_sensor.attr,
+	&dev_attr_ps_led_driver_current.attr,
+	&dev_attr_ps_limit.attr,
+	&dev_attr_ps_show_raw.attr,
+	NULL
+};
+
+static struct attribute_group ps_attr_grp = {
+//	.name = "proximity sensor",
+	.attrs = ps_attr
+};
+
+
+/* initial and register a input device for sensor */
+static int init_input_dev(struct isl29044_data_t *dev_dat)
+{
+	int err;
+	struct input_dev *als_dev;
+	struct input_dev *ps_dev;
+
+	als_dev = input_allocate_device();
+	if (!als_dev)
+	{
+		return -ENOMEM;
+	}
+
+	ps_dev = input_allocate_device();
+	if (!ps_dev)
+	{
+		err = -ENOMEM;
+		goto err_free_als;
+	}
+
+	als_dev->name = "lightsensor-level";
+	als_dev->id.bustype = BUS_I2C;
+	als_dev->id.vendor  = 0x0001;
+	als_dev->id.product = 0x0001;
+	als_dev->id.version = 0x0100;
+	als_dev->evbit[0] = BIT_MASK(EV_ABS);
+	als_dev->absbit[BIT_WORD(ABS_MISC)] |= BIT_MASK(ABS_MISC);
+	als_dev->dev.platform_data = &isl29044_data;
+	input_set_abs_params(als_dev, ABS_MISC, 0, 2000, 0, 0);
+
+	ps_dev->name = "proximity";
+	ps_dev->id.bustype = BUS_I2C;
+	ps_dev->id.vendor  = 0x0001;
+	ps_dev->id.product = 0x0002;
+	ps_dev->id.version = 0x0100;
+	ps_dev->evbit[0] = BIT_MASK(EV_ABS);
+	ps_dev->absbit[BIT_WORD(ABS_DISTANCE)] |= BIT_MASK(ABS_DISTANCE);
+	ps_dev->dev.platform_data = &isl29044_data;
+	input_set_abs_params(ps_dev, ABS_DISTANCE, 0, 1, 0, 0);
+
+	err = input_register_device(als_dev);
+	if (err)
+	{
+		goto err_free_ps;
+	}
+
+	err = input_register_device(ps_dev);
+	if (err)
+	{
+		goto err_free_ps;
+	}
+
+#if 0
+	/* register device attribute */
+	err = device_create_file(&als_dev->dev, &dev_attr_enable_als_sensor);
+	if (err) goto err_free_ps;
+
+	err = device_create_file(&ps_dev->dev, &dev_attr_enable_ps_sensor);
+	if (err) goto err_rm_als_en_attr;
+
+	err = device_create_file(&ps_dev->dev, &dev_attr_ps_led_driver_current);
+	if (err) goto err_rm_ps_en_attr;
+
+	err = device_create_file(&als_dev->dev, &dev_attr_als_range);
+	if (err) goto err_rm_ps_led_attr;
+
+	err = device_create_file(&als_dev->dev, &dev_attr_als_mode);
+	if (err) goto err_rm_als_range_attr;
+
+	err = device_create_file(&ps_dev->dev, &dev_attr_ps_limit);
+	if (err) goto err_rm_als_mode_attr;
+
+	err = device_create_file(&als_dev->dev, &dev_attr_poll_delay);
+	if (err) goto err_rm_ps_limit_attr;
+
+	err = device_create_file(&als_dev->dev, &dev_attr_als_show_raw);
+	if (err) goto err_rm_poll_delay_attr;
+
+	err = device_create_file(&ps_dev->dev, &dev_attr_ps_show_raw);
+	if (err) goto err_rm_als_show_raw_attr;
+#endif
+
+	err = sysfs_create_group(&als_dev->dev.kobj, &als_attr_grp);
+	if (err) {
+		dev_err(&als_dev->dev, "isl29044: device create als file failed\n");
+		goto err_free_ps;
+	}
+
+	err = sysfs_create_group(&ps_dev->dev.kobj, &ps_attr_grp);
+	if (err) {
+		dev_err(&ps_dev->dev, "isl29044: device create ps file failed\n");
+		goto err_free_ps;
+	}
+
+	dev_dat->als_input_dev = als_dev;
+	dev_dat->ps_input_dev = ps_dev;
+
+	return 0;
+
+#if 0
+err_rm_als_show_raw_attr:
+	device_remove_file(&als_dev->dev, &dev_attr_als_show_raw);
+err_rm_poll_delay_attr:
+	device_remove_file(&als_dev->dev, &dev_attr_poll_delay);
+err_rm_ps_limit_attr:
+	device_remove_file(&ps_dev->dev, &dev_attr_ps_limit);
+err_rm_als_mode_attr:
+	device_remove_file(&als_dev->dev, &dev_attr_als_mode);
+err_rm_als_range_attr:
+	device_remove_file(&als_dev->dev, &dev_attr_als_range);
+err_rm_ps_led_attr:
+	device_remove_file(&ps_dev->dev, &dev_attr_ps_led_driver_current);
+err_rm_ps_en_attr:
+	device_remove_file(&ps_dev->dev, &dev_attr_enable_ps_sensor);
+err_rm_als_en_attr:
+	device_remove_file(&als_dev->dev, &dev_attr_enable_als_sensor);
+#endif
+
+err_free_ps:
+	input_free_device(ps_dev);
+err_free_als:
+	input_free_device(als_dev);
+
+	return err;
+}
+
+struct sensor_regulator {
+	struct regulator *vreg;
+	const char *name;
+	u32	min_uV;
+	u32	max_uV;
+};
+
+struct sensor_regulator isl29044_acc_vreg[] = {
+	{NULL, "vdd", 1700000, 3600000},
+	{NULL, "vddio", 1700000, 3600000},
+};
+
+static int isl29044_acc_config_regulator(struct isl29044_data_t *acc, bool on)
+{
+	int rc = 0, i;
+	int num_reg = sizeof(isl29044_acc_vreg) / sizeof(struct sensor_regulator);
+
+	if (on) {
+		for (i = 0; i < num_reg; i++) {
+			isl29044_acc_vreg[i].vreg =
+				regulator_get(&acc->client->dev,
+				isl29044_acc_vreg[i].name);
+			if (IS_ERR(isl29044_acc_vreg[i].vreg)) {
+				rc = PTR_ERR(isl29044_acc_vreg[i].vreg);
+				pr_err("%s:regulator get failed rc=%d\n",
+								__func__, rc);
+				isl29044_acc_vreg[i].vreg = NULL;
+				goto error_vdd;
+			}
+
+			if (regulator_count_voltages(
+				isl29044_acc_vreg[i].vreg) > 0) {
+				rc = regulator_set_voltage(
+					isl29044_acc_vreg[i].vreg,
+					isl29044_acc_vreg[i].min_uV,
+					isl29044_acc_vreg[i].max_uV);
+				if (rc) {
+					pr_err("%s: set voltage failed rc=%d\n",
+					__func__, rc);
+					regulator_put(isl29044_acc_vreg[i].vreg);
+					isl29044_acc_vreg[i].vreg = NULL;
+					goto error_vdd;
+				}
+			}
+
+			rc = regulator_enable(isl29044_acc_vreg[i].vreg);
+			if (rc) {
+				pr_err("%s: regulator_enable failed rc =%d\n",
+					__func__, rc);
+				if (regulator_count_voltages(
+					isl29044_acc_vreg[i].vreg) > 0) {
+					regulator_set_voltage(
+						isl29044_acc_vreg[i].vreg, 0,
+						isl29044_acc_vreg[i].max_uV);
+				}
+				regulator_put(isl29044_acc_vreg[i].vreg);
+				isl29044_acc_vreg[i].vreg = NULL;
+				goto error_vdd;
+			}
+		}
+		return rc;
+	} else {
+		i = num_reg;
+	}
+
+error_vdd:
+	while (--i >= 0) {
+		if (!IS_ERR_OR_NULL(isl29044_acc_vreg[i].vreg)) {
+			if (regulator_count_voltages(
+			isl29044_acc_vreg[i].vreg) > 0) {
+				regulator_set_voltage(isl29044_acc_vreg[i].vreg,
+						0, isl29044_acc_vreg[i].max_uV);
+			}
+			regulator_disable(isl29044_acc_vreg[i].vreg);
+			regulator_put(isl29044_acc_vreg[i].vreg);
+			isl29044_acc_vreg[i].vreg = NULL;
+		}
+	}
+	return rc;
+}
+
+/* Return 0 if detection is successful, -ENODEV otherwise */
+static int isl29044_detect(struct i2c_client *client,
+	struct i2c_board_info *info)
+{
+	struct i2c_adapter *adapter = client->adapter;
+
+	printk(KERN_DEBUG "In isl29044_detect()\n");
+	if (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_WRITE_BYTE_DATA
+				     | I2C_FUNC_SMBUS_READ_BYTE))
+	{
+		printk("I2c adapter don't support ISL29044\n");
+		return -ENODEV;
+	}
+
+	/* probe that if isl29044 is at the i2 address */
+	if (i2c_smbus_xfer(adapter, client->addr, 0,I2C_SMBUS_WRITE,
+		0,I2C_SMBUS_QUICK,NULL) < 0)
+		{
+		printk("I2c smbus don't support ISL29044\n");
+		return -ENODEV;
+}
+	strlcpy(info->type, "isl29044", I2C_NAME_SIZE);
+	printk("%s is found at i2c device address %d\n",
+		info->type, client->addr);
+
+	return 0;
+}
+
+/* isl29044 probed */
+static int isl29044_probe(struct i2c_client *client,
+			 const struct i2c_device_id *id)
+{
+	int err, i;
+	u8 reg_dat[8];
+
+	printk(KERN_DEBUG "In isl29044_probe()\n");
+
+	/* initial device data struct */
+	isl29044_data.client = client;
+	isl29044_data.als_pwr_status = 0;
+	isl29044_data.ps_pwr_status = 0;
+	isl29044_data.ps_led_drv_cur = 0;
+	isl29044_data.als_range = 1;
+	isl29044_data.als_mode = 0;
+	isl29044_data.ps_lt = 120;
+	isl29044_data.ps_ht = 150;
+	isl29044_data.poll_delay = 200;
+	isl29044_data.show_als_raw = 0;
+	isl29044_data.show_ps_raw = 0;
+
+	spin_lock_init(&isl29044_data.als_timer_lock);
+	spin_lock_init(&isl29044_data.ps_timer_lock);
+	INIT_WORK(&isl29044_data.als_work, &do_als_work);
+	INIT_WORK(&isl29044_data.ps_work, &do_ps_work);
+	init_timer(&isl29044_data.als_timer);
+	init_timer(&isl29044_data.ps_timer);
+
+	i2c_set_clientdata(client,&isl29044_data);
+	isl29044_acc_config_regulator(&isl29044_data, true);
+	/* initial isl29044 */
+	err = set_sensor_reg(&isl29044_data);
+	if(err < 0) return err;
+
+	/* initial als interrupt limit to low = 0, high = 4095, so als cannot
+	   trigger a interrupt. We use ps interrupt only */
+	reg_dat[5] = 0x00;
+	reg_dat[6] = 0xf0;
+	reg_dat[7] = 0xff;
+	for(i = 5; i <= 7; i++)
+	{
+		err = i2c_smbus_write_byte_data(client, i, reg_dat[i]);
+		if(err < 0) return err;
+	}
+
+	/* Add input device register here */
+	err = init_input_dev(&isl29044_data);
+	if(err < 0)
+	{
+		return err;
+	}
+
+	return err;
+}
+
+static int isl29044_remove(struct i2c_client *client)
+{
+	struct input_dev *als_dev;
+	struct input_dev *ps_dev;
+
+	printk(KERN_INFO "%s at address %d is removed\n",client->name,client->addr);
+
+	/* clean the isl29044 data struct when isl29044 device remove */
+	isl29044_data.client = NULL;
+	isl29044_data.als_pwr_status = 0;
+	isl29044_data.ps_pwr_status = 0;
+
+	als_dev = isl29044_data.als_input_dev;
+	ps_dev = isl29044_data.ps_input_dev;
+
+#if 0
+	device_remove_file(&ps_dev->dev, &dev_attr_ps_show_raw);
+	device_remove_file(&als_dev->dev, &dev_attr_als_show_raw);
+	device_remove_file(&als_dev->dev, &dev_attr_poll_delay);
+	device_remove_file(&ps_dev->dev, &dev_attr_ps_limit);
+	device_remove_file(&als_dev->dev, &dev_attr_als_mode);
+	device_remove_file(&als_dev->dev, &dev_attr_als_range);
+	device_remove_file(&ps_dev->dev, &dev_attr_ps_led_driver_current);
+	device_remove_file(&als_dev->dev, &dev_attr_enable_als_sensor);
+	device_remove_file(&ps_dev->dev, &dev_attr_enable_ps_sensor);
+#endif
+
+	sysfs_remove_group(&als_dev->dev.kobj, &als_attr_grp);
+	sysfs_remove_group(&ps_dev->dev.kobj, &ps_attr_grp);
+	isl29044_acc_config_regulator(&isl29044_data, false);
+	input_unregister_device(als_dev);
+	input_unregister_device(ps_dev);
+
+	isl29044_data.als_input_dev = NULL;
+	isl29044_data.ps_input_dev = NULL;
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+/* if define power manager, define suspend and resume function */
+static int isl29044_suspend(struct i2c_client *client, pm_message_t mesg)
+{
+	struct isl29044_data_t *dat;
+	int ret;
+
+	dat = i2c_get_clientdata(client);
+
+	spin_lock(&dat->als_timer_lock);
+	dat->als_pwr_before_suspend = dat->als_pwr_status;
+	spin_unlock(&dat->als_timer_lock);
+	ret = set_als_pwr_st(0, dat);
+	if(ret < 0) return ret;
+
+	spin_lock(&dat->ps_timer_lock);
+	dat->ps_pwr_before_suspend = dat->ps_pwr_status;
+	spin_unlock(&dat->ps_timer_lock);
+	ret = set_ps_pwr_st(0, dat);
+	if(ret < 0) return ret;
+
+	return 0;
+}
+
+static int isl29044_resume(struct i2c_client *client)
+{
+	struct isl29044_data_t *dat;
+	int ret;
+
+	dat = i2c_get_clientdata(client);
+
+	ret = set_als_pwr_st(dat->als_pwr_before_suspend, dat);
+	if(ret < 0) return ret;
+
+	ret = set_ps_pwr_st(dat->ps_pwr_before_suspend, dat);
+	if(ret < 0) return ret;
+
+	return 0;
+}
+#else
+#define	isl29044_suspend 	NULL
+#define isl29044_resume		NULL
+#endif		/*ifdef CONFIG_PM end*/
+
+static const struct i2c_device_id isl29044_id[] = {
+	{ "isl29044", 0 },
+	{ }
+};
+
+#ifdef CONFIG_OF
+static struct of_device_id intersil_match_table[] = {
+            { .compatible = "intersil,isl29044",},
+            { },
+    };
+#else
+#define intersil_match_table NULL
+#endif
+
+static struct i2c_driver isl29044_driver = {
+	.driver = {
+		.name	= "isl29044",
+		.of_match_table = intersil_match_table,
+	},
+	.probe			= isl29044_probe,
+	.remove			= isl29044_remove,
+	.id_table		= isl29044_id,
+	.detect			= isl29044_detect,
+	.address_list	= normal_i2c,
+	.suspend		= isl29044_suspend,
+	.resume			= isl29044_resume
+};
+
+struct i2c_client *isl29044_client;
+
+static int __init isl29044_init(void)
+{
+	int ret;
+
+	/* register the i2c driver for isl29044 */
+	ret = i2c_add_driver(&isl29044_driver);
+	if(ret < 0) printk(KERN_ERR "Add isl29044 driver error, ret = %d\n", ret);
+	printk(KERN_DEBUG "init isl29044 module\n");
+
+	return ret;
+}
+
+static void __exit isl29044_exit(void)
+{
+	printk(KERN_DEBUG "exit isl29044 module\n");
+	i2c_del_driver(&isl29044_driver);
+}
+
+
+MODULE_AUTHOR("Chen Shouxian");
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION("isl29044 ambient light sensor driver");
+MODULE_VERSION(DRIVER_VERSION);
+
+module_init(isl29044_init);
+module_exit(isl29044_exit);
diff --git a/drivers/input/misc/tmd277x.c b/drivers/input/misc/tmd277x.c
new file mode 100644
index 0000000..99b95db
--- /dev/null
+++ b/drivers/input/misc/tmd277x.c
@@ -0,0 +1,1538 @@
+/* drivers/staging/taos/tmd277x.c
+ *
+ * Copyright (C) 2011-2013 Sony Ericsson Mobile Communications AB.
+ *
+ * Author: Aleksej Makarov <aleksej.makarov@sonyericsson.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2, as
+ * published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ */
+#include <linux/kernel.h>
+#include <linux/i2c.h>
+#include <linux/errno.h>
+#include <linux/delay.h>
+#include <linux/string.h>
+#include <linux/mutex.h>
+#include <linux/unistd.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/input.h>
+#include <linux/slab.h>
+#include <linux/pm.h>
+#include <linux/i2c/tmd277x.h>
+#include <linux/module.h>
+
+#ifdef CONFIG_OF
+#include <linux/of_gpio.h>
+#endif
+
+//#include <mach/regs-gpio.h>
+#include <mach/irqs.h>
+#include <linux/irq.h>
+
+enum tmd277x_regs {
+	TMD277X_ENABLE,
+	TMD277X_ALS_TIME,
+	TMD277X_PRX_TIME,
+	TMD277X_WAIT_TIME,
+	TMD277X_ALS_MINTHRESHLO,
+	TMD277X_ALS_MINTHRESHHI,
+	TMD277X_ALS_MAXTHRESHLO,
+	TMD277X_ALS_MAXTHRESHHI,
+	TMD277X_PRX_MINTHRESHLO,
+	TMD277X_PRX_MINTHRESHHI,
+	TMD277X_PRX_MAXTHRESHLO,
+	TMD277X_PRX_MAXTHRESHHI,
+	TMD277X_PERSISTENCE,
+	TMD277X_CONFIG,
+	TMD277X_PRX_PULSE_COUNT,
+	TMD277X_CONTROL,
+
+	TMD277X_REVID = 0x11,
+	TMD277X_CHIPID,
+	TMD277X_STATUS,
+	TMD277X_ALS_CHAN0LO,
+	TMD277X_ALS_CHAN0HI,
+	TMD277X_ALS_CHAN1LO,
+	TMD277X_ALS_CHAN1HI,
+	TMD277X_PRX_LO,
+	TMD277X_PRX_HI,
+
+	TMD277X_REG_PRX_OFFS = 0x1e,
+	TMD277X_REG_MAX,
+};
+
+enum tmd277x_cmd_reg {
+	TMD277X_CMD_REG           = (1 << 7),
+	TMD277X_CMD_INCR          = (0x1 << 5),
+	TMD277X_CMD_SPL_FN        = (0x3 << 5),
+	TMD277X_CMD_PROX_INT_CLR  = (0x5 << 0),
+	TMD277X_CMD_ALS_INT_CLR   = (0x6 << 0),
+};
+
+enum tmd277x_en_reg {
+	TMD277X_EN_PWR_ON   = (1 << 0),
+	TMD277X_EN_ALS      = (1 << 1),
+	TMD277X_EN_PRX      = (1 << 2),
+	TMD277X_EN_WAIT     = (1 << 3),
+	TMD277X_EN_ALS_IRQ  = (1 << 4),
+	TMD277X_EN_PRX_IRQ  = (1 << 5),
+	TMD277X_EN_SAI      = (1 << 6),
+};
+
+enum tmd277x_status {
+	TMD277X_ST_ALS_VALID  = (1 << 0),
+	TMD277X_ST_PRX_VALID  = (1 << 1),
+	TMD277X_ST_ALS_IRQ    = (1 << 4),
+	TMD277X_ST_PRX_IRQ    = (1 << 5),
+	TMD277X_ST_PRX_SAT    = (1 << 6),
+};
+
+enum {
+	TMD277X_ALS_GAIN_MASK = (3 << 0),
+	TMD277X_ALS_AGL_MASK  = (1 << 2),
+	TMD277X_ALS_AGL_SHIFT = 2,
+	TMD277X_ATIME_PER_100 = 273,
+	TMD277X_ATIME_DEFAULT_MS = 50,
+	SCALE_SHIFT = 11,
+	RATIO_SHIFT = 10,
+	MAX_ALS_VALUE = 0xffff,
+	MIN_ALS_VALUE = 10,
+	GAIN_SWITCH_LEVEL = 100,
+	GAIN_AUTO_INIT_VALUE = 16,
+};
+
+static u8 const tmd277x_ids[] = {
+	0x39,
+	0x30,
+};
+
+static char const *tmd277x_names[] = {
+	"tmd27723 / tmd27727",
+	"tmd27721 / tmd27725",
+};
+
+static u8 const restorable_regs[] = {
+	TMD277X_ALS_TIME,
+	TMD277X_PRX_TIME,
+	TMD277X_WAIT_TIME,
+	TMD277X_PERSISTENCE,
+	TMD277X_CONFIG,
+	TMD277X_PRX_PULSE_COUNT,
+	TMD277X_CONTROL,
+	TMD277X_REG_PRX_OFFS,
+};
+
+static u8 const als_gains[] = {
+	1,
+	8,
+	16,
+	120
+};
+
+struct taos_als_info {
+	int ch0;
+	int ch1;
+	u32 cpl;
+	u32 saturation;
+	int lux;
+};
+
+struct taos_prox_info {
+	int raw;
+	int detected;
+};
+
+static struct lux_segment segment_default[] = {
+	{
+		.ratio = (435 << RATIO_SHIFT) / 1000,
+		.k0 = (46516 << SCALE_SHIFT) / 1000,
+		.k1 = (95381 << SCALE_SHIFT) / 1000,
+	},
+	{
+		.ratio = (551 << RATIO_SHIFT) / 1000,
+		.k0 = (23740 << SCALE_SHIFT) / 1000,
+		.k1 = (43044 << SCALE_SHIFT) / 1000,
+	},
+};
+
+struct tmd2772_chip {
+	struct mutex lock;
+	struct i2c_client *client;
+	struct taos_prox_info prx_inf;
+	struct taos_als_info als_inf;
+	struct taos_parameters params;
+	struct tmd2772_i2c_platform_data *pdata;
+	u8 shadow[TMD277X_REG_MAX];
+	struct input_dev *p_idev;
+	struct input_dev *a_idev;
+	int in_suspend;
+	int wake_irq;
+	int irq_pending;
+	bool unpowered;
+	bool als_enabled;
+	bool prx_enabled;
+	struct lux_segment *segment;
+	int segment_num;
+	int seg_num_max;
+	bool als_gain_auto;
+};
+
+static int taos_i2c_read(struct tmd2772_chip *chip, u8 reg, u8 *val)
+{
+	int ret;
+	s32 read;
+	struct i2c_client *client = chip->client;
+
+	ret = i2c_smbus_write_byte(client, (TMD277X_CMD_REG | reg));
+	if (ret < 0) {
+		dev_err(&client->dev, "%s: failed to write register %x\n",
+				__func__, reg);
+		return ret;
+	}
+	read = i2c_smbus_read_byte(client);
+	if (read < 0) {
+		dev_err(&client->dev, "%s: failed to read from register %x\n",
+				__func__, reg);
+		return ret;
+	}
+	*val = read;
+	return read;
+}
+
+static int taos_i2c_blk_read(struct tmd2772_chip *chip,
+		u8 reg, u8 *val, int size)
+{
+	s32 ret;
+	struct i2c_client *client = chip->client;
+
+	ret =  i2c_smbus_read_i2c_block_data(client,
+			TMD277X_CMD_REG | TMD277X_CMD_INCR | reg, size, val);
+	if (ret < 0)
+		dev_err(&client->dev, "%s: failed at address %x (%d bytes)\n",
+				__func__, reg, size);
+	return ret;
+}
+
+static int taos_i2c_write(struct tmd2772_chip *chip, u8 reg, u8 val)
+{
+	int ret;
+	struct i2c_client *client = chip->client;
+
+	ret = i2c_smbus_write_byte_data(client, TMD277X_CMD_REG | reg, val);
+	if (ret < 0)
+		dev_err(&client->dev, "%s: failed to write register %x\n",
+				__func__, reg);
+	return ret;
+}
+
+static int taos_i2c_blk_write(struct tmd2772_chip *chip,
+		u8 reg, u8 *val, int size)
+{
+	s32 ret;
+	struct i2c_client *client = chip->client;
+
+	ret =  i2c_smbus_write_i2c_block_data(client,
+			TMD277X_CMD_REG | TMD277X_CMD_INCR | reg, size, val);
+	if (ret < 0)
+		dev_err(&client->dev, "%s: failed at address %x (%d bytes)\n",
+				__func__, reg, size);
+	return ret;
+}
+
+static int set_segment_table(struct tmd2772_chip *chip,
+		struct lux_segment *segment, int seg_num)
+{
+	int i;
+	struct device *dev = &chip->client->dev;
+
+	chip->seg_num_max = chip->pdata->segment_num ?
+			chip->pdata->segment_num : ARRAY_SIZE(segment_default);
+
+	if (!chip->segment) {
+		dev_dbg(dev, "%s: allocating segment table\n", __func__);
+		chip->segment = kzalloc(sizeof(*chip->segment) *
+				chip->seg_num_max, GFP_KERNEL);
+		if (!chip->segment) {
+			dev_err(dev, "%s: no memory!\n", __func__);
+			return -ENOMEM;
+		}
+	}
+	if (seg_num > chip->seg_num_max) {
+		dev_warn(dev, "%s: %d segment requested, %d applied\n",
+				__func__, seg_num, chip->seg_num_max);
+		chip->segment_num = chip->seg_num_max;
+	} else {
+		chip->segment_num = seg_num;
+	}
+	memcpy(chip->segment, segment,
+			chip->segment_num * sizeof(*chip->segment));
+	dev_dbg(dev, "%s: %d segment requested, %d applied\n", __func__,
+			seg_num, chip->seg_num_max);
+	for (i = 0; i < chip->segment_num; i++)
+		dev_dbg(dev, "segment %d: ratio %6u, k0 %6u, k1 %6u\n",
+				i, chip->segment[i].ratio,
+				chip->segment[i].k0, chip->segment[i].k1);
+	return 0;
+}
+
+static void taos_calc_cpl(struct tmd2772_chip *chip) 
+{
+	u32 cpl;
+	u32 sat;
+	u8 atime = chip->shadow[TMD277X_ALS_TIME];
+	u8 agl = (chip->shadow[TMD277X_CONFIG] & TMD277X_ALS_AGL_MASK)  
+			>> TMD277X_ALS_AGL_SHIFT;			
+
+
+	u32 time_scale = (256 - atime ) * 2730 / 200;   //2730 =2.73*1000  
+
+/*20120830 johnny
+	u32 time_scale = ((256 - atime) << SCALE_SHIFT) *		//atime = TMD277X_ALS_TIME 
+		TMD277X_ATIME_PER_100 / (TMD277X_ATIME_DEFAULT_MS * 100); // TMD277X_ATIME_PER_100 = 273,TMD277X_ATIME_DEFAULT_MS = 50
+*/
+										//time_scale = ((256-238)<<11)*273/(50*100) = 2012
+	cpl = time_scale * chip->params.als_gain;				// cpl = 2012 * 8 = 16096
+	if (agl)   							
+		cpl = cpl * 16 / 1000;						// cpl = 16096*16/1000 = 257
+	sat = min_t(u32, MAX_ALS_VALUE, (u32)(256 - atime) << 10); 	//  (256-238)<<10 = 18432,min_t(u32,X,u32,Y)
+	sat = sat * 8 / 10;					  	
+	dev_dbg(&chip->client->dev,//12
+			"%s: cpl = %u [time_scale %u, gain %u, agl %u], "
+			"saturation %u\n", __func__, cpl, time_scale,
+			chip->params.als_gain, agl, sat);
+	chip->als_inf.cpl = cpl;					//CPL = chip->als_inf.cpl
+	chip->als_inf.saturation = sat;					//sat = chip->als_inf.saturation
+}
+
+static int set_als_gain(struct tmd2772_chip *chip, int gain)
+{
+	int rc;
+	u8 ctrl_reg  = chip->shadow[TMD277X_CONTROL] & ~TMD277X_ALS_GAIN_MASK;
+
+	switch (gain) {
+	case 1:
+		ctrl_reg |= AGAIN_1;
+		break;
+	case 8:
+		ctrl_reg |= AGAIN_8;
+		break;
+	case 16:
+		ctrl_reg |= AGAIN_16;
+		break;
+	case 120:
+		ctrl_reg |= AGAIN_120;
+		break;
+	default:
+		dev_err(&chip->client->dev, "%s: wrong als gain %d\n",
+				__func__, gain);
+		return -EINVAL;
+	}
+	rc = taos_i2c_write(chip, TMD277X_CONTROL, ctrl_reg);
+	if (!rc) {
+		chip->shadow[TMD277X_CONTROL] = ctrl_reg;
+		chip->params.als_gain = gain;
+		dev_dbg(&chip->client->dev, "%s: new gain %d\n",
+				__func__, gain);
+	}
+	return rc;
+}
+
+static int taos_get_lux(struct tmd2772_chip *chip)
+{
+	unsigned i;
+	int ret = 0;
+	struct device *dev = &chip->client->dev;	
+	struct lux_segment *s = chip->segment;		
+	u32 c0 = chip->als_inf.ch0;
+	u32 c1 = chip->als_inf.ch1;
+	u32 sat = chip->als_inf.saturation;
+	u32 ratio;
+	u64 lux_0, lux_1;
+	u32 cpl = chip->als_inf.cpl;
+	u32 lux, k0 = 0, k1 = 0;
+
+	if (!chip->als_gain_auto) {  			
+									
+		if (c0 <= MIN_ALS_VALUE) {  				//MIN_ALS_VALUE = 10
+			dev_dbg(dev, "%s: darkness\n", __func__);
+			lux = 0;
+			goto exit;
+		} else if (c0 >= sat) {
+			dev_dbg(dev, "%s: saturation, keep lux\n", __func__);
+			lux = chip->als_inf.lux;
+			goto exit;
+		}
+	} else {							//chip->als_gain_auto = "AUTO"
+		u8 gain = chip->params.als_gain;			// auto gain , 1x , 16x , 120x
+		int rc = -EIO;
+
+		if (gain == 16 && c0 >= sat) {
+			rc = set_als_gain(chip, 1);
+		} else if (gain == 16 && c0 < GAIN_SWITCH_LEVEL) {	//GAIN_SWITCH_LEVEL = 100
+			rc = set_als_gain(chip, 120);
+		} else if ((gain == 120 && c0 >= sat) ||
+				(gain == 1 && c0 < GAIN_SWITCH_LEVEL)) {
+			rc = set_als_gain(chip, 16);
+		}
+		if (!rc) {							
+			dev_dbg(dev, "%s: gain adjusted, skip\n", __func__);	
+			taos_calc_cpl(chip);
+			ret = -EAGAIN;
+			lux = chip->als_inf.lux;
+			goto exit;
+		}
+
+		if (c0 <= MIN_ALS_VALUE) {
+			dev_dbg(dev, "%s: darkness\n", __func__);
+			lux = 0;
+			goto exit;
+		} else if (c0 >= sat) {
+			dev_dbg(dev, "%s: saturation, keep lux\n", __func__);
+			lux = chip->als_inf.lux;
+			goto exit;
+		}
+	}
+
+	//atime = 50ms, gain = 8x , ch0 = 3891 , ch1 = 424
+
+	ratio = (c1 << RATIO_SHIFT) / c0;						//ratio = c1 * 1024 / c0     //ratio = 111
+	for (i = 0; i < chip->segment_num; i++, s++) {
+		if (ratio <= s->ratio) {
+			dev_dbg(&chip->client->dev, "%s: ratio %u segment %u "
+					"[r %u, k0 %u, k1 %u]\n", __func__,
+					ratio, i, s->ratio, s->k0, s->k1);
+			k0 = s->k0;
+			k1 = s->k1;
+			break;
+		}
+	}
+	if (i >= chip->segment_num) {
+		dev_dbg(&chip->client->dev, "%s: ratio %u - darkness\n",
+				__func__, ratio);
+		lux = 0;
+		goto exit;
+	}
+
+	lux_0 = ( ( ( c0 * 100 ) - ( c1 * 175 ) ) * 10 ) / cpl;
+	lux_1 = ( ( ( c0 *  63 ) - ( c1 * 100 ) ) * 10 ) / cpl; 				//20120830	lux
+
+	
+	//snprintf( buf, "lux_0 = 0x%16llx , lux_1 = 0x%16llx , c0 = 0x%16llx , c1 = 0x%16llx ", lux_0 , lux_1 , c0 , c1 );
+
+	lux = max(lux_0, lux_1);							//20120830	lux
+	lux = max(lux , (u32)0);							//20120830	lux
+
+exit:
+	dev_dbg(&chip->client->dev, "%s: lux %u (%u x %u - %u x %u) / %u\n",
+		__func__, lux, k0, c0, k1, c1, cpl);
+	lux = lux / 4;
+	chip->als_inf.lux = lux;
+	return ret;
+}
+
+static int pltf_power_on(struct tmd2772_chip *chip)
+{
+	int rc = 0;
+	if (chip->pdata->platform_power) {
+		rc = chip->pdata->platform_power(&chip->client->dev,
+			POWER_ON);
+		msleep(10);
+	}
+	chip->unpowered = rc != 0;
+	return rc;
+}
+
+static int pltf_power_off(struct tmd2772_chip *chip)
+{
+	int rc = 0;
+	if (chip->pdata->platform_power) {
+		rc = chip->pdata->platform_power(&chip->client->dev,
+			POWER_OFF);
+		chip->unpowered = rc == 0;
+	} else {
+		chip->unpowered = false;
+	}
+	return rc;
+}
+
+static int taos_irq_clr(struct tmd2772_chip *chip, u8 bits)
+{
+	int ret = i2c_smbus_write_byte(chip->client, TMD277X_CMD_REG |
+			TMD277X_CMD_SPL_FN | bits);
+	if (ret < 0)
+		dev_err(&chip->client->dev, "%s: failed, bits %x\n",
+				__func__, bits);
+	return ret;
+}
+
+static void taos_get_als(struct tmd2772_chip *chip)
+{
+	u32 ch0, ch1;
+	u8 *buf = &chip->shadow[TMD277X_ALS_CHAN0LO];
+
+	ch0 = le16_to_cpup((const __le16 *)&buf[0]);
+	ch1 = le16_to_cpup((const __le16 *)&buf[2]);
+	chip->als_inf.ch0 = ch0;
+	chip->als_inf.ch1 = ch1;
+	dev_dbg(&chip->client->dev, "%s: ch0 %u, ch1 %u\n", __func__, ch0, ch1);
+}
+
+static void taos_get_prox(struct tmd2772_chip *chip)
+{
+	u8 *buf = &chip->shadow[TMD277X_PRX_LO];
+	bool d = chip->prx_inf.detected;
+
+	chip->prx_inf.raw = (buf[1] << 8) | buf[0];
+	chip->prx_inf.detected =
+			(d && (chip->prx_inf.raw > chip->params.prox_th_min)) ||
+			(!d && (chip->prx_inf.raw > chip->params.prox_th_max));
+	dev_dbg(&chip->client->dev, "%s: raw %d, detected %d\n", __func__,
+			chip->prx_inf.raw, chip->prx_inf.detected);
+}
+
+static int taos_read_all(struct tmd2772_chip *chip)
+{
+	struct i2c_client *client = chip->client;
+	s32 ret;
+
+	dev_dbg(&client->dev, "%s\n", __func__);
+	ret = taos_i2c_blk_read(chip, TMD277X_STATUS,
+			&chip->shadow[TMD277X_STATUS],
+			TMD277X_PRX_HI - TMD277X_STATUS + 1);
+	return (ret < 0) ? ret : 0;
+}
+
+static int update_prox_thresh(struct tmd2772_chip *chip, bool on_enable)
+{
+	s32 ret;
+	u8 *buf = &chip->shadow[TMD277X_PRX_MINTHRESHLO];
+	u16 from, to;
+
+	if (on_enable) {
+		/* zero gate to force irq */
+		from = to = 0;
+	} else {
+		if (chip->prx_inf.detected) {
+			from = chip->params.prox_th_min;
+			to = 0xffff;
+		} else {
+			from = 0;
+			to = chip->params.prox_th_max;
+		}
+	}
+	dev_dbg(&chip->client->dev, "%s: %u - %u\n", __func__, from, to);
+	*buf++ = from & 0xff;
+	*buf++ = from >> 8;
+	*buf++ = to & 0xff;
+	*buf++ = to >> 8;
+	ret = taos_i2c_blk_write(chip, TMD277X_PRX_MINTHRESHLO,
+			&chip->shadow[TMD277X_PRX_MINTHRESHLO],
+			TMD277X_PRX_MAXTHRESHHI - TMD277X_PRX_MINTHRESHLO + 1);
+	return (ret < 0) ? ret : 0;
+}
+
+static int update_als_thres(struct tmd2772_chip *chip, bool on_enable)
+{
+	s32 ret;
+	u8 *buf = &chip->shadow[TMD277X_ALS_MINTHRESHLO];
+	u16 gate = chip->params.als_gate;
+	u16 from, to, cur;
+
+	cur = chip->als_inf.ch0;
+	if (on_enable) {
+		/* zero gate far away form current position to force an irq */
+		from = to = cur > 0xffff / 2 ? 0 : 0xffff;
+	} else {
+		gate = cur * gate / 100;
+		if (!gate)
+			gate = 1;
+		if (cur > gate)
+			from = cur - gate;
+		else
+			from = 0;
+		if (cur < (0xffff - gate))
+			to = cur + gate;
+		else
+			to = 0xffff;
+	}
+	dev_dbg(&chip->client->dev, "%s: [%u - %u]\n", __func__, from, to);
+	*buf++ = from & 0xff;
+	*buf++ = from >> 8;
+	*buf++ = to & 0xff;
+	*buf++ = to >> 8;
+	ret = taos_i2c_blk_write(chip, TMD277X_ALS_MINTHRESHLO,
+			&chip->shadow[TMD277X_ALS_MINTHRESHLO],
+			TMD277X_ALS_MAXTHRESHHI - TMD277X_ALS_MINTHRESHLO + 1);
+	return (ret < 0) ? ret : 0;
+}
+
+static void report_prox(struct tmd2772_chip *chip)
+{
+	if (chip->p_idev) {
+		input_report_abs(chip->p_idev, ABS_DISTANCE,
+				chip->prx_inf.detected ? 0 : 1);
+		input_sync(chip->p_idev);
+	}
+}
+
+static void report_als(struct tmd2772_chip *chip)
+{
+	if (chip->a_idev) {
+		int rc = taos_get_lux(chip);
+		if (!rc) {
+			int lux = chip->als_inf.lux;
+			input_report_abs(chip->a_idev, ABS_MISC, lux);
+			input_sync(chip->a_idev);
+			update_als_thres(chip, 0);
+		} else {
+			update_als_thres(chip, 1);
+		}
+	}
+}
+
+static int taos_check_and_report(struct tmd2772_chip *chip)
+{
+	u8 status;
+
+	int ret = taos_read_all(chip);
+	if (ret)
+		goto exit_clr;
+
+	status = chip->shadow[TMD277X_STATUS];
+	dev_dbg(&chip->client->dev, "%s: status 0x%02x\n", __func__, status);
+	if ((status & (TMD277X_ST_PRX_VALID | TMD277X_ST_PRX_IRQ)) ==
+			(TMD277X_ST_PRX_VALID | TMD277X_ST_PRX_IRQ)) {
+		printk("ps\n");
+		taos_get_prox(chip);
+		report_prox(chip);
+		update_prox_thresh(chip, 0);
+	}
+
+	if ((status & (TMD277X_ST_ALS_VALID | TMD277X_ST_ALS_IRQ)) ==
+			(TMD277X_ST_ALS_VALID | TMD277X_ST_ALS_IRQ)) {
+		printk("als\n");
+		taos_get_als(chip);
+		report_als(chip);
+	}
+exit_clr:
+	taos_irq_clr(chip, TMD277X_CMD_PROX_INT_CLR | TMD277X_CMD_ALS_INT_CLR);
+	return ret;
+}
+
+static irqreturn_t taos_irq(int irq, void *handle)
+{
+	struct tmd2772_chip *chip = handle;
+	struct device *dev = &chip->client->dev;
+	mutex_lock(&chip->lock);
+	if (chip->in_suspend) {
+		dev_dbg(dev, "%s: in suspend\n", __func__);
+		chip->irq_pending = 1;
+		disable_irq_nosync(chip->client->irq);
+		goto bypass;
+	}
+	dev_dbg(dev, "%s\n", __func__);
+	(void)taos_check_and_report(chip);
+bypass:
+	mutex_unlock(&chip->lock);
+	return IRQ_HANDLED;
+}
+
+static void set_pltf_settings(struct tmd2772_chip *chip)
+{
+	struct taos_raw_settings const *s = chip->pdata->raw_settings;
+	u8 *sh = chip->shadow;
+	struct device *dev = &chip->client->dev;
+
+	if (s) {
+		dev_dbg(dev, "%s: form pltf data\n", __func__);
+		sh[TMD277X_ALS_TIME] = s->als_time;
+		sh[TMD277X_PRX_TIME] = s->prx_time;
+		sh[TMD277X_WAIT_TIME] = s->wait_time;
+		sh[TMD277X_PERSISTENCE] = s->persist;
+		sh[TMD277X_CONFIG] = s->cfg_reg;
+		sh[TMD277X_PRX_PULSE_COUNT] = s->prox_pulse_cnt;
+		sh[TMD277X_CONTROL] = s->ctrl_reg;
+		sh[TMD277X_REG_PRX_OFFS] = s->prox_offs;
+	} else {
+		dev_dbg(dev, "%s: use defaults\n", __func__);
+		sh[TMD277X_ALS_TIME] = 238; /* ~50 ms */
+		sh[TMD277X_PRX_TIME] = 255;
+		sh[TMD277X_WAIT_TIME] = 0;
+		sh[TMD277X_PERSISTENCE] = PRX_PERSIST(1) | ALS_PERSIST(3);
+		sh[TMD277X_CONFIG] = 0;
+		sh[TMD277X_PRX_PULSE_COUNT] = 12;
+		sh[TMD277X_CONTROL] = AGAIN_8 | PGAIN_4 |
+				PDIOD_CH0 | PDRIVE_30MA;
+		sh[TMD277X_REG_PRX_OFFS] = 0;
+	}
+	chip->params.als_gate = chip->pdata->parameters.als_gate;
+	chip->params.prox_th_max = chip->pdata->parameters.prox_th_max;
+	chip->params.prox_th_min = chip->pdata->parameters.prox_th_min;
+	chip->params.als_gain = chip->pdata->parameters.als_gain;
+	if (chip->pdata->parameters.als_gain) {
+		chip->params.als_gain = chip->pdata->parameters.als_gain;
+	} else {
+		chip->als_gain_auto = true;
+		chip->params.als_gain = GAIN_AUTO_INIT_VALUE;
+		dev_dbg(&chip->client->dev, "%s: auto als gain.\n", __func__);
+	}
+	(void)set_als_gain(chip, chip->params.als_gain);
+	taos_calc_cpl(chip);
+}
+
+static int flush_regs(struct tmd2772_chip *chip)
+{
+	unsigned i;
+	int rc;
+	u8 reg;
+
+	dev_dbg(&chip->client->dev, "%s\n", __func__);
+	for (i = 0; i < ARRAY_SIZE(restorable_regs); i++) {
+		reg = restorable_regs[i];
+		rc = taos_i2c_write(chip, reg, chip->shadow[reg]);
+		if (rc) {
+			dev_err(&chip->client->dev, "%s: err on reg 0x%02x\n",
+					__func__, reg);
+			break;
+		}
+	}
+	return rc;
+}
+
+static int update_enable_reg(struct tmd2772_chip *chip)
+{
+	dev_dbg(&chip->client->dev, "%s: %02x\n", __func__,
+			chip->shadow[TMD277X_ENABLE]);
+	return taos_i2c_write(chip, TMD277X_ENABLE,
+			chip->shadow[TMD277X_ENABLE]);
+}
+
+static int taos_prox_enable(struct tmd2772_chip *chip, int on)
+{
+	int rc;
+
+	dev_dbg(&chip->client->dev, "%s: on = %d\n", __func__, on);
+	if (on) {
+		taos_irq_clr(chip, TMD277X_CMD_PROX_INT_CLR);
+		update_prox_thresh(chip, 1);
+		chip->shadow[TMD277X_ENABLE] |=
+				(TMD277X_EN_PWR_ON | TMD277X_EN_PRX |
+				TMD277X_EN_PRX_IRQ);
+		rc = update_enable_reg(chip);
+		if (rc)
+			return rc;
+		msleep(3);
+	} else {
+		chip->shadow[TMD277X_ENABLE] &=
+				~(TMD277X_EN_PRX_IRQ | TMD277X_EN_PRX);
+		if (!(chip->shadow[TMD277X_ENABLE] & TMD277X_EN_ALS))
+			chip->shadow[TMD277X_ENABLE] &= ~TMD277X_EN_PWR_ON;
+		rc = update_enable_reg(chip);
+		if (rc)
+			return rc;
+		taos_irq_clr(chip, TMD277X_CMD_PROX_INT_CLR);
+	}
+	if (!rc)
+		chip->prx_enabled = on;
+	return rc;
+}
+
+static int taos_als_enable(struct tmd2772_chip *chip, int on)
+{
+	int rc;
+
+	dev_dbg(&chip->client->dev, "%s: on = %d\n", __func__, on);
+	printk("%s: on = %d\n", __func__, on);
+	if (on) {
+		taos_irq_clr(chip, TMD277X_CMD_ALS_INT_CLR);
+		update_als_thres(chip, 1);
+		chip->shadow[TMD277X_ENABLE] |=
+				(TMD277X_EN_PWR_ON | TMD277X_EN_ALS |
+				TMD277X_EN_ALS_IRQ);
+		rc = update_enable_reg(chip);
+		if (rc)
+			return rc;
+		msleep(3);
+	} else {
+		chip->shadow[TMD277X_ENABLE] &=
+				~(TMD277X_EN_ALS_IRQ | TMD277X_EN_ALS);
+		if (!(chip->shadow[TMD277X_ENABLE] & TMD277X_EN_PRX))
+			chip->shadow[TMD277X_ENABLE] &= ~TMD277X_EN_PWR_ON;
+		rc = update_enable_reg(chip);
+		if (rc)
+			return rc;
+		taos_irq_clr(chip, TMD277X_CMD_ALS_INT_CLR);
+	}
+	if (!rc)
+		chip->als_enabled = on;
+	return rc;
+}
+
+static ssize_t taos_device_als_ch0(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct tmd2772_chip *chip = dev_get_drvdata(dev);
+	return snprintf(buf, PAGE_SIZE, "%d\n", chip->als_inf.ch0);
+}
+
+static ssize_t taos_device_als_ch1(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct tmd2772_chip *chip = dev_get_drvdata(dev);
+	return snprintf(buf, PAGE_SIZE, "%d\n", chip->als_inf.ch1);
+}
+
+static ssize_t taos_device_als_cpl(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct tmd2772_chip *chip = dev_get_drvdata(dev);
+	return snprintf(buf, PAGE_SIZE, "%d\n", chip->als_inf.cpl);
+}
+
+static ssize_t taos_device_als_lux(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct tmd2772_chip *chip = dev_get_drvdata(dev);
+	return snprintf(buf, PAGE_SIZE, "%d\n", chip->als_inf.lux);
+}
+
+static ssize_t taos_lux_table_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct tmd2772_chip *chip = dev_get_drvdata(dev);
+	struct lux_segment *s = chip->segment;
+	int i, k;
+
+	for (i = k = 0; i < chip->segment_num; i++)
+		k += snprintf(buf + k, PAGE_SIZE - k, "%d:%u,%u,%u\n", i,
+				(s[i].ratio * 1000) >> RATIO_SHIFT,
+				(s[i].k0 * 1000) >> SCALE_SHIFT,
+				(s[i].k1 * 1000) >> SCALE_SHIFT);
+	return k;
+}
+
+static ssize_t taos_lux_table_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	int i;
+	struct tmd2772_chip *chip = dev_get_drvdata(dev);
+	u32 ratio, k0, k1;
+
+	if (4 != sscanf(buf, "%10d:%10u,%10u,%10u", &i, &ratio, &k0, &k1))
+		return -EINVAL;
+	if (i >= chip->segment_num)
+		return -EINVAL;
+	mutex_lock(&chip->lock);
+	chip->segment[i].ratio = (ratio << RATIO_SHIFT) / 1000;
+	chip->segment[i].k0 = (k0 << SCALE_SHIFT) / 1000;
+	chip->segment[i].k1 = (k1 << SCALE_SHIFT) / 1000;
+	mutex_unlock(&chip->lock);
+	return size;
+}
+
+static ssize_t tmd2772_als_enable_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct tmd2772_chip *chip = dev_get_drvdata(dev);
+	return snprintf(buf, PAGE_SIZE, "%d\n", chip->als_enabled);
+}
+
+static ssize_t tmd2772_als_enable(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	struct tmd2772_chip *chip = dev_get_drvdata(dev);
+	bool value;
+
+	if (strtobool(buf, &value))
+		return -EINVAL;
+
+	if (value)
+		taos_als_enable(chip,1);
+	else
+		taos_als_enable(chip,0);
+
+	return size;
+}
+
+static ssize_t tmd2772_prox_enable_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct tmd2772_chip *chip = dev_get_drvdata(dev);
+	return snprintf(buf, PAGE_SIZE, "%d\n", chip->prx_enabled);
+}
+
+static ssize_t tmd2772_prox_enable(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	struct tmd2772_chip *chip = dev_get_drvdata(dev);
+	bool value;
+
+	if (strtobool(buf, &value))
+		return -EINVAL;
+
+	if (value)
+		taos_prox_enable(chip,1);
+	else
+		taos_prox_enable(chip,0);
+
+	return size;
+}
+
+static ssize_t taos_als_gain_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct tmd2772_chip *chip = dev_get_drvdata(dev);
+	return snprintf(buf, PAGE_SIZE, "%d (%s)\n", chip->params.als_gain,
+			chip->als_gain_auto ? "auto" : "manual");
+}
+
+static ssize_t taos_als_gain_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	unsigned long gain;
+	int rc;
+	struct tmd2772_chip *chip = dev_get_drvdata(dev);
+
+	rc = strict_strtoul(buf, 10, &gain);
+	if (rc)
+		return -EINVAL;
+	if (gain != 0 && gain != 1 && gain != 8 && gain != 16 && gain != 120)
+		return -EINVAL;
+	mutex_lock(&chip->lock);
+	if (gain) {
+		chip->als_gain_auto = false;
+		rc = set_als_gain(chip, gain);
+		if (!rc)
+			taos_calc_cpl(chip);
+	} else {
+		chip->als_gain_auto = true;
+	}
+	mutex_unlock(&chip->lock);
+	return rc ? rc : size;
+}
+
+static ssize_t taos_als_gate_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct tmd2772_chip *chip = dev_get_drvdata(dev);
+	return snprintf(buf, PAGE_SIZE, "%d (in %%)\n", chip->params.als_gate);
+}
+
+static ssize_t taos_als_gate_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	unsigned long gate;
+	int rc;
+	struct tmd2772_chip *chip = dev_get_drvdata(dev);
+
+	rc = strict_strtoul(buf, 10, &gate);
+	if (rc || gate > 100)
+		return -EINVAL;
+	mutex_lock(&chip->lock);
+	chip->params.als_gate = gate;
+	mutex_unlock(&chip->lock);
+	return size;
+}
+
+static ssize_t taos_device_prox_raw(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	u8 *bufff;
+	int rawww;
+	struct tmd2772_chip *chip = dev_get_drvdata(dev);
+
+	int ret = taos_read_all(chip);
+	if (ret)
+		goto exit_clr;
+
+	bufff = &chip->shadow[TMD277X_PRX_LO];
+
+	rawww = (bufff[1] << 8) | bufff[0];
+	return snprintf(buf, PAGE_SIZE, "%d\n", rawww);
+exit_clr:
+	taos_irq_clr(chip, TMD277X_CMD_PROX_INT_CLR | TMD277X_CMD_ALS_INT_CLR);
+	return ret;
+}
+
+static ssize_t taos_device_prx_raw(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct tmd2772_chip *chip = dev_get_drvdata(dev);
+	return snprintf(buf, PAGE_SIZE, "%d\n", chip->prx_inf.raw);
+}
+
+static ssize_t taos_device_prx_detected(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct tmd2772_chip *chip = dev_get_drvdata(dev);
+	return snprintf(buf, PAGE_SIZE, "%d\n", chip->prx_inf.detected);
+}
+
+static ssize_t read_reg(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct tmd2772_chip *chip = dev_get_drvdata(dev);
+	struct i2c_client *client = chip->client;
+
+	char *after;
+	int i;
+	u8 reg;
+
+	after = buf;
+	reg = 0x01;
+
+	for(i = 0; i < 15; i++) {
+		i2c_smbus_write_byte(client, (TMD277X_CMD_REG | reg));
+		after += sprintf(after,"0x%02x\t",i2c_smbus_read_byte(client));
+		reg++;
+	}
+	after += sprintf(after, "\n\t");
+
+	reg = 0x12;
+	for(i = 0; i < 8; i++) {
+		i2c_smbus_write_byte(client, (TMD277X_CMD_REG | reg));
+		after += sprintf(after,"0x%02x\t",i2c_smbus_read_byte(client));
+		reg++;
+	}
+	i2c_smbus_write_byte(client, (TMD277X_CMD_REG | 0x1e));
+	after += sprintf(after,"0x%02x\t",i2c_smbus_read_byte(client));
+	after += sprintf(after, "\n");
+	return (after - buf);
+}
+
+static struct device_attribute prox_attrs[] = {
+	__ATTR(prox_raw, 0444, taos_device_prox_raw, NULL),
+	__ATTR(prx_raw, 0444, taos_device_prx_raw, NULL),
+	__ATTR(prx_detect, 0444, taos_device_prx_detected, NULL),
+	__ATTR(enable_ps_sensor, 0666, tmd2772_prox_enable_show, tmd2772_prox_enable),
+};
+
+static struct device_attribute als_attrs[] = {
+	__ATTR(als_ch0, 0444, taos_device_als_ch0, NULL),
+	__ATTR(als_ch1, 0444, taos_device_als_ch1, NULL),
+	__ATTR(als_cpl, 0444, taos_device_als_cpl, NULL),
+	__ATTR(als_chlux, 0444, taos_device_als_lux, NULL),
+	__ATTR(als_gain, 0644, taos_als_gain_show, taos_als_gain_store),
+	__ATTR(als_gate, 0644, taos_als_gate_show, taos_als_gate_store),
+	__ATTR(lux_table, 0644, taos_lux_table_show, taos_lux_table_store),
+	__ATTR(enable_als_sensor, 0666, tmd2772_als_enable_show, tmd2772_als_enable),
+	__ATTR(get_reg,0644,read_reg,NULL),
+};
+
+static int add_sysfs_interfaces(struct device *dev,
+	struct device_attribute *a, int size)
+{
+	int i;
+	for (i = 0; i < size; i++)
+		if (device_create_file(dev, a + i))
+			goto undo;
+	return 0;
+undo:
+	for (; i >= 0 ; i--)
+		device_remove_file(dev, a + i);
+	dev_err(dev, "%s: failed to create sysfs interface\n", __func__);
+	return -ENODEV;
+}
+
+static void remove_sysfs_interfaces(struct device *dev,
+	struct device_attribute *a, int size)
+{
+	int i;
+	for (i = 0; i < size; i++)
+		device_remove_file(dev, a + i);
+}
+
+static int taos_get_id(struct tmd2772_chip *chip, u8 *id, u8 *rev)
+{
+	int rc = taos_i2c_read(chip, TMD277X_REVID, rev);
+	if (rc < 0)
+		return rc;
+	return taos_i2c_read(chip, TMD277X_CHIPID, id);
+}
+
+static int power_on(struct tmd2772_chip *chip)
+{
+	int rc;
+	rc = pltf_power_on(chip);
+	if (rc)
+		return rc;
+	dev_dbg(&chip->client->dev, "%s: chip was off, restoring regs\n",
+			__func__);
+	return flush_regs(chip);
+}
+#if 0
+static int prox_idev_open(struct input_dev *idev)
+{
+	struct tmd2772_chip *chip = dev_get_drvdata(&idev->dev);
+	int rc;
+	bool als = chip->a_idev && chip->a_idev->users;
+printk("%s\n",__func__);
+	dev_dbg(&idev->dev, "%s\n", __func__);
+	mutex_lock(&chip->lock);
+	if (chip->unpowered) {
+		rc = power_on(chip);
+		if (rc)
+			goto chip_on_err;
+	}
+	rc = taos_prox_enable(chip, 1);
+	if (rc && !als)
+		pltf_power_off(chip);
+chip_on_err:
+	mutex_unlock(&chip->lock);
+	return rc;
+}
+
+static void prox_idev_close(struct input_dev *idev)
+{
+	struct tmd2772_chip *chip = dev_get_drvdata(&idev->dev);
+printk("%s\n",__func__);
+	dev_dbg(&idev->dev, "%s\n", __func__);
+	mutex_lock(&chip->lock);
+	taos_prox_enable(chip, 0);
+	if (!chip->a_idev || !chip->a_idev->users)
+		pltf_power_off(chip);
+	mutex_unlock(&chip->lock);
+}
+
+static int als_idev_open(struct input_dev *idev)
+{
+	struct tmd2772_chip *chip = dev_get_drvdata(&idev->dev);
+	int rc;
+	bool prox = chip->p_idev && chip->p_idev->users;
+printk("%s\n",__func__);
+	dev_dbg(&idev->dev, "%s\n", __func__);
+	mutex_lock(&chip->lock);
+	if (chip->unpowered) {
+		rc = power_on(chip);
+		if (rc)
+			goto chip_on_err;
+	}
+	rc = taos_als_enable(chip, 1);
+	if (rc && !prox)
+		pltf_power_off(chip);
+chip_on_err:
+	mutex_unlock(&chip->lock);
+	return rc;
+}
+
+static void als_idev_close(struct input_dev *idev)
+{
+	struct tmd2772_chip *chip = dev_get_drvdata(&idev->dev);
+printk("%s\n",__func__);
+	dev_dbg(&idev->dev, "%s\n", __func__);
+	mutex_lock(&chip->lock);
+	taos_als_enable(chip, 0);
+	if (!chip->p_idev || !chip->p_idev->users)
+		pltf_power_off(chip);
+	mutex_unlock(&chip->lock);
+}
+#endif
+
+static int taos_parse_dt(struct device *dev,
+				struct tmd2772_i2c_platform_data *pdata)
+{
+	struct device_node *np = dev->of_node;
+	u32 temp_val;
+	int rc;
+
+	rc = of_property_read_u32(np, "tmd2772,int_gpio", &temp_val);
+	if (rc && (rc != -EINVAL)) {
+		dev_err(dev, "Unable to read int_gpio\n");
+		return rc;
+	} else {
+		pdata->int_gpio = (int)temp_val;
+	}
+	pdata->als_can_wake = of_property_read_bool(np, "tmd2772,als_can_wake");
+	pdata->proximity_can_wake = of_property_read_bool(np, "tmd2772,proximity_can_wake");
+	rc = of_property_read_u32(np, "tmd2772,prox_th_min", &temp_val);
+	if (rc && (rc != -EINVAL)) {
+		dev_err(dev, "Unable to read prox_th_min\n");
+		return rc;
+	} else {
+		pdata->parameters.prox_th_min = (u16)temp_val;
+	}
+	rc = of_property_read_u32(np, "tmd2772,prox_th_max", &temp_val);
+	if (rc && (rc != -EINVAL)) {
+		dev_err(dev, "Unable to read prox_th_max\n");
+		return rc;
+	} else {
+			pdata->parameters.prox_th_max = (u16)temp_val;
+		}
+	rc = of_property_read_u32(np, "tmd2772,als_gate", &temp_val);
+	if (rc && (rc != -EINVAL)) {
+		dev_err(dev, "Unable to read als_gate\n");
+		return rc;
+	} else {
+			pdata->parameters.als_gate = (u16)temp_val;
+		}
+	pdata->raw_settings = NULL;
+	return 0;
+}
+
+static int __devinit taos_probe(struct i2c_client *client,
+	const struct i2c_device_id *idp)
+{
+	int i, ret;
+	u8 id, rev;
+	struct device *dev;
+	static struct tmd2772_chip *chip;
+	struct tmd2772_i2c_platform_data *pdata;
+	bool powered = 0;
+	printk("tmd2772\n");
+	dev = &client->dev;
+	pdata = kzalloc(sizeof(struct tmd2772_i2c_platform_data), GFP_KERNEL);
+	if (!pdata) {
+		ret = -ENOMEM;
+		goto malloc_failed;
+	}
+
+	if (client->dev.of_node) {
+		memset(pdata, 0 , sizeof(struct tmd2772_i2c_platform_data));
+		ret = taos_parse_dt(&client->dev, pdata);
+		if (ret) {
+			dev_err(&client->dev,
+				"Unable to parse platfrom data err=%d\n", ret);
+			return ret;
+		}
+	}  else {
+		if (client->dev.platform_data) {
+			pdata = (struct tmd2772_i2c_platform_data *)client->dev.platform_data;
+		} else {
+			dev_err(&client->dev, "platform data is NULL. Abort.\n");
+			return -EINVAL;
+		}
+	}
+
+	pdata->prox_name = "proximity";
+	pdata->als_name = "lightsensor-level";
+	dev_info(&client->dev, "%s: client->irq = %d\n", __func__, client->irq);
+	if (!i2c_check_functionality(client->adapter,
+			I2C_FUNC_SMBUS_BYTE_DATA)) {
+		dev_err(&client->dev, "%s: i2c smbus byte data unsupported\n", __func__);
+		ret = -EOPNOTSUPP;
+		goto init_failed;
+	}
+	if (!pdata) {
+		dev_err(&client->dev, "%s: platform data required\n", __func__);
+		ret = -EINVAL;
+		goto init_failed;
+	}
+	if (!(pdata->prox_name || pdata->als_name) || client->irq < 0) {
+		dev_err(&client->dev, "%s: no reason to run.\n", __func__);
+		ret = -EINVAL;
+		goto init_failed;
+	}
+	if (pdata->platform_init) {
+		ret = pdata->platform_init(dev);
+		if (ret)
+			goto init_failed;
+	}
+	if (pdata->platform_power) {
+		ret = pdata->platform_power(dev, POWER_ON);
+		if (ret) {
+			dev_err(&client->dev, "%s: pltf power on failed\n", __func__);
+			goto pon_failed;
+		}
+		powered = true;
+		msleep(10);
+	}
+	chip = kzalloc(sizeof(struct tmd2772_chip), GFP_KERNEL);
+	if (!chip) {
+		ret = -ENOMEM;
+		goto malloc_failed;
+	}
+	chip->client = client;
+	chip->pdata = pdata;
+	i2c_set_clientdata(client, chip);
+	chip->seg_num_max = chip->pdata->segment_num ?
+			chip->pdata->segment_num : ARRAY_SIZE(segment_default);
+	if (chip->pdata->segment)
+		ret = set_segment_table(chip, chip->pdata->segment,
+			chip->pdata->segment_num);
+	else
+		ret =  set_segment_table(chip, segment_default,
+			ARRAY_SIZE(segment_default));
+	if (ret)
+		goto set_segment_failed;
+
+	ret = taos_get_id(chip, &id, &rev);
+	if (ret < 0)
+		goto id_failed;
+	for (i = 0; i < ARRAY_SIZE(tmd277x_ids); i++) {
+		if (id == tmd277x_ids[i])
+			break;
+	}
+	if (i < ARRAY_SIZE(tmd277x_names)) {
+		dev_info(&client->dev, "%s: '%s rev. %d' detected\n", __func__,
+			tmd277x_names[i], rev);
+	} else {
+		dev_err(&client->dev, "%s: not supported chip id\n", __func__);
+		ret = -EOPNOTSUPP;
+		goto id_failed;
+	}
+	mutex_init(&chip->lock);
+	set_pltf_settings(chip);
+	ret = flush_regs(chip);
+	if (ret)
+		goto flush_regs_failed;
+	if (pdata->platform_power) {
+		pdata->platform_power(dev, POWER_OFF);
+		powered = false;
+		chip->unpowered = true;
+	}
+
+	if (!pdata->prox_name)
+		goto bypass_prox_idev;
+	chip->p_idev = input_allocate_device();
+	if (!chip->p_idev) {
+		dev_err(&client->dev, "%s: no memory for input_dev '%s'\n",
+				__func__, pdata->prox_name);
+		ret = -ENODEV;
+		goto input_p_alloc_failed;
+	}
+	chip->p_idev->name = pdata->prox_name;
+	chip->p_idev->id.bustype = BUS_I2C;
+	set_bit(EV_ABS, chip->p_idev->evbit);
+	set_bit(ABS_DISTANCE, chip->p_idev->absbit);
+	input_set_abs_params(chip->p_idev, ABS_DISTANCE, 0, 1, 0, 0);
+	//chip->p_idev->open = prox_idev_open;
+	//chip->p_idev->close = prox_idev_close;
+	dev_set_drvdata(&chip->p_idev->dev, chip);
+	ret = input_register_device(chip->p_idev);
+	if (ret) {
+		input_free_device(chip->p_idev);
+		dev_err(&client->dev, "%s: cant register input '%s'\n",
+				__func__, pdata->prox_name);
+		goto input_p_alloc_failed;
+	}
+	ret = add_sysfs_interfaces(&chip->p_idev->dev,
+			prox_attrs, ARRAY_SIZE(prox_attrs));
+	if (ret)
+		goto input_p_sysfs_failed;
+bypass_prox_idev:
+	if (!pdata->als_name)
+		goto bypass_als_idev;
+	chip->a_idev = input_allocate_device();
+	if (!chip->a_idev) {
+		dev_err(&client->dev, "%s: no memory for input_dev '%s'\n",
+				__func__, pdata->als_name);
+		ret = -ENODEV;
+		goto input_a_alloc_failed;
+	}
+	chip->a_idev->name = pdata->als_name;
+	chip->a_idev->id.bustype = BUS_I2C;
+	set_bit(EV_ABS, chip->a_idev->evbit);
+	set_bit(ABS_MISC, chip->a_idev->absbit);
+	input_set_abs_params(chip->a_idev, ABS_MISC, 0, 65535, 0, 0);
+	//chip->a_idev->open = als_idev_open;
+	//chip->a_idev->close = als_idev_close;
+	dev_set_drvdata(&chip->a_idev->dev, chip);
+	ret = input_register_device(chip->a_idev);
+	if (ret) {
+		input_free_device(chip->a_idev);
+		dev_err(&client->dev, "%s: cant register input '%s'\n",
+				__func__, pdata->prox_name);
+		goto input_a_alloc_failed;
+	}
+	ret = add_sysfs_interfaces(&chip->a_idev->dev,
+			als_attrs, ARRAY_SIZE(als_attrs));
+	if (ret)
+		goto input_a_sysfs_failed;
+
+bypass_als_idev:
+printk("int_gpio=%d\n",chip->pdata->int_gpio);
+	gpio_tlmm_config(GPIO_CFG(chip->pdata->int_gpio, 0, GPIO_CFG_INPUT,
+				GPIO_CFG_PULL_UP, GPIO_CFG_8MA),
+				GPIO_CFG_ENABLE);
+	ret = request_threaded_irq(client->irq, NULL, taos_irq,
+		      IRQ_TYPE_EDGE_FALLING,
+		      "taos_irq", chip);
+	if (ret) {
+		dev_info(&client->dev, "Failed to request irq %d\n", client->irq);
+		goto irq_register_fail;
+	}
+
+	dev_info(&client->dev, "Probe ok.\n");
+	return 0;
+
+irq_register_fail:
+	if (chip->a_idev) {
+		remove_sysfs_interfaces(&chip->a_idev->dev,
+			als_attrs, ARRAY_SIZE(als_attrs));
+input_a_sysfs_failed:
+		input_unregister_device(chip->a_idev);
+	}
+input_a_alloc_failed:
+	if (chip->p_idev) {
+		remove_sysfs_interfaces(&chip->p_idev->dev,
+			prox_attrs, ARRAY_SIZE(prox_attrs));
+input_p_sysfs_failed:
+		input_unregister_device(chip->p_idev);
+	}
+input_p_alloc_failed:
+flush_regs_failed:
+id_failed:
+	kfree(chip->segment);
+set_segment_failed:
+	i2c_set_clientdata(client, NULL);
+	kfree(chip);
+malloc_failed:
+	if (powered && pdata->platform_power)
+		pdata->platform_power(dev, POWER_OFF);
+pon_failed:
+	if (pdata->platform_teardown)
+		pdata->platform_teardown(dev);
+init_failed:
+	dev_err(&client->dev, "Probe failed.\n");
+	return ret;
+}
+
+static int taos_suspend(struct device *dev)
+{
+	struct tmd2772_chip *chip = dev_get_drvdata(dev);
+	struct tmd2772_i2c_platform_data *pdata = dev->platform_data;
+
+	dev_dbg(dev, "%s\n", __func__);
+	mutex_lock(&chip->lock);
+	chip->in_suspend = 1;
+	if (chip->p_idev && chip->p_idev->users) {
+		if (pdata->proximity_can_wake) {
+			dev_dbg(dev, "set wake on proximity\n");
+			chip->wake_irq = 1;
+		} else {
+			dev_dbg(dev, "proximity off\n");
+			taos_prox_enable(chip, 0);
+		}
+	}
+	if (chip->a_idev && chip->a_idev->users) {
+		if (pdata->als_can_wake) {
+			dev_dbg(dev, "set wake on als\n");
+			chip->wake_irq = 1;
+		} else {
+			dev_dbg(dev, "als off\n");
+			taos_als_enable(chip, 0);
+		}
+	}
+	if (chip->wake_irq) {
+		irq_set_irq_wake(chip->client->irq, 1);
+	} else if (!chip->unpowered) {
+		dev_dbg(dev, "powering off\n");
+		pltf_power_off(chip);
+	}
+	mutex_unlock(&chip->lock);
+
+	return 0;
+}
+
+static int taos_resume(struct device *dev)
+{
+	struct tmd2772_chip *chip = dev_get_drvdata(dev);
+	bool als_on, prx_on;
+	int rc = 0;
+	mutex_lock(&chip->lock);
+	prx_on = chip->p_idev && chip->p_idev->users;
+	als_on = chip->a_idev && chip->a_idev->users;
+	chip->in_suspend = 0;
+	dev_dbg(dev, "%s: powerd %d, als: needed %d  enabled %d,"
+			" prox: needed %d  enabled %d\n", __func__,
+			!chip->unpowered, als_on, chip->als_enabled,
+			prx_on, chip->prx_enabled);
+	if (chip->wake_irq) {
+		irq_set_irq_wake(chip->client->irq, 0);
+		chip->wake_irq = 0;
+	}
+	if (chip->unpowered && (prx_on || als_on)) {
+		dev_dbg(dev, "powering on\n");
+		rc = power_on(chip);
+		if (rc)
+			goto err_power;
+	}
+	if (prx_on && !chip->prx_enabled)
+		(void)taos_prox_enable(chip, 1);
+	if (als_on && !chip->als_enabled)
+		(void)taos_als_enable(chip, 1);
+	if (chip->irq_pending) {
+		dev_dbg(dev, "%s: pending interrupt\n", __func__);
+		chip->irq_pending = 0;
+		(void)taos_check_and_report(chip);
+		enable_irq(chip->client->irq);
+	}
+err_power:
+	mutex_unlock(&chip->lock);
+
+	return 0;
+}
+
+static int __devexit taos_remove(struct i2c_client *client)
+{
+	struct tmd2772_chip *chip = i2c_get_clientdata(client);
+	free_irq(client->irq, chip);
+	if (chip->a_idev) {
+		remove_sysfs_interfaces(&chip->a_idev->dev,
+			als_attrs, ARRAY_SIZE(als_attrs));
+		input_unregister_device(chip->a_idev);
+	}
+	if (chip->p_idev) {
+		remove_sysfs_interfaces(&chip->p_idev->dev,
+			prox_attrs, ARRAY_SIZE(prox_attrs));
+		input_unregister_device(chip->p_idev);
+	}
+	if (chip->pdata->platform_teardown)
+		chip->pdata->platform_teardown(&client->dev);
+	i2c_set_clientdata(client, NULL);
+	kfree(chip->segment);
+	kfree(chip);
+	return 0;
+}
+
+static struct i2c_device_id taos_idtable[] = {
+	{ "tmd2772", 0 },
+	{}
+};
+MODULE_DEVICE_TABLE(i2c, taos_idtable);
+
+static struct of_device_id taos_match_table[] = {
+	{ .compatible = "tmd2772,tmd2772", },
+	{ },
+};
+
+static const struct dev_pm_ops taos_pm_ops = {
+	.suspend = taos_suspend,
+	.resume  = taos_resume,
+};
+
+static struct i2c_driver taos_driver = {
+	.driver = {
+		.name = "tmd2772",
+		.pm = &taos_pm_ops,
+		.of_match_table = taos_match_table,
+	},
+	.id_table = taos_idtable,
+	.probe = taos_probe,
+	.remove = __devexit_p(taos_remove),
+};
+
+static int __init taos_init(void)
+{
+	return i2c_add_driver(&taos_driver);
+}
+
+static void __exit taos_exit(void)
+{
+	i2c_del_driver(&taos_driver);
+}
+
+module_init(taos_init);
+module_exit(taos_exit);
+
+MODULE_AUTHOR("Aleksej Makarov <aleksej.makarov@sonyericsson.com>");
+MODULE_DESCRIPTION("TAOS tmd2772 ambient light and proximity sensor driver");
+MODULE_LICENSE("GPL");
diff --git a/include/linux/i2c/tmd277x.h b/include/linux/i2c/tmd277x.h
new file mode 100644
index 0000000..b3bbd5a
--- /dev/null
+++ b/include/linux/i2c/tmd277x.h
@@ -0,0 +1,100 @@
+/*
+ * Copyright (C) 2010-2013 Samsung Electronics. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ */
+
+#ifndef __LINUX_TAOS_H
+#define __LINUX_TAOS_H
+
+#include <linux/types.h>
+
+#ifdef __KERNEL__
+#define TAOS_OPT "taos-opt"
+#define MIN 1
+struct device;
+
+enum tmd2772_pwr_state {
+	POWER_ON,
+	POWER_OFF,
+	POWER_STANDBY,
+};
+
+enum taos_ctrl_reg {
+	AGAIN_1        = (0 << 0),
+	AGAIN_8        = (1 << 0),
+	AGAIN_16       = (2 << 0),
+	AGAIN_120      = (3 << 0),
+	PGAIN_1        = (0 << 2),
+	PGAIN_2        = (1 << 2),
+	PGAIN_4        = (2 << 2),
+	PGAIN_8        = (3 << 2),
+	PDIOD_NO       = (0 << 4),
+	PDIOD_CH0      = (1 << 4),
+	PDIOD_CH1      = (2 << 4),
+	PDIOD_DONT_USE = (3 << 4),
+	PDRIVE_120MA   = (0 << 6),
+	PDRIVE_60MA    = (1 << 6),
+	PDRIVE_30MA    = (2 << 6),
+	PDRIVE_15MA    = (3 << 6),
+};
+
+#define PRX_PERSIST(p) (((p) & 0xf) << 4)
+#define ALS_PERSIST(p) (((p) & 0xf) << 0)
+
+struct taos_raw_settings {
+	u8 als_time;
+	u8 als_gain;
+	u8 prx_time;
+	u8 wait_time;
+	u8 persist;
+	u8 cfg_reg;
+	u8 prox_pulse_cnt;
+	u8 ctrl_reg;
+	u8 prox_offs;
+};
+
+struct taos_parameters {
+	u16 prox_th_min;
+	u16 prox_th_max;
+	u16 als_gate;
+	u16 als_gain;
+};
+
+struct lux_segment {
+	u32 ratio;
+	u32 k0;
+	u32 k1;
+};
+
+struct tmd2772_i2c_platform_data {
+	/* The following callback for power events received and handled by
+	   the driver.  Currently only for SUSPEND and RESUME */
+	int (*platform_power)(struct device *dev, enum tmd2772_pwr_state state);
+	int (*platform_init)(struct device *dev);
+	void (*platform_teardown)(struct device *dev);
+	char const *prox_name;
+	char const *als_name;
+	struct taos_parameters parameters;
+	struct taos_raw_settings const *raw_settings;
+	bool proximity_can_wake;
+	bool als_can_wake;
+	struct lux_segment *segment;
+	int segment_num;
+	int int_gpio;
+};
+
+#endif /*__KERNEL__*/
+#endif
-- 
1.7.8.3

