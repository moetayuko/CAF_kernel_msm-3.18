From ec4c62b55c4676f9353819ffe0e8cd84e4ae512f Mon Sep 17 00:00:00 2001
From: lnxbuild <lnxbuild@localhost>
Date: Sun, 18 Aug 2013 14:31:27 +0800
Subject: [PATCH 08/11] add driver for camera
 ov8850/s5k4h5/s5k4el/ov5648/mt9v113

Change-Id: Ife001b341bee8fe35a44fda87a87af6bfd35b7ea
---
 arch/arm/boot/dts/msm8610-qrd-camera-sensor.dtsi   |  198 +++++-
 arch/arm/boot/dts/msm8610-regulator.dtsi           |    2 +-
 arch/arm/boot/dts/msm8610-v1-qrd-skuac.dts         |    1 +
 arch/arm/configs/msm8610_defconfig                 |    5 +
 arch/arm/mach-msm/clock-8610.c                     |   13 +-
 drivers/media/platform/msm/camera_v2/Kconfig       |   43 +
 .../media/platform/msm/camera_v2/sensor/Makefile   |    5 +
 .../platform/msm/camera_v2/sensor/msm_sensor.c     |    2 +-
 .../msm/camera_v2/sensor/mt9v113_sunny_p0m01k.c    |  905 ++++++++++++++++++++
 .../msm/camera_v2/sensor/ov5648_sunny_p5v18g.c     |  465 ++++++++++
 .../msm/camera_v2/sensor/ov8850_foxconn_dc0901b.c  |  463 ++++++++++
 .../camera_v2/sensor/s5k4e1_liteon_13p1ba535d.c    |  470 ++++++++++
 .../camera_v2/sensor/s5k4h5_liteon_12p1ba855d.c    |  460 ++++++++++
 13 files changed, 3027 insertions(+), 5 deletions(-)
 create mode 100644 drivers/media/platform/msm/camera_v2/sensor/mt9v113_sunny_p0m01k.c
 create mode 100644 drivers/media/platform/msm/camera_v2/sensor/ov5648_sunny_p5v18g.c
 create mode 100644 drivers/media/platform/msm/camera_v2/sensor/ov8850_foxconn_dc0901b.c
 create mode 100644 drivers/media/platform/msm/camera_v2/sensor/s5k4e1_liteon_13p1ba535d.c
 create mode 100644 drivers/media/platform/msm/camera_v2/sensor/s5k4h5_liteon_12p1ba855d.c

diff --git a/arch/arm/boot/dts/msm8610-qrd-camera-sensor.dtsi b/arch/arm/boot/dts/msm8610-qrd-camera-sensor.dtsi
index e73573a..bb55430 100644
--- a/arch/arm/boot/dts/msm8610-qrd-camera-sensor.dtsi
+++ b/arch/arm/boot/dts/msm8610-qrd-camera-sensor.dtsi
@@ -10,7 +10,7 @@
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  */
-
+ 
 &i2c {
         qcom,camera@7d {
                 compatible = "qcom,hi256";
@@ -82,5 +82,201 @@
 		qcom,cci-master = <0>;
 		status = "ok";
 	};
+	
+	
+		actuator0: qcom,actuator@18 {
+			cell-index = <1>;
+			reg = <0x18>;
+			compatible = "qcom,actuator";
+			qcom,cci-master = <0>;
+		};	
+	
+		qcom,camera@6c {
+				compatible = "qcom,ov8850_foxconn";
+				reg = <0x6c>;
+				qcom,slave-id = <0x6c 0x300a 0x8850>;
+				qcom,csiphy-sd-index = <0>;
+				qcom,csid-sd-index = <0>;
+				qcom,actuator-src = <&actuator0>;
+				//qcom,led-flash-src = <&led_flash0>;
+				qcom,mount-angle = <270>;
+				qcom,sensor-name = "ov8850_foxconn";
+				cam_vdig-supply = <&pm8110_l2>;
+				cam_vio-supply = <&pm8110_l7>;
+				cam_vana-supply = <&pm8110_l22>;
+				qcom,cam-vreg-name = "cam_vdig", "cam_vio", "cam_vana";
+				qcom,cam-vreg-type = <0 0 0>;
+				qcom,cam-vreg-min-voltage = <1200000 1800000 2850000>;
+				qcom,cam-vreg-max-voltage = <1200000 1800000 2850000>;
+				qcom,cam-vreg-op-mode = <200000 200000 100000>;
+				qcom,gpio-no-mux = <0>;
+				gpios = <&msmgpio 13 0>,
+					<&msmgpio 21 0>,//reset
+					<&msmgpio 20 0>,//stanby
+					<&msmgpio 101 0>, //dvdd_en
+					<&msmgpio 79 0>; //vcm_pwdn
+				qcom,gpio-reset = <1>;
+				qcom,gpio-standby = <2>;
+				qcom,gpio-req-tbl-num = <0 1 2 3 4>;
+				qcom,gpio-req-tbl-flags = <1 0 0 0 0>;
+				qcom,gpio-req-tbl-label = "CAMIF_MCLK",
+					"CAM_RESET1",
+					"CAM_STANDBY",
+					"CAM_DVDDEN",
+					"CAM_VCMPWDN";
+				qcom,csi-lane-assign = <0xe4>;
+				qcom,csi-lane-mask = <0x7>;
+				qcom,sensor-position = <0>;
+				qcom,sensor-mode = <1>;
+				qcom,cci-master = <0>;
+			};
+	
+		qcom,camera@22 {
+				compatible = "qcom,s5k4h5_liteon";
+				reg = <0x22>;
+				qcom,slave-id = <0x20 0x0000 0x485B>;
+				qcom,csiphy-sd-index = <0>;
+				qcom,csid-sd-index = <0>;
+				qcom,actuator-src = <&actuator0>;
+				//qcom,led-flash-src = <&led_flash0>;
+				qcom,mount-angle = <270>;
+				qcom,sensor-name = "s5k4h5_liteon";
+				cam_vdig-supply = <&pm8110_l2>;
+				cam_vio-supply = <&pm8110_l7>;
+				cam_vana-supply = <&pm8110_l22>;
+				qcom,cam-vreg-name = "cam_vdig", "cam_vio", "cam_vana";
+				qcom,cam-vreg-type = <0 0 0>;
+				qcom,cam-vreg-min-voltage = <1200000 1800000 2850000>;
+				qcom,cam-vreg-max-voltage = <1200000 1800000 2850000>;
+				qcom,cam-vreg-op-mode = <200000 200000 100000>;
+				qcom,gpio-no-mux = <0>;
+				gpios = <&msmgpio 13 0>,
+					<&msmgpio 21 0>,//reset
+					<&msmgpio 101 0>, //dvdd_en
+					<&msmgpio 79 0>; //vcm_pwdn
+				qcom,gpio-reset = <1>;
+				qcom,gpio-req-tbl-num = <0 1 2 3>;
+				qcom,gpio-req-tbl-flags = <1 0 0 0>;
+				qcom,gpio-req-tbl-label = "CAMIF_MCLK",
+					"CAM_RESET1",
+					"CAM_DVDDEN",
+					"CAM_VCMPWDN";
+				qcom,csi-lane-assign = <0xe4>;
+				qcom,csi-lane-mask = <0x7>;
+				qcom,sensor-position = <0>;
+				qcom,sensor-mode = <1>;
+				qcom,cci-master = <0>;
+			};
+			
+  qcom,camera@68 {
+			compatible = "qcom,ov5648_sunny_p5v18g";
+			reg = <0x68>;
+			qcom,slave-id = <0x6c 0x300a 0x5648>;
+			qcom,csiphy-sd-index = <0>;
+			qcom,csid-sd-index = <0>;
+			qcom,actuator-src = <&actuator0>;
+			//qcom,led-flash-src = <&led_flash0>;
+			qcom,mount-angle = <90>;
+			qcom,sensor-name = "ov5648_sunny_p5v18g";
+			cam_vdig-supply = <&pm8110_l2>;
+			cam_vio-supply = <&pm8110_l7>;
+			cam_vana-supply = <&pm8110_l22>;
+			qcom,cam-vreg-name = "cam_vdig", "cam_vio", "cam_vana";
+			qcom,cam-vreg-type = <0 0 0>;
+			qcom,cam-vreg-min-voltage = <1200000 1800000 2850000>;
+			qcom,cam-vreg-max-voltage = <1200000 1800000 2850000>;
+			qcom,cam-vreg-op-mode = <200000 200000 100000>;
+			qcom,gpio-no-mux = <0>;
+			gpios = <&msmgpio 13 0>,
+				<&msmgpio 21 0>,//reset
+				<&msmgpio 20 0>,//stanby
+				<&msmgpio 79 0>; //vcm_pwdn
+			qcom,gpio-reset = <1>;
+			qcom,gpio-standby = <2>;
+			qcom,gpio-req-tbl-num = <0 1 2 3>;
+			qcom,gpio-req-tbl-flags = <1 0 0 0>;
+			qcom,gpio-req-tbl-label = "CAMIF_MCLK",
+				"CAM_RESET1",
+				"CAM_STANDBY",
+				"CAM_VCMPWDN";
+			qcom,csi-lane-assign = <0xe4>;
+			qcom,csi-lane-mask = <0x7>;
+			qcom,sensor-position = <0>;
+			qcom,sensor-mode = <0>;
+			qcom,cci-master = <0>;
+		};		
+	
+	qcom,camera@6a {
+				compatible = "qcom,s5k4e1_liteon";
+				reg = <0x6a>;
+				qcom,slave-id = <0x6c 0x0000 0x4E10>;
+				qcom,csiphy-sd-index = <0>;
+				qcom,csid-sd-index = <0>;
+				qcom,actuator-src = <&actuator0>;
+				//qcom,led-flash-src = <&led_flash0>;
+				qcom,mount-angle = <90>;
+				qcom,sensor-name = "s5k4e1_liteon";
+				cam_vdig-supply = <&pm8110_l2>;
+				cam_vio-supply = <&pm8110_l7>;
+				cam_vana-supply = <&pm8110_l22>;
+				qcom,cam-vreg-name = "cam_vdig", "cam_vio", "cam_vana";
+				qcom,cam-vreg-type = <0 0 0>;
+				qcom,cam-vreg-min-voltage = <1200000 1800000 2850000>;
+				qcom,cam-vreg-max-voltage = <1200000 1800000 2850000>;
+				qcom,cam-vreg-op-mode = <200000 200000 100000>;
+				qcom,gpio-no-mux = <0>;
+				gpios = <&msmgpio 13 0>,
+					<&msmgpio 21 0>,//reset
+					<&msmgpio 20 0>,//stanby
+					<&msmgpio 79 0>; //vcm_pwdn
+				qcom,gpio-reset = <1>;
+				qcom,gpio-standby = <2>;
+				qcom,gpio-req-tbl-num = <0 1 2 3>;
+				qcom,gpio-req-tbl-flags = <1 0 0 0>;
+				qcom,gpio-req-tbl-label = "CAMIF_MCLK",
+					"CAM_RESET1",
+					"CAM_STANDBY",
+					"CAM_VCMPWDN";
+				qcom,csi-lane-assign = <0xe4>;
+				qcom,csi-lane-mask = <0x7>;
+				qcom,sensor-position = <0>;
+				qcom,sensor-mode = <0>;
+				qcom,cci-master = <0>;
+			};
+	
+
+  qcom,camera@7a {
+		  compatible = "qcom,mt9v113";
+		  reg = <0x7a>;
+		  qcom,slave-id = <0x7a 0x0000 0x2280>;
+		  qcom,csiphy-sd-index = <1>;
+		  qcom,csid-sd-index = <1>;
+		  qcom,mount-angle = <90>;
+		  qcom,sensor-name = "mt9v113";
+		  cam_vdig-supply = <&pm8110_l2>;
+		  cam_vio-supply = <&pm8110_l7>;
+		  cam_vana-supply = <&pm8110_l22>;
+		  qcom,cam-vreg-name = "cam_vdig", "cam_vio", "cam_vana";
+		  qcom,cam-vreg-type = <0 0 0>;
+		  qcom,cam-vreg-min-voltage = <1200000 1800000 2850000>;
+		  qcom,cam-vreg-max-voltage = <1200000 1800000 2850000>;
+		  qcom,cam-vreg-op-mode = <200000 200000 100000>;
+		  qcom,gpio-no-mux = <0>;
+		  gpios = <&msmgpio 13 0>,
+		  	<&msmgpio 15 0>,
+		  	<&msmgpio 85 0>;
+		  qcom,gpio-reset = <1>;
+		  qcom,gpio-standby = <2>;
+		  qcom,gpio-req-tbl-num = <0 1 2>;
+		  qcom,gpio-req-tbl-flags = <1 0 0>;
+		  qcom,gpio-req-tbl-label = "CAMIF_MCLK",
+		  			  "CAM_RESET",
+		  			  "CAM_STANDBY";
+		  qcom,csi-lane-assign = <0xe4>;
+		  qcom,csi-lane-mask = <0x3>;
+		  qcom,sensor-position = <1>;
+		  qcom,sensor-mode = <1>;
+		  qcom,cci-master = <0>;
+	};		
 };
 
diff --git a/arch/arm/boot/dts/msm8610-regulator.dtsi b/arch/arm/boot/dts/msm8610-regulator.dtsi
index 34cbd99..362397c 100644
--- a/arch/arm/boot/dts/msm8610-regulator.dtsi
+++ b/arch/arm/boot/dts/msm8610-regulator.dtsi
@@ -227,7 +227,7 @@
 	rpm-regulator-ldoa7 {
 		status = "okay";
 		pm8110_l7: regulator-l7 {
-			regulator-min-microvolt = <2050000>;
+			regulator-min-microvolt = <1800000>;
 			regulator-max-microvolt = <2050000>;
 			qcom,init-voltage = <2050000>;
 			status = "okay";
diff --git a/arch/arm/boot/dts/msm8610-v1-qrd-skuac.dts b/arch/arm/boot/dts/msm8610-v1-qrd-skuac.dts
index 8c75ebf..29b475b 100644
--- a/arch/arm/boot/dts/msm8610-v1-qrd-skuac.dts
+++ b/arch/arm/boot/dts/msm8610-v1-qrd-skuac.dts
@@ -20,6 +20,7 @@
 /include/ "dsi-v2-panel-byd-nt35517-qhd-video.dtsi"
 /include/ "dsi-v2-panel-hx8389b-qhd-video.dtsi"
 /include/ "dsi-v2-panel-emulator.dtsi"
+/include/ "msm8610-qrd-camera-sensor.dtsi"
 
 / {
 	model = "Qualcomm MSM 8610 QRD";
diff --git a/arch/arm/configs/msm8610_defconfig b/arch/arm/configs/msm8610_defconfig
index 9a22f52..32201b4 100644
--- a/arch/arm/configs/msm8610_defconfig
+++ b/arch/arm/configs/msm8610_defconfig
@@ -306,6 +306,11 @@ CONFIG_OV8825=y
 CONFIG_s5k4e1=y
 CONFIG_HI256=y
 CONFIG_OV12830=y
+CONFIG_OV8850_FOXCONN_DC0901B=y
+CONFIG_OV5648_SUNNY_P5V18G=y
+CONFIG_S5K4H5_LITEON_12P1BA855D=y
+CONFIG_S5K4E1_LITEON_13P1BA535D=y
+CONFIG_MT9V113_SUNNY_P0M01K=y
 CONFIG_MSM_CAMERA_SENSOR=y
 CONFIG_MSM_CCI=y
 CONFIG_MSM_CSIPHY=y
diff --git a/arch/arm/mach-msm/clock-8610.c b/arch/arm/mach-msm/clock-8610.c
index b1b9397..2c15ff6 100644
--- a/arch/arm/mach-msm/clock-8610.c
+++ b/arch/arm/mach-msm/clock-8610.c
@@ -3014,13 +3014,22 @@ static struct clk_lookup msm_clocks_8610[] = {
 	CLK_LOOKUP("cam_src_clk", mclk0_clk_src.c, "6-006d"),
 	CLK_LOOKUP("cam_src_clk", mclk1_clk_src.c, "6-0078"),
 	CLK_LOOKUP("cam_src_clk", mclk0_clk_src.c, "6-0020"),
+	CLK_LOOKUP("cam_src_clk", mclk0_clk_src.c, "6-006c"),
+	CLK_LOOKUP("cam_src_clk", mclk0_clk_src.c, "6-0022"),	
+	CLK_LOOKUP("cam_src_clk", mclk0_clk_src.c, "6-0068"),	
+	CLK_LOOKUP("cam_src_clk", mclk0_clk_src.c, "6-006a"),		
+	CLK_LOOKUP("cam_src_clk", mclk0_clk_src.c, "6-007a"),
 	CLK_LOOKUP("cam_clk", mclk0_clk.c, "6-006f"),
 	CLK_LOOKUP("cam_clk", mclk0_clk.c, "6-007d"),
 	CLK_LOOKUP("cam_clk", mclk0_clk.c, "6-006d"),
 	CLK_LOOKUP("cam_clk", mclk1_clk.c, "6-0078"),
 	CLK_LOOKUP("cam_clk", mclk0_clk.c, "6-0020"),
-
-
+	CLK_LOOKUP("cam_clk", mclk0_clk.c, "6-006c"),
+  CLK_LOOKUP("cam_clk", mclk0_clk.c, "6-0022"),	
+	CLK_LOOKUP("cam_clk", mclk0_clk.c, "6-0068"),  	
+	CLK_LOOKUP("cam_clk", mclk0_clk.c, "6-006a"),  	
+	CLK_LOOKUP("cam_clk", mclk0_clk.c, "6-007a"),
+ 
 	/* CSIPHY clocks */
 	CLK_LOOKUP("csiphy_timer_src_clk", csi0phytimer_clk_src.c,
 		"fda00c00.qcom,csiphy"),
diff --git a/drivers/media/platform/msm/camera_v2/Kconfig b/drivers/media/platform/msm/camera_v2/Kconfig
index 4668d02..f075d77 100644
--- a/drivers/media/platform/msm/camera_v2/Kconfig
+++ b/drivers/media/platform/msm/camera_v2/Kconfig
@@ -182,6 +182,33 @@ config GC0339
 		Preview and snapshot resolution shall be 640*480 at 30 fps,
 		It does not support auto focus.
 
+
+config MT9V113_SUNNY_P0M01K
+	bool "Sensor MT9V113 (BAYER .3M)"
+	depends on MSMB_CAMERA
+	---help---
+		MT9V113 is a Aptina .3 MP Bayer Sensor.
+		It supports 1 or 2 mipi lanes.
+		It does not support auto focus.		
+		
+config OV5648_SUNNY_P5V18G
+	bool "OmniVision OV5648 (BAYER 5MP)"
+	depends on MSMB_CAMERA
+	---help---
+		OmniVision 5 MP Bayer Sensor For Rear Camera
+		2 mipi lane, preview config = 1296*972 30 fps,
+		snapshot config = 2592 * 1944 at 15 fps with 
+		auto focus.		
+
+config S5K4E1_LITEON_13P1BA535D
+	bool "Samsung S5K4E1 (BAYER 5MP)"
+	depends on MSMB_CAMERA
+	---help---
+		Samsung 5 MP Bayer Sensor For Rear Camera
+		2 mipi lane, preview config = 1296*972 30 fps,
+		snapshot config = 2592 * 1944 at 15 fps with 
+		auto focus.	
+
 config OV8825
 	bool "OmniVision OV8825 (BAYER 8MP)"
 	depends on MSMB_CAMERA
@@ -191,6 +218,22 @@ config OV8825
 		snapshot config = 3264 * 2448 at 18 fps.
 		2 lanes max fps is 18, 4 lanes max fps is 24.
 
+config OV8850_FOXCONN_DC0901B
+	bool "OmniVision OV8850 (BAYER 8MP)"
+	depends on MSMB_CAMERA
+	---help---
+		OmniVision 8 MP Bayer Sensor with auto focus.uses
+		2 mipi lanes, preview config = 1632*1224 30 fps,
+		snapshot config = 3264 * 2448 at 20 fps.
+		
+config S5K4H5_LITEON_12P1BA855D
+	bool "Samsang S5K4H5 (BAYER 8MP)"
+	depends on MSMB_CAMERA
+	---help---
+		OmniVision 8 MP Bayer Sensor with auto focus.uses
+		2 mipi lanes, preview config = 1632*1224 30 fps,
+		snapshot config = 3264 * 2448 at 15 fps.		
+		
 config s5k4e1
 	bool "Sensor s5k4e1 (BAYER 5MP)"
 	depends on MSMB_CAMERA
diff --git a/drivers/media/platform/msm/camera_v2/sensor/Makefile b/drivers/media/platform/msm/camera_v2/sensor/Makefile
index bd1b10b..8555d9c4 100644
--- a/drivers/media/platform/msm/camera_v2/sensor/Makefile
+++ b/drivers/media/platform/msm/camera_v2/sensor/Makefile
@@ -10,6 +10,10 @@ obj-$(CONFIG_IMX135) += imx135.o
 obj-$(CONFIG_OV8825) += ov8825.o
 obj-$(CONFIG_s5k4e1) += s5k4e1.o
 obj-$(CONFIG_OV12830) += ov12830.o
+obj-$(CONFIG_OV8850_FOXCONN_DC0901B) += ov8850_foxconn_dc0901b.o
+obj-$(CONFIG_OV5648_SUNNY_P5V18G) += ov5648_sunny_p5v18g.o
+obj-$(CONFIG_S5K4H5_LITEON_12P1BA855D) += s5k4h5_liteon_12p1ba855d.o
+obj-$(CONFIG_S5K4E1_LITEON_13P1BA535D) += s5k4e1_liteon_13p1ba535d.o
 obj-$(CONFIG_OV2720) += ov2720.o
 obj-$(CONFIG_OV9724) += ov9724.o
 obj-$(CONFIG_HI256) += hi256.o
@@ -17,3 +21,4 @@ obj-$(CONFIG_OV5648) += ov5648.o
 obj-$(CONFIG_MT9M114) += mt9m114.o
 obj-$(CONFIG_SP1628) += sp1628.o
 obj-$(CONFIG_GC0339) += gc0339.o
+obj-$(CONFIG_MT9V113_SUNNY_P0M01K) += mt9v113_sunny_p0m01k.o
\ No newline at end of file
diff --git a/drivers/media/platform/msm/camera_v2/sensor/msm_sensor.c b/drivers/media/platform/msm/camera_v2/sensor/msm_sensor.c
index cd585c3..b53b098 100644
--- a/drivers/media/platform/msm/camera_v2/sensor/msm_sensor.c
+++ b/drivers/media/platform/msm/camera_v2/sensor/msm_sensor.c
@@ -1229,7 +1229,7 @@ int32_t msm_sensor_match_id(struct msm_sensor_ctrl_t *s_ctrl)
 		return rc;
 	}
 
-	CDBG("%s: read id: %x expected id %x:\n", __func__, chipid,
+	pr_err("%s: read id: %x expected id %x:\n", __func__, chipid,
 		s_ctrl->sensordata->slave_info->sensor_id);
 	if (chipid != s_ctrl->sensordata->slave_info->sensor_id) {
 		pr_err("msm_sensor_match_id chip id doesnot match\n");
diff --git a/drivers/media/platform/msm/camera_v2/sensor/mt9v113_sunny_p0m01k.c b/drivers/media/platform/msm/camera_v2/sensor/mt9v113_sunny_p0m01k.c
new file mode 100644
index 0000000..d6ba23d
--- /dev/null
+++ b/drivers/media/platform/msm/camera_v2/sensor/mt9v113_sunny_p0m01k.c
@@ -0,0 +1,905 @@
+/* Copyright (c) 2013, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+#include <mach/gpiomux.h>
+
+#include "msm_sensor.h"
+#include "msm_cci.h"
+#include "msm_camera_io_util.h"
+#include "msm_camera_i2c_mux.h"
+
+
+#define CONFIG_MSMB_CAMERA_DEBUG
+
+#undef CDBG
+#ifdef CONFIG_MSMB_CAMERA_DEBUG
+#define CDBG(fmt, args...) pr_err(fmt, ##args)
+#else
+#define CDBG(fmt, args...) do { } while (0)
+#endif
+
+#define MT9V113_SENSOR_NAME "mt9v113"
+DEFINE_MSM_MUTEX(mt9v113_mut);
+
+static struct msm_sensor_ctrl_t mt9v113_s_ctrl;
+
+static struct msm_sensor_power_setting mt9v113_power_setting[] = {
+/*
+	{  
+		.seq_type = SENSOR_VREG,
+		.seq_val = CAM_VDIG,
+		.config_val = 0,
+		.delay = 0,
+	},
+*/
+	{
+		.seq_type = SENSOR_VREG,
+		.seq_val = CAM_VIO,
+		.config_val = 0,
+		.delay = 0,
+	},
+	{
+		.seq_type = SENSOR_VREG,
+		.seq_val = CAM_VANA,
+		.config_val = 0,
+		.delay = 5,
+	},
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_STANDBY,
+		.config_val = GPIO_OUT_HIGH,
+		.delay = 10,
+	},
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_RESET,
+		.config_val = GPIO_OUT_LOW,
+		.delay = 50,
+	},
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_STANDBY,
+		.config_val = GPIO_OUT_LOW,
+		.delay = 20,
+	},
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_RESET,
+		.config_val = GPIO_OUT_HIGH,
+		.delay = 50,
+	},
+	{
+		.seq_type = SENSOR_CLK,
+		.seq_val = SENSOR_CAM_MCLK,
+		.config_val = 24000000,
+		.delay = 5,
+	},
+
+	{
+		.seq_type = SENSOR_I2C_MUX,
+		.seq_val = 0,
+		.config_val = 0,
+		.delay = 5,
+	},
+};
+
+static struct msm_camera_i2c_reg_conf mt9v113_start_settings[] = {
+	{0x3400, 0x7a2C},
+};
+
+static struct msm_camera_i2c_reg_conf mt9v113_stop_settings[] = {
+	{0x3400, 0x7a26},
+};
+
+static struct msm_camera_i2c_reg_conf mt9v113_recommend_setting1[] = {
+    {0x098C, 0x02F0}, // MCU_ADDRESS
+    {0x0990, 0x0000}, // MCU_DATA_0
+    {0x098C, 0x02F2}, // MCU_ADDRESS
+    {0x0990, 0x0210}, // MCU_DATA_0
+    {0x098C, 0x02F4}, // MCU_ADDRESS
+    {0x0990, 0x001A}, // MCU_DATA_0
+    {0x098C, 0x2145}, // MCU_ADDRESS
+    {0x0990, 0x02F4}, // MCU_DATA_0
+    {0x098C, 0xA134}, // MCU_ADDRESS
+    {0x0990, 0x0001}, // MCU_DATA_0
+    {0x31E0, 0x0001}, // PIX_DEF_ID
+    {0x001A, 0x0010}, // RESET_AND_MISC_CONTROL
+    {0x3400, 0x7A2C}, // MIPI_CONTROL
+    {0x321C, 0x8003}, // OFIFO_CONTROL_STATUS
+    {0x001E, 0x0777}, // PAD_SLEW
+    {0x0016, 0x42DF}, // CLOCKS_CONTROL
+    // 24MHz / 26MHz
+    {0x0014, 0xB04B}, // PLL_CONTROL
+    {0x0014, 0xB049}, // PLL_CONTROL
+    {0x0010, 0x021C}, //PLL Dividers=540
+    {0x0012, 0x0000}, //PLL P Dividers=0
+};
+static struct msm_camera_i2c_reg_conf mt9v113_recommend_setting2[] = {
+    {0x098C, 0x2703}, //Output Width (A)
+    {0x0990, 0x0280}, //=640
+    {0x098C, 0x2705}, //Output Height (A)
+    {0x0990, 0x01E0}, //=480
+    {0x098C, 0x2707}, //Output Width (B)
+    {0x0990, 0x0280}, //=640
+    {0x098C, 0x2709}, //Output Height (B)
+    {0x0990, 0x01E0}, //=480
+    {0x098C, 0x270D}, //Row Start (A)
+    {0x0990, 0x0000}, //=0
+    {0x098C, 0x270F}, //Column Start (A)
+    {0x0990, 0x0000}, //=0
+    {0x098C, 0x2711}, //Row End (A)
+    {0x0990, 0x01E7}, //=487
+    {0x098C, 0x2713}, //Column End (A)
+    {0x0990, 0x0287}, //=647
+    {0x098C, 0x2715}, //Row Speed (A)
+    {0x0990, 0x0001}, //=1
+    {0x098C, 0x2717}, //Read Mode (A)
+    {0x0990, 0x0026}, //=38
+    {0x098C, 0x2719}, //sensor_fine_correction (A)
+    {0x0990, 0x001A}, //=26
+    {0x098C, 0x271B}, //sensor_fine_IT_min (A)
+    {0x0990, 0x006B}, //=107
+    {0x098C, 0x271D}, //sensor_fine_IT_max_margin (A)
+    {0x0990, 0x006B}, //=107
+    {0x098C, 0x271F}, //Frame Lines (A)
+    {0x0990, 0x022A}, //=554
+    {0x098C, 0x2721}, //Line Length (A)
+    {0x0990, 0x034A}, //=842
+    {0x098C, 0x2723}, //Row Start (B)
+    {0x0990, 0x0000}, //=0
+    {0x098C, 0x2725}, //Column Start (B)
+    {0x0990, 0x0000}, //=0
+    {0x098C, 0x2727}, //Row End (B)
+    {0x0990, 0x01E7}, //=487
+    {0x098C, 0x2729}, //Column End (B)
+    {0x0990, 0x287 }, //=647
+    {0x098C, 0x272B}, //Row Speed (B)
+    {0x0990, 0x0001}, //=1
+    {0x098C, 0x272D}, //Read Mode (B)
+    {0x0990, 0x0026}, //=38
+    {0x098C, 0x272F}, //sensor_fine_correction (B)
+    {0x0990, 0x001A}, //=26
+    {0x098C, 0x2731}, //sensor_fine_IT_min (B)
+    {0x0990, 0x006B}, //=107
+    {0x098C, 0x2733}, //sensor_fine_IT_max_margin (B)
+    {0x0990, 0x006B}, //=107
+    {0x098C, 0x2735}, //Frame Lines (B)
+    {0x0990, 0x046F}, //=1135
+    {0x098C, 0x2737}, //Line Length (B)
+    {0x0990, 0x034A}, //=842
+    {0x098C, 0x2739}, //Crop_X0 (A)
+    {0x0990, 0x0000}, //=0
+    {0x098C, 0x273B}, //Crop_X1 (A)
+    {0x0990, 0x027F}, //=639
+    {0x098C, 0x273D}, //Crop_Y0 (A)
+    {0x0990, 0x0000}, //=0
+    {0x098C, 0x273F}, //Crop_Y1 (A)
+    {0x0990, 0x01DF}, //=479
+    {0x098C, 0x2747}, //Crop_X0 (B)
+    {0x0990, 0x0000}, //=0
+    {0x098C, 0x2749}, //Crop_X1 (B)
+    {0x0990, 0x027F}, //=639
+    {0x098C, 0x274B}, //Crop_Y0 (B)
+    {0x0990, 0x0000}, //=0
+    {0x098C, 0x274D}, //Crop_Y1 (B)
+    {0x0990, 0x01DF}, //=479
+    {0x098C, 0x222D}, //R9 Step
+    {0x0990, 0x008B}, //=139
+    {0x098C, 0xA408}, //search_f1_50
+    {0x0990, 0x0021}, //=33
+    {0x098C, 0xA409}, //search_f2_50
+    {0x0990, 0x0023}, //=35
+    {0x098C, 0xA40A}, //search_f1_60
+    {0x0990, 0x0028}, //=40
+    {0x098C, 0xA40B}, //search_f2_60
+    {0x0990, 0x002A}, //=42
+    {0x098C, 0x2411}, //R9_Step_60 (A)
+    {0x0990, 0x008B}, //=139
+    {0x098C, 0x2413}, //R9_Step_50 (A)
+    {0x0990, 0x00A6}, //=166
+    {0x098C, 0x2415}, //R9_Step_60 (B)
+    {0x0990, 0x008B}, //=139
+    {0x098C, 0x2417}, //R9_Step_50 (B)
+    {0x0990, 0x00A6}, //=166
+    {0x098C, 0xA404}, //FD Mode
+    {0x0990, 0x0010}, //=16
+    {0x098C, 0xA40D}, //Stat_min
+    {0x0990, 0x0002}, //=2
+    {0x098C, 0xA40E}, //Stat_max
+    {0x0990, 0x0003}, //=3
+    {0x098C, 0xA410}, //Min_amplitude
+    {0x0990, 0x000A}, //=10
+    //85% LSC
+    {0x3210, 0x09B0}, // COLOR_PIPELINE_CONTROL
+    {0x364E, 0x0210}, // P_GR_P0Q0
+    {0x3650, 0x0CCA}, // P_GR_P0Q1
+    {0x3652, 0x2D12}, // P_GR_P0Q2
+    {0x3654, 0xCD0C}, // P_GR_P0Q3
+    {0x3656, 0xC632}, // P_GR_P0Q4
+    {0x3658, 0x00D0}, // P_RD_P0Q0
+    {0x365A, 0x60AA}, // P_RD_P0Q1
+    {0x365C, 0x7272}, // P_RD_P0Q2
+    {0x365E, 0xFE09}, // P_RD_P0Q3
+    {0x3660, 0xAD72}, // P_RD_P0Q4
+    {0x3662, 0x0170}, // P_BL_P0Q0
+    {0x3664, 0x5DCB}, // P_BL_P0Q1
+    {0x3666, 0x27D2}, // P_BL_P0Q2
+    {0x3668, 0xCE4D}, // P_BL_P0Q3
+    {0x366A, 0x9DB3}, // P_BL_P0Q4
+    {0x366C, 0x0150}, // P_GB_P0Q0
+    {0x366E, 0xB809}, // P_GB_P0Q1
+    {0x3670, 0x30B2}, // P_GB_P0Q2
+    {0x3672, 0x82AD}, // P_GB_P0Q3
+    {0x3674, 0xC1D2}, // P_GB_P0Q4
+    {0x3676, 0xC4CD}, // P_GR_P1Q0
+    {0x3678, 0xBE47}, // P_GR_P1Q1
+    {0x367A, 0x5E4F}, // P_GR_P1Q2
+    {0x367C, 0x9F10}, // P_GR_P1Q3
+    {0x367E, 0xEC30}, // P_GR_P1Q4
+    {0x3680, 0x914D}, // P_RD_P1Q0
+    {0x3682, 0x846A}, // P_RD_P1Q1
+    {0x3684, 0x66AB}, // P_RD_P1Q2
+    {0x3686, 0x20D0}, // P_RD_P1Q3
+    {0x3688, 0x1714}, // P_RD_P1Q4
+    {0x368A, 0x99AC}, // P_BL_P1Q0
+    {0x368C, 0x5CED}, // P_BL_P1Q1
+    {0x368E, 0x00B1}, // P_BL_P1Q2
+    {0x3690, 0x716C}, // P_BL_P1Q3
+    {0x3692, 0x9594}, // P_BL_P1Q4
+    {0x3694, 0xA22D}, // P_GB_P1Q0
+    {0x3696, 0xB88A}, // P_GB_P1Q1
+    {0x3698, 0x02B0}, // P_GB_P1Q2
+    {0x369A, 0xC38F}, // P_GB_P1Q3
+    {0x369C, 0x2B30}, // P_GB_P1Q4
+    {0x369E, 0x6B32}, // P_GR_P2Q0
+    {0x36A0, 0x128C}, // P_GR_P2Q1
+    {0x36A2, 0x2574}, // P_GR_P2Q2
+    {0x36A4, 0xD1B3}, // P_GR_P2Q3
+    {0x36A6, 0xC2B8}, // P_GR_P2Q4
+    {0x36A8, 0x1893}, // P_RD_P2Q0
+    {0x36AA, 0x8DB0}, // P_RD_P2Q1
+    {0x36AC, 0x2134}, // P_RD_P2Q2
+    {0x36AE, 0x9014}, // P_RD_P2Q3
+    {0x36B0, 0xFC57}, // P_RD_P2Q4
+    {0x36B2, 0x2DB2}, // P_BL_P2Q0
+    {0x36B4, 0x8FB1}, // P_BL_P2Q1
+    {0x36B6, 0x9832}, // P_BL_P2Q2
+    {0x36B8, 0x1CD4}, // P_BL_P2Q3
+    {0x36BA, 0xE437}, // P_BL_P2Q4
+    {0x36BC, 0x5992}, // P_GB_P2Q0
+    {0x36BE, 0x99AF}, // P_GB_P2Q1
+    {0x36C0, 0x0F54}, // P_GB_P2Q2
+    {0x36C2, 0x9A52}, // P_GB_P2Q3
+    {0x36C4, 0xB358}, // P_GB_P2Q4
+    {0x36C6, 0xC3EE}, // P_GR_P3Q0
+    {0x36C8, 0xC3F1}, // P_GR_P3Q1
+    {0x36CA, 0x94D2}, // P_GR_P3Q2
+    {0x36CC, 0x4175}, // P_GR_P3Q3
+    {0x36CE, 0x4EB7}, // P_GR_P3Q4
+    {0x36D0, 0xF310}, // P_RD_P3Q0
+    {0x36D2, 0x0C51}, // P_RD_P3Q1
+    {0x36D4, 0x6C75}, // P_RD_P3Q2
+    {0x36D6, 0xDA96}, // P_RD_P3Q3
+    {0x36D8, 0x8FF9}, // P_RD_P3Q4
+    {0x36DA, 0x9C10}, // P_BL_P3Q0
+    {0x36DC, 0x99B2}, // P_BL_P3Q1
+    {0x36DE, 0xFCD4}, // P_BL_P3Q2
+    {0x36E0, 0x6CD5}, // P_BL_P3Q3
+    {0x36E2, 0x7E98}, // P_BL_P3Q4
+    {0x36E4, 0xE64E}, // P_GB_P3Q0
+    {0x36E6, 0x8E72}, // P_GB_P3Q1
+    {0x36E8, 0x38D2}, // P_GB_P3Q2
+    {0x36EA, 0x4935}, // P_GB_P3Q3
+    {0x36EC, 0xBCB6}, // P_GB_P3Q4
+    {0x36EE, 0xB5F3}, // P_GR_P4Q0
+    {0x36F0, 0xBAD4}, // P_GR_P4Q1
+    {0x36F2, 0x8E39}, // P_GR_P4Q2
+    {0x36F4, 0x1FF8}, // P_GR_P4Q3
+    {0x36F6, 0x1D3C}, // P_GR_P4Q4
+    {0x36F8, 0x8CB3}, // P_RD_P4Q0
+    {0x36FA, 0x8834}, // P_RD_P4Q1
+    {0x36FC, 0xBF58}, // P_RD_P4Q2
+    {0x36FE, 0x4239}, // P_RD_P4Q3
+    {0x3700, 0x19F9}, // P_RD_P4Q4
+    {0x3702, 0x770D}, // P_BL_P4Q0
+    {0x3704, 0x7234}, // P_BL_P4Q1
+    {0x3706, 0xCB98}, // P_BL_P4Q2
+    {0x3708, 0x84B9}, // P_BL_P4Q3
+    {0x370A, 0x33FC}, // P_BL_P4Q4
+    {0x370C, 0xA1D2}, // P_GB_P4Q0
+    {0x370E, 0xAE33}, // P_GB_P4Q1
+    {0x3710, 0x8E79}, // P_GB_P4Q2
+    {0x3712, 0x4AB8}, // P_GB_P4Q3
+    {0x3714, 0x2D1C}, // P_GB_P4Q4
+    {0x3644, 0x013C}, // POLY_ORIGIN_C
+    {0x3642, 0x00E8}, // POLY_ORIGIN_R
+    {0x3210, 0x09B8}, // COLOR_PIPELINE_CONTROL
+    // Char Setting and fine-tuning
+    {0x098C, 0xAB1F}, // MCU_ADDRESS [HG_LLMODE]
+    {0x0990, 0x00C7}, // MCU_DATA_0
+    {0x098C, 0xAB31}, // MCU_ADDRESS [HG_NR_STOP_G]
+    {0x0990, 0x001E}, // MCU_DATA_0
+    {0x098C, 0x274F}, // MCU_ADDRESS [RESERVED_MODE_4F]
+    {0x0990, 0x0004}, // MCU_DATA_0
+    {0x098C, 0x2741}, // MCU_ADDRESS [RESERVED_MODE_41]
+    {0x0990, 0x0004}, // MCU_DATA_0
+    {0x098C, 0xAB20}, // MCU_ADDRESS [HG_LL_SAT1]
+    {0x0990, 0x0054}, // MCU_DATA_0
+    {0x098C, 0xAB21}, // MCU_ADDRESS [HG_LL_INTERPTHRESH1]
+    {0x0990, 0x0046}, // MCU_DATA_0
+    {0x098C, 0xAB22}, // MCU_ADDRESS [HG_LL_APCORR1]
+    {0x0990, 0x0002}, // MCU_DATA_0
+    {0x098C, 0xAB24}, // MCU_ADDRESS [HG_LL_SAT2]
+    {0x0990, 0x0005}, // MCU_DATA_0
+    {0x098C, 0x2B28}, // MCU_ADDRESS [HG_LL_BRIGHTNESSSTART]
+    {0x0990, 0x170C}, // MCU_DATA_0
+    {0x098C, 0x2B2A}, // MCU_ADDRESS [HG_LL_BRIGHTNESSSTOP]
+    {0x0990, 0x3E80}, // MCU_DATA_0
+    {0x3210, 0x09B8}, // COLOR_PIPELINE_CONTROL
+    {0x098C, 0x2306}, // MCU_ADDRESS [AWB_CCM_L_0]
+    {0x0990, 0x0315}, // MCU_DATA_0
+    {0x098C, 0x2308}, // MCU_ADDRESS [AWB_CCM_L_1]
+    {0x0990, 0xFDDC}, // MCU_DATA_0
+    {0x098C, 0x230A}, // MCU_ADDRESS [AWB_CCM_L_2]
+    {0x0990, 0x003A}, // MCU_DATA_0
+    {0x098C, 0x230C}, // MCU_ADDRESS [AWB_CCM_L_3]
+    {0x0990, 0xFF58}, // MCU_DATA_0
+    {0x098C, 0x230E}, // MCU_ADDRESS [AWB_CCM_L_4]
+    {0x0990, 0x02B7}, // MCU_DATA_0
+    {0x098C, 0x2310}, // MCU_ADDRESS [AWB_CCM_L_5]
+    {0x0990, 0xFF31}, // MCU_DATA_0
+    {0x098C, 0x2312}, // MCU_ADDRESS [AWB_CCM_L_6]
+    {0x0990, 0xFF4C}, // MCU_DATA_0
+    {0x098C, 0x2314}, // MCU_ADDRESS [AWB_CCM_L_7]
+    {0x0990, 0xFE4C}, // MCU_DATA_0
+    {0x098C, 0x2316}, // MCU_ADDRESS [AWB_CCM_L_8]
+    {0x0990, 0x039E}, // MCU_DATA_0
+    {0x098C, 0x2318}, // MCU_ADDRESS [AWB_CCM_L_9]
+    {0x0990, 0x001C}, // MCU_DATA_0
+    {0x098C, 0x231A}, // MCU_ADDRESS [AWB_CCM_L_10]
+    {0x0990, 0x0039}, // MCU_DATA_0
+    {0x098C, 0x231C}, // MCU_ADDRESS [AWB_CCM_RL_0]
+    {0x0990, 0x007F}, // MCU_DATA_0
+    {0x098C, 0x231E}, // MCU_ADDRESS [AWB_CCM_RL_1]
+    {0x0990, 0xFF77}, // MCU_DATA_0
+    {0x098C, 0x2320}, // MCU_ADDRESS [AWB_CCM_RL_2]
+    {0x0990, 0x000A}, // MCU_DATA_0
+    {0x098C, 0x2322}, // MCU_ADDRESS [AWB_CCM_RL_3]
+    {0x0990, 0x0020}, // MCU_DATA_0
+    {0x098C, 0x2324}, // MCU_ADDRESS [AWB_CCM_RL_4]
+    {0x0990, 0x001B}, // MCU_DATA_0
+    {0x098C, 0x2326}, // MCU_ADDRESS [AWB_CCM_RL_5]
+    {0x0990, 0xFFC6}, // MCU_DATA_0
+    {0x098C, 0x2328}, // MCU_ADDRESS [AWB_CCM_RL_6]
+    {0x0990, 0x0086}, // MCU_DATA_0
+    {0x098C, 0x232A}, // MCU_ADDRESS [AWB_CCM_RL_7]
+    {0x0990, 0x00B5}, // MCU_DATA_0
+    {0x098C, 0x232C}, // MCU_ADDRESS [AWB_CCM_RL_8]
+    {0x0990, 0xFEC3}, // MCU_DATA_0
+    {0x098C, 0x232E}, // MCU_ADDRESS [AWB_CCM_RL_9]
+    {0x0990, 0x0001}, // MCU_DATA_0
+    {0x098C, 0x2330}, // MCU_ADDRESS [AWB_CCM_RL_10]
+    {0x0990, 0xFFEF}, // MCU_DATA_0
+    {0x098C, 0xA348}, // MCU_ADDRESS [AWB_GAIN_BUFFER_SPEED]
+    {0x0990, 0x0008}, // MCU_DATA_0
+    {0x098C, 0xA349}, // MCU_ADDRESS [AWB_JUMP_DIVISOR]
+    {0x0990, 0x0002}, // MCU_DATA_0
+    {0x098C, 0xA34A}, // MCU_ADDRESS [AWB_GAIN_MIN]
+    {0x0990, 0x0090}, // MCU_DATA_0
+    {0x098C, 0xA34B}, // MCU_ADDRESS [AWB_GAIN_MAX]
+    {0x0990, 0x00FF}, // MCU_DATA_0
+    {0x098C, 0xA34C}, // MCU_ADDRESS [AWB_GAINMIN_B]
+    {0x0990, 0x0075}, // MCU_DATA_0
+    {0x098C, 0xA34D}, // MCU_ADDRESS [AWB_GAINMAX_B]
+    {0x0990, 0x00EF}, // MCU_DATA_0
+    {0x098C, 0xA351}, // MCU_ADDRESS [AWB_CCM_POSITION_MIN]
+    {0x0990, 0x0000}, // MCU_DATA_0
+    {0x098C, 0xA352}, // MCU_ADDRESS [AWB_CCM_POSITION_MAX]
+    {0x0990, 0x007F}, // MCU_DATA_0
+    {0x098C, 0xA354}, // MCU_ADDRESS [AWB_SATURATION]
+    {0x0990, 0x0043}, // MCU_DATA_0
+    {0x098C, 0xA355}, // MCU_ADDRESS [AWB_MODE]
+    {0x0990, 0x0001}, // MCU_DATA_0
+    {0x098C, 0xA35D}, // MCU_ADDRESS [AWB_STEADY_BGAIN_OUT_MIN]
+    {0x0990, 0x0078}, // MCU_DATA_0
+    {0x098C, 0xA35E}, // MCU_ADDRESS [AWB_STEADY_BGAIN_OUT_MAX]
+    {0x0990, 0x0086}, // MCU_DATA_0
+    {0x098C, 0xA35F}, // MCU_ADDRESS [AWB_STEADY_BGAIN_IN_MIN]
+    {0x0990, 0x007E}, // MCU_DATA_0
+    {0x098C, 0xA360}, // MCU_ADDRESS [AWB_STEADY_BGAIN_IN_MAX]
+    {0x0990, 0x0082}, // MCU_DATA_0
+    {0x098C, 0x2361}, // MCU_ADDRESS [AWB_CNT_PXL_TH]
+    {0x0990, 0x0040}, // MCU_DATA_0
+    {0x098C, 0xA363}, // MCU_ADDRESS [AWB_TG_MIN0]
+    {0x0990, 0x00D2}, // MCU_DATA_0
+    {0x098C, 0xA364}, // MCU_ADDRESS [AWB_TG_MAX0]
+    {0x0990, 0x00F6}, // MCU_DATA_0
+    {0x098C, 0xA302}, // MCU_ADDRESS [AWB_WINDOW_POS]
+    {0x0990, 0x0000}, // MCU_DATA_0
+    {0x098C, 0xA303}, // MCU_ADDRESS [AWB_WINDOW_SIZE]
+    {0x0990, 0x00EF}, // MCU_DATA_0
+    {0x098C, 0xAB20}, // MCU_ADDRESS [HG_LL_SAT1]
+    {0x0990, 0x0024}, // MCU_DATA_0
+    // AE Setting Frame rate 7.5fps ~ 30fps
+    {0x098C, 0xA20C}, // MCU_ADDRESS
+    {0x0990, 0x0004}, // AE_MAX_INDEX
+    {0x098C, 0xA215}, // MCU_ADDRESS
+    {0x0990, 0x0004}, // AE_INDEX_TH23
+    {0x098C, 0xA20D}, // MCU_ADDRESS [AE_MIN_VIRTGAIN]
+    {0x0990, 0x0030}, // MCU_DATA_0
+    {0x098C, 0xA20E}, // MCU_ADDRESS [AE_MAX_VIRTGAIN]
+    {0x0990, 0x0080}, // MCU_DATA_0
+    // Sharpness
+    {0x098C, 0xAB22}, // MCU_ADDRESS [HG_LL_APCORR1]
+    {0x0990, 0x0001}, // MCU_DATA_0
+    // AE Gate
+    {0x098C, 0xA207}, // MCU_ADDRESS [AE_GATE]
+    {0x0990, 0x0006}, // MCU_DATA_0
+    // AE Target
+    {0x098C, 0xA24F}, // MCU_ADDRESS [AE_BASETARGET]
+    {0x0990, 0x0044}, // MCU_DATA_0
+    {0x098C, 0xAB3C}, // MCU_ADDRESS [HG_GAMMA_TABLE_A_0]
+    {0x0990, 0x0000}, // MCU_DATA_0
+    {0x098C, 0xAB3D}, // MCU_ADDRESS [HG_GAMMA_TABLE_A_1]
+    {0x0990, 0x0007}, // MCU_DATA_0
+    {0x098C, 0xAB3E}, // MCU_ADDRESS [HG_GAMMA_TABLE_A_2]
+    {0x0990, 0x0016}, // MCU_DATA_0
+    {0x098C, 0xAB3F}, // MCU_ADDRESS [HG_GAMMA_TABLE_A_3]
+    {0x0990, 0x0039}, // MCU_DATA_0
+    {0x098C, 0xAB40}, // MCU_ADDRESS [HG_GAMMA_TABLE_A_4]
+    {0x0990, 0x005F}, // MCU_DATA_0
+    {0x098C, 0xAB41}, // MCU_ADDRESS [HG_GAMMA_TABLE_A_5]
+    {0x0990, 0x007A}, // MCU_DATA_0
+    {0x098C, 0xAB42}, // MCU_ADDRESS [HG_GAMMA_TABLE_A_6]
+    {0x0990, 0x008F}, // MCU_DATA_0
+    {0x098C, 0xAB43}, // MCU_ADDRESS [HG_GAMMA_TABLE_A_7]
+    {0x0990, 0x00A1}, // MCU_DATA_0
+    {0x098C, 0xAB44}, // MCU_ADDRESS [HG_GAMMA_TABLE_A_8]
+    {0x0990, 0x00AF}, // MCU_DATA_0
+    {0x098C, 0xAB45}, // MCU_ADDRESS [HG_GAMMA_TABLE_A_9]
+    {0x0990, 0x00BB}, // MCU_DATA_0
+    {0x098C, 0xAB46}, // MCU_ADDRESS [HG_GAMMA_TABLE_A_10]
+    {0x0990, 0x00C6}, // MCU_DATA_0
+    {0x098C, 0xAB47}, // MCU_ADDRESS [HG_GAMMA_TABLE_A_11]
+    {0x0990, 0x00CF}, // MCU_DATA_0
+    {0x098C, 0xAB48}, // MCU_ADDRESS [HG_GAMMA_TABLE_A_12]
+    {0x0990, 0x00D8}, // MCU_DATA_0
+    {0x098C, 0xAB49}, // MCU_ADDRESS [HG_GAMMA_TABLE_A_13]
+    {0x0990, 0x00E0}, // MCU_DATA_0
+    {0x098C, 0xAB4A}, // MCU_ADDRESS [HG_GAMMA_TABLE_A_14]
+    {0x0990, 0x00E7}, // MCU_DATA_0
+    {0x098C, 0xAB4B}, // MCU_ADDRESS [HG_GAMMA_TABLE_A_15]
+    {0x0990, 0x00EE}, // MCU_DATA_0
+    {0x098C, 0xAB4C}, // MCU_ADDRESS [HG_GAMMA_TABLE_A_16]
+    {0x0990, 0x00F4}, // MCU_DATA_0
+    {0x098C, 0xAB4D}, // MCU_ADDRESS [HG_GAMMA_TABLE_A_17]
+    {0x0990, 0x00FA}, // MCU_DATA_0
+    {0x098C, 0xAB4E}, // MCU_ADDRESS [HG_GAMMA_TABLE_A_18]
+    {0x0990, 0x00FF}, // MCU_DATA_0
+    // saturation
+    {0x098C, 0xAB20}, // MCU_ADDRESS [HG_LL_SAT1]
+    {0x0990, 0x0045}, // MCU_DATA_0
+    {0x098C, 0xAB24}, // MCU_ADDRESS [HG_LL_SAT2]
+    {0x0990, 0x0034}, // MCU_DATA_0
+    {0x098C, 0xA20C}, // MCU_ADDRESS
+    {0x0990, 0x0018}, // AE_MAX_INDEX
+    {0x098C, 0xA215}, // MCU_ADDRESS
+    {0x0990, 0x0008}, // AE_INDEX_TH23
+    {0x098C, 0xA20C}, // MCU_ADDRESS
+    {0x0990, 0x0018}, // AE_MAX_INDEX
+    {0x098C, 0xA215}, // MCU_ADDRESS
+    {0x0990, 0x0018}, // AE_INDEX_TH23
+    {0x098C, 0xA34A}, // MCU_ADDRESS
+    {0x0990, 0x007A}, // MCU_DATA_0
+    {0x098C, 0xA103}, // MCU_ADDRESS
+};
+static struct msm_camera_i2c_reg_conf mt9v113_recommend_setting3[] = {
+    {0x098C, 0xA244},
+    {0x0990, 0x00BB},
+    {0x3400, 0x7a26},
+};
+
+static struct v4l2_subdev_info mt9v113_subdev_info[] = {
+	{
+		.code   = V4L2_MBUS_FMT_YUYV8_2X8,
+		.colorspace = V4L2_COLORSPACE_JPEG,
+		.fmt    = 1,
+		.order  = 0,
+	},
+};
+
+static const struct i2c_device_id mt9v113_i2c_id[] = {
+	{MT9V113_SENSOR_NAME, (kernel_ulong_t)&mt9v113_s_ctrl},
+	{ }
+};
+
+static int32_t msm_mt9v113_i2c_probe(struct i2c_client *client,
+	const struct i2c_device_id *id)
+{
+	CDBG("%s, E.", __func__);
+
+	return msm_sensor_i2c_probe(client, id, &mt9v113_s_ctrl);
+}
+
+static struct i2c_driver mt9v113_i2c_driver = {
+	.id_table = mt9v113_i2c_id,
+	.probe  = msm_mt9v113_i2c_probe,
+	.driver = {
+		.name = MT9V113_SENSOR_NAME,
+	},
+};
+
+static struct msm_camera_i2c_client mt9v113_sensor_i2c_client = {
+	.addr_type = MSM_CAMERA_I2C_WORD_ADDR,
+};
+
+static const struct of_device_id mt9v113_dt_match[] = {
+	{.compatible = "qcom,mt9v113", .data = &mt9v113_s_ctrl},
+	{}
+};
+
+MODULE_DEVICE_TABLE(of, mt9v113_dt_match);
+
+static struct platform_driver mt9v113_platform_driver = {
+	.driver = {
+		.name = "qcom,mt9v113",
+		.owner = THIS_MODULE,
+		.of_match_table = mt9v113_dt_match,
+	},
+};
+
+static int32_t mt9v113_platform_probe(struct platform_device *pdev)
+{
+	int32_t rc;
+	const struct of_device_id *match;
+	CDBG("%s, E.", __func__);
+	match = of_match_device(mt9v113_dt_match, &pdev->dev);
+	rc = msm_sensor_platform_probe(pdev, match->data);
+	return rc;
+}
+
+static int __init mt9v113_init_module(void)
+{
+	int32_t rc;
+	pr_info("%s:%d\n", __func__, __LINE__);
+	rc = platform_driver_probe(&mt9v113_platform_driver,
+		mt9v113_platform_probe);
+	if (!rc)
+		return rc;
+	pr_err("%s:%d rc %d\n", __func__, __LINE__, rc);
+	return i2c_add_driver(&mt9v113_i2c_driver);
+}
+
+static void __exit mt9v113_exit_module(void)
+{
+	pr_info("%s:%d\n", __func__, __LINE__);
+	if (mt9v113_s_ctrl.pdev) {
+		msm_sensor_free_sensor_data(&mt9v113_s_ctrl);
+		platform_driver_unregister(&mt9v113_platform_driver);
+	} else
+		i2c_del_driver(&mt9v113_i2c_driver);
+	return;
+}
+
+int32_t mt9v113_sensor_config(struct msm_sensor_ctrl_t *s_ctrl,
+	void __user *argp)
+{
+	struct sensorb_cfg_data *cdata = (struct sensorb_cfg_data *)argp;
+	long rc = 0;
+	int32_t i = 0;
+	mutex_lock(s_ctrl->msm_sensor_mutex);
+	CDBG("%s:%d %s cfgtype = %d\n", __func__, __LINE__,
+		s_ctrl->sensordata->sensor_name, cdata->cfgtype);
+	switch (cdata->cfgtype) {
+	case CFG_GET_SENSOR_INFO:
+		memcpy(cdata->cfg.sensor_info.sensor_name,
+			s_ctrl->sensordata->sensor_name,
+			sizeof(cdata->cfg.sensor_info.sensor_name));
+		cdata->cfg.sensor_info.session_id =
+			s_ctrl->sensordata->sensor_info->session_id;
+		for (i = 0; i < SUB_MODULE_MAX; i++)
+			cdata->cfg.sensor_info.subdev_id[i] =
+				s_ctrl->sensordata->sensor_info->subdev_id[i];
+		CDBG("%s:%d sensor name %s\n", __func__, __LINE__,
+			cdata->cfg.sensor_info.sensor_name);
+		CDBG("%s:%d session id %d\n", __func__, __LINE__,
+			cdata->cfg.sensor_info.session_id);
+		for (i = 0; i < SUB_MODULE_MAX; i++)
+			CDBG("%s:%d subdev_id[%d] %d\n", __func__, __LINE__, i,
+				cdata->cfg.sensor_info.subdev_id[i]);
+
+		break;
+	case CFG_SET_INIT_SETTING:
+		/* Write Recommend settings */
+		pr_err("%s, sensor write init setting!!", __func__);
+		rc = s_ctrl->sensor_i2c_client->i2c_func_tbl->i2c_write(
+			s_ctrl->sensor_i2c_client,0x0018,0x4028, MSM_CAMERA_I2C_WORD_DATA);
+		msleep(20);
+		rc = s_ctrl->sensor_i2c_client->i2c_func_tbl->i2c_write(
+			s_ctrl->sensor_i2c_client,0x001A,0x0011, MSM_CAMERA_I2C_WORD_DATA);
+		msleep(10);
+		rc = s_ctrl->sensor_i2c_client->i2c_func_tbl->i2c_write(
+			s_ctrl->sensor_i2c_client,0x001A,0x0010, MSM_CAMERA_I2C_WORD_DATA);
+		msleep(10);
+		rc = s_ctrl->sensor_i2c_client->i2c_func_tbl->i2c_write(
+			s_ctrl->sensor_i2c_client,0x0018,0x4028, MSM_CAMERA_I2C_WORD_DATA);
+		msleep(50);
+		rc = s_ctrl->sensor_i2c_client->i2c_func_tbl->
+			i2c_write_conf_tbl(s_ctrl->sensor_i2c_client,mt9v113_recommend_setting1,
+			ARRAY_SIZE(mt9v113_recommend_setting1),
+			MSM_CAMERA_I2C_WORD_DATA);
+		rc = s_ctrl->sensor_i2c_client->i2c_func_tbl->i2c_write(
+			s_ctrl->sensor_i2c_client,0x0014,0x244B, MSM_CAMERA_I2C_WORD_DATA);
+		msleep(1);
+		rc = s_ctrl->sensor_i2c_client->i2c_func_tbl->i2c_write(
+			s_ctrl->sensor_i2c_client,0x0014,0x304B, MSM_CAMERA_I2C_WORD_DATA);
+		msleep(10);
+		rc = s_ctrl->sensor_i2c_client->i2c_func_tbl->i2c_write(
+			s_ctrl->sensor_i2c_client,0x0014,0xB04A, MSM_CAMERA_I2C_WORD_DATA);
+		msleep(1);
+		rc = s_ctrl->sensor_i2c_client->i2c_func_tbl->
+			i2c_write_conf_tbl(s_ctrl->sensor_i2c_client,mt9v113_recommend_setting2,
+			ARRAY_SIZE(mt9v113_recommend_setting2),
+			MSM_CAMERA_I2C_WORD_DATA);
+		rc = s_ctrl->sensor_i2c_client->i2c_func_tbl->i2c_write(
+			s_ctrl->sensor_i2c_client,0x0990,0x0006, MSM_CAMERA_I2C_WORD_DATA);
+		msleep(200);
+		rc = s_ctrl->sensor_i2c_client->i2c_func_tbl->i2c_write(
+			s_ctrl->sensor_i2c_client,0x098C,0xA103, MSM_CAMERA_I2C_WORD_DATA);
+		rc = s_ctrl->sensor_i2c_client->i2c_func_tbl->i2c_write(
+			s_ctrl->sensor_i2c_client,0x0990,0x0005, MSM_CAMERA_I2C_WORD_DATA);
+		msleep(100);
+		rc = s_ctrl->sensor_i2c_client->i2c_func_tbl->
+			i2c_write_conf_tbl(s_ctrl->sensor_i2c_client,mt9v113_recommend_setting3,
+			ARRAY_SIZE(mt9v113_recommend_setting3),MSM_CAMERA_I2C_WORD_DATA);
+		break;
+	case CFG_SET_RESOLUTION:
+		break;
+	case CFG_SET_STOP_STREAM:
+		pr_err("%s, sensor stop stream!!", __func__);
+		rc = s_ctrl->sensor_i2c_client->i2c_func_tbl->
+			i2c_write_conf_tbl(s_ctrl->sensor_i2c_client,
+			mt9v113_stop_settings,
+			ARRAY_SIZE(mt9v113_stop_settings),
+			MSM_CAMERA_I2C_WORD_DATA);
+		break;
+	case CFG_SET_START_STREAM:
+		pr_err("%s, sensor start stream!!", __func__);
+		rc = s_ctrl->sensor_i2c_client->i2c_func_tbl->
+			i2c_write_conf_tbl(s_ctrl->sensor_i2c_client,
+			mt9v113_start_settings,
+			ARRAY_SIZE(mt9v113_start_settings),
+			MSM_CAMERA_I2C_WORD_DATA);
+		break;
+	case CFG_GET_SENSOR_INIT_PARAMS:
+		cdata->cfg.sensor_init_params =
+			*s_ctrl->sensordata->sensor_init_params;
+		CDBG("%s:%d init params mode %d pos %d mount %d\n", __func__,
+			__LINE__,
+			cdata->cfg.sensor_init_params.modes_supported,
+			cdata->cfg.sensor_init_params.position,
+			cdata->cfg.sensor_init_params.sensor_mount_angle);
+		break;
+	case CFG_SET_SLAVE_INFO: {
+		struct msm_camera_sensor_slave_info sensor_slave_info;
+		struct msm_sensor_power_setting_array *power_setting_array;
+		int slave_index = 0;
+		if (copy_from_user(&sensor_slave_info,
+		    (void *)cdata->cfg.setting,
+		    sizeof(struct msm_camera_sensor_slave_info))) {
+			pr_err("%s:%d failed\n", __func__, __LINE__);
+			rc = -EFAULT;
+			break;
+		}
+		/* Update sensor slave address */
+		if (sensor_slave_info.slave_addr) {
+			s_ctrl->sensor_i2c_client->cci_client->sid =
+				sensor_slave_info.slave_addr >> 1;
+		}
+
+		/* Update sensor address type */
+		s_ctrl->sensor_i2c_client->addr_type =
+			sensor_slave_info.addr_type;
+
+		/* Update power up / down sequence */
+		s_ctrl->power_setting_array =
+			sensor_slave_info.power_setting_array;
+		power_setting_array = &s_ctrl->power_setting_array;
+		power_setting_array->power_setting = kzalloc(
+			power_setting_array->size *
+			sizeof(struct msm_sensor_power_setting), GFP_KERNEL);
+		if (!power_setting_array->power_setting) {
+			pr_err("%s:%d failed\n", __func__, __LINE__);
+			rc = -ENOMEM;
+			break;
+		}
+		if (copy_from_user(power_setting_array->power_setting,
+		    (void *)sensor_slave_info.power_setting_array.power_setting,
+		    power_setting_array->size *
+		    sizeof(struct msm_sensor_power_setting))) {
+			kfree(power_setting_array->power_setting);
+			pr_err("%s:%d failed\n", __func__, __LINE__);
+			rc = -EFAULT;
+			break;
+		}
+		s_ctrl->free_power_setting = true;
+		CDBG("%s sensor id %x\n", __func__,
+			sensor_slave_info.slave_addr);
+		CDBG("%s sensor addr type %d\n", __func__,
+			sensor_slave_info.addr_type);
+		CDBG("%s sensor reg %x\n", __func__,
+			sensor_slave_info.sensor_id_info.sensor_id_reg_addr);
+		CDBG("%s sensor id %x\n", __func__,
+			sensor_slave_info.sensor_id_info.sensor_id);
+		for (slave_index = 0; slave_index <
+			power_setting_array->size; slave_index++) {
+			CDBG("%s i %d power setting %d %d %ld %d\n", __func__,
+				slave_index,
+				power_setting_array->power_setting[slave_index].
+				seq_type,
+				power_setting_array->power_setting[slave_index].
+				seq_val,
+				power_setting_array->power_setting[slave_index].
+				config_val,
+				power_setting_array->power_setting[slave_index].
+				delay);
+		}
+		kfree(power_setting_array->power_setting);
+		break;
+	}
+	case CFG_WRITE_I2C_ARRAY: {
+		struct msm_camera_i2c_reg_setting conf_array;
+		struct msm_camera_i2c_reg_array *reg_setting = NULL;
+
+		if (copy_from_user(&conf_array,
+			(void *)cdata->cfg.setting,
+			sizeof(struct msm_camera_i2c_reg_setting))) {
+			pr_err("%s:%d failed\n", __func__, __LINE__);
+			rc = -EFAULT;
+			break;
+		}
+
+		reg_setting = kzalloc(conf_array.size *
+			(sizeof(struct msm_camera_i2c_reg_array)), GFP_KERNEL);
+		if (!reg_setting) {
+			pr_err("%s:%d failed\n", __func__, __LINE__);
+			rc = -ENOMEM;
+			break;
+		}
+		if (copy_from_user(reg_setting, (void *)conf_array.reg_setting,
+			conf_array.size *
+			sizeof(struct msm_camera_i2c_reg_array))) {
+			pr_err("%s:%d failed\n", __func__, __LINE__);
+			kfree(reg_setting);
+			rc = -EFAULT;
+			break;
+		}
+
+		conf_array.reg_setting = reg_setting;
+		rc = s_ctrl->sensor_i2c_client->i2c_func_tbl->i2c_write_table(
+			s_ctrl->sensor_i2c_client, &conf_array);
+		kfree(reg_setting);
+		break;
+	}
+	case CFG_WRITE_I2C_SEQ_ARRAY: {
+		struct msm_camera_i2c_seq_reg_setting conf_array;
+		struct msm_camera_i2c_seq_reg_array *reg_setting = NULL;
+
+		if (copy_from_user(&conf_array,
+			(void *)cdata->cfg.setting,
+			sizeof(struct msm_camera_i2c_seq_reg_setting))) {
+			pr_err("%s:%d failed\n", __func__, __LINE__);
+			rc = -EFAULT;
+			break;
+		}
+
+		reg_setting = kzalloc(conf_array.size *
+			(sizeof(struct msm_camera_i2c_seq_reg_array)),
+			GFP_KERNEL);
+		if (!reg_setting) {
+			pr_err("%s:%d failed\n", __func__, __LINE__);
+			rc = -ENOMEM;
+			break;
+		}
+		if (copy_from_user(reg_setting, (void *)conf_array.reg_setting,
+			conf_array.size *
+			sizeof(struct msm_camera_i2c_seq_reg_array))) {
+			pr_err("%s:%d failed\n", __func__, __LINE__);
+			kfree(reg_setting);
+			rc = -EFAULT;
+			break;
+		}
+
+		conf_array.reg_setting = reg_setting;
+		rc = s_ctrl->sensor_i2c_client->i2c_func_tbl->
+			i2c_write_seq_table(s_ctrl->sensor_i2c_client,
+			&conf_array);
+		kfree(reg_setting);
+		break;
+	}
+
+	case CFG_POWER_UP:
+		if (s_ctrl->func_tbl->sensor_power_up)
+			rc = s_ctrl->func_tbl->sensor_power_up(s_ctrl);
+		else
+			rc = -EFAULT;
+		break;
+
+	case CFG_POWER_DOWN:
+		if (s_ctrl->func_tbl->sensor_power_down)
+			rc = s_ctrl->func_tbl->sensor_power_down(
+				s_ctrl);
+		else
+			rc = -EFAULT;
+		break;
+
+	case CFG_SET_STOP_STREAM_SETTING: {
+		struct msm_camera_i2c_reg_setting *stop_setting =
+			&s_ctrl->stop_setting;
+		struct msm_camera_i2c_reg_array *reg_setting = NULL;
+		if (copy_from_user(stop_setting, (void *)cdata->cfg.setting,
+		    sizeof(struct msm_camera_i2c_reg_setting))) {
+			pr_err("%s:%d failed\n", __func__, __LINE__);
+			rc = -EFAULT;
+			break;
+		}
+
+		reg_setting = stop_setting->reg_setting;
+		stop_setting->reg_setting = kzalloc(stop_setting->size *
+			(sizeof(struct msm_camera_i2c_reg_array)), GFP_KERNEL);
+		if (!stop_setting->reg_setting) {
+			pr_err("%s:%d failed\n", __func__, __LINE__);
+			rc = -ENOMEM;
+			break;
+		}
+		if (copy_from_user(stop_setting->reg_setting,
+		    (void *)reg_setting, stop_setting->size *
+		    sizeof(struct msm_camera_i2c_reg_array))) {
+			pr_err("%s:%d failed\n", __func__, __LINE__);
+			kfree(stop_setting->reg_setting);
+			stop_setting->reg_setting = NULL;
+			stop_setting->size = 0;
+			rc = -EFAULT;
+			break;
+		}
+		break;
+	}
+	default:
+		rc = -EFAULT;
+		break;
+	}
+
+	mutex_unlock(s_ctrl->msm_sensor_mutex);
+
+	return rc;
+}
+
+static struct msm_sensor_fn_t mt9v113_sensor_func_tbl = {
+	.sensor_config = mt9v113_sensor_config,
+	.sensor_power_up = msm_sensor_power_up,
+	.sensor_power_down = msm_sensor_power_down,
+};
+
+static struct msm_sensor_ctrl_t mt9v113_s_ctrl = {
+	.sensor_i2c_client = &mt9v113_sensor_i2c_client,
+	.power_setting_array.power_setting = mt9v113_power_setting,
+	.power_setting_array.size = ARRAY_SIZE(mt9v113_power_setting),
+	.msm_sensor_mutex = &mt9v113_mut,
+	.sensor_v4l2_subdev_info = mt9v113_subdev_info,
+	.sensor_v4l2_subdev_info_size = ARRAY_SIZE(mt9v113_subdev_info),
+	.func_tbl = &mt9v113_sensor_func_tbl,
+};
+
+module_init(mt9v113_init_module);
+module_exit(mt9v113_exit_module);
+MODULE_DESCRIPTION("Aptina 0.3MP YUV sensor driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/media/platform/msm/camera_v2/sensor/ov5648_sunny_p5v18g.c b/drivers/media/platform/msm/camera_v2/sensor/ov5648_sunny_p5v18g.c
new file mode 100644
index 0000000..e5a92f0
--- /dev/null
+++ b/drivers/media/platform/msm/camera_v2/sensor/ov5648_sunny_p5v18g.c
@@ -0,0 +1,465 @@
+/* Copyright (c) 2013, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+#include <mach/gpiomux.h>
+#include "msm_sensor.h"
+#include "msm_sd.h"
+#include "camera.h"
+#include "msm_cci.h"
+#include "msm_camera_io_util.h"
+#include "msm_camera_i2c_mux.h"
+#include <mach/rpm-regulator.h>
+#include <mach/rpm-regulator-smd.h>
+#include <linux/regulator/consumer.h>
+
+#define OV5648_SUNNY_P5V18G_SENSOR_NAME "ov5648_sunny_p5v18g"
+DEFINE_MSM_MUTEX(ov5648_sunny_p5v18g_mut);
+
+#define GPIO_CAM_VCM_PWDN 79
+
+#undef CDBG
+#define OV5648_SUNNY_P5V18G_DEBUG
+#ifdef OV5648_SUNNY_P5V18G_DEBUG
+#define CDBG(fmt, args...) pr_err(fmt, ##args)
+#else
+#define CDBG(fmt, args...) do { } while (0)
+#endif
+
+
+static struct msm_sensor_ctrl_t ov5648_sunny_p5v18g_s_ctrl;
+
+
+static struct msm_sensor_power_setting ov5648_sunny_p5v18g_power_setting[] = {
+	{
+		.seq_type = SENSOR_VREG,
+		.seq_val = CAM_VANA,
+		.config_val = 0,
+		.delay = 5,
+	},	
+	{
+		.seq_type = SENSOR_VREG,
+		.seq_val = CAM_VIO,
+		.config_val = 0,
+		.delay = 5,
+	},
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_STANDBY,
+		.config_val = GPIO_OUT_LOW,
+		.delay = 15,
+	},
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_RESET,
+		.config_val = GPIO_OUT_LOW,
+		.delay = 40,
+	},
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_STANDBY,
+		.config_val = GPIO_OUT_HIGH,
+		.delay = 40,
+	},
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_RESET,
+		.config_val = GPIO_OUT_HIGH,
+		.delay = 40,
+	},
+	{
+		.seq_type = SENSOR_CLK,
+		.seq_val = SENSOR_CAM_MCLK,
+		.config_val = 24000000,
+		.delay = 5,
+	},
+	{
+		.seq_type = SENSOR_I2C_MUX,
+		.seq_val = 0,
+		.config_val = 0,
+		.delay = 0,
+	},
+};
+
+static struct v4l2_subdev_info ov5648_sunny_p5v18g_subdev_info[] = {
+	{
+		.code   = V4L2_MBUS_FMT_SBGGR10_1X10,
+		.colorspace = V4L2_COLORSPACE_JPEG,
+		.fmt    = 1,
+		.order    = 0,
+	},
+};
+
+static const struct i2c_device_id ov5648_sunny_p5v18g_i2c_id[] = {
+	{OV5648_SUNNY_P5V18G_SENSOR_NAME, (kernel_ulong_t)&ov5648_sunny_p5v18g_s_ctrl},
+	{ }
+};
+
+static int32_t msm_ov5648_sunny_p5v18g_i2c_probe(struct i2c_client *client,
+	const struct i2c_device_id *id)
+{
+	return msm_sensor_i2c_probe(client, id, &ov5648_sunny_p5v18g_s_ctrl);
+}
+
+static struct i2c_driver ov5648_sunny_p5v18g_i2c_driver = {
+	.id_table = ov5648_sunny_p5v18g_i2c_id,
+	.probe  = msm_ov5648_sunny_p5v18g_i2c_probe,
+	.driver = {
+		.name = OV5648_SUNNY_P5V18G_SENSOR_NAME,
+	},
+};
+
+static struct msm_camera_i2c_client ov5648_sunny_p5v18g_sensor_i2c_client = {
+	.addr_type = MSM_CAMERA_I2C_WORD_ADDR,
+};
+
+static const struct of_device_id ov5648_sunny_p5v18g_dt_match[] = {
+	{.compatible = "qcom,ov5648_sunny_p5v18g", .data = &ov5648_sunny_p5v18g_s_ctrl},
+	{}
+};
+
+MODULE_DEVICE_TABLE(of, ov5648_sunny_p5v18g_dt_match);
+
+static struct platform_driver ov5648_sunny_p5v18g_platform_driver = {
+	.driver = {
+		.name = "qcom,ov5648_sunny_p5v18g",
+		.owner = THIS_MODULE,
+		.of_match_table = ov5648_sunny_p5v18g_dt_match,
+	},
+};
+
+static int32_t ov5648_sunny_p5v18g_platform_probe(struct platform_device *pdev)
+{
+	int32_t rc = 0;
+	const struct of_device_id *match;
+	match = of_match_device(ov5648_sunny_p5v18g_dt_match, &pdev->dev);
+	rc = msm_sensor_platform_probe(pdev, match->data);
+	return rc;
+}
+
+static int __init ov5648_sunny_p5v18g_init_module(void)
+{
+	int32_t rc = 0;
+	pr_info("%s:%d\n", __func__, __LINE__);
+	rc = platform_driver_probe(&ov5648_sunny_p5v18g_platform_driver,
+		ov5648_sunny_p5v18g_platform_probe);
+	if (!rc)
+		return rc;
+	pr_err("%s:%d rc %d\n", __func__, __LINE__, rc);
+	return i2c_add_driver(&ov5648_sunny_p5v18g_i2c_driver);
+}
+
+static void __exit ov5648_sunny_p5v18g_exit_module(void)
+{
+	pr_info("%s:%d\n", __func__, __LINE__);
+	if (ov5648_sunny_p5v18g_s_ctrl.pdev) {
+		msm_sensor_free_sensor_data(&ov5648_sunny_p5v18g_s_ctrl);
+		platform_driver_unregister(&ov5648_sunny_p5v18g_platform_driver);
+	} else
+		i2c_del_driver(&ov5648_sunny_p5v18g_i2c_driver);
+	return;
+}
+
+static int32_t ov5648_sunny_p5v18g_sensor_enable_i2c_mux(struct msm_camera_i2c_conf *i2c_conf)
+{
+	struct v4l2_subdev *i2c_mux_sd =
+		dev_get_drvdata(&i2c_conf->mux_dev->dev);
+	v4l2_subdev_call(i2c_mux_sd, core, ioctl,
+		VIDIOC_MSM_I2C_MUX_INIT, NULL);
+	v4l2_subdev_call(i2c_mux_sd, core, ioctl,
+		VIDIOC_MSM_I2C_MUX_CFG, (void *)&i2c_conf->i2c_mux_mode);
+	return 0;
+}
+
+static int32_t ov5648_sunny_p5v18g_sensor_disable_i2c_mux(struct msm_camera_i2c_conf *i2c_conf)
+{
+	struct v4l2_subdev *i2c_mux_sd =
+		dev_get_drvdata(&i2c_conf->mux_dev->dev);
+	v4l2_subdev_call(i2c_mux_sd, core, ioctl,
+				VIDIOC_MSM_I2C_MUX_RELEASE, NULL);
+	return 0;
+}
+
+
+int32_t ov5648_sunny_p5v18g_sensor_power_up(struct msm_sensor_ctrl_t *s_ctrl)
+{
+	int32_t rc = 0, index = 0;
+	struct msm_sensor_power_setting_array *power_setting_array = NULL;
+	struct msm_sensor_power_setting *power_setting = NULL;
+	struct msm_camera_sensor_board_info *data = s_ctrl->sensordata;
+
+	CDBG("%s:%d\n", __func__, __LINE__);
+	power_setting_array = &s_ctrl->power_setting_array;
+
+	if (data->gpio_conf->cam_gpiomux_conf_tbl != NULL) {
+		pr_err("%s:%d mux install\n", __func__, __LINE__);
+		msm_gpiomux_install(
+			(struct msm_gpiomux_config *)
+			data->gpio_conf->cam_gpiomux_conf_tbl,
+			data->gpio_conf->cam_gpiomux_conf_tbl_size);
+	}
+
+	rc = msm_camera_request_gpio_table(
+		data->gpio_conf->cam_gpio_req_tbl,
+		data->gpio_conf->cam_gpio_req_tbl_size, 1);
+	if (rc < 0) {
+		pr_err("%s: request gpio failed\n", __func__);
+		return rc;
+	}
+	for (index = 0; index < power_setting_array->size; index++) {
+		CDBG("%s index %d\n", __func__, index);
+		power_setting = &power_setting_array->power_setting[index];
+		CDBG("%s type %d\n", __func__, power_setting->seq_type);
+		switch (power_setting->seq_type) {
+		case SENSOR_CLK:
+			if (power_setting->seq_val >= s_ctrl->clk_info_size) {
+				pr_err("%s clk index %d >= max %d\n", __func__,
+					power_setting->seq_val,
+					s_ctrl->clk_info_size);
+				goto power_up_failed;
+			}
+			if (power_setting->config_val)
+				s_ctrl->clk_info[power_setting->seq_val].
+					clk_rate = power_setting->config_val;
+
+			rc = msm_cam_clk_enable(s_ctrl->dev,
+				&s_ctrl->clk_info[0],
+				(struct clk **)&power_setting->data[0],
+				s_ctrl->clk_info_size,
+				1);
+			if (rc < 0) {
+				pr_err("%s: clk enable failed\n",
+					__func__);
+				goto power_up_failed;
+			}
+			break;
+		case SENSOR_GPIO:
+			if (power_setting->seq_val >= SENSOR_GPIO_MAX ||
+				!data->gpio_conf->gpio_num_info) {
+				pr_err("%s gpio index %d >= max %d\n", __func__,
+					power_setting->seq_val,
+					SENSOR_GPIO_MAX);
+				goto power_up_failed;
+			}
+			pr_debug("%s:%d gpio set val %d\n", __func__, __LINE__,
+				data->gpio_conf->gpio_num_info->gpio_num
+				[power_setting->seq_val]);
+			gpio_set_value_cansleep(
+				data->gpio_conf->gpio_num_info->gpio_num
+				[power_setting->seq_val],
+				power_setting->config_val);		
+			break;
+		case SENSOR_VREG:
+			if (power_setting->seq_val >= CAM_VREG_MAX) {
+				pr_err("%s vreg index %d >= max %d\n", __func__,
+					power_setting->seq_val,
+					SENSOR_GPIO_MAX);
+				goto power_up_failed;
+			}
+			msm_camera_config_single_vreg(s_ctrl->dev,
+				&data->cam_vreg[power_setting->seq_val],
+				(struct regulator **)&power_setting->data[0],
+				1);
+
+			gpio_set_value_cansleep(GPIO_CAM_VCM_PWDN,1); //disable vcm_pwdn
+			
+			break;
+		case SENSOR_I2C_MUX:
+			if (data->i2c_conf && data->i2c_conf->use_i2c_mux)
+				ov5648_sunny_p5v18g_sensor_enable_i2c_mux(data->i2c_conf);
+			break;
+		default:
+			pr_err("%s error power seq type %d\n", __func__,
+				power_setting->seq_type);
+			break;
+		}
+		if (power_setting->delay > 20) {
+			msleep(power_setting->delay);
+		} else if (power_setting->delay) {
+			usleep_range(power_setting->delay * 1000,
+				(power_setting->delay * 1000) + 1000);
+		}
+	}
+
+	if (s_ctrl->sensor_device_type == MSM_CAMERA_PLATFORM_DEVICE) {
+		rc = s_ctrl->sensor_i2c_client->i2c_func_tbl->i2c_util(
+			s_ctrl->sensor_i2c_client, MSM_CCI_INIT);
+		if (rc < 0) {
+			pr_err("%s cci_init failed\n", __func__);
+			goto power_up_failed;
+		}
+	}
+
+	if (s_ctrl->func_tbl->sensor_match_id)
+		rc = s_ctrl->func_tbl->sensor_match_id(s_ctrl);
+	else
+		rc = msm_sensor_match_id(s_ctrl);
+	if (rc < 0) {
+		pr_err("%s:%d match id failed rc %d\n", __func__, __LINE__, rc);
+		goto power_up_failed;
+	}
+
+	CDBG("%s exit\n", __func__);
+	return 0;
+power_up_failed:
+	pr_err("%s:%d failed\n", __func__, __LINE__);
+	if (s_ctrl->sensor_device_type == MSM_CAMERA_PLATFORM_DEVICE) {
+		s_ctrl->sensor_i2c_client->i2c_func_tbl->i2c_util(
+			s_ctrl->sensor_i2c_client, MSM_CCI_RELEASE);
+	}
+
+	for (index--; index >= 0; index--) {
+		CDBG("%s index %d\n", __func__, index);
+		power_setting = &power_setting_array->power_setting[index];
+		CDBG("%s type %d\n", __func__, power_setting->seq_type);
+		switch (power_setting->seq_type) {
+		case SENSOR_CLK:
+			msm_cam_clk_enable(s_ctrl->dev,
+				&s_ctrl->clk_info[0],
+				(struct clk **)&power_setting->data[0],
+				s_ctrl->clk_info_size,
+				0);
+			break;
+		case SENSOR_GPIO:
+			gpio_set_value_cansleep(
+				data->gpio_conf->gpio_num_info->gpio_num
+				[power_setting->seq_val], GPIOF_OUT_INIT_LOW);
+			break;
+		case SENSOR_VREG:
+			msm_camera_config_single_vreg(s_ctrl->dev,
+				&data->cam_vreg[power_setting->seq_val],
+				(struct regulator **)&power_setting->data[0],
+				0);
+			break;
+		case SENSOR_I2C_MUX:
+			if (data->i2c_conf && data->i2c_conf->use_i2c_mux)
+				ov5648_sunny_p5v18g_sensor_disable_i2c_mux(data->i2c_conf);
+			break;
+		default:
+			pr_err("%s error power seq type %d\n", __func__,
+				power_setting->seq_type);
+			break;
+		}
+		if (power_setting->delay > 20) {
+			msleep(power_setting->delay);
+		} else if (power_setting->delay) {
+			usleep_range(power_setting->delay * 1000,
+				(power_setting->delay * 1000) + 1000);
+		}
+	}
+	msm_camera_request_gpio_table(
+		data->gpio_conf->cam_gpio_req_tbl,
+		data->gpio_conf->cam_gpio_req_tbl_size, 0);
+	return rc;
+}
+
+int32_t ov5648_sunny_p5v18g_sensor_power_down(struct msm_sensor_ctrl_t *s_ctrl)
+{
+	int32_t index = 0;
+	struct msm_sensor_power_setting_array *power_setting_array = NULL;
+	struct msm_sensor_power_setting *power_setting = NULL;
+	struct msm_camera_sensor_board_info *data = s_ctrl->sensordata;
+	s_ctrl->stop_setting_valid = 0;
+
+	CDBG("%s:%d\n", __func__, __LINE__);
+	power_setting_array = &s_ctrl->power_setting_array;
+
+	if (s_ctrl->sensor_device_type == MSM_CAMERA_PLATFORM_DEVICE) {
+		s_ctrl->sensor_i2c_client->i2c_func_tbl->i2c_util(
+			s_ctrl->sensor_i2c_client, MSM_CCI_RELEASE);
+	}
+
+	for (index = (power_setting_array->size - 1); index >= 0; index--) {
+		CDBG("%s index %d\n", __func__, index);
+		power_setting = &power_setting_array->power_setting[index];
+		CDBG("%s type %d\n", __func__, power_setting->seq_type);
+		switch (power_setting->seq_type) {
+		case SENSOR_CLK:
+			msm_cam_clk_enable(s_ctrl->dev,
+				&s_ctrl->clk_info[0],
+				(struct clk **)&power_setting->data[0],
+				s_ctrl->clk_info_size,
+				0);
+			break;
+		case SENSOR_GPIO:
+			if (power_setting->seq_val >= SENSOR_GPIO_MAX ||
+				!data->gpio_conf->gpio_num_info) {
+				pr_err("%s gpio index %d >= max %d\n", __func__,
+					power_setting->seq_val,
+					SENSOR_GPIO_MAX);
+				continue;
+			}
+			gpio_set_value_cansleep(
+				data->gpio_conf->gpio_num_info->gpio_num
+				[power_setting->seq_val], GPIOF_OUT_INIT_LOW);
+			break;
+		case SENSOR_VREG:
+			if (power_setting->seq_val >= CAM_VREG_MAX) {
+				pr_err("%s vreg index %d >= max %d\n", __func__,
+					power_setting->seq_val,
+					SENSOR_GPIO_MAX);
+				continue;
+			}
+			msm_camera_config_single_vreg(s_ctrl->dev,
+				&data->cam_vreg[power_setting->seq_val],
+				(struct regulator **)&power_setting->data[0],
+				0);
+
+			gpio_set_value_cansleep(GPIO_CAM_VCM_PWDN,0); //enable vcm_pwdn
+			break;
+		case SENSOR_I2C_MUX:
+			if (data->i2c_conf && data->i2c_conf->use_i2c_mux)
+				ov5648_sunny_p5v18g_sensor_disable_i2c_mux(data->i2c_conf);
+			break;
+		default:
+			pr_err("%s error power seq type %d\n", __func__,
+				power_setting->seq_type);
+			break;
+		}
+		if (power_setting->delay > 20) {
+			msleep(power_setting->delay);
+		} else if (power_setting->delay) {
+			usleep_range(power_setting->delay * 1000,
+				(power_setting->delay * 1000) + 1000);
+		}
+	}
+	msm_camera_request_gpio_table(
+		data->gpio_conf->cam_gpio_req_tbl,
+		data->gpio_conf->cam_gpio_req_tbl_size, 0);
+	CDBG("%s exit\n", __func__);
+
+	return 0;
+}
+
+
+
+static struct msm_sensor_fn_t ov5648_sunny_p5v18g_sensor_func_tbl = {
+	.sensor_config = msm_sensor_config,
+	.sensor_power_up = ov5648_sunny_p5v18g_sensor_power_up,
+	.sensor_power_down = ov5648_sunny_p5v18g_sensor_power_down,
+	.sensor_match_id = msm_sensor_match_id,
+};
+
+
+static struct msm_sensor_ctrl_t ov5648_sunny_p5v18g_s_ctrl = {
+	.sensor_i2c_client = &ov5648_sunny_p5v18g_sensor_i2c_client,
+	.power_setting_array.power_setting = ov5648_sunny_p5v18g_power_setting,
+	.power_setting_array.size = ARRAY_SIZE(ov5648_sunny_p5v18g_power_setting),
+	.msm_sensor_mutex = &ov5648_sunny_p5v18g_mut,
+	.sensor_v4l2_subdev_info = ov5648_sunny_p5v18g_subdev_info,
+	.sensor_v4l2_subdev_info_size = ARRAY_SIZE(ov5648_sunny_p5v18g_subdev_info),
+	.func_tbl = &ov5648_sunny_p5v18g_sensor_func_tbl,
+};
+
+module_init(ov5648_sunny_p5v18g_init_module);
+module_exit(ov5648_sunny_p5v18g_exit_module);
+MODULE_DESCRIPTION("ov5648_sunny_p5v18g");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/media/platform/msm/camera_v2/sensor/ov8850_foxconn_dc0901b.c b/drivers/media/platform/msm/camera_v2/sensor/ov8850_foxconn_dc0901b.c
new file mode 100644
index 0000000..10f9513
--- /dev/null
+++ b/drivers/media/platform/msm/camera_v2/sensor/ov8850_foxconn_dc0901b.c
@@ -0,0 +1,463 @@
+/* Copyright (c) 2013, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+#include <mach/gpiomux.h>
+#include "msm_sensor.h"
+#include "msm_sd.h"
+#include "camera.h"
+#include "msm_cci.h"
+#include "msm_camera_io_util.h"
+#include "msm_camera_i2c_mux.h"
+#include <mach/rpm-regulator.h>
+#include <mach/rpm-regulator-smd.h>
+#include <linux/regulator/consumer.h>
+
+#define OV8850_FOXCONN_SENSOR_NAME "ov8850_foxconn"
+DEFINE_MSM_MUTEX(ov8850_foxconn_mut);
+
+#define GPIO_CAM_DVDD_EN   101
+#define GPIO_CAM_VCM_PWDN  79
+
+#undef CDBG
+#define OV8850_FOXCONN_DEBUG
+#ifdef OV8850_FOXCONN_DEBUG
+#define CDBG(fmt, args...) pr_err(fmt, ##args)
+#else
+#define CDBG(fmt, args...) do { } while (0)
+#endif
+
+static struct msm_sensor_ctrl_t ov8850_foxconn_s_ctrl;
+
+static struct msm_sensor_power_setting ov8850_foxconn_power_setting[] = {
+	{
+		.seq_type = SENSOR_VREG,
+		.seq_val = CAM_VANA,
+		.config_val = 0,
+		.delay = 5,
+	},	
+	{
+		.seq_type = SENSOR_VREG,
+		.seq_val = CAM_VIO,
+		.config_val = 0,
+		.delay = 5,
+	},
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_STANDBY,
+		.config_val = GPIO_OUT_LOW,
+		.delay = 15,
+	},
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_RESET,
+		.config_val = GPIO_OUT_LOW,
+		.delay = 40,
+	},
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_STANDBY,
+		.config_val = GPIO_OUT_HIGH,
+		.delay = 40,
+	},
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_RESET,
+		.config_val = GPIO_OUT_HIGH,
+		.delay = 40,
+	},
+	{
+		.seq_type = SENSOR_CLK,
+		.seq_val = SENSOR_CAM_MCLK,
+		.config_val = 24000000,
+		.delay = 5,
+	},
+	{
+		.seq_type = SENSOR_I2C_MUX,
+		.seq_val = 0,
+		.config_val = 0,
+		.delay = 0,
+	},
+};
+
+static struct v4l2_subdev_info ov8850_foxconn_subdev_info[] = {
+	{
+		.code   = V4L2_MBUS_FMT_SBGGR10_1X10,
+		.colorspace = V4L2_COLORSPACE_JPEG,
+		.fmt    = 1,
+		.order    = 0,
+	},
+};
+
+static const struct i2c_device_id ov8850_foxconn_i2c_id[] = {
+	{OV8850_FOXCONN_SENSOR_NAME, (kernel_ulong_t)&ov8850_foxconn_s_ctrl},
+	{ }
+};
+
+static int32_t msm_ov8850_foxconn_i2c_probe(struct i2c_client *client,
+	const struct i2c_device_id *id)
+{
+	return msm_sensor_i2c_probe(client, id, &ov8850_foxconn_s_ctrl);
+}
+
+static struct i2c_driver ov8850_foxconn_i2c_driver = {
+	.id_table = ov8850_foxconn_i2c_id,
+	.probe  = msm_ov8850_foxconn_i2c_probe,
+	.driver = {
+		.name = OV8850_FOXCONN_SENSOR_NAME,
+	},
+};
+
+static struct msm_camera_i2c_client ov8850_foxconn_sensor_i2c_client = {
+	.addr_type = MSM_CAMERA_I2C_WORD_ADDR,
+};
+
+static const struct of_device_id ov8850_foxconn_dt_match[] = {
+	{.compatible = "qcom,ov8850_foxconn", .data = &ov8850_foxconn_s_ctrl},
+	{}
+};
+
+MODULE_DEVICE_TABLE(of, ov8850_foxconn_dt_match);
+
+static struct platform_driver ov8850_foxconn_platform_driver = {
+	.driver = {
+		.name = "qcom,ov8850_foxconn",
+		.owner = THIS_MODULE,
+		.of_match_table = ov8850_foxconn_dt_match,
+	},
+};
+
+static int32_t ov8850_foxconn_platform_probe(struct platform_device *pdev)
+{
+	int32_t rc = 0;
+	const struct of_device_id *match;
+	match = of_match_device(ov8850_foxconn_dt_match, &pdev->dev);
+	rc = msm_sensor_platform_probe(pdev, match->data);
+	return rc;
+}
+
+static int __init ov8850_foxconn_init_module(void)
+{
+	int32_t rc = 0;
+	pr_info("%s:%d\n", __func__, __LINE__);
+	rc = platform_driver_probe(&ov8850_foxconn_platform_driver,
+		ov8850_foxconn_platform_probe);
+	if (!rc)
+		return rc;
+	pr_err("%s:%d rc %d\n", __func__, __LINE__, rc);
+	return i2c_add_driver(&ov8850_foxconn_i2c_driver);
+}
+
+static void __exit ov8850_foxconn_exit_module(void)
+{
+	pr_info("%s:%d\n", __func__, __LINE__);
+	if (ov8850_foxconn_s_ctrl.pdev) {
+		msm_sensor_free_sensor_data(&ov8850_foxconn_s_ctrl);
+		platform_driver_unregister(&ov8850_foxconn_platform_driver);
+	} else
+		i2c_del_driver(&ov8850_foxconn_i2c_driver);
+	return;
+}
+
+static int32_t ov8850_foxconn_sensor_enable_i2c_mux(struct msm_camera_i2c_conf *i2c_conf)
+{
+	struct v4l2_subdev *i2c_mux_sd =
+		dev_get_drvdata(&i2c_conf->mux_dev->dev);
+	v4l2_subdev_call(i2c_mux_sd, core, ioctl,
+		VIDIOC_MSM_I2C_MUX_INIT, NULL);
+	v4l2_subdev_call(i2c_mux_sd, core, ioctl,
+		VIDIOC_MSM_I2C_MUX_CFG, (void *)&i2c_conf->i2c_mux_mode);
+	return 0;
+}
+
+static int32_t ov8850_foxconn_sensor_disable_i2c_mux(struct msm_camera_i2c_conf *i2c_conf)
+{
+	struct v4l2_subdev *i2c_mux_sd =
+		dev_get_drvdata(&i2c_conf->mux_dev->dev);
+	v4l2_subdev_call(i2c_mux_sd, core, ioctl,
+				VIDIOC_MSM_I2C_MUX_RELEASE, NULL);
+	return 0;
+}
+
+int32_t ov8850_foxconn_sensor_power_up(struct msm_sensor_ctrl_t *s_ctrl)
+{
+	int32_t rc = 0, index = 0;
+	struct msm_sensor_power_setting_array *power_setting_array = NULL;
+	struct msm_sensor_power_setting *power_setting = NULL;
+	struct msm_camera_sensor_board_info *data = s_ctrl->sensordata;
+
+	CDBG("%s:%d\n", __func__, __LINE__);
+	power_setting_array = &s_ctrl->power_setting_array;
+
+	if (data->gpio_conf->cam_gpiomux_conf_tbl != NULL) {
+		pr_err("%s:%d mux install\n", __func__, __LINE__);
+		msm_gpiomux_install(
+			(struct msm_gpiomux_config *)
+			data->gpio_conf->cam_gpiomux_conf_tbl,
+			data->gpio_conf->cam_gpiomux_conf_tbl_size);
+	}
+
+	rc = msm_camera_request_gpio_table(
+		data->gpio_conf->cam_gpio_req_tbl,
+		data->gpio_conf->cam_gpio_req_tbl_size, 1);
+	if (rc < 0) {
+		pr_err("%s: request gpio failed\n", __func__);
+		return rc;
+	}
+	for (index = 0; index < power_setting_array->size; index++) {
+		CDBG("%s index %d\n", __func__, index);
+		power_setting = &power_setting_array->power_setting[index];
+		CDBG("%s type %d\n", __func__, power_setting->seq_type);
+		switch (power_setting->seq_type) {
+		case SENSOR_CLK:
+			if (power_setting->seq_val >= s_ctrl->clk_info_size) {
+				pr_err("%s clk index %d >= max %d\n", __func__,
+					power_setting->seq_val,
+					s_ctrl->clk_info_size);
+				goto power_up_failed;
+			}
+			if (power_setting->config_val)
+				s_ctrl->clk_info[power_setting->seq_val].
+					clk_rate = power_setting->config_val;
+
+			rc = msm_cam_clk_enable(s_ctrl->dev,
+				&s_ctrl->clk_info[0],
+				(struct clk **)&power_setting->data[0],
+				s_ctrl->clk_info_size,
+				1);
+			if (rc < 0) {
+				pr_err("%s: clk enable failed\n",
+					__func__);
+				goto power_up_failed;
+			}
+			break;
+		case SENSOR_GPIO:
+			if (power_setting->seq_val >= SENSOR_GPIO_MAX ||
+				!data->gpio_conf->gpio_num_info) {
+				pr_err("%s gpio index %d >= max %d\n", __func__,
+					power_setting->seq_val,
+					SENSOR_GPIO_MAX);
+				goto power_up_failed;
+			}
+			pr_debug("%s:%d gpio set val %d\n", __func__, __LINE__,
+				data->gpio_conf->gpio_num_info->gpio_num
+				[power_setting->seq_val]);
+			gpio_set_value_cansleep(
+				data->gpio_conf->gpio_num_info->gpio_num
+				[power_setting->seq_val],
+				power_setting->config_val);		
+			break;
+		case SENSOR_VREG:
+			if (power_setting->seq_val >= CAM_VREG_MAX) {
+				pr_err("%s vreg index %d >= max %d\n", __func__,
+					power_setting->seq_val,
+					SENSOR_GPIO_MAX);
+				goto power_up_failed;
+			}
+			msm_camera_config_single_vreg(s_ctrl->dev,
+				&data->cam_vreg[power_setting->seq_val],
+				(struct regulator **)&power_setting->data[0],
+				1);
+
+			gpio_set_value_cansleep(GPIO_CAM_DVDD_EN,1); //enable dvdd_en
+			gpio_set_value_cansleep(GPIO_CAM_VCM_PWDN,1); //enable vcm
+			
+			break;
+		case SENSOR_I2C_MUX:
+			if (data->i2c_conf && data->i2c_conf->use_i2c_mux)
+				ov8850_foxconn_sensor_enable_i2c_mux(data->i2c_conf);
+			break;
+		default:
+			pr_err("%s error power seq type %d\n", __func__,
+				power_setting->seq_type);
+			break;
+		}
+		if (power_setting->delay > 20) {
+			msleep(power_setting->delay);
+		} else if (power_setting->delay) {
+			usleep_range(power_setting->delay * 1000,
+				(power_setting->delay * 1000) + 1000);
+		}
+	}
+
+	if (s_ctrl->sensor_device_type == MSM_CAMERA_PLATFORM_DEVICE) {
+		rc = s_ctrl->sensor_i2c_client->i2c_func_tbl->i2c_util(
+			s_ctrl->sensor_i2c_client, MSM_CCI_INIT);
+		if (rc < 0) {
+			pr_err("%s cci_init failed\n", __func__);
+			goto power_up_failed;
+		}
+	}
+
+	if (s_ctrl->func_tbl->sensor_match_id)
+		rc = s_ctrl->func_tbl->sensor_match_id(s_ctrl);
+	else
+		rc = msm_sensor_match_id(s_ctrl);
+	if (rc < 0) {
+		pr_err("%s:%d match id failed rc %d\n", __func__, __LINE__, rc);
+		goto power_up_failed;
+	}
+
+	CDBG("%s exit\n", __func__);
+	return 0;
+power_up_failed:
+	pr_err("%s:%d failed\n", __func__, __LINE__);
+	if (s_ctrl->sensor_device_type == MSM_CAMERA_PLATFORM_DEVICE) {
+		s_ctrl->sensor_i2c_client->i2c_func_tbl->i2c_util(
+			s_ctrl->sensor_i2c_client, MSM_CCI_RELEASE);
+	}
+
+	for (index--; index >= 0; index--) {
+		CDBG("%s index %d\n", __func__, index);
+		power_setting = &power_setting_array->power_setting[index];
+		CDBG("%s type %d\n", __func__, power_setting->seq_type);
+		switch (power_setting->seq_type) {
+		case SENSOR_CLK:
+			msm_cam_clk_enable(s_ctrl->dev,
+				&s_ctrl->clk_info[0],
+				(struct clk **)&power_setting->data[0],
+				s_ctrl->clk_info_size,
+				0);
+			break;
+		case SENSOR_GPIO:
+			gpio_set_value_cansleep(
+				data->gpio_conf->gpio_num_info->gpio_num
+				[power_setting->seq_val], GPIOF_OUT_INIT_LOW);
+			break;
+		case SENSOR_VREG:
+			msm_camera_config_single_vreg(s_ctrl->dev,
+				&data->cam_vreg[power_setting->seq_val],
+				(struct regulator **)&power_setting->data[0],
+				0);
+			break;
+		case SENSOR_I2C_MUX:
+			if (data->i2c_conf && data->i2c_conf->use_i2c_mux)
+				ov8850_foxconn_sensor_disable_i2c_mux(data->i2c_conf);
+			break;
+		default:
+			pr_err("%s error power seq type %d\n", __func__,
+				power_setting->seq_type);
+			break;
+		}
+		if (power_setting->delay > 20) {
+			msleep(power_setting->delay);
+		} else if (power_setting->delay) {
+			usleep_range(power_setting->delay * 1000,
+				(power_setting->delay * 1000) + 1000);
+		}
+	}
+	msm_camera_request_gpio_table(
+		data->gpio_conf->cam_gpio_req_tbl,
+		data->gpio_conf->cam_gpio_req_tbl_size, 0);
+	return rc;
+}
+
+int32_t ov8850_foxconn_sensor_power_down(struct msm_sensor_ctrl_t *s_ctrl)
+{
+	int32_t index = 0;
+	struct msm_sensor_power_setting_array *power_setting_array = NULL;
+	struct msm_sensor_power_setting *power_setting = NULL;
+	struct msm_camera_sensor_board_info *data = s_ctrl->sensordata;
+	s_ctrl->stop_setting_valid = 0;
+
+	CDBG("%s:%d\n", __func__, __LINE__);
+	power_setting_array = &s_ctrl->power_setting_array;
+
+	if (s_ctrl->sensor_device_type == MSM_CAMERA_PLATFORM_DEVICE) {
+		s_ctrl->sensor_i2c_client->i2c_func_tbl->i2c_util(
+			s_ctrl->sensor_i2c_client, MSM_CCI_RELEASE);
+	}
+
+	for (index = (power_setting_array->size - 1); index >= 0; index--) {
+		CDBG("%s index %d\n", __func__, index);
+		power_setting = &power_setting_array->power_setting[index];
+		CDBG("%s type %d\n", __func__, power_setting->seq_type);
+		switch (power_setting->seq_type) {
+		case SENSOR_CLK:
+			msm_cam_clk_enable(s_ctrl->dev,
+				&s_ctrl->clk_info[0],
+				(struct clk **)&power_setting->data[0],
+				s_ctrl->clk_info_size,
+				0);
+			break;
+		case SENSOR_GPIO:
+			if (power_setting->seq_val >= SENSOR_GPIO_MAX ||
+				!data->gpio_conf->gpio_num_info) {
+				pr_err("%s gpio index %d >= max %d\n", __func__,
+					power_setting->seq_val,
+					SENSOR_GPIO_MAX);
+				continue;
+			}
+			gpio_set_value_cansleep(
+				data->gpio_conf->gpio_num_info->gpio_num
+				[power_setting->seq_val], GPIOF_OUT_INIT_LOW);
+			break;
+		case SENSOR_VREG:
+			if (power_setting->seq_val >= CAM_VREG_MAX) {
+				pr_err("%s vreg index %d >= max %d\n", __func__,
+					power_setting->seq_val,
+					SENSOR_GPIO_MAX);
+				continue;
+			}
+			msm_camera_config_single_vreg(s_ctrl->dev,
+				&data->cam_vreg[power_setting->seq_val],
+				(struct regulator **)&power_setting->data[0],
+				0);
+
+			gpio_set_value_cansleep(GPIO_CAM_DVDD_EN,0); //disable dvdd_en
+			gpio_set_value_cansleep(GPIO_CAM_VCM_PWDN,0); //disable vcm
+
+			break;
+		case SENSOR_I2C_MUX:
+			if (data->i2c_conf && data->i2c_conf->use_i2c_mux)
+				ov8850_foxconn_sensor_disable_i2c_mux(data->i2c_conf);
+			break;
+		default:
+			pr_err("%s error power seq type %d\n", __func__,
+				power_setting->seq_type);
+			break;
+		}
+		if (power_setting->delay > 20) {
+			msleep(power_setting->delay);
+		} else if (power_setting->delay) {
+			usleep_range(power_setting->delay * 1000,
+				(power_setting->delay * 1000) + 1000);
+		}
+	}
+	msm_camera_request_gpio_table(
+		data->gpio_conf->cam_gpio_req_tbl,
+		data->gpio_conf->cam_gpio_req_tbl_size, 0);
+	CDBG("%s exit\n", __func__);
+
+	return 0;
+}
+
+static struct msm_sensor_fn_t ov8850_foxconn_sensor_func_tbl = {
+	.sensor_config = msm_sensor_config,
+	.sensor_power_up = ov8850_foxconn_sensor_power_up,
+	.sensor_power_down = ov8850_foxconn_sensor_power_down,
+	.sensor_match_id = msm_sensor_match_id,
+};
+
+static struct msm_sensor_ctrl_t ov8850_foxconn_s_ctrl = {
+	.sensor_i2c_client = &ov8850_foxconn_sensor_i2c_client,
+	.power_setting_array.power_setting = ov8850_foxconn_power_setting,
+	.power_setting_array.size = ARRAY_SIZE(ov8850_foxconn_power_setting),
+	.msm_sensor_mutex = &ov8850_foxconn_mut,
+	.sensor_v4l2_subdev_info = ov8850_foxconn_subdev_info,
+	.sensor_v4l2_subdev_info_size = ARRAY_SIZE(ov8850_foxconn_subdev_info),
+	.func_tbl = &ov8850_foxconn_sensor_func_tbl,
+};
+
+module_init(ov8850_foxconn_init_module);
+module_exit(ov8850_foxconn_exit_module);
+MODULE_DESCRIPTION("ov8850_foxconn");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/media/platform/msm/camera_v2/sensor/s5k4e1_liteon_13p1ba535d.c b/drivers/media/platform/msm/camera_v2/sensor/s5k4e1_liteon_13p1ba535d.c
new file mode 100644
index 0000000..a312a56
--- /dev/null
+++ b/drivers/media/platform/msm/camera_v2/sensor/s5k4e1_liteon_13p1ba535d.c
@@ -0,0 +1,470 @@
+/* Copyright (c) 2013, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+#include <mach/gpiomux.h>
+#include "msm_sensor.h"
+#include "msm_sd.h"
+#include "camera.h"
+#include "msm_cci.h"
+#include "msm_camera_io_util.h"
+#include "msm_camera_i2c_mux.h"
+#include <mach/rpm-regulator.h>
+#include <mach/rpm-regulator-smd.h>
+#include <linux/regulator/consumer.h>
+
+#define S5K4E1_LITEON_SENSOR_NAME "s5k4e1_liteon"
+DEFINE_MSM_MUTEX(s5k4e1_liteon_mut);
+
+#define GPIO_CAM_VCM_PWDN 79
+
+#undef CDBG
+#define S5K4E1_LITEON_DEBUG
+#ifdef S5K4E1_LITEON_DEBUG
+#define CDBG(fmt, args...) pr_err(fmt, ##args)
+#else
+#define CDBG(fmt, args...) do { } while (0)
+#endif
+
+
+static struct msm_sensor_ctrl_t s5k4e1_liteon_s_ctrl;
+
+
+static struct msm_sensor_power_setting s5k4e1_liteon_power_setting[] = {
+	{
+		.seq_type = SENSOR_VREG,
+		.seq_val = CAM_VANA,
+		.config_val = 0,
+		.delay = 5,
+	},	
+	{
+		.seq_type = SENSOR_VREG,
+		.seq_val = CAM_VIO,
+		.config_val = 0,
+		.delay = 5,
+	},
+        /*
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_STANDBY,
+		.config_val = GPIO_OUT_LOW,
+		.delay = 15,
+	},
+        */
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_RESET,
+		.config_val = GPIO_OUT_LOW,
+		.delay = 40,
+	},
+        /*
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_STANDBY,
+		.config_val = GPIO_OUT_HIGH,
+		.delay = 40,
+	},
+        */
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_RESET,
+		.config_val = GPIO_OUT_HIGH,
+		.delay = 40,
+	},
+	{
+		.seq_type = SENSOR_CLK,
+		.seq_val = SENSOR_CAM_MCLK,
+		.config_val = 24000000,
+		.delay = 5,
+	},
+	{
+		.seq_type = SENSOR_I2C_MUX,
+		.seq_val = 0,
+		.config_val = 0,
+		.delay = 0,
+	},
+};
+
+static struct v4l2_subdev_info s5k4e1_liteon_subdev_info[] = {
+	{
+		.code   = V4L2_MBUS_FMT_SGRBG10_1X10,
+		.colorspace = V4L2_COLORSPACE_JPEG,
+		.fmt    = 1,
+		.order    = 0,
+	},
+};
+
+static const struct i2c_device_id s5k4e1_liteon_i2c_id[] = {
+	{S5K4E1_LITEON_SENSOR_NAME, (kernel_ulong_t)&s5k4e1_liteon_s_ctrl},
+	{ }
+};
+
+static int32_t msm_s5k4e1_liteon_i2c_probe(struct i2c_client *client,
+	const struct i2c_device_id *id)
+{
+	return msm_sensor_i2c_probe(client, id, &s5k4e1_liteon_s_ctrl);
+}
+
+static struct i2c_driver s5k4e1_liteon_i2c_driver = {
+	.id_table = s5k4e1_liteon_i2c_id,
+	.probe  = msm_s5k4e1_liteon_i2c_probe,
+	.driver = {
+		.name = S5K4E1_LITEON_SENSOR_NAME,
+	},
+};
+
+static struct msm_camera_i2c_client s5k4e1_liteon_sensor_i2c_client = {
+	.addr_type = MSM_CAMERA_I2C_WORD_ADDR,
+};
+
+static const struct of_device_id s5k4e1_liteon_dt_match[] = {
+	{.compatible = "qcom,s5k4e1_liteon", .data = &s5k4e1_liteon_s_ctrl},
+	{}
+};
+
+MODULE_DEVICE_TABLE(of, s5k4e1_liteon_dt_match);
+
+static struct platform_driver s5k4e1_liteon_platform_driver = {
+	.driver = {
+		.name = "qcom,s5k4e1_liteon",
+		.owner = THIS_MODULE,
+		.of_match_table = s5k4e1_liteon_dt_match,
+	},
+};
+
+static int32_t s5k4e1_liteon_platform_probe(struct platform_device *pdev)
+{
+	int32_t rc = 0;
+	const struct of_device_id *match;
+	match = of_match_device(s5k4e1_liteon_dt_match, &pdev->dev);
+	rc = msm_sensor_platform_probe(pdev, match->data);
+	return rc;
+}
+
+static int __init s5k4e1_liteon_init_module(void)
+{
+	int32_t rc = 0;
+	pr_info("%s:%d\n", __func__, __LINE__);
+	rc = platform_driver_probe(&s5k4e1_liteon_platform_driver,
+		s5k4e1_liteon_platform_probe);
+	if (!rc)
+		return rc;
+	pr_err("%s:%d rc %d\n", __func__, __LINE__, rc);
+	return i2c_add_driver(&s5k4e1_liteon_i2c_driver);
+}
+
+static void __exit s5k4e1_liteon_exit_module(void)
+{
+	pr_info("%s:%d\n", __func__, __LINE__);
+	if (s5k4e1_liteon_s_ctrl.pdev) {
+		msm_sensor_free_sensor_data(&s5k4e1_liteon_s_ctrl);
+		platform_driver_unregister(&s5k4e1_liteon_platform_driver);
+	} else
+		i2c_del_driver(&s5k4e1_liteon_i2c_driver);
+	return;
+}
+
+static int32_t s5k4e1_liteon_sensor_enable_i2c_mux(struct msm_camera_i2c_conf *i2c_conf)
+{
+	struct v4l2_subdev *i2c_mux_sd =
+		dev_get_drvdata(&i2c_conf->mux_dev->dev);
+	v4l2_subdev_call(i2c_mux_sd, core, ioctl,
+		VIDIOC_MSM_I2C_MUX_INIT, NULL);
+	v4l2_subdev_call(i2c_mux_sd, core, ioctl,
+		VIDIOC_MSM_I2C_MUX_CFG, (void *)&i2c_conf->i2c_mux_mode);
+	return 0;
+}
+
+static int32_t s5k4e1_liteon_sensor_disable_i2c_mux(struct msm_camera_i2c_conf *i2c_conf)
+{
+	struct v4l2_subdev *i2c_mux_sd =
+		dev_get_drvdata(&i2c_conf->mux_dev->dev);
+	v4l2_subdev_call(i2c_mux_sd, core, ioctl,
+				VIDIOC_MSM_I2C_MUX_RELEASE, NULL);
+	return 0;
+}
+
+
+int32_t s5k4e1_liteon_sensor_power_up(struct msm_sensor_ctrl_t *s_ctrl)
+{
+	int32_t rc = 0, index = 0;
+	struct msm_sensor_power_setting_array *power_setting_array = NULL;
+	struct msm_sensor_power_setting *power_setting = NULL;
+	struct msm_camera_sensor_board_info *data = s_ctrl->sensordata;
+
+	CDBG("%s:%d\n", __func__, __LINE__);
+	power_setting_array = &s_ctrl->power_setting_array;
+
+	if (data->gpio_conf->cam_gpiomux_conf_tbl != NULL) {
+		pr_err("%s:%d mux install\n", __func__, __LINE__);
+		msm_gpiomux_install(
+			(struct msm_gpiomux_config *)
+			data->gpio_conf->cam_gpiomux_conf_tbl,
+			data->gpio_conf->cam_gpiomux_conf_tbl_size);
+	}
+
+	rc = msm_camera_request_gpio_table(
+		data->gpio_conf->cam_gpio_req_tbl,
+		data->gpio_conf->cam_gpio_req_tbl_size, 1);
+	if (rc < 0) {
+		pr_err("%s: request gpio failed\n", __func__);
+		return rc;
+	}
+	for (index = 0; index < power_setting_array->size; index++) {
+		CDBG("%s index %d\n", __func__, index);
+		power_setting = &power_setting_array->power_setting[index];
+		CDBG("%s type %d\n", __func__, power_setting->seq_type);
+		switch (power_setting->seq_type) {
+		case SENSOR_CLK:
+			if (power_setting->seq_val >= s_ctrl->clk_info_size) {
+				pr_err("%s clk index %d >= max %d\n", __func__,
+					power_setting->seq_val,
+					s_ctrl->clk_info_size);
+				goto power_up_failed;
+			}
+			if (power_setting->config_val)
+				s_ctrl->clk_info[power_setting->seq_val].
+					clk_rate = power_setting->config_val;
+
+			rc = msm_cam_clk_enable(s_ctrl->dev,
+				&s_ctrl->clk_info[0],
+				(struct clk **)&power_setting->data[0],
+				s_ctrl->clk_info_size,
+				1);
+			if (rc < 0) {
+				pr_err("%s: clk enable failed\n",
+					__func__);
+				goto power_up_failed;
+			}
+			break;
+		case SENSOR_GPIO:
+			if (power_setting->seq_val >= SENSOR_GPIO_MAX ||
+				!data->gpio_conf->gpio_num_info) {
+				pr_err("%s gpio index %d >= max %d\n", __func__,
+					power_setting->seq_val,
+					SENSOR_GPIO_MAX);
+				goto power_up_failed;
+			}
+			pr_debug("%s:%d gpio set val %d\n", __func__, __LINE__,
+				data->gpio_conf->gpio_num_info->gpio_num
+				[power_setting->seq_val]);
+			gpio_set_value_cansleep(
+				data->gpio_conf->gpio_num_info->gpio_num
+				[power_setting->seq_val],
+				power_setting->config_val);		
+			break;
+		case SENSOR_VREG:
+			if (power_setting->seq_val >= CAM_VREG_MAX) {
+				pr_err("%s vreg index %d >= max %d\n", __func__,
+					power_setting->seq_val,
+					SENSOR_GPIO_MAX);
+				goto power_up_failed;
+			}
+			msm_camera_config_single_vreg(s_ctrl->dev,
+				&data->cam_vreg[power_setting->seq_val],
+				(struct regulator **)&power_setting->data[0],
+				1);
+
+			gpio_set_value_cansleep(GPIO_CAM_VCM_PWDN,1); //disable vcm
+						
+			break;
+		case SENSOR_I2C_MUX:
+			if (data->i2c_conf && data->i2c_conf->use_i2c_mux)
+				s5k4e1_liteon_sensor_enable_i2c_mux(data->i2c_conf);
+			break;
+		default:
+			pr_err("%s error power seq type %d\n", __func__,
+				power_setting->seq_type);
+			break;
+		}
+		if (power_setting->delay > 20) {
+			msleep(power_setting->delay);
+		} else if (power_setting->delay) {
+			usleep_range(power_setting->delay * 1000,
+				(power_setting->delay * 1000) + 1000);
+		}
+	}
+
+	if (s_ctrl->sensor_device_type == MSM_CAMERA_PLATFORM_DEVICE) {
+		rc = s_ctrl->sensor_i2c_client->i2c_func_tbl->i2c_util(
+			s_ctrl->sensor_i2c_client, MSM_CCI_INIT);
+		if (rc < 0) {
+			pr_err("%s cci_init failed\n", __func__);
+			goto power_up_failed;
+		}
+	}
+
+	if (s_ctrl->func_tbl->sensor_match_id)
+		rc = s_ctrl->func_tbl->sensor_match_id(s_ctrl);
+	else
+		rc = msm_sensor_match_id(s_ctrl);
+	if (rc < 0) {
+		pr_err("%s:%d match id failed rc %d\n", __func__, __LINE__, rc);
+		goto power_up_failed;
+	}
+
+	CDBG("%s exit\n", __func__);
+	return 0;
+power_up_failed:
+	pr_err("%s:%d failed\n", __func__, __LINE__);
+	if (s_ctrl->sensor_device_type == MSM_CAMERA_PLATFORM_DEVICE) {
+		s_ctrl->sensor_i2c_client->i2c_func_tbl->i2c_util(
+			s_ctrl->sensor_i2c_client, MSM_CCI_RELEASE);
+	}
+
+	for (index--; index >= 0; index--) {
+		CDBG("%s index %d\n", __func__, index);
+		power_setting = &power_setting_array->power_setting[index];
+		CDBG("%s type %d\n", __func__, power_setting->seq_type);
+		switch (power_setting->seq_type) {
+		case SENSOR_CLK:
+			msm_cam_clk_enable(s_ctrl->dev,
+				&s_ctrl->clk_info[0],
+				(struct clk **)&power_setting->data[0],
+				s_ctrl->clk_info_size,
+				0);
+			break;
+		case SENSOR_GPIO:
+			gpio_set_value_cansleep(
+				data->gpio_conf->gpio_num_info->gpio_num
+				[power_setting->seq_val], GPIOF_OUT_INIT_LOW);
+			break;
+		case SENSOR_VREG:
+			msm_camera_config_single_vreg(s_ctrl->dev,
+				&data->cam_vreg[power_setting->seq_val],
+				(struct regulator **)&power_setting->data[0],
+				0);
+			break;
+		case SENSOR_I2C_MUX:
+			if (data->i2c_conf && data->i2c_conf->use_i2c_mux)
+				s5k4e1_liteon_sensor_disable_i2c_mux(data->i2c_conf);
+			break;
+		default:
+			pr_err("%s error power seq type %d\n", __func__,
+				power_setting->seq_type);
+			break;
+		}
+		if (power_setting->delay > 20) {
+			msleep(power_setting->delay);
+		} else if (power_setting->delay) {
+			usleep_range(power_setting->delay * 1000,
+				(power_setting->delay * 1000) + 1000);
+		}
+	}
+	msm_camera_request_gpio_table(
+		data->gpio_conf->cam_gpio_req_tbl,
+		data->gpio_conf->cam_gpio_req_tbl_size, 0);
+	return rc;
+}
+
+int32_t s5k4e1_liteon_sensor_power_down(struct msm_sensor_ctrl_t *s_ctrl)
+{
+	int32_t index = 0;
+	struct msm_sensor_power_setting_array *power_setting_array = NULL;
+	struct msm_sensor_power_setting *power_setting = NULL;
+	struct msm_camera_sensor_board_info *data = s_ctrl->sensordata;
+	s_ctrl->stop_setting_valid = 0;
+
+	CDBG("%s:%d\n", __func__, __LINE__);
+	power_setting_array = &s_ctrl->power_setting_array;
+
+	if (s_ctrl->sensor_device_type == MSM_CAMERA_PLATFORM_DEVICE) {
+		s_ctrl->sensor_i2c_client->i2c_func_tbl->i2c_util(
+			s_ctrl->sensor_i2c_client, MSM_CCI_RELEASE);
+	}
+
+	for (index = (power_setting_array->size - 1); index >= 0; index--) {
+		CDBG("%s index %d\n", __func__, index);
+		power_setting = &power_setting_array->power_setting[index];
+		CDBG("%s type %d\n", __func__, power_setting->seq_type);
+		switch (power_setting->seq_type) {
+		case SENSOR_CLK:
+			msm_cam_clk_enable(s_ctrl->dev,
+				&s_ctrl->clk_info[0],
+				(struct clk **)&power_setting->data[0],
+				s_ctrl->clk_info_size,
+				0);
+			break;
+		case SENSOR_GPIO:
+			if (power_setting->seq_val >= SENSOR_GPIO_MAX ||
+				!data->gpio_conf->gpio_num_info) {
+				pr_err("%s gpio index %d >= max %d\n", __func__,
+					power_setting->seq_val,
+					SENSOR_GPIO_MAX);
+				continue;
+			}
+			gpio_set_value_cansleep(
+				data->gpio_conf->gpio_num_info->gpio_num
+				[power_setting->seq_val], GPIOF_OUT_INIT_LOW);
+			break;
+		case SENSOR_VREG:
+			if (power_setting->seq_val >= CAM_VREG_MAX) {
+				pr_err("%s vreg index %d >= max %d\n", __func__,
+					power_setting->seq_val,
+					SENSOR_GPIO_MAX);
+				continue;
+			}
+			msm_camera_config_single_vreg(s_ctrl->dev,
+				&data->cam_vreg[power_setting->seq_val],
+				(struct regulator **)&power_setting->data[0],
+				0);
+
+			gpio_set_value_cansleep(GPIO_CAM_VCM_PWDN,0); //disable vcm
+							
+			break;
+		case SENSOR_I2C_MUX:
+			if (data->i2c_conf && data->i2c_conf->use_i2c_mux)
+				s5k4e1_liteon_sensor_disable_i2c_mux(data->i2c_conf);
+			break;
+		default:
+			pr_err("%s error power seq type %d\n", __func__,
+				power_setting->seq_type);
+			break;
+		}
+		if (power_setting->delay > 20) {
+			msleep(power_setting->delay);
+		} else if (power_setting->delay) {
+			usleep_range(power_setting->delay * 1000,
+				(power_setting->delay * 1000) + 1000);
+		}
+	}
+	msm_camera_request_gpio_table(
+		data->gpio_conf->cam_gpio_req_tbl,
+		data->gpio_conf->cam_gpio_req_tbl_size, 0);
+	CDBG("%s exit\n", __func__);
+
+	return 0;
+}
+
+
+
+static struct msm_sensor_fn_t s5k4e1_liteon_sensor_func_tbl = {
+	.sensor_config = msm_sensor_config,
+	.sensor_power_up = s5k4e1_liteon_sensor_power_up,
+	.sensor_power_down = s5k4e1_liteon_sensor_power_down,
+	.sensor_match_id = msm_sensor_match_id,
+};
+
+
+static struct msm_sensor_ctrl_t s5k4e1_liteon_s_ctrl = {
+	.sensor_i2c_client = &s5k4e1_liteon_sensor_i2c_client,
+	.power_setting_array.power_setting = s5k4e1_liteon_power_setting,
+	.power_setting_array.size = ARRAY_SIZE(s5k4e1_liteon_power_setting),
+	.msm_sensor_mutex = &s5k4e1_liteon_mut,
+	.sensor_v4l2_subdev_info = s5k4e1_liteon_subdev_info,
+	.sensor_v4l2_subdev_info_size = ARRAY_SIZE(s5k4e1_liteon_subdev_info),
+	.func_tbl = &s5k4e1_liteon_sensor_func_tbl,
+};
+
+module_init(s5k4e1_liteon_init_module);
+module_exit(s5k4e1_liteon_exit_module);
+MODULE_DESCRIPTION("s5k4e1_liteon");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/media/platform/msm/camera_v2/sensor/s5k4h5_liteon_12p1ba855d.c b/drivers/media/platform/msm/camera_v2/sensor/s5k4h5_liteon_12p1ba855d.c
new file mode 100644
index 0000000..d386897
--- /dev/null
+++ b/drivers/media/platform/msm/camera_v2/sensor/s5k4h5_liteon_12p1ba855d.c
@@ -0,0 +1,460 @@
+/* Copyright (c) 2013, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+#include <mach/gpiomux.h>
+#include "msm_sensor.h"
+#include "msm_sd.h"
+#include "camera.h"
+#include "msm_cci.h"
+#include "msm_camera_io_util.h"
+#include "msm_camera_i2c_mux.h"
+#include <mach/rpm-regulator.h>
+#include <mach/rpm-regulator-smd.h>
+#include <linux/regulator/consumer.h>
+
+#define S5K4H5_LITEON_SENSOR_NAME "s5k4h5_liteon"
+DEFINE_MSM_MUTEX(s5k4h5_liteon_mut);
+
+#define GPIO_CAM_DVDD_EN   101
+#define GPIO_CAM_VCM_PWDN  79
+
+#undef CDBG
+#define S5K4H5_LITEON_DEBUG
+#ifdef S5K4H5_LITEON_DEBUG
+#define CDBG(fmt, args...) pr_err(fmt, ##args)
+#else
+#define CDBG(fmt, args...) do { } while (0)
+#endif
+
+static struct msm_sensor_ctrl_t s5k4h5_liteon_s_ctrl;
+
+static struct msm_sensor_power_setting s5k4h5_liteon_power_setting[] = {
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_RESET,
+		.config_val = GPIO_OUT_HIGH,
+		.delay = 40,
+	},
+	{
+		.seq_type = SENSOR_VREG,
+		.seq_val = CAM_VANA,
+		.config_val = 0,
+		.delay = 5,
+	},	
+	{
+		.seq_type = SENSOR_VREG,
+		.seq_val = CAM_VIO,
+		.config_val = 0,
+		.delay = 5,
+	},
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_RESET,
+		.config_val = GPIO_OUT_LOW,
+		.delay = 40,
+	},
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_RESET,
+		.config_val = GPIO_OUT_HIGH,
+		.delay = 40,
+	},
+	{
+		.seq_type = SENSOR_CLK,
+		.seq_val = SENSOR_CAM_MCLK,
+		.config_val = 24000000,
+		.delay = 5,
+	},
+	{
+		.seq_type = SENSOR_I2C_MUX,
+		.seq_val = 0,
+		.config_val = 0,
+		.delay = 0,
+	},
+};
+
+static struct v4l2_subdev_info s5k4h5_liteon_subdev_info[] = {
+	{
+		.code   = V4L2_MBUS_FMT_SGRBG10_1X10,
+		.colorspace = V4L2_COLORSPACE_JPEG,
+		.fmt    = 1,
+		.order    = 0,
+	},
+};
+
+static const struct i2c_device_id s5k4h5_liteon_i2c_id[] = {
+	{S5K4H5_LITEON_SENSOR_NAME, (kernel_ulong_t)&s5k4h5_liteon_s_ctrl},
+	{ }
+};
+
+static int32_t msm_s5k4h5_liteon_i2c_probe(struct i2c_client *client,
+	const struct i2c_device_id *id)
+{
+	return msm_sensor_i2c_probe(client, id, &s5k4h5_liteon_s_ctrl);
+}
+
+static struct i2c_driver s5k4h5_liteon_i2c_driver = {
+	.id_table = s5k4h5_liteon_i2c_id,
+	.probe  = msm_s5k4h5_liteon_i2c_probe,
+	.driver = {
+		.name = S5K4H5_LITEON_SENSOR_NAME,
+	},
+};
+
+static struct msm_camera_i2c_client s5k4h5_liteon_sensor_i2c_client = {
+	.addr_type = MSM_CAMERA_I2C_WORD_ADDR,
+};
+
+static const struct of_device_id s5k4h5_liteon_dt_match[] = {
+	{.compatible = "qcom,s5k4h5_liteon", .data = &s5k4h5_liteon_s_ctrl},
+	{}
+};
+
+MODULE_DEVICE_TABLE(of, s5k4h5_liteon_dt_match);
+
+static struct platform_driver s5k4h5_liteon_platform_driver = {
+	.driver = {
+		.name = "qcom,s5k4h5_liteon",
+		.owner = THIS_MODULE,
+		.of_match_table = s5k4h5_liteon_dt_match,
+	},
+};
+
+static int32_t s5k4h5_liteon_platform_probe(struct platform_device *pdev)
+{
+	int32_t rc = 0;
+	const struct of_device_id *match;
+	match = of_match_device(s5k4h5_liteon_dt_match, &pdev->dev);
+	rc = msm_sensor_platform_probe(pdev, match->data);
+	return rc;
+}
+
+static int __init s5k4h5_liteon_init_module(void)
+{
+	int32_t rc = 0;
+	pr_info("%s:%d\n", __func__, __LINE__);
+	rc = platform_driver_probe(&s5k4h5_liteon_platform_driver,
+		s5k4h5_liteon_platform_probe);
+	if (!rc)
+		return rc;
+	pr_err("%s:%d rc %d\n", __func__, __LINE__, rc);
+	return i2c_add_driver(&s5k4h5_liteon_i2c_driver);
+}
+
+static void __exit s5k4h5_liteon_exit_module(void)
+{
+	pr_info("%s:%d\n", __func__, __LINE__);
+	if (s5k4h5_liteon_s_ctrl.pdev) {
+		msm_sensor_free_sensor_data(&s5k4h5_liteon_s_ctrl);
+		platform_driver_unregister(&s5k4h5_liteon_platform_driver);
+	} else
+		i2c_del_driver(&s5k4h5_liteon_i2c_driver);
+	return;
+}
+
+static int32_t s5k4h5_liteon_sensor_enable_i2c_mux(struct msm_camera_i2c_conf *i2c_conf)
+{
+	struct v4l2_subdev *i2c_mux_sd =
+		dev_get_drvdata(&i2c_conf->mux_dev->dev);
+	v4l2_subdev_call(i2c_mux_sd, core, ioctl,
+		VIDIOC_MSM_I2C_MUX_INIT, NULL);
+	v4l2_subdev_call(i2c_mux_sd, core, ioctl,
+		VIDIOC_MSM_I2C_MUX_CFG, (void *)&i2c_conf->i2c_mux_mode);
+	return 0;
+}
+
+static int32_t s5k4h5_liteon_sensor_disable_i2c_mux(struct msm_camera_i2c_conf *i2c_conf)
+{
+	struct v4l2_subdev *i2c_mux_sd =
+		dev_get_drvdata(&i2c_conf->mux_dev->dev);
+	v4l2_subdev_call(i2c_mux_sd, core, ioctl,
+				VIDIOC_MSM_I2C_MUX_RELEASE, NULL);
+	return 0;
+}
+
+int32_t s5k4h5_liteon_sensor_power_up(struct msm_sensor_ctrl_t *s_ctrl)
+{
+	int32_t rc = 0, index = 0;
+	struct msm_sensor_power_setting_array *power_setting_array = NULL;
+	struct msm_sensor_power_setting *power_setting = NULL;
+	struct msm_camera_sensor_board_info *data = s_ctrl->sensordata;
+
+	CDBG("%s:%d\n", __func__, __LINE__);
+	power_setting_array = &s_ctrl->power_setting_array;
+
+	if (data->gpio_conf->cam_gpiomux_conf_tbl != NULL) {
+		pr_err("%s:%d mux install\n", __func__, __LINE__);
+		msm_gpiomux_install(
+			(struct msm_gpiomux_config *)
+			data->gpio_conf->cam_gpiomux_conf_tbl,
+			data->gpio_conf->cam_gpiomux_conf_tbl_size);
+	}
+
+	rc = msm_camera_request_gpio_table(
+		data->gpio_conf->cam_gpio_req_tbl,
+		data->gpio_conf->cam_gpio_req_tbl_size, 1);
+	if (rc < 0) {
+		pr_err("%s: request gpio failed\n", __func__);
+		return rc;
+	}
+	for (index = 0; index < power_setting_array->size; index++) {
+		CDBG("%s index %d\n", __func__, index);
+		power_setting = &power_setting_array->power_setting[index];
+		CDBG("%s type %d\n", __func__, power_setting->seq_type);
+		switch (power_setting->seq_type) {
+		case SENSOR_CLK:
+			if (power_setting->seq_val >= s_ctrl->clk_info_size) {
+				pr_err("%s clk index %d >= max %d\n", __func__,
+					power_setting->seq_val,
+					s_ctrl->clk_info_size);
+				goto power_up_failed;
+			}
+			if (power_setting->config_val)
+				s_ctrl->clk_info[power_setting->seq_val].
+					clk_rate = power_setting->config_val;
+
+			rc = msm_cam_clk_enable(s_ctrl->dev,
+				&s_ctrl->clk_info[0],
+				(struct clk **)&power_setting->data[0],
+				s_ctrl->clk_info_size,
+				1);
+			if (rc < 0) {
+				pr_err("%s: clk enable failed\n",
+					__func__);
+				goto power_up_failed;
+			}
+			break;
+		case SENSOR_GPIO:
+			if (power_setting->seq_val >= SENSOR_GPIO_MAX ||
+				!data->gpio_conf->gpio_num_info) {
+				pr_err("%s gpio index %d >= max %d\n", __func__,
+					power_setting->seq_val,
+					SENSOR_GPIO_MAX);
+				goto power_up_failed;
+			}
+			pr_debug("%s:%d gpio set val %d\n", __func__, __LINE__,
+				data->gpio_conf->gpio_num_info->gpio_num
+				[power_setting->seq_val]);
+			gpio_set_value_cansleep(
+				data->gpio_conf->gpio_num_info->gpio_num
+				[power_setting->seq_val],
+				power_setting->config_val);		
+			break;
+		case SENSOR_VREG:
+			if (power_setting->seq_val >= CAM_VREG_MAX) {
+				pr_err("%s vreg index %d >= max %d\n", __func__,
+					power_setting->seq_val,
+					SENSOR_GPIO_MAX);
+				goto power_up_failed;
+			}
+
+			gpio_set_value_cansleep(GPIO_CAM_DVDD_EN,1); //enable dvdd_en	
+			
+			msm_camera_config_single_vreg(s_ctrl->dev,
+				&data->cam_vreg[power_setting->seq_val],
+				(struct regulator **)&power_setting->data[0],
+				1);
+
+			gpio_set_value_cansleep(GPIO_CAM_VCM_PWDN,1); //enable vcm
+			
+			break;
+		case SENSOR_I2C_MUX:
+			if (data->i2c_conf && data->i2c_conf->use_i2c_mux)
+				s5k4h5_liteon_sensor_enable_i2c_mux(data->i2c_conf);
+			break;
+		default:
+			pr_err("%s error power seq type %d\n", __func__,
+				power_setting->seq_type);
+			break;
+		}
+		if (power_setting->delay > 20) {
+			msleep(power_setting->delay);
+		} else if (power_setting->delay) {
+			usleep_range(power_setting->delay * 1000,
+				(power_setting->delay * 1000) + 1000);
+		}
+	}
+
+	if (s_ctrl->sensor_device_type == MSM_CAMERA_PLATFORM_DEVICE) {
+		rc = s_ctrl->sensor_i2c_client->i2c_func_tbl->i2c_util(
+			s_ctrl->sensor_i2c_client, MSM_CCI_INIT);
+		if (rc < 0) {
+			pr_err("%s cci_init failed\n", __func__);
+			goto power_up_failed;
+		}
+	}
+
+	if (s_ctrl->func_tbl->sensor_match_id)
+		rc = s_ctrl->func_tbl->sensor_match_id(s_ctrl);
+	else
+		rc = msm_sensor_match_id(s_ctrl);
+	if (rc < 0) {
+		pr_err("%s:%d match id failed rc %d\n", __func__, __LINE__, rc);
+		goto power_up_failed;
+	}
+
+	CDBG("%s exit\n", __func__);
+	return 0;
+power_up_failed:
+	pr_err("%s:%d failed\n", __func__, __LINE__);
+	if (s_ctrl->sensor_device_type == MSM_CAMERA_PLATFORM_DEVICE) {
+		s_ctrl->sensor_i2c_client->i2c_func_tbl->i2c_util(
+			s_ctrl->sensor_i2c_client, MSM_CCI_RELEASE);
+	}
+
+	for (index--; index >= 0; index--) {
+		CDBG("%s index %d\n", __func__, index);
+		power_setting = &power_setting_array->power_setting[index];
+		CDBG("%s type %d\n", __func__, power_setting->seq_type);
+		switch (power_setting->seq_type) {
+		case SENSOR_CLK:
+			msm_cam_clk_enable(s_ctrl->dev,
+				&s_ctrl->clk_info[0],
+				(struct clk **)&power_setting->data[0],
+				s_ctrl->clk_info_size,
+				0);
+			break;
+		case SENSOR_GPIO:
+			gpio_set_value_cansleep(
+				data->gpio_conf->gpio_num_info->gpio_num
+				[power_setting->seq_val], GPIOF_OUT_INIT_LOW);
+			break;
+		case SENSOR_VREG:
+			msm_camera_config_single_vreg(s_ctrl->dev,
+				&data->cam_vreg[power_setting->seq_val],
+				(struct regulator **)&power_setting->data[0],
+				0);
+			break;
+		case SENSOR_I2C_MUX:
+			if (data->i2c_conf && data->i2c_conf->use_i2c_mux)
+				s5k4h5_liteon_sensor_disable_i2c_mux(data->i2c_conf);
+			break;
+		default:
+			pr_err("%s error power seq type %d\n", __func__,
+				power_setting->seq_type);
+			break;
+		}
+		if (power_setting->delay > 20) {
+			msleep(power_setting->delay);
+		} else if (power_setting->delay) {
+			usleep_range(power_setting->delay * 1000,
+				(power_setting->delay * 1000) + 1000);
+		}
+	}
+	msm_camera_request_gpio_table(
+		data->gpio_conf->cam_gpio_req_tbl,
+		data->gpio_conf->cam_gpio_req_tbl_size, 0);
+	return rc;
+}
+
+int32_t s5k4h5_liteon_sensor_power_down(struct msm_sensor_ctrl_t *s_ctrl)
+{
+#if 1
+	int32_t index = 0;
+	struct msm_sensor_power_setting_array *power_setting_array = NULL;
+	struct msm_sensor_power_setting *power_setting = NULL;
+	struct msm_camera_sensor_board_info *data = s_ctrl->sensordata;
+	s_ctrl->stop_setting_valid = 0;
+
+	CDBG("%s:%d\n", __func__, __LINE__);
+	power_setting_array = &s_ctrl->power_setting_array;
+
+	if (s_ctrl->sensor_device_type == MSM_CAMERA_PLATFORM_DEVICE) {
+		s_ctrl->sensor_i2c_client->i2c_func_tbl->i2c_util(
+			s_ctrl->sensor_i2c_client, MSM_CCI_RELEASE);
+	}
+
+	for (index = (power_setting_array->size - 1); index >= 0; index--) {
+		CDBG("%s index %d\n", __func__, index);
+		power_setting = &power_setting_array->power_setting[index];
+		CDBG("%s type %d\n", __func__, power_setting->seq_type);
+		switch (power_setting->seq_type) {
+		case SENSOR_CLK:
+			msm_cam_clk_enable(s_ctrl->dev,
+				&s_ctrl->clk_info[0],
+				(struct clk **)&power_setting->data[0],
+				s_ctrl->clk_info_size,
+				0);
+			break;
+		case SENSOR_GPIO:
+			if (power_setting->seq_val >= SENSOR_GPIO_MAX ||
+				!data->gpio_conf->gpio_num_info) {
+				pr_err("%s gpio index %d >= max %d\n", __func__,
+					power_setting->seq_val,
+					SENSOR_GPIO_MAX);
+				continue;
+			}
+			gpio_set_value_cansleep(
+				data->gpio_conf->gpio_num_info->gpio_num
+				[power_setting->seq_val], GPIOF_OUT_INIT_LOW);
+			break;
+		case SENSOR_VREG:
+			if (power_setting->seq_val >= CAM_VREG_MAX) {
+				pr_err("%s vreg index %d >= max %d\n", __func__,
+					power_setting->seq_val,
+					SENSOR_GPIO_MAX);
+				continue;
+			}
+			msm_camera_config_single_vreg(s_ctrl->dev,
+				&data->cam_vreg[power_setting->seq_val],
+				(struct regulator **)&power_setting->data[0],
+				0);
+
+			gpio_set_value_cansleep(GPIO_CAM_DVDD_EN,0); //disable dvdd_en
+			gpio_set_value_cansleep(GPIO_CAM_VCM_PWDN,0); //disable vcm
+
+			break;
+		case SENSOR_I2C_MUX:
+			if (data->i2c_conf && data->i2c_conf->use_i2c_mux)
+				s5k4h5_liteon_sensor_disable_i2c_mux(data->i2c_conf);
+			break;
+		default:
+			pr_err("%s error power seq type %d\n", __func__,
+				power_setting->seq_type);
+			break;
+		}
+		if (power_setting->delay > 20) {
+			msleep(power_setting->delay);
+		} else if (power_setting->delay) {
+			usleep_range(power_setting->delay * 1000,
+				(power_setting->delay * 1000) + 1000);
+		}
+	}
+	msm_camera_request_gpio_table(
+		data->gpio_conf->cam_gpio_req_tbl,
+		data->gpio_conf->cam_gpio_req_tbl_size, 0);
+	CDBG("%s exit\n", __func__);
+#endif
+	return 0;
+}
+
+static struct msm_sensor_fn_t s5k4h5_liteon_sensor_func_tbl = {
+	.sensor_config = msm_sensor_config,
+	.sensor_power_up = s5k4h5_liteon_sensor_power_up,
+	.sensor_power_down = s5k4h5_liteon_sensor_power_down,
+	.sensor_match_id = msm_sensor_match_id,
+};
+
+static struct msm_sensor_ctrl_t s5k4h5_liteon_s_ctrl = {
+	.sensor_i2c_client = &s5k4h5_liteon_sensor_i2c_client,
+	.power_setting_array.power_setting = s5k4h5_liteon_power_setting,
+	.power_setting_array.size = ARRAY_SIZE(s5k4h5_liteon_power_setting),
+	.msm_sensor_mutex = &s5k4h5_liteon_mut,
+	.sensor_v4l2_subdev_info = s5k4h5_liteon_subdev_info,
+	.sensor_v4l2_subdev_info_size = ARRAY_SIZE(s5k4h5_liteon_subdev_info),
+	.func_tbl = &s5k4h5_liteon_sensor_func_tbl,
+};
+
+module_init(s5k4h5_liteon_init_module);
+module_exit(s5k4h5_liteon_exit_module);
+MODULE_DESCRIPTION("s5k4h5_liteon");
+MODULE_LICENSE("GPL v2");
-- 
1.7.8.3

